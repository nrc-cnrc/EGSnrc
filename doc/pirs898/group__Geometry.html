<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>EGSnrc C++ class library: Geometry module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<script language="JavaScript" type="text/javascript">
    $(document).ready(function(){
    var imgArr = new Array( // relative paths of images
    'linac2.png',
    'egs_isotropic_source.png',
    'egs_conestack.png',
    'car.png',
    'egs_cd_geometry.png',
    'chamber.png',
    'c_in_box.png',
    'egs_collimated_source.png',
    'egs_iplanes.png',
    'egs_point_source.png',
    'linac_s1.png',
    'egs_ndgeometry.png',
    'egs_roundrect_cylinders.png',
    'egs_source_collection.png',
    'egs_xyzrepeater.png',
    'cones.png',
    'egs_prism.png',
    'egs_pyramid.png',
    'I6702.png',
    'egs_xyzgeometry.png',
    'linac1.png'
    );
    var preloadArr = new Array();
    var i;
    /* preload images */
    for(i=0; i < imgArr.length; i++){
    preloadArr[i] = new Image();
    preloadArr[i].src = imgArr[i];
    }
    changeImg();
    var intID = setInterval(changeImg, 5000);
    /* image rotator */
    function changeImg(){
    $('#egsImageScroller').css('background','#000000 url(' + preloadArr[Math.floor(Math.random() * imgArr.length)].src +') center/contain no-repeat');
    }
    });
</script>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="egsImageScroller"></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EGSnrc C++ class library
   &#160;<span id="projectnumber">Report PIRS-898 (2021)</span>
   </div>
   <div id="projectbrief">Iwan Kawrakow, Ernesto Mainegra-Hing, Frederic Tessier, Reid Townson and Blake Walters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Geometry module</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module contains classes that model various geometry types. If you are looking for description of how to define a certain geometry in your input file, click on the corresponding class and see the detailed description.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__ElementaryG"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElementaryG.html">Elementary Geometries</a></td></tr>
<tr class="memdesc:group__ElementaryG"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Elementary" or "primitive" geometries are geometry classes that implement their methods directly (<em>i.e</em>. without the help of other geometries). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__CompositeG"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CompositeG.html">Composite Geometries</a></td></tr>
<tr class="memdesc:group__CompositeG"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite geometries are classes that implement their geometry methods using the geometry methods of their constituent geometries based on a certain type of logic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base geometry class. Every geometry class must be derived from <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a>.  <a href="classEGS__BaseGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Box.html">EGS_Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A box geometry.  <a href="classEGS__Box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__CDGeometry.html">EGS_CDGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "combinatorial dimension" geometry.  <a href="classEGS__CDGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__SimpleCone.html">EGS_SimpleCone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single cone that may be open (i.e. extends to infinity or closed by a plane perpendicular to the cone axis.  <a href="classEGS__SimpleCone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__ParallelCones.html">EGS_ParallelCones</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of "parallel cones" (<em>i.e</em>. cones with the same axis and opening angles but different apexes)  <a href="classEGS__ParallelCones.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__ConeSet.html">EGS_ConeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of cones with different opening angles but the same axis and apexes.  <a href="classEGS__ConeSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__ConeStack.html">EGS_ConeStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cone stack.  <a href="classEGS__ConeStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__CylindersT.html">EGS_CylindersT&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of concentric cylinders.  <a href="classEGS__CylindersT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__DynamicGeometry.html">EGS_DynamicGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic geometry.  <a href="classEGS__DynamicGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__EnvelopeGeometry.html">EGS_EnvelopeGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An envelope geometry class.  <a href="classEGS__EnvelopeGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__FastEnvelope.html">EGS_FastEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An envelope geometry class.  <a href="classEGS__FastEnvelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__StackGeometry.html">EGS_StackGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack of geometries.  <a href="classEGS__StackGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html">EGS_TransformedGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transformed geometry.  <a href="classEGS__TransformedGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__IPlanes.html">EGS_IPlanes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of planes intersecting in the same axis.  <a href="classEGS__IPlanes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__RadialRepeater.html">EGS_RadialRepeater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A radial geometry replicator.  <a href="classEGS__RadialRepeater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Lattice.html">EGS_Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bravais, cubic, and hexagonal lattice geometry.  <a href="classEGS__Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Mesh.html">EGS_Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tetrahedral mesh geometry.  <a href="classEGS__Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html">EGS_NDGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class modeling a N-dimensional geometry.  <a href="classEGS__NDGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__XYZGeometry.html">EGS_XYZGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XYZ-geometry.  <a href="classEGS__XYZGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__DeformedXYZ.html">EGS_DeformedXYZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deformed XYZ-geometry.  <a href="classEGS__DeformedXYZ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__XYZRepeater.html">EGS_XYZRepeater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A geometry repeated on a regular XYZ grid.  <a href="classEGS__XYZRepeater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Octree.html">EGS_Octree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An octree geometry.  <a href="classEGS__Octree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PlanesT.html">EGS_PlanesT&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of parallel planes.  <a href="classEGS__PlanesT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PlaneCollection.html">EGS_PlaneCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of non-parallel planes.  <a href="classEGS__PlaneCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PrismT.html">EGS_PrismT&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for modeling prisms.  <a href="classEGS__PrismT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PyramidT.html">EGS_PyramidT&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class for modeling pyramids.  <a href="classEGS__PyramidT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__RoundRectCylindersT.html">EGS_RoundRectCylindersT&lt; Tx, Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of concentric rounded rectangles.  <a href="classEGS__RoundRectCylindersT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__RZGeometry.html">EGS_RZGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a subclass of <a class="el" href="classEGS__NDGeometry.html" title="A class modeling a N-dimensional geometry.">EGS_NDGeometry</a> for conveniently defining an RZ geometry  <a href="classEGS__RZGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Space.html">EGS_Space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The entire space as a geometry object.  <a href="classEGS__Space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__cSpheres.html">EGS_cSpheres</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of concentric spheres.  <a href="classEGS__cSpheres.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__UnionGeometry.html">EGS_UnionGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A geometry constructed as the union of other geometries.  <a href="classEGS__UnionGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__VHPGeometry.html">EGS_VHPGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Voxelized Human Phantom (VHP) geometry.  <a href="classEGS__VHPGeometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5bc12ceac1e65f64b3c7d3b62e4ce4ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga5bc12ceac1e65f64b3c7d3b62e4ce4ff">EGS_GLIB_</a></td></tr>
<tr class="separator:ga5bc12ceac1e65f64b3c7d3b62e4ce4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module contains classes that model various geometry types. If you are looking for description of how to define a certain geometry in your input file, click on the corresponding class and see the detailed description. </p>
<p><a class="anchor" id="geometry_anchor"></a> <a class="el" href="group__Geometry.html#geometry_general">General discussion</a> <br  />
 <a class="el" href="group__Geometry.html#geometry_design">Design of the egspp geometry package</a> <br  />
 <a class="el" href="group__Geometry.html#geometry_common">Common geometry input syntax</a> <br  />
 <a class="el" href="group__Geometry.html#geometry_media">Media definition</a> <br  />
 <a class="el" href="group__Geometry.html#geometry_implementing">Implementing new geometry classes</a> <br  />
 <a class="el" href="group__Geometry.html#geometry_view">The geometry viewer: egs_view</a> <br  />
 <a class="el" href="group__Geometry.html#geometry_examples">Example geometries</a> <br  />
</p>
<h1><a class="anchor" id="geometry_general"></a>
General discussion</h1>
<p>There are many different ways to model a geometrical structure. One frequently used approach is to use simple solids such as boxes, spheres, cylinders, etc., and various boolean operations (unions, logical or, etc.) to put together more complicated objects (this approach is typically known as constructive solid geometry, CGS). Another way is to describe geometrical objects using the surfaces by which they are surrounded. In many cases first and second order surfaces or a limited set of relatively simple solids are sufficient to describe a wide range of even complex objects and therefore, at least in principle, these two approaches reduce the task of programming a general purpose geometry package to the programming of a relatively small number of geometrical methods. However, in practical simulations the region number of a particle must be known at all times and determining the index of a new region being entered may not be a trivial task. Many of the available geometry packages solve this problem by initiating a global search for the new region index, which makes the simulation extremely slow in situations with complex geometries and a large number of regions. For instance, it is well known that a MCNP simulation in a simple voxel-type geometry constructed from the MCNP geometry package is of the order of 1000 times slower compared to a special-purpose voxel geometry. An efficient way of crossing interfaces between different regions has therefore been given a high priority in the design and implementation of the EGSnrc geometry package.</p>
<p>The EGSnrc geometry package considers geometrical structures at the highest possible level of abstraction: any object that is able to provide a certain set of geometry related methods is considered to be a "geometry". No distinction is made between surfaces or solids, or between simple geometrical structures and highly complex ones. An object is considered to be a geometry if it can provide answers to the following questions:</p><ol type="1">
<li>Given a region index <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/>, a position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png" width="11" height="12"/>, a direction <img class="formulaInl" alt="$\vec{u}$" src="form_2.png" width="11" height="12"/> and an intended transport distance <img class="formulaInl" alt="$t$" src="form_3.png" width="6" height="11"/>, will the particle trajectory intersect a boundary? If yes, what is the new region index and what is the distance to the boundary? The method providing the answer to this questions will be referred to as the <code>howfar()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#a42a459b557011291ea2e8978ebee6295">howfar() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class.</li>
<li>Given a region index <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/> and a position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png" width="11" height="12"/>, what is the nearest distance to a boundary in any direction ? The method providing the answer to this questions will be referred to as the <code>hownear()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#a111e6d8ea34e403bebaf3621223950d9">hownear() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class.</li>
<li>Is position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png" width="11" height="12"/> inside or outside the geometry. The method providing the answer to this questions will be referred to as the <code>isInside()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#a816bf2d26bdabc3e4ee2f092bd903d92">isInside() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class.</li>
<li>In addition to the above, what is the region index corresponding to <img class="formulaInl" alt="$\vec{x}$" src="form_1.png" width="11" height="12"/> if it is inside ? The method providing the answer to this questions will be referred to as the <code>isWhere()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#af1a37ed6f281a2442a7e96d9658894a9">isWhere() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class.</li>
<li>What is the medium in region <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/>? The method providing the answer to this questions will be referred to as the <code>medium()</code> method of a geometry specified by the <a class="el" href="classEGS__BaseGeometry.html#ab46405acddbb45317fe06dcab50b7e00">medium() </a> virtual function of the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class.</li>
<li>How many regions are there in this geometry? The method providing the answer to this questions will be referred to as the <code>regions()</code> method of a geometry specified by the <a class="el" href="classEGS__BaseGeometry.html#aba4f74cef06f9b56d401d047cca06196">regions() </a> virtual function of the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class.</li>
</ol>
<p>As a convention, all geometries numerate their regions between 0 and the number of regions minus one whereas a negative region index is considered to be outside of the geometry (<em>i.e</em>., if a particle would exit the geometry after crossing a boundary, the new region index returned is -1, or if the region index <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/> is negative in questions 1 and 2, the geometry object can assume that it is known that the position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png" width="11" height="12"/> is outside of the geometry). Questions 1 and 2 are specified by the EGSnrc geometry interface specification except that now geometry objects must be able to determine the answer to these questions also for the situation of the position being outside (<em>i.e</em>. region <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/> is negative). This extension, together with 3, 4 and 6 is necessary so that one can construct more complicated geometries from simpler geometries as will be seen below. Questions 5 and 7 are necessary to completely decouple the geometry information from EGSnrc (when EGSnrc is compiled for use with the new C++ interface, all arrays present in the original version holding information on a region-by-region bases such as the medium index, the particle transport cutoff energies, etc., are turned into scalar quantities).</p>
<p>To describe the various geometry objects provided by the egspp library, we will group them in two broad classes:</p><ol type="1">
<li>Elementary or primitive geometries. These geometries are called elementary not because it is easy to implement the required methods but because these methods are implemented directly, without the use of geometry methods of other objects.</li>
<li>Composite geometries. The geometry methods of such geometries are implemented using the geometry methods of the objects from which such geometries are built using a certain type of logic to obtain <code>howfar()</code>, <code>hownear()</code>, etc., from the corresponding methods of the constituents. Composite geometries can be constructed from elementary geometries and/or other composite geometries.</li>
</ol>
<h1><a class="anchor" id="geometry_design"></a>
Design of the egspp geometry package</h1>
<p>Given the above discussion, all geometry objects in the egspp package are derived from the <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a> class, which is part of the main egspp library. Concrete geometry classes are compiled into separate shared libraries (a.k.a. dynamic shared objects, DSO, or dynamically linkable library, DLL) that can be loaded dynamically at run time as needed. Each of these geometry libraries provides a </p><pre class="fragment">EGS_BaseGeometry *createGeometry(EGS_Input *inp)
</pre><p> C-style function, the address of which is resolved when a geometry library is loaded and is used to create a geometry object from the input information stored in an <a class="el" href="classEGS__Input.html" title="A class for storing information in a tree-like structure of key-value pairs. This class is used throu...">EGS_Input</a> object and pointed to by <em>inp</em>. The information stored in the input object is typically extracted from an input file that specifies the various aspects of a particle simulation. It is of course possible to create an <a class="el" href="classEGS__Input.html" title="A class for storing information in a tree-like structure of key-value pairs. This class is used throu...">EGS_Input</a> object specifying one or more geometries by other means (<em>e.g</em>. within a GUI) and then use the geometry creation functions <a class="el" href="classEGS__BaseGeometry.html#a7f73df441569e779463ebb17d15a864a" title="Create a geometry (or geometries) from a given input.">EGS_BaseGeometry::createGeometry()</a> or <a class="el" href="classEGS__BaseGeometry.html#a2b5590a407e70597c6da34c1647c6934" title="Create a single geometry from the input inp.">EGS_BaseGeometry::createSingleGeometry()</a> to obtain a pointer to the geometry object.</p>
<p>The motivation behind this design is twofold:</p><ul>
<li>Most of the time simulations are performed within a geometry that only requires a single class or a limited set of classes to be modeled. It would therefore be wasteful to link against a library containing all geometry classes available in egspp.</li>
<li>Extendibility: it is easy to create a new geometry class by deriving from <a class="el" href="classEGS__BaseGeometry.html" title="Base geometry class. Every geometry class must be derived from EGS_BaseGeometry.">EGS_BaseGeometry</a>, implementing the necessary methods and the <code>createGeometry</code> function and compiling the class into a shared library that can immediately be used with the rest of the system.</li>
</ul>
<h1><a class="anchor" id="geometry_common"></a>
Common geometry input syntax</h1>
<p>The definition of a geometry must be within a composite property <code>geometry</code> within another composite property <code>geometry definition</code> of the input object. This implies that if the geometry is defined in an input file, the file must contain a section </p><pre class="fragment">:start geometry definition:
    :start geometry:
       definition of a geometry
       name = myGeometry
    :stop geometry:

    simulation geometry = myGeometry
:stop geometry definition:
</pre><p> (see the <a class="el" href="classEGS__Input.html">EGS_Input documentation </a> for details of the input file syntax. Note also that in what follows the input file syntax will be used to describe an <a class="el" href="classEGS__Input.html" title="A class for storing information in a tree-like structure of key-value pairs. This class is used throu...">EGS_Input</a> property). The geometry in which to perform the simulation is specified using the <code>simulation geometry</code> input parameter. If more than one geometry is to be constructed, there can be several <code>geometry</code> properties (<em>i.e</em>. several <code>:start geometry: :stop geometry: </code> sections). Each geometry must have a <code>name</code> property with a unique name value because names are used to refer to other geometries in <em>e.g</em>. the construction of composite geometries. Each geometry must also contain a <code>library</code> property, which be used to dynamically load the library that provides the geometry class being defined by the input. Library names must be given without their platform specific prefixes and suffixes (<em>e.g</em>. <code>egs_planes</code> stands for <code>libegs_planes.so</code> on Linux and <code>egs_planes.dll</code> on Windows). Some geometry libraries provide implementations for more than one geometry class. For such libraries a <code>type</code> property is required in the geometry definition to specify the type of the object being constructed. For instance, </p><pre class="fragment">:start geometry:
    library = egs_planes
    type    = EGS_Xplanes
    name    = planes1
    other input
:stop geometry:
</pre><p> is needed in the input file to specify that a geometry of type <code>EGS_Xplanes</code> with name <code>planes1</code> should be constructed from the DSO <code>egs_planes</code> (<code>other</code> <code>input</code> stands for additional key-value pairs used by the <code>EGS_Xplanes</code> constructor).</p>
<h2><a class="anchor" id="geometry_media"></a>
Media definition</h2>
<p>All geometries can be filled with media by including a <code>media input</code> property within the geometry definition. Because geometries can be used as building blocks for other geometries, which could fill the regions with media, it is not considered a mistake if a geometry does not define its media. However, the user must be careful to eventually define media for all real regions of the simulation geometry to avoid program crashes. Many geometries can be filled with media with the following keys within the <code>media input</code> property: </p><pre class="fragment">:start media input:
    media = list of media names as in the PEGS file
    set medium = 2 or 3 integers
    set medium = 2 or 3 integers
    ...
    set medium = 2 or 3 integers
:stop media input:
</pre><p> The <code>media</code> key defines the media names from the PEGS file that will be used for the simulation. When this key is encountered, all regions of a geometry are filled with the first medium in the list of media. There can be an arbitrary number of <code>set</code> <code>medium</code> keys (including zero, in which case the geometry will be homogeneous and filled with the first medium in the list of media). If 2 integers <img class="formulaInl" alt="$i_1, i$" src="form_4.png" width="24" height="14"/> are found as input to a <code>set</code> <code>medium</code> key, then region <img class="formulaInl" alt="$i_1$" src="form_5.png" width="12" height="14"/> is set to contain the medium with index <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/> in the list of media. If 3 integers <img class="formulaInl" alt="$i_1, i_2, i$" src="form_6.png" width="44" height="14"/> are found, then all regions between <img class="formulaInl" alt="$i_1$" src="form_5.png" width="12" height="14"/> and <img class="formulaInl" alt="$i_2$" src="form_7.png" width="12" height="14"/> (inclusive) are set to the medium with index <img class="formulaInl" alt="$i$" src="form_0.png" width="6" height="11"/> in the list of media. It is important to note that the medium index is the index in the list of media for the current geometry, not a global medium index. The geometry factory object, which is responsible for the construction of the various geometries, maintains a global list of media names defined in all geometries and automatically translates local media indices to global media indices. If, for instance, the first geometry defines the media names <code>H2O521ICRU, AL521ICRU, PB521ICRU</code> and the second geometry the media <code>PB521ICRU, H2O521ICRU, W521ICRU</code>, the global list of media after the definition of the second geometry will be <code>H2O521ICRU, AL521ICRU, PB521ICRU, W521ICRU</code>. In the definition of the first geometry one would refer to <code>H2O521ICRU</code> as medium 0, <code>AL521ICRU</code> as medium 1 and to <code>PB521ICRU</code> as medium 2 and they will get translated into global medium indices 0, 1 and 2. In the definition of the second geometry one would refer to <code>PB521ICRU</code> as medium 0, to <code>H2O521ICRU</code> as medium 1 and to <code>W521ICRU</code> as medium 2 and they will get translated into global media 2, 0 and 4. It is important to note that region and medium indices use C-style numbering, <em>i.e</em>. they run between 0 and <img class="formulaInl" alt="$n-1$" src="form_8.png" width="36" height="11"/> and not between 1 and <img class="formulaInl" alt="$n$" src="form_9.png" width="11" height="8"/>.</p>
<p>The definition of media according to the above input syntax is performed in the <a class="el" href="classEGS__BaseGeometry.html#a28bf612777de14f97108021ae7eb3865">setMedia() </a> function of the base geometry class. Some geometry classes re-implement this function to either prevent media definition (<em>e.g</em>. <a class="el" href="classEGS__UnionGeometry.html" title="A geometry constructed as the union of other geometries.">EGS_UnionGeometry</a>, where the media definition should be done in each geometry of the union, not the union itself) or to implement a more convenient media definition scheme (<em>e.g</em>. <a class="el" href="classEGS__NDGeometry.html" title="A class modeling a N-dimensional geometry.">EGS_NDGeometry</a> or <a class="el" href="classEGS__ConeStack.html" title="A cone stack.">EGS_ConeStack</a>).</p>
<h1><a class="anchor" id="geometry_implementing"></a>
Implementing new geometry classes</h1>
<p>The implementation of a new geometry class may become necessary for various reasons, <em>e.g</em>.</p><ol type="1">
<li>The geometrical structure of interest can not be constructed using the classes supplied with the egspp distribution. <a href="geometry_2egs_box_2egs_box_8cpp-example.html">This page</a> provides a detailed description of the implementation of the <a class="el" href="classEGS__Box.html" title="A box geometry.">EGS_Box</a> class that can serve as a guide for developing a new geometry class.</li>
<li>The user may want to re-implement some method of an existing geometry class such as <em>e.g</em>. <a class="el" href="classEGS__BaseGeometry.html#a28bf612777de14f97108021ae7eb3865">setMedia() </a> to make the definition of media easier</li>
</ol>
<p>The geometry testing <a class="el" href="classEGS__GeometryTester.html">utility </a> provided with the distribution is very helpful in the process of developing new geometries and has helped to find numerous bugs in the initial implementations of the various geometry classes provided with <code>egspp</code>.</p>
<h1><a class="anchor" id="geometry_view"></a>
The geometry viewer: egs_view</h1>
<p>The geometry package comes with a viewer that can be used to look at a geometry defined in an input file in 3D. The viewer permits the user to zoom in and out, change the viewing position, change the colors of the various materials, make materials (semi-)transparent so that it is possible to see inside the geometry, etc. To view the geometry defined in the file <code>some_file</code>, execute the following command </p><pre class="fragment">egs_view some_file
</pre><p> If the name of the file is omitted (or the viewer is started by clicking on its icon), the user is prompted to select a geometry definition file from a file selection dialog. After reading the geometry information, the geometry viewer attempts to automatically determine an optimum viewing position and zoom factor. This is done by first searching for a point that is inside the geometry and then sending out rays in all directions to check for the size of the geometry being viewed. If your geometry is very distant from the origin or if it is too small to be resolved by the search grid, the viewer will fail to find a point inside the geometry and will display an error message. If this problem occurs, one has to include the following section in the geometry definition file outside of the geometry definition section: </p><pre class="fragment">:start view control:
    xmin = some input
    xmax = some input
    ymin = some input
    ymax = some input
    zmin = some input
    zmax = some input
:stop view control:
</pre><p> to help the viewer find a point inside the geometry. Type in the coordinates in cm for a bounding box around your geometry, to help the viewer know where to search.</p>
<p>The rendering of the 3D scene is done using the same geometry methods that are used in a particle simulation (<a class="el" href="classEGS__BaseGeometry.html#a42a459b557011291ea2e8978ebee6295">howfar()</a>, <a class="el" href="classEGS__BaseGeometry.html#af1a37ed6f281a2442a7e96d9658894a9">isWhere()</a>, etc.) by sending rays from the viewing position to the projection screen and calculating their intersections with the geometry. Although this approach is much slower than rendering a scene built from GL primitives and therefore requires a fairly fast CPU, it has the advantage of a thorough check of the geometry definition. If the scene rendered by the viewer looks OK and corresponds to what the user expects, the user can be fairly confident that the geometry definition has no mistakes.</p>
<p>The 3D image just shown in the viewing window can be saved in a file in any format supported by the Qt library (typically jpeg, png, bmp, and various others) using <code>File-&gt;Save</code> <code>image</code>.</p>
<p>Save your view settings, including material colors, clipping planes and more using <code>File-&gt;Save</code> <code>settings</code>. Load the settings again from the <code>File</code> menu, or from the command line using</p>
<pre class="fragment">egs_view yourInput.egsinp yourInput.egsview
</pre><h2><a class="anchor" id="egs_view_display"></a>
The egs_view display tab</h2>
<p>The geometry currently being viewed is selected in the <code>Simulation</code> <code>geometry</code> section. This defaults to the simulation geometry specified in the input file. <code>Clipping</code> <code>planes</code> allow the user to view the internal structure of a geometry. For clipping planes, <code>ax</code>, <code>ay</code> and <code>az</code> define the unit normal to a planar surface. The surface can then be offset from the origin by setting the distance <code>d</code> [cm]. After typing in the 4 parameters, hit <code>Enter</code> to apply the clipping plane, or click away. Use the checkbox to the right of each clipping plane to toggle them on and off.</p>
<p>Particle tracks can be loaded in the viewer, if the simulation was configured to produce a ptracks file (using <a class="el" href="classEGS__TrackScoring.html">EGS_TrackScoring</a>). One way to load the tracks is to launch egs_view with the ptracks file as an additional input. For example,</p>
<pre class="fragment">egs_view yourInput.egsinp yourInput.ptracks
</pre><p>Alternatively, load the ptracks file using <code>File-&gt;Open</code> <code>tracks</code>.... The range of tracks to view can be limited using the two input boxes next to each particle type. Note that you can also load previously saved settings from the command line by also listing the .egsview file, before or after the .ptracks file.</p>
<p>The dose, if scored to a 3ddose file, can be loaded using <code>File-&gt;Open</code> <code>dose</code>.... If a dose scoring ausgab object (<a class="el" href="classEGS__DoseScoring.html">EGS_DoseScoring</a>) that is configured to produce a 3ddose file exists in the input file, then the 3ddose file will be automatically loaded and populate the list in the <code>Dose</code> section. The transparency of the dose is adjusted with the slider. If a 3ddose file is listed but disabled (or "grayed out"), this means that the 3ddose file dimensions did not match an <a class="el" href="classEGS__XYZGeometry.html">EGS_XYZGeometry</a> in the input file.</p>
<div class="image">
<img src="egs_view1.png" alt=""/>
<div class="caption">
The egs_view display tab</div></div>
<h2><a class="anchor" id="egs_view_colors"></a>
The egs_view colors tab</h2>
<p>Various colors in the viewer can be controlled on this tab. Most importantly, material transparencies can be adjusted. Select the material of interest, set its color with the <code>Color</code> button, and set its transparency with the slider.</p>
<p>Setting the other view colors should be intuitive. The particle tracks also have a checkbox to toggle energy-dependent transparency. Enabled by default, this option allows the transparency of track lines to be adjusted depending on the energy of the particle. Particles with the highest energy will not be transparent at all, and the lowest energy particles will be the most transparent.</p>
<div class="image">
<img src="egs_view2.png" alt=""/>
<div class="caption">
The egs_view colors tab</div></div>
<h2><a class="anchor" id="egs_view_regions"></a>
The egs_view regions tab</h2>
<p>The <code>Regions</code> tab allows the user to enable or disable the display of specific regions in the geometry. It does not actually remove the region from the geometry, so it can still be found by hovering the mouse. Rather, it sets the transparency of the region to 0. It also lists the material and color of every region. Of course, for complex geometries this list would be prohibitively long and affect the performance of the application, so the tab is disabled if greater than 1000 regions are in the geometry.</p>
<div class="image">
<img src="egs_view3.png" alt=""/>
<div class="caption">
The egs_view regions tab</div></div>
<h2><a class="anchor" id="egs_view_camera"></a>
The egs_view camera tab</h2>
<p>The <code>Camera</code> tab allows the user to control the camera position. A few camera presets are provided to look along each axis. To set a default view, position the camera as you like and click the <code>Set</code> <code>Home</code> button.</p>
<p>An alternative way to control the view is through directly setting the <code>Camera</code> <code>position</code>. This sets where you are looking from, in the coordinates of the geometry. However, the egs_view has a limitation that the <code>Rotation</code> <code>point</code> must reside within the geometry volume, and a constant distance between the camera position and the rotation point is automatically maintained when you change either parameter. If the new (automatic) rotation point falls outside the geometry, then the change fails to be applied and the camera position is reset to its last setting. Similarly, the user cannot directly set the rotation point itself outside the geometry.</p>
<p>To easily set the rotation point, double click on any surface in the geometry. The new rotation point will be set at that position.</p>
<p>Take note of the controls listed in the <code>Controls</code> section!</p>
<div class="image">
<img src="egs_view4.png" alt=""/>
<div class="caption">
The egs_view camera tab</div></div>
<h1><a class="anchor" id="geometry_examples"></a>
Example geometries</h1>
<p>In the directory <code>$HEN_HOUSE/egs++/geometry/examples</code> there are several example input files specifying geometries for the <code>egspp</code> geometry package. They are provided with the hope that they will help the user to understand the concepts and learn the syntax of the geometry package. Here is a brief description of the examples and screen shots for some of them:</p><ul>
<li>The file <code>hemisphere.geom</code> defines a hemisphere using an <a class="el" href="classEGS__NDGeometry.html">N-dimensional </a> geometry made of a <a class="el" href="classEGS__cSpheres.html">set of spheres</a> and a <a class="el" href="classEGS__PlanesT.html">set of planes</a>.</li>
<li>The file <code>pyramid.geom</code> defines a <a class="el" href="classEGS__PyramidT.html">pyramid </a> with an irregular base that is truncated at the two ends with a <a class="el" href="classEGS__PlanesT.html">set of planes </a> within an <a class="el" href="classEGS__NDGeometry.html">N-dimensional geometry</a>.</li>
<li>The file <code>rz.geom</code> defines a RZ-geometry using an <a class="el" href="classEGS__NDGeometry.html">N-dimensional geometry</a> made of a <a class="el" href="classEGS__CylindersT.html">set of cylinders</a> and a <a class="el" href="classEGS__PlanesT.html">set of planes</a>. The geometry defined is the same as in the <code>cavrznrc_template.egsinp</code> file for the CAVRZnrc application (a simple pancake ionization chamber with graphite walls and air cavity).</li>
<li>The file <code>rz1.geom</code> defines the same geometry as <code>rz.geom</code> but now using an <a class="el" href="classEGS__EnvelopeGeometry.html">envelope geometry</a> to inscribe a smaller cylinder into a larger one, where both cylinders are made using <a class="el" href="classEGS__ConeStack.html" title="A cone stack.">EGS_ConeStack</a> objects.</li>
<li>The file <code>cones.geom</code> demonstrates the use of the <a class="el" href="classEGS__ConeSet.html" title="A set of cones with different opening angles but the same axis and apexes.">EGS_ConeSet</a> class. The user is encouraged to change the <code>flag</code> setting to see how this changes the geometry. <div class="image">
<img src="cones.png" alt=""/>
<div class="caption">
The cone geometry defined in cones.geom</div></div>
</li>
<li>The file <code>rz_phi.geom</code> shows the use of <a class="el" href="classEGS__IPlanes.html">I-planes </a> to divide a cylinder into azimuthal segments <div class="image">
<img src="iplanes.png" alt=""/>
<div class="caption">
rz_phi.geom: using I-planes to divide a cylinder into segments</div></div>
</li>
<li>The file <code>xyz.geom</code> defines an <a class="el" href="classEGS__XYZGeometry.html">XYZ-geometry </a> filled with water and two inhomogeneities made of air and aluminum.</li>
<li><code>mushroom.geom</code> defines a mushroom-like geometrical structure using a <a class="el" href="classEGS__CDGeometry.html">CD-geometry </a> with a <a class="el" href="classEGS__PlanesT.html">set of planes</a> as a base and <a class="el" href="classEGS__cSpheres.html">spheres</a> and <a class="el" href="classEGS__CylindersT.html">cylinders </a> inscribed into the two regions defined by the planes.</li>
<li>The file <code>I6702.inp</code> defines a <img class="formulaInl" alt="$^{125}$" src="form_10.png" width="18" height="9"/>I model 6702 brachytherapy seed using a <a class="el" href="classEGS__CDGeometry.html">CD-geometry</a>, <a class="el" href="classEGS__cSpheres.html">sets of spheres</a> for the rounded ends and an <a class="el" href="classEGS__EnvelopeGeometry.html">envelope </a> containing the radioactive seeds for the middle portion <div class="image">
<img src="I6702.png" alt=""/>
<div class="caption">
Model 6702 brachytherapy seed defined in I6702.inp</div></div>
 <div class="image">
<img src="I6702a.png" alt=""/>
<div class="caption">
Model 6702 brachytherapy seed defined in I6702.inp</div></div>
 The two different views were generated using the transparency and clipping planes features of the geometry viewer.</li>
<li>The file <code>rounded_ionchamber.geom</code> defines an ionization chamber geometry that has rounded ends using a <a class="el" href="classEGS__CDGeometry.html">CD-geometry</a> <div class="image">
<img src="chamber.png" alt=""/>
<div class="caption">
An ionization chamber with rounded ends defined in rounded_ionchamber.geom</div></div>
</li>
<li>The file <code>chambers_in_box.geom</code> takes the ion chamber described in <code>rounded_ionchamber.geom</code> and inscribes it, together with two transformed replicas, into a box of water using an envelope geometry (see the title page).</li>
<li>The files <code>seeds_in_xyz.geom</code> and <code>seeds_in_xyz1.geom</code> define an XYZ-geometry containing 12 replicas of the brachytherapy seed specified in <code>I6702.inp</code>. The difference between the two is that in the one case the XYZ-geometry is used as the envelope in an envelope geometry whereas in the other case the XYZ-geometry is used as the base geometry of a CD-geometry. The user will quickly notice that the CD-geometry approach is substantially more efficient when trying to view these geometries with the geometry viewer.</li>
<li>The file <code>car.geom</code> shows how to put together a car from simpler structures (<a class="el" href="classEGS__ConeStack.html" title="A cone stack.">EGS_ConeStack</a> objects are used for the axis and wheels, <a class="el" href="classEGS__Box.html">boxes</a> for the car body) using a <a class="el" href="classEGS__UnionGeometry.html">union</a>. <div class="image">
<img src="car.png" alt=""/>
<div class="caption">
A car geometry defined in car.png</div></div>
</li>
<li>The file <code>photon_linac.geom</code> shows how one can quickly put together a geometry model of the treatment head of a medical linear accelerator. The geometry defined in this file is identical to the 16 MV photon example that comes with the BEAMnrc distribution (except that the monitor chamber is not included). <div class="image">
<img src="linac1.png" alt=""/>
<div class="caption">
A Linac geometry defined in photon_linac.geom</div></div>
 <div class="image">
<img src="linac2.png" alt=""/>
<div class="caption">
A different view of the geometry defined in photon_linac.geom</div></div>
</li>
</ul>
<p>Note that all figures shown in this section were generated with the <code>egspp</code> <a class="el" href="group__Geometry.html#geometry_view">geometry viewer</a>. A more detailed description of the example geometries can be found <a class="el" href="example_geometries.html">here</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5bc12ceac1e65f64b3c7d3b62e4ce4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bc12ceac1e65f64b3c7d3b62e4ce4ff">&#9670;&nbsp;</a></span>EGS_GLIB_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EGS_GLIB_</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>egs_glib is a shim to be used in conjunction with the EGS Input <code>include file</code> directive for creating geometries defined in external files.</p>
<p>This is useful when you have a geometry defined in an external file: </p><pre class="fragment"> # your egsinp/geom file
:start geometry definition:

    :start geometry:
        library = egs_glib
        name = my_external_geom
        include file = /path/to/some/external/geom
    :stop geometry:

    :start geometry:
        library = egs_ndgeometry
        type = EGS_XYZGeometry
        name = my_base_geom
        x-planes =  -10 -5 0 5 10
        y-planes =  -10 -5 0 5 10
        z-planes =  -10 -5 0 5 10

        :start media input:
            media = WATER
        :stop media input:

    :stop geometry:

    :start geometry:
        library = egs_genvelope
        name = my_envelope_geom
        base geometry = my_base_geom
        inscribed geometries = my_external_geom
    :stop geometry:

    simulation geometry = my_envelope_geom

:stop geometry definition:</pre><p>and then in your external file you would have something like:</p>
<pre class="fragment"> #The external geom (/path/to/some/external/geom)
:start geometry definition:

    :start geometry:
        library   = egs_spheres
        midpoint  = 0 0 0
        radii     = 4
        name      = the_sphere
        :start media input:
            media = medium1
        :stop media input:
    :stop geometry:

    simulation geometry = the_sphere

:stop geometry definition:</pre><p>The above two definitions would result in a geometry equivalent to:</p>
<pre class="fragment">:start geometry definition:

    :start geometry:
        library   = egs_spheres
        midpoint  = 0 0 0
        radii     = 4
        name      = the_sphere
        :start media input:
            media = medium1
        :stop media input:
    :stop geometry:

    :start geometry:
        library = egs_ndgeometry
        type = XYZGeometry
        name = my_base_geom
        x-planes =  -10 5 0 5 10
        y-planes =  -10 5 0 5 10
        z-planes =  -10 5 0 5 10
    :stop geometry:

    :start geometry:
        library = egs_genvelope
        name = my_envelope_geom
        base geometry = my_base_geom
        inscribed geometries =  the_sphere
    :stop geometry:

    simulation geometry = my_envelope_geom

:stop geometry definition:</pre><h2><a class="anchor" id="autotoc_md8"></a>
Examples</h2>
<p>Examples of using the glib library are available in the glib.geom and seeds_in_xyz_aenv.geom files. </p>

<p class="definition">Definition at line <a class="el" href="egs__glib_8h_source.html#l00169">169</a> of file <a class="el" href="egs__glib_8h_source.html">egs_glib.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
