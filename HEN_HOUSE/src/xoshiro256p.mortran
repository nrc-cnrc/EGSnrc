%C80
"#############################################################################"
"                                                                             "
"  EGSnrc xoshiro256+ random number generator                                 "
"  Copyright (C) 2024 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Ernesto Mainegra-Hing, 2024                               "
"                                                                             "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Sum-scrambled F2 linear pseudorandom number generator (64-bit).            "
"                                                                             "
"  Random number generators based on linear recurrences modulo 2 are among    "
"  the fastest long-period generators currently available. The uniformity and "
"  independence of the points they produce, by taking vectors of successive   "
"  output values from all possible initial states, can be quickly measured  "
"  using analytical figures of merit. Generators having good figures of merit "
"  values are, in general, statistically reliable.
"  Xoshiro256+ is faster than xoshiro256++ since it uses a weaker scrambler   "
"  based on the sum of the first and last words of the state array. If, one is"
"  only interested in generating 64-bit floating-point numbers (by extracting "
"  the upper 53 bits), or if the mild linear artifacts in its lowest bits are "
"  not considered problematic, this one is a faster generator with analogous  "
"  statistical properties.
"                                                                             "
"  Footprint (bits): 256     Period: 2**256 - 1                               "
"                                                                             "
"  References:                                                                "
"                                                                             "
"  D. Blackman and S. Vigna.  ACM Trans.Math.Softw., 47:1-32, 2021            "
"  P. L'Ecuyer and R. Simard. ACM Trans.Math.Softw., 33(4), Article 22, 2007  "
"  P. L'Ecuyer and F. Panneton. F2-Linear Random Number Generators, (2009)    "
"  International Series in Operations Research & Management Science,          "
"  vol 133. Springer, Boston, MA. https://doi.org/10.1007/b110059_9           "
"                                                                             "
"#############################################################################"
#define RNGSIZE $RNGSIZE
%Q1
%F
      !> Returns real normalized random number U(0,1)
      function unif01() result(res_f)
        implicit none

        !> Inverse of largest integer
        real*8, parameter :: twom53 = 1.0d0/2.0d0**53

        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8 :: s
     
        integer*8 :: s_loc(4)
        integer*8 :: t
        integer*8 :: res
        real*8    :: res_f
    
        s_loc = s
        
        !> Sum
        res = s_loc(1) + s_loc(4)
    
        ! Convert to real
        res_f = shiftr(res, 11)*twom53
    
        t = shiftl(s_loc(2), 17)
    
        s_loc(3) = ieor(s_loc(3), s_loc(1))
        s_loc(4) = ieor(s_loc(4), s_loc(2))
        s_loc(2) = ieor(s_loc(2), s_loc(3))
        s_loc(1) = ieor(s_loc(1), s_loc(4))
            
        s_loc(3) = ieor(s_loc(3), t)
    
        !> Left-rotation
        s_loc(4) = ior(shiftl(s_loc(4), 45),  
     >                 shiftr(s_loc(4), 19))
        
        s = s_loc
    
      end function unif01

      !> Get the next value (returned as 64 bit signed integer)
      function next()
        implicit none

        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8  :: s
        integer*8  :: next, t
        integer*8  :: s_loc(4)
        
        s_loc = s
            
        !> Sum
        next = s_loc(1) + s_loc(4)
        
        t = shiftl(s_loc(2), 17)
        
        s_loc(3) = ieor(s_loc(3), s_loc(1))
        s_loc(4) = ieor(s_loc(4), s_loc(2))
        s_loc(2) = ieor(s_loc(2), s_loc(3))
        s_loc(1) = ieor(s_loc(1), s_loc(4))
                
        s_loc(3) = ieor(s_loc(3), t)
        
        !> Left-rotation
        s_loc(4) = ior(shiftl(s_loc(4), 45),  
     >                 shiftr(s_loc(4), 19))
            
        s = s_loc
      
      end function next

      ! This is the jump function for the generator. It is equivalent
      ! to 2^64 calls to next(); it can be used to generate 2^64
      ! non-overlapping subsequences for parallel computations.
      subroutine jump
        implicit none    
        ! A 64 bit integer type
        integer, parameter :: i8 = selected_int_kind(18)
        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8 :: s
        integer   :: i, b
        integer*8 :: t(4), next, dummy
        ! The signed equivalent of the unsigned constants
        integer*8, parameter :: jmp_c(4) = (/1733541517147835066_i8,
     +                                      -3051731464161248980_i8, 
     +                                      -6244198995065845334_i8,
     +                                       4155657270789760540_i8/)
        
        t = 0
        do i = 1, 4
           do b = 0, 63
              if (iand(jmp_c(i), shiftl(1_i8, b)) /= 0) then
                 t = ieor(t, s)
              end if
              dummy = next()
           end do
        end do
                         
        s = t
        
      end subroutine jump
            
      !> Set a seed for the rng
      subroutine set_seed(the_seed)
        implicit none
     
        ! Current rng state (seeds)
        common/randomm/s(4)
        integer*8 :: s
        integer*8 :: the_seed(4)
      
        s = the_seed
        
        !Perform calls to next() to improve randomness of initial state
        call jump
      
      end subroutine set_seed

      !> Returns current seeds
      subroutine get_state( state )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer*8 :: state(4)
        state = s
      end subroutine get_state

      !> Reset current seeds
      subroutine set_state( state )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer*8 :: state(4)
        s = state
      end subroutine set_state
      
      !> Output current seeds to ounit with fixed format
      subroutine show_seeds( ounit )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer ounit
        write(ounit,"(4(/a,i0))") " s(1) = ",s(1)," s(2) = ",s(2),
     +                           " s(3) = ",s(3)," s(4) = ",s(4)
      end subroutine show_seeds

      !> Output current seeds to ounit with fixed format
      subroutine print_seeds( ounit, fmt )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer   :: ounit
        character *(*) fmt
        write(ounit,fmt) s
      end subroutine print_seeds
%M
;
