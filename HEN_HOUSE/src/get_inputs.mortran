%C80
"#############################################################################"
"                                                                             "
"  EGSnrc parameter input functions                                           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Aaron Merovitz, 1998                                      "
"                   Dave Rogers, 1998                                         "
"                   Iwan Kawrakow, 1998                                       "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
"                                                                             "
"  - Input values taken only if between specified delimiters (prior this      "
"    change, the first VALUES_SOUGHT found was taken, even if it was not      "
"    between the specified delimiters).                                       "
"                                                                             "
"  - Changed argument list to a common block GetInput defined in egs4.macros  "
"    to avoid memory use explosion.                                           "
"                                                                             "
"  - Eliminated initial loop checking for presence of values sought as it is  "
"    not necessary.                                                           "
"                                                                             "
"  - Introduced macros for handling strings (skipping blanks and comments,    "
"    changing to upper case, etc.)                                            "
"                                                                             "
"  - Eliminated string input bug: strings were always converted to upper case "
"                                                                             "
"  - Changed definition of strings to character*$MACRO where $MACRO has a     "
"    certain value that can be be defined in the user code if longer strings  "
"    are required.                                                            "
"                                                                             "
"                                                                             "
"  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
"                                                                             "
"  - Missing or misspelled end delimiter together with a missing value sought  "
"    caused the routine to terminate. It now prints an error message and      "
"    continues to look for additional input.                                  "
"                                                                             "
"  - Introduced an array ERROR_FLAGS where the input status of each of the    "
"    attempted inputs is stored.                                              "
"                                                                             "
"#############################################################################"


SUBROUTINE GET_INPUT;
"                                                                           "
"                                                                           "
" FUNCTION: Extracts the requested values_sought from input file and        "
"           returns it to the caller.                                       "
"                                                                           "
" USAGE   :      Inputs must have the general form:                         "
"              ***************************************                      "
"              * Value_sought=  Value(s)             *                      "
"              ***************************************                      "
"         e.g.:        MEDNUM= 0, 1, 2                                      "
"                      MEDIA= AIR700ICRU                                    "
"                      RAYLEIGH SCATTERING= on                              "
"                                                                           "
"***************************************************************************"
"           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
"***************************************************************************"
"
"   Inputs are all in the format: name of value_sought= value
"   where the name of value_sought must match that expected by the
"   program and the = sign must have no blanks between it and value_sought.
"
"   The value_sought must be the first thing on a line but blanks are
"     allowed before it.
"
"   Various inputs are only sought between certain delimeter strings
"     which are defined below (eg :start I/O control: :stop I/O control:)
"     If not specified, the whole file is searched for a requested value_sought.
"     Delimeter strings are enclosed by colons.
"     Note that within delimeter strings, order of inputs does not matter.
"
"   If a requested quantity is not found, this is noted in $input.errors
"     and this file is printed at the end of the log file.
"
"   A semi-colon implies the end of input for this quantity but is
"     not mandatory.  However, this means they cannot be used in titles.
"   A # sign indicated everything else on the line is a comment (and
"     cannot be used in titles.
"   Case is not important in the names of the quantites.
"
"   Commas separate multiple values for a given quantity and a comma
"     at the end of a line implies there is more input on the next line.
"   Values can extend over as many lines as needed. Use commas to imply
"     there are more values on the next line.
"
"   Blank lines and blanks in general are ignored.
"
"   The maximum record length is 256 characters.
"
"
"*******************************************************************************
"* (1)  *  Integers between parentheses show the value of the internal         *
"*      *  variable corresponding to this input. These are for reference only. *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value(no ; or #).              *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"                                                                           "
"                                                                           "
" FEATURES: If the amount of values needed for a particular values_sought   "
"           is known and passed throught NVALUE(I), the subroutine will     "
"           check that the number of inputs correspond.  Otherwise,         "
"           NVALUE(I) will return the # of inputs found.                    "
"                                                                           "
"           For any integer or real (TYPE=0 or 1), get_inputs will check    "
"           that the numerical value input is between VALUE_MIN and         "
"           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
"                                                                           "
"           Writing in the input file can be upper case or lower case.      "
"           However, all FORTRAN >MUST< be programmed in upper case.        "
"              Changed the above: Can now be upper or lower case            "
"                                 IK, Dec. 1998                             "
"                                                                           "
"           For clarity, inputs can be terminated with a semicolon(;).      "
"           This is by no means necessary.                                  "
"                                                                           "
"***************************************************************************"
"          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
"***************************************************************************"
"                                                                           "
"                   **** DECLARE YOUR INPUTS ****                           "
"                                                                           "
"    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
"                                                                           "
"  I=I+1;                              <--index counter                     "
"  NUM_DRMIN=I;                        <--named pointer to the index num.   "
"  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
"  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
"  TYPE(I)=0;                          <--Type (0-3)                        "
"  VALUE_MIN(I)=0;                     <--Minimum value                     "
"  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
"  DEFAULT(I)=0;                       <--Default value                     "
"                                                                           "
"    CHARACTER INPUTS (TYPE 2)                                              "
"                                                                           "
"  I=I+1;
"  NUM_TITLE=I;
"  VALUES_SOUGHT(I)='TITLE';
"  TYPE(I)=2;
"  NVALUE(I)=1;                        <--left out if not known
"
"    ALLOWED INPTUS (TYPE 3)
"
"  I=I+1;
"  NUM_IWATCH=I;
"  VALUES_SOUGHT(I)='IWATCH';
"  NVALUE(I)=1;                        <--left out if not known
"  TYPE(I)=3;
"  ALLOWED_INPUTS(I,0)='OFF';
"  ALLOWED_INPUTS(I,1)='INTERACTIONS';
"  ALLOWED_INPUTS(I,2)='STEPS';
"  ALLOWED_INPUTS(I,3)='DEPOSITED';
"  ALLOWED_INPUTS(I,4)='GRAPH';
"                                                                           "
"                      **** STATE THE DELIMETER ****                        "
"                                                                           "
"            DELIMETER='TRANSPORT CONTROL'                                  "
"     OR     DELIMETER='NONE';                                              "
"                                                                           "
"  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
"                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
"                                                                           "
"   The inputs are returned through CHAR_VALUE for character inputs         "
"   or VALUE for integers, reals and allowed inputs                         "
"                                                                           "
"---------------------------------------------------------------------------"


;IMPLICIT NONE;

COMIN/GetInput,EGS-IO/;

"***************************************************************************"
"*                   Variables used by the subroutine                      *"
"***************************************************************************"
CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
CHARACTER*$STRING256  TEXTPIECE; "Used to read a piece of TEXT                 "
CHARACTER*$STRING40  DELIM_START;"Start of the delimeter                       "
CHARACTER*$STRING40  DELIM_END;  "End of the delimeter                         "
CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
$INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
$INTEGER       IINDEX;          "Integer index for clipping string excess.     "
$INTEGER       iVNAME;          "Length of variable name string.               "
$INTEGER       IVAL;            "Value number of the value_sought              "
$INTEGER       UNITNUM;         "Unit number of the input file                 "
$INTEGER       ERR;             "Unit number of the error file                 "
$INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
$INTEGER       LINE;            "Counts the eumber of lines                    "
$INTEGER       INT_VALUE;       "For printing integers                         "
$INTEGER       INT_VALUE_MIN;   "For printing integers                         "
$INTEGER       INT_VALUE_MAX;   "For printing integers                         "
$LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
$LOGICAL       START_FOUND;     "Start of delimeter switch                     "
$INTEGER       ifound,length,lll,Kconvert;
$INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
                       "support this"
logical IDEBUG;
character*1 blank;
$INTEGER    error_level;
$INTEGER    the_level;
data blank/' '/;
data        error_level/1/;
save        error_level;
"---------------------------------------------------------------------------"

"Macro changing text string to upper case"
"REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
REPLACE {$CONVERT # TO UPPER CASE;} WITH
{;
   DO Kconvert=1, lnblnk1({P1}) [
         CURSOR=ICHAR({P1}(Kconvert:Kconvert));
         IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            CURSOR=CURSOR-32;
            {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
         ]
   ]
}
;

"Macro to skip leading blanks "
REPLACE {$SKIP LEADING BLANKS IN #;} WITH
{;
  length = len({P1});
  WHILE ( index({P1},blank) = 1 ) [
    IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
    length = length - 1;
  ]
}

"Macro that removes everything after comments "
REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
{
  ifound = INDEX({P2},{P1});
  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
}

REPLACE {$STRING-OUTPUT(#);} WITH
{;
  length = lnblnk1({P1});
  IF( length > 0 ) [
    DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
    write(i_log,*); "For a new line"
  ]
}

IDEBUG = .false.;   "set to .true. for debug outputs"
ERROR_FLAG = 0;
IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
   I5,' to', I5, '  with a max allowed of',I5);
]
IF (NMAX < NMIN | NMAX > $NMAX)[
  OUTPUT NMAX, NMIN, $NMAX;
  (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
  '    with a max of',I5//' This implies a bug in the calling routine'/
  ' Fix it up and try again.  Stopping now.');
  STOP;
]
ERR=i_errors;    "inputfile.errors"
UNITNUM=i_input; "inputfile.egs4inp"
DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
$CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
$CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"

IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
   A/A/);
]
"===================check that each value_sought is there===================="

DO I = NMIN, NMAX  [ "for each value_sought"
   REWIND (UNITNUM);   "Rewind the input file"
   LINE=0;             "reset line counter"
   CHECK=0;            "reset error checker"
   ERROR_FLAGS(I)=0;
   " Set to default for the case the input is not found "
   IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
   IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
   VNAME=VALUES_SOUGHT(I);
   iVNAME=lnblnk1(VNAME);
   IF( ivname < 1 )
   [
     IF( error_level > 0 ) [
       write(ERR,*) ' ======================= Warning ===================== ';
       write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
       write(ERR,*) ' ===================================================== ';
     ]
     ERROR_FLAG=1;
     ERROR_FLAGS(I)=1;
     goto :END-NMIN-NMAX-LOOP:;
   ]

   $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
   iindex = 0;
   IF (DELIMETER = 'NONE') [ start_found = .true.; ]
   ELSE                    [ start_found = .false.; ]
   WHILE ( iindex = 0 )  "Until the value sought is found"
   [
:GI25:
       CONTINUE;
       LINE=LINE+1;
       IF( start_found ) [
         READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       ELSE [
         READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
       ]
       "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
       $SKIP LEADING BLANKS IN text;
       $REMOVE EVERYTHING AFTER '#' IN text;
       $REMOVE EVERYTHING AFTER ';' IN text;
       length = lnblnk1(TEXT);
       TEXT=TEXT(:length);
       origtext = text(:length);
       $CONVERT text TO UPPER CASE;
       IF( ~start_found ) [
         IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
         goto :GI25:;
       ]

       iindex=INDEX(TEXT,VNAME(:iVNAME));

       " Check for end delimeter "
       IF( DELIMETER~='NONE' )
       [
         IF (INDEX(TEXT,DELIM_END)~=0)
         [
             IF( error_level > 0 ) [
             WRITE (ERR,*) '***************ERROR***************';
             WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                           '<<',' NOT FOUND';
             WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
             ]
             ERROR_FLAG=1;
             ERROR_FLAGS(I)=1;
             GOTO :END-NMIN-NMAX-LOOP:;
         ]
       ]
   ] "end while loop. If we pass this loop, we have the values_sought string "
     "in text"

   CHECK=0; "reset error checker"
   IF( idebug ) [
       write(i_log,*) ' ******* Found: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   " Set string pointer to position after vname string and/or "
   " leadinf equals                                           "
   IINDEX=IINDEX+iVNAME;
   TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
   IF( idebug ) [
       write(i_log,*) ' After removing vname: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]
   IINDEX=INDEX(TEXT,'=');
   IF (IINDEX.NE.0) [
      TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
   ]
   ELSE [
       IINDEX=INDEX(TEXT,':');
       IF (IINDEX.NE.0) [
          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
       ]
   ]
   IF( idebug ) [
       write(i_log,*) ' After removing leading equals: ';
       write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
       write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
   ]

   "===============read the value(i)======================="
   IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
   [
        IF (vname(:ivname)='TITLE')
        [
           READ (UNITNUM,FMT='(A256)') TEXTPIECE;
           IF (lnblnk1(TEXTPIECE)~=0) [
              TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
              $SKIP LEADING BLANKS IN text;
              $SKIP LEADING BLANKS IN origtext;
              GOTO :TITLE-THERE:;
           ]
        ]
        IF( error_level > 0 ) [
        WRITE (ERR,*) '*************ERROR*************';
        WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
        WRITE (ERR,*) 'VALUE NOT THERE!!';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        RETURN;
   ]
:TITLE-THERE:
   CONTINUE;

   " Always check for default. The following sets the value to "
   " default(i) for a numeric input (type=1 or 2) and to 0 for "
   " an 'allowed input' => use only if one input is expected!  "
   iindex = index(text,'DEFAULT');
   IF( iindex ~= 0 )
   [                  "User requested a default value"
       IF( type(i) ~= 2 )
       [
           IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
           ELSE               [ VALUE(I,1)=0;          ]
           goto :END-NMIN-NMAX-LOOP:;
       ]
   ]

   IF ((TYPE(I) = 0)|(TYPE(I) = 1))
   [                                 "Read the number"
       IVAL=1;  "nvalue counter"
       IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
                 IF( error_level > 0 ) [
                 WRITE(ERR,*) '*************ERROR*************';
                 WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                 WRITE (ERR,*) 'VALUE NOT THERE!!';
                 ]
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
                 RETURN;
           ]
           READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
           IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
"==========================================================================="
"=================================Defaults=================================="

           IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
           [
               IF (TYPE(I)=0)
               [
                    INT_VALUE=DEFAULT(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTA:) INT_VALUE,
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    ]
                    :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
                    INT_VALUE=VALUE(I,IVAL);
                    INT_VALUE_MIN=VALUE_MIN(I);
                    INT_VALUE_MAX=VALUE_MAX(I);
                    IF( error_level > 0 ) [
                    WRITE(ERR,:FMTB:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
                    ]
                    :FMTB: FORMAT (A,'=', I9,' should be between ',
                                   I9,' and ', I9);
               ]
               IF (TYPE(I)=1)
               [
                    IF( error_level > 0 ) [
                    WRITE(ERR,*) '************WARNING************';
                    WRITE(ERR,:FMTC:) DEFAULT(I),
                                 VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
                    :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
                    WRITE(ERR,:FMTD:)
                        VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
                        VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
                    :FMTD: FORMAT (A,'=', F12.6,' should be between ',
                                   G14.6,' and ', G14.6);
                    ]
               ]
               VALUE(I,IVAL)=DEFAULT(I);
           ] "end IF default"

           IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
"==========================================================================="
"=======================Move to next value, else exit======================="

           IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
           [
               IF ( idebug ) [
                   write(i_log,*) ' A comma or a blank text found -> ';
                   write(i_log,*) ' searching for further input';
               ]
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   IF ( idebug ) [
                     write(i_log,*) ' Empty text -> reading next line! ';
                   ]
                   LINE=LINE+1;
                   READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             IF( error_level > 0 ) [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ]
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
                   IF( idebug ) [
                     write(i_log,*) ' Next line: ';
                     write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
                     write(i_log,'(a,$)') ' origtext: ';
                                          $STRING-OUTPUT(origtext);
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
       ] "end loop"
       IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '**************ERROR**************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
       ]
       ELSE [NVALUE(I)=IVAL;]
:GI1010:
       CONTINUE;
   ] "end IF TYPE"

"============================read the char_value(i)========================="

   IF ((TYPE(I) = 2) | (TYPE(I) = 3))
   [                                   "Read the string"
       IVAL=1;     "nvalue counter"
       IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
       LOOP
       [
           IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
           IF (lnblnk1(TEXT)=0) [
              IF( error_level > 0 ) [
              WRITE(ERR,*) '*************ERROR*************';
              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
              WRITE (ERR,*) 'VALUE NOT THERE!!';
              ]
              ERROR_FLAG=1;
              ERROR_FLAGS(I)=1;
              RETURN;
           ]
           IF (vname(:ivname)='TITLE') [
              TEXTPIECE=origtext;
              GOTO :READ-IT:
           ]
           iindex = INDEX(origtext,',');
           IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
           ELSE               [ TEXTPIECE=origtext;            ]
                      "The above is to avoid conversion to upper case"
                      "for e.g. media names                          "
           :READ-IT:
           CONTINUE;
           READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
           $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
           IF( idebug ) [
             write(i_log,*) ' Read the following char string: ';
             $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
           ]
"===============================Allowed inputs=============================="
           IF (TYPE(I) = 3)
           [
              $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
              ALLOWED=.FALSE.;
              DO K=0, $MXALINP [
                 vname1 = ALLOWED_INPUTS(I,K);
                 $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
                 $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
                 IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
                    ALLOWED=.TRUE.;
                    VALUE(I,IVAL)=K;
                    IF( idebug ) [
                      write(i_log,*) ' Found a allowed_value match ',k;
                    ]
                 ]
              ]
              IF (.NOT.ALLOWED) [
                 WRITE(ERR,*) '*************ERROR*************';
                 IF (IVAL~=1) [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
                 WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
                 ]
                 ELSE [
                    WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                    WRITE(ERR,*) 'INPUT-->',
                               CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
                               '<--NOT ALLOWED';
                    WRITE(ERR,*) 'OPTIONS ARE:';
                    WRITE(ERR,:FMT:)
                    (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
                     K=0,$MXALINP);
                 ]
                 :FMT: FORMAT(A40);
                 ERROR_FLAG=1;
                 ERROR_FLAGS(I)=1;
              ]
           ]
"=======================Move to next value, else exit======================="

           IF (vname(:ivname)='TITLE') [ EXIT; ]
           DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
           KEEPTEXT(:lnblnk1(TEXT))=TEXT;
           iindex = INDEX(TEXT,',');
           IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
           [
               TEXT=TEXT(INDEX(TEXT,',')+1:);
               origtext=origtext(iindex+1:);
               WHILE (lnblnk1(TEXT)=0)
               [
                   LINE=LINE+1;
                   READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
                   $SKIP LEADING BLANKS IN text;
                   $REMOVE EVERYTHING AFTER '#' IN text;
                   $REMOVE EVERYTHING AFTER ';' IN text;
                   length = lnblnk1(TEXT);
                   TEXT=TEXT(:length);
                   origtext = text(:length);
                   $CONVERT text TO UPPER CASE;

                   "Check whether this line containes one of the strings sought"
                   DO K = 1 , NMAX
                   [
                       vname1 = VALUES_SOUGHT(K);
                       length = lnblnk1(vname1);
                       IF( length > 0 )
                       [
                           $SKIP LEADING BLANKS IN vname1;
                           $CONVERT vname1 TO UPPER CASE;
                           IF (INDEX(TEXT,vname1(:length))~=0)
                           [
                             WRITE(ERR,*) '************ERROR************';
                             WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
                             WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
                                      '<--COMMA INDICATES ANOTHER INPUT';
                             WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
                                             TEXT(:lnblnk1(TEXT));
                             WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
                             ERROR_FLAG=1;
                             ERROR_FLAGS(I)=1;
                           ]
                       ]
                   ]
               ]
           ] "end if ~=0"
           ELSE [EXIT;]
           IVAL=IVAL+1;
        ] "end loop"
        IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
           IF( error_level > 0 ) [
           WRITE (ERR,*) '*******************ERROR*******************';
           WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
           WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
           WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
           ]
           ERROR_FLAG=1;
           ERROR_FLAGS(I)=1;
        ]
        ELSE [NVALUE(I)=IVAL;]
   ]
"==========================================================================="
"==========================================================================="
   goto :END-NMIN-NMAX-LOOP:;

:GI1003:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'END DELIMETER: >>',
          DELIM_END(:lnblnk1(DELIM_END)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1004:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '******************ERROR***********************';
        WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
        WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
        WRITE (ERR,*) 'VALUE SOUGHT: >>',
          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
        WRITE (ERR,*) 'START DELIMETER: >>',
          DELIM_START(:lnblnk1(DELIM_START)),'<<';
        ]
        ERROR_FLAG=1;
        ERROR_FLAGS(I)=1;
        goto :END-NMIN-NMAX-LOOP:;

:GI1007:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
        WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
        WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"
        GOTO :END-NMIN-NMAX-LOOP:;
:GI1008:
        IF( error_level > 0 ) [
        WRITE (ERR,*) '***************ERROR***************';
        WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
        WRITE (ERR,*) 'LINE #',LINE;
        WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
        ]
        ERROR_FLAG=1; "turn on the error flag"
        ERROR_FLAGS(I)=1; "turn on the error flag"

:END-NMIN-NMAX-LOOP:
    CONTINUE;
] "end do NMAX loop"
RETURN;

"**************if any errors**************"
:GI1001:
      WRITE (ERR,*) '***************ERROR***************';
      WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
      goto :GI1009:;
"the following is no longer used so comment it out"
":GI1002:
"      WRITE (ERR,*) '***************ERROR***************';
"      IF (CHECK=100) [
"         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
"         WRITE (ERR,*) 'WAS NOT FOUND';
"      ]
"      ELSE [
"         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
"                       '<<',' NOT FOUND';
"      ]
"      WRITE (ERR,*) 'END OF FILE REACHED';
:GI1009:
      CONTINUE;  "exit if there is an error"
      ERROR_FLAG=1; "turn on the error flag"
      ERROR_FLAGS(I)=1; "turn on the error flag"
      RETURN;

entry get_input_set_error_level(the_level);
error_level = the_level;
return;
END;



%E   "get_inputs.mortran"
"*****************************************************************************
"
subroutine get_transport_parameter(ounit);
"
" is provided for use with the EGSnrc system. It reads all physics
" related parameters from the input file using the get_input routine.
" For a description for the format/conventions used in get_input,
" see the description at the beginning of this file.
" In order to use this routine, include transportp.macros BEFORE
" get_inputs.mortran via the configuration file.
" If the routine is called with ounit > 0, the transport parameter
" settings will be printid on unit ounit.
"
" Version 0.1           Iwan Kawrakow, January 1999
"
"******************************************************************************
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (case does not matter and
"             the internal variables are shown in [ ] brackets):
"
"       Global ECUT=     Global (in all regions) electron transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Global (in all regions) photon transport cut
"                        off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions
"                        will be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%).
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        difference even in `well conditioned' situations
"                        (e.g. depth dose curves for RTP energy range
"                        electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If KM, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, NRC default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but significant in the keV energy range. If NRC is
"                        selected, the NRC brems cross-section data base will
"                        be used, which is a version of the NIST data base
"                        with corrected electron-electron brems contributions
"                        (corrections to the NIST data is typically only
"                        significant for low values of the atomic number Z
"                        and for k/T < 0.005).
"       Triplet production= On or Off (default).  Turns on/off simulation
"                        of triplet production.  If On, then Borsellino's
"                        first Born approximation is used to sample triplet
"                        events based on the triplet cross-section data.
"                        [ itriplet ]
"       Bound Compton scattering=  On, Off, Simple or norej (default)
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impulse approximation.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to use for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Radiative Compton corrections= On or Off (default). If on, then
"                        include radiative corrections for Compton scattering.
"                        Equations are based on original Brown & Feynman
"                        equations (Phys. Rev. 85, p 231--1952).  Requires
"                        a change to the user codes Makefile to include
"                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
"                        SOURCES (just before
"                        $(EGS_SOURCEDIR)get_inputs.mortran).
"                        [ radc_flag ]
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski, penelope.  If set to On or ik, then use
"                        Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then
"                        use the cross-sections of Casnati (contained in the
"                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
"                        kolbenstvedt, gryzinski and penelope. This is only of
"                        interest in kV X-ray calculations.
"                        Case-sensitive except for Off, On or ik options.
"                        [ eii_flag ]
"       Pair angular sampling= Off, Simple, KM.
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.  Uniform
"                        Default is Simple, make sure you always use
"                        Simple or KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel), epdl (Evaluated Photon Data
"                        Library), xcom (the default), pegs4, mcdf-xcom and
"                        mcdf-epdl:
"                        Allows the use of photon cross-sections other than
"                        from the PEGS4 file (unless the pegs4 option is
"                        specified).  Options mcdf-xcom and mcdf-epdl use
"                        Sabbatucci and Salvat's renormalized photoelectric
"                        cross sections with either xcom or epdl for all other
"                        cross sections.  These are more accurate but can
"                        increase CPU time by up to 6 %.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering.
"                        Default is On. Should be turned on for low energy
"                        applications.
"                        If custom, user must provide media names and form
"                        factor files for each desired medium. For the rest
"                        of the media, default atomic FF are used.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"Ali:photonuc, 2 blocks of comments"
"       Photonuclear attenuation= Off (default) or On
"                        If On, models the photonuclear effect. Current
"                        implementation is crude. Available on a
"                        region-by-region basis (see below)
"                        [ IPHOTONUCR ]
"       Photonuclear cross sections= Total photonuclear cross sections. User-
"                        supplied total photonuclear cross-sections in
"                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
"                        where photonuc_xsections is the name supplied for
"                        this input (case sensitive). In the absence of
"                        any user-supplied data, or if photonuc_xsections
"                        is set to 'default', the default file is
"                        iaea_photonuc.data.
"                        [ photonuc_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Atomic relaxations= Off, On, eadl, simple
"                        Default is eadl.  On defaults to eadl.
"                        When simulating atomic relaxations:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross sections
"                        - Shell vacancies created in photoelectric,
"                          compton and electron impact ionization events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         The eadl option features a more accurate treatment
"                         of relaxation events and uses binding energies
"                         consistent with those in of the photon cross sections
"                         used in the simulation.  If using mcdf-xcom or
"                         mcdf-epdl photon cross sections, you cannot use
"                         the simple option and this will automatically get
"                         reset to eadl.
"                         Make sure to use eadl or simple for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"       and photonuclear effect(Ali:photonuc)
"       can also be turned On/Off on a region-by-region
"       basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"                or                  Ali:photonuc
"       Photonuclear start region=
"       Photonuclear stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn on in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************

implicit none;  "Hard coded to catch possible user replacements of the "
                "following common blocks"

character*80 line;
character*512 toUpper;

$INTEGER ounit;
$declare_max_medium;

$COMIN-GET-TRANSPORTP;

$INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
          num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
          num_ffmed,num_ffiles,
          num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
          num_pxsec,num_pxsec_out, num_cxsec,
          num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
          num_efield, num_bfield, num_emlmt,"EMH: EM fields"
          num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
          egs_open_file,lnblnk1;

$LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
          incoh_inregions,coh_inregions,relax_inregions,
          pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"

character*15 output_strings(14);"Ali:photonuc, increased by 1"
save         output_strings,line;
save         ecut_inregions,pcut_inregions,smax_inregions,
             incoh_inregions,coh_inregions,relax_inregions,
             pe_inregions,aux_inregions,photonuc_inregions,
             num_photonuc;"Ali:photonuc"


DO k=1,80 [ line(k:k) = '='; ]
delimeter = $THE_DELIMETER;
ival = 0;

;
/ecut_inregions,pcut_inregions,smax_inregions,
 incoh_inregions,coh_inregions,relax_inregions,
 pe_inregions,aux_inregions,
 "Ali:photonuc, 1 line"
 photonuc_inregions/ = .false.;

"open a .errors file exclusively for output from this subroutine"
i_errors=15;
i_errors=egs_open_file(i_errors,0,1,'.errors');

write(i_errors,*)
' If you are not trying to reset transport parameters, ';
write(i_errors,*)
' ignore all the output until the message ';
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

" ECUT "
ival                = ival + 1;
num_ecut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-ECUT;

" PCUT "
ival                = ival + 1;
num_pcut            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $GLOBAL-PCUT;

" SMAX "
ival                = ival + 1;
num_smax            = ival;                     "Set the variable pointer"
values_sought(ival) = $GLOBAL_SMAX;             "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $MAX-SMAX;

" Incoherent (Compton) scattering "
ival                = ival + 1;
num_incoh           = ival;                     "Set the variable pointer"
values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'Simple';
allowed_inputs(ival,5) = 'norej';

" Radiative corrections for Compton scattering "
ival                = ival + 1;
num_radc            = ival;
values_sought(ival) = $RADC_COMPTON;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Coherent (Rayleigh) scattering "
ival                = ival + 1;
num_coh             = ival;                     "Set the variable pointer"
values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'custom';

" Atomic Relaxations "
ival                = ival + 1;
num_relax           = ival;                     "Set the variable pointer"
values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;
allowed_inputs(ival,4) = 'eadl';
allowed_inputs(ival,5) = 'simple';

" Photoelectron angular sampling "
ival                = ival + 1;
num_pe_ang          = ival;                     "Set the variable pointer"
values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Bremsstrahlung angular sampling "
ival                = ival + 1;
num_brems_ang       = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Simple';
allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"

" Bremsstrahlung cross sections "
ival                = ival + 1;
num_brems_cs        = ival;                     "Set the variable pointer"
values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"


" Pair angular sampling "
ival                = ival + 1;
num_pair_ang        = ival;                     "Set the variable pointer"
values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
                                 "leading term of the distribution which is"
                                 "probably sufficiently accurate for most"
                                 "applications"
allowed_inputs(ival,3) = 'Uniform';
allowed_inputs(ival,4) = 'Blend';

" Pair cross sections "
ival                = ival + 1;
num_pair_cs         = ival;
values_sought(ival) = $PAIR_CROSS_SECTIONS;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'BH';
allowed_inputs(ival,1) = 'NRC';

" Triplet production "
ival                = ival + 1;
num_triplet         = ival;
values_sought(ival) = $TRIPLET_PRODUCTION;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Spin effects          "
ival                = ival + 1;
num_spin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SPIN_EFFECTS;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';                 "Only global on/off available"

" Electron impact ionization "
ival                = ival + 1;
num_eii             = ival;
values_sought(ival) = $ELECTRON_IMPACT_IONI;
nvalue(ival)        = 1;
type(ival)          = 2;
"type(ival)          = 3;"
"allowed_inputs(ival,0) = 'Off';"
"allowed_inputs(ival,1) = 'On';"
"allowed_inputs(ival,2) = 'casnati';"
"allowed_inputs(ival,3) = 'kolbenstvedt';"
"allowed_inputs(ival,4) = 'gryzinski';"

" L-shell EII xsection scaling"
ival                = ival + 1;
num_eii_L= ival;                                "Set the variable pointer"
values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0e+9;
default(ival)       = 1.0;

" ESTEPE "
ival                = ival + 1;
num_estepe          = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 1e-5;                     "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $MAX-ELOSS;

" XIMAX "
ival                = ival + 1;
num_ximax           = ival;                     "Set the variable pointer"
values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0;                        "Define the allowed range"
value_max(ival)     = 1;
default(ival)       = $EXACT-BCA-XIMAX;

" BCA "
ival                = ival + 1;
num_bca             = ival;                     "Set the variable pointer"
values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'Exact';
allowed_inputs(ival,1) = 'PRESTA-I';

" Skindepth "
ival                = ival + 1;
num_skin            = ival;                     "Set the variable pointer"
values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1;                       "Define the allowed range"
value_max(ival)     = 1e15;
default(ival)       = $SKIN-DEPTH-FOR-BCA;

" Electron-step algorithm "
ival                = ival + 1;
num_alg             = ival;                     "Set the variable pointer"
values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 3;                        "An `allowed' input"
allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
allowed_inputs(ival,1) = 'PRESTA-I';

" Photon cross sections "
ival                = ival + 1;
num_pxsec           = ival;
values_sought(ival) = $PHOTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" Photon cross sections output "
ival                = ival + 1;
num_pxsec_out       = ival;
values_sought(ival) = $PHOTON_XSECTIONS_OUT;
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';

" Compton cross sections "
ival                = ival + 1;
num_cxsec           = ival;
values_sought(ival) = $COMPTON_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

" E-Field "
ival                = ival + 1;
num_efield          = ival;                     "Set the variable pointer"
values_sought(ival) = $E_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e15;                    "Define the allowed range"
value_max(ival)     =  1e15;
default(ival)       =  0;

" B-Field "
ival                = ival + 1;
num_bfield          = ival;                     "Set the variable pointer"
values_sought(ival) = $B_FIELD;                 "The code word"
nvalue(ival)        = 3;                        "3 inputs"
type(ival)          = 1;                        "A real number"
value_min(ival)     = -1e10;                    "Define the allowed range"
value_max(ival)     =  1e10;
default(ival)       =  0;

" EM-field step and eloss restriction "
ival                = ival + 1;
num_emlmt           = ival;                     "Set the variable pointer"
values_sought(ival) = $EM_LMT;                 "The code word"
nvalue(ival)        = 1;                        "1 input"
type(ival)          = 1;                        "A real number"
value_min(ival)     = 0.0;                      "Define the allowed range"
value_max(ival)     = 1.0;
default(ival)       = 0.02;

"Ali:photonuc, 2 blocks"
" Photonuclear "
ival                = ival + 1;
num_photonuc        = ival;           "set the variable pointer"
values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
nvalue(ival)        = 1;              "1 input"
type(ival)          = 3;              "an `allowed' input"
allowed_inputs(ival,0) = 'Off';
allowed_inputs(ival,1) = 'On';
allowed_inputs(ival,2) = $ON_IN_REGIONS;
allowed_inputs(ival,3) = $OFF_IN_REGIONS;

" Photonuclear cross sections "
ival                = ival + 1;
num_photonuc_xsec   = ival;
values_sought(ival) = $PHOTONUC_XSECTIONS;
nvalue(ival)        = 1;
type(ival)          = 2;

"Ali:photonuc, 1 line"
Nmin = num_ecut; Nmax = num_photonuc_xsec;
"Nmin = num_ecut; Nmax = num_cxsec;"

CALL GET_INPUT;

IF( error_flags(num_ecut) = 0 ) [
    DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
]
IF( error_flags(num_pcut) = 0 ) [
    DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
]
IF( error_flags(num_smax) = 0 ) [
    DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
]
IF( error_flags(num_brems_ang) = 0 ) [
    ibrdst = value(num_brems_ang,1);
]
IF( error_flags(num_brems_cs) = 0 ) [
    ibr_nist = value(num_brems_cs,1);
]
IF( error_flags(num_radc) = 0 ) [
    radc_flag = value(num_radc,1);
]
IF( error_flags(num_pair_ang) = 0 ) [
    iprdst = value(num_pair_ang,1);
]
IF( error_flags(num_pair_cs) = 0 ) [
    pair_nrc = value(num_pair_cs,1);
]
IF( error_flags(num_triplet) = 0 ) [
    itriplet = value(num_triplet,1);
]
IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
IF( error_flags(num_bca) = 0 ) [
    bca_algorithm = value(num_bca,1);
    IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
]
IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
IF( error_flags(num_spin) = 0 ) [
   itmp = value(num_spin,1);
   IF( itmp = 1 ) [ spin_effects = .true.; ]
   ELSE           [ spin_effects = .false.; ]
]
/******************************************************
   Mantaining compatibility with previous versions
   allowing ON(IK) and OFF besides custom EII data
   compilation files of the form eii_prefix.data.
 ******************************************************/
IF( error_flags(num_eii) = 0 ) [
   eii_xfile = char_value(num_eii,1);eii_flag=1;
   IF (toUpper($cstring(eii_xfile)).eq.'ON' |
       toUpper($cstring(eii_xfile)).eq.'IK' )[
       eii_xfile = 'ik';
    $egs_info(*,'==> Using default EII data compilation ',
              $cstring(eii_xfile));
   ]
   ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
       eii_xfile='Off';eii_flag=0;
   ]
   ELSE["Using non-default EII data compilation"
    $egs_warning(*,'==> Using non-default EII data compilation ',
                 $cstring(eii_xfile));
   ]
]
/******************************************************
   Use Sabbatucci and Salvat shellwise photoelectric
   cross sections together with XCOM or EPDL cross sections
   for pair production.
 ******************************************************/
IF( error_flags(num_pxsec) = 0 ) [
    photon_xsections = char_value(num_pxsec,1);
    IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
    ]
    ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
        mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
    ]
    ELSE[
        mcdf_pe_xsections = .false.;
    ]
]
/**********************************************************/
IF( error_flags(num_pxsec_out) = 0 ) [
    xsec_out = value(num_pxsec_out,1);
]
IF( error_flags(num_cxsec) = 0 ) [
    comp_xsections = char_value(num_cxsec,1);
]
"Ali:photonuc, 3 lines"
IF( error_flags(num_photonuc_xsec) = 0 ) [
    photonuc_xsections = char_value(num_photonuc_xsec,1);
]

IF( error_flags(num_efield) = 0 ) [
    ExIN = value(num_efield,1);
    EyIN = value(num_efield,2);
    EzIN = value(num_efield,3);
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]
" Initially set to input values, could change with regions"
" by converting it to an array over all regions. This is  "
" currently implemented only for the C++ applications     "
IF( error_flags(num_bfield) = 0 ) [
    BxIN = value(num_bfield,1);
    ByIN = value(num_bfield,2);
    BzIN = value(num_bfield,3);
    Bx=BxIN;By=ByIN;Bz=BzIN;
    Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
    IF( error_flags(num_emlmt) = 0 )[
       EMLMTIN=value(num_emlmt,1);
    ]
    IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
        emfield_on=.true.
    ]
]


/***************************************************************/
/* Get media for which to read custom ff and the ff file names */
/***************************************************************/
IF( error_flags(num_coh) = 0 ) [
  IF(value(num_coh,1) = 4)[
   write(*,'(/a/)') ' ===> custom ff requested!';
   ival                = ival + 1;
   num_ffmed           = ival;
   values_sought(ival) = 'ff media names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   ival                = ival + 1;
   num_ffiles          = ival;
   values_sought(ival) = 'ff file names';
   type(ival)          = 2;  "i.e.  character input"
   nvalue(ival)        = 0;
   Nmin = num_ffmed; Nmax = num_ffiles;
   CALL GET_INPUT;
   IF( error_flags(num_ffmed) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               ' error_flag = ', error_flags(num_ffmed));
   ]
   IF( error_flags(num_ffiles) > 0 ) [
    $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               ' error_flag = ', error_flags(num_ffiles));
   ]
   IF (nvalue(num_ffmed)>$MXMED)[
      $egs_fatal('(a,a,i3,a)',
              '***** Number of media with custom ff larger ',
              'than maximum number of media $MXMED = ',$MXMED,
              ' increase $MXMED and try again!!!');
   ]
   DO i=1,nvalue(num_ffmed) [
    iray_ff_media(i) = char_value(num_ffmed,i);
    iray_ff_file(i)  = char_value(num_ffiles,i);
   ]
   value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
  ]
  write(*,'(/)');
]
/***************************************************************/
/*
 Inputs allowing setting by region are checked with the macro
 $TURN-ON/OFF-IN-REGIONS. For this type of input, the second
 and third entries correspond to turning ON or OFF the interaction
 in specific regions. If no input is found, the default value is
 used.
 */
/***************************************************************/
$TURN-ON/OFF-IN-REGIONS(num_incoh,
                    'Bound Compton start region',
                    'Bound Compton stop region',
                    ibcmp); incoh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_coh,
                    'Rayleigh start region',
                    'Rayleigh stop region',
                    iraylr); coh_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_relax,
                    'Relaxations start region',
                    'Relaxations stop region',
                    iedgfl); relax_inregions = aux_inregions;
$TURN-ON/OFF-IN-REGIONS(num_pe_ang,
                    'PE sampling start region',
                    'PE sampling stop region',
                    iphter); pe_inregions = aux_inregions;
"Ali:photonuc, 1 block"
$TURN-ON/OFF-IN-REGIONS(num_photonuc,
                    'Photonuclear start region',
                    'Photonuclear stop region',
                    iphotonucr); photonuc_inregions = aux_inregions;
$SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
                                         'Set ECUT stop region');
ecut_inregions = aux_inregions;

$SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
                                         'Set PCUT stop region');
pcut_inregions = aux_inregions;

$SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
                                         'Set SMAX stop region');
smax_inregions = aux_inregions;

write(i_errors,*);
write(i_errors,*)
' ******************** end input transport parameter *********************** ';
write(i_errors,*);

"Check if EADL relaxation requested. Note that original relaxation"
"algorithm using <M> and <N> is only turned ON for all regions."
"Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
"default case."
IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
   eadl_relax = .true.;
   "Default relaxation is EADL"
   IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
]
ELSE [
    IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
       eadl_relax = .true.; value(num_relax,1)=4;
       $egs_warning('(a/,a/,a/)',
                    '    Simplified atomic relaxation not allowed',
                    '    with shellwise PE cross sections. Resetting',
                    '    to detailed EADL atomic relaxation!!!');
    ]
    ELSE [
       eadl_relax = .false.;
    ]
]

" we put the information stored in allowed_inputs into "
" output_strings just in case the user over-rides it "
" before printing out the settings "

output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
itmp = value(num_incoh,1);
output_strings(2) = allowed_inputs(num_incoh,itmp);
$RADC_WARNING;
output_strings(12) = allowed_inputs(num_radc,radc_flag);
itmp = value(num_coh,1);
output_strings(3) = allowed_inputs(num_coh,itmp);
itmp = value(num_relax,1);
output_strings(4) = allowed_inputs(num_relax,itmp);
itmp = value(num_pe_ang,1);
output_strings(5) = allowed_inputs(num_pe_ang,itmp);
output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
output_strings(11) = allowed_inputs(num_triplet,itriplet);
"output_strings(13) = allowed_inputs(num_eii,eii_flag);"
"Ali:photonuc, 2 lines"
itmp = value(num_photonuc,1);
output_strings(14) = allowed_inputs(num_photonuc,itmp);

entry show_transport_parameter(ounit);

IF ( ounit <= 0 ) return;

write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);
write(ounit,'(a,/)')
'                   Electron/Photon transport parameter';
write(ounit,'(a,/)') line;

/* initialized in egs_set_defaults */
write(ounit,'(a,38x,a)') ' Photon cross sections',
      $cstring(photon_xsections);
write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);

write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
ELSE [
    IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
    ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
]
write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
"Ali:photonuc, 3 lines. EMH added IF statement"
IF ( value(num_photonuc,1) > 0 )[
 write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
 write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
 $cstring(photonuc_xsections);
]

write(ounit,*);

write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
ELSE [
    IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
    ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
]
write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
IF (eii_L_factor ~= 1.0) [
   write(ounit,'(a,25x,f6.4)')
   ' L-shell EII xsections scaling factor',eii_L_factor;
]
write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
ELSE [
    IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
    ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
]
write(ounit,'(a,16x,f6.4)')
 ' Maximum fractional energy loss/step (ESTEPE)',estepe;
write(ounit,'(a,21x,f6.4)')
 ' Maximum 1st elastic moment/step (XIMAX)',ximax;
write(ounit,'(a,33x,a10)')
 ' Boundary crossing algorithm',output_strings(7);
write(ounit,'(a,22x,g9.4)')
 ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
write(ounit,'(a,37x,a10)')
 ' Electron-step algorithm',output_strings(8);
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
  write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
                  ExIN,EyIN,EzIN;
]
IF( Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
                  Bx,By,Bz;
]
IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
    Bx~=0 | By~=0 | Bz~=0 )[
  write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
]
write(ounit,*);
write(ounit,'(a)') line;
write(ounit,*);

return;
end;
;
/************************************************************************
 *
 * The following subroutine can be used to modify the elastic
 * scattering power in one or more media.
 * To do so, the user includes one or more lines in
 * the transport parameter section of the input file
 *
 *     scale elastic scattering in SOME_MEDIUM= 1.05
 *
 * where SOME_MEDIUM is the name of a medium.
 *
 * The effect of this will be that both, xcc and blcc will
 * get multiplied with the provided factor, leaving the
 * screening angle unchanged but increasing the number of collisions
 * per unit length.
 *
 ************************************************************************/

subroutine set_elastic_parameter;

implicit none;
$INTEGER ounit;
$declare_max_medium;
;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
$INTEGER imed,ival,lnblnk1,nchanged;
character*24 medname;

ounit = i_log;
ounit = i_log;
delimeter = $THE_DELIMETER;
call get_input_set_error_level(0);
ival = 0;
DO imed=1,nmed [
    call egs_get_medium_name(imed,medname);
    ival                = ival + 1;
    values_sought(ival) = 'scale elastic scattering in '//
                           medname(:lnblnk1(medname));
    nvalue(ival)        = 1;
    type(ival)          = 1;
    value_min(ival)     = 1e-3;
    value_max(ival)     = 1e3;
    default(ival)       = 1;
]
Nmin = 1; Nmax = nmed;
CALL GET_INPUT;
nchanged = 0;
DO imed=1,nmed [
    IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
]
IF( nchanged > 0 ) [
    write(ounit,'(//a)')
'================ Elastic scattering scaled as follows ==================';
    DO imed=1,nmed [
        IF( error_flags(imed) = 0 ) [
            call egs_get_medium_name(imed,medname);
            xcc(imed)  = xcc(imed)*value(imed,1);
            blcc(imed) = blcc(imed)*value(imed,1);
            write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
              value(imed,1);
        ]
    ]
    write(ounit,'(a//)')
'========================================================================';
]
return; end;
;

"==========================end of get_inputs.mortran=================="
