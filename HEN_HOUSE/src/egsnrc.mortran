%C80
"#############################################################################"
"                                                                             "
"  EGSnrc core source code                                                    "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Iwan Kawrakow, 2000                                       "
"                   Dave Rogers, 2000                                         "
"                                                                             "
"  Contributors:    Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"


"Compiler directives"
"==================="
%Q1         "Automatically close comments at end of line
            "but NOTE, this doesn't happen inside a REPLACE macro
            "you must open and close within a REPLACE macro.
%C80        "Allow 80 columns of source/line (default is 72)
!INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
!INDENT F2; "Indent fortran output 2 spaces each nesting level
%L          "Turn on listing

%I4 "INDENT FOUR SPACES EACH LEVEL"

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH;
"                                                                  "
"******************************************************************"
"   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
"   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
"                                                                  "
"   If the user requests radiative splitting (via nbr_split > 1),  "
"   this routine produces 2*nbr_split annihilation photons at once,"
"   each carying the fraction 1/nbr_split of the weight of the     "
"   incident positron.                                             "
"                                                                  "
"   Except for taking out the calculation of                       "
"   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
"   rejection function normalized to its maximum, the sampling     "
"   technique is the same as the original EGS4 implementation.     "
"                                                                  "
"   I. Kawrakow, January 2000                                      "
"                                                                  "
"******************************************************************"
$IMPLICIT-NONE;

$COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                 "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
                 "EGS-VARIANCE-REDUCTION/;                         "

$DEFINE-LOCAL-VARIABLES-ANNIH;
$INTEGER ip;

NPold = NP; "Set the old stack counter"
IF( nbr_split <= 0 ) [ return; ]
PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
                 "i.e. electron assumed to be at rest
AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
A=AVIP/RM;
"AI=1.0/A;  AI not necessary, IK Oct 97"
G=A-1.0;
T=G-1.0;
P=SQRT(A*T);
POT=P/T;
EP0=1.0/(A+P);
"   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
"Take the calculation of the logarithm out of the loop, IK Oct 97"
WSAMP=LOG((1.0-EP0)/EP0);

aa = u(np); bb = v(np); cc = w(np);
sinpsi = aa*aa + bb*bb;
IF( sinpsi > 1e-20 ) [
   sinpsi = sqrt(sinpsi);
   sindel = bb/sinpsi; cosdel = aa/sinpsi;
]

IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]

DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
                        "radiative event                              "

    IF( np+1 > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]

    LOOP[
        $RANDOMSET RNNO01;
        EP=EP0*EXP(RNNO01*WSAMP);
        "   NOW DECIDE WHETHER TO ACCEPT"
        $RANDOMSET RNNO02;
        "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
        "The above rejection function has a maximum = 1 - 2/A**2"
        "For efficiency, it is better to divide by the maximum value, IK Oct 97"
        REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
    ] UNTIL (RNNO02 <= REJF);


    "   SET UP ENERGIES"
    ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
    PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
    E(NP)=PESG1; IQ(NP)=0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    COSTHE=MIN(1.0,(ESG1-RM)*POT/ESG1);
    SINTHE=SQRT(1.0-COSTHE*COSTHE);
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;
    PESG2=PAVIP-PESG1; esg2 = pesg2;
    e(np) = pesg2; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    COSTHE=MIN(1.0,(ESG2-RM)*POT/ESG2);
    SINTHE=-SQRT(1.0-COSTHE*COSTHE);
    IF( sinpsi >= 1e-10 ) [
        us = sinthe*cphi; vs = sinthe*sphi;
        u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
        v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
        w(np) = cc*costhe - sinpsi*us;
    ]
    ELSE [
        u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
    ]
    np = np + 1;

]
np = np-1;

RETURN;
"END OF SUBROUTINE ANNIH"   END;

"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE ANNIH_AT_REST;
"                                                                  "
" It is handy to be able to initiate annihilation at rest from     "
" places other than the electron discard section (e.g. AUSGAB)     "
" Annihilation at rest takes a sufficent amount of time to not     "
" have any real benefit from this code being inline in the         "
" ELECTR subroutine.                                               "
" I. Kawrakow, June 2005.                                          "
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-ANNIH-ATREST;
$REAL costhe,sinthe,cphi,sphi;
$INTEGER ibr,ip;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

NPold = NP;
$CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
    " nbr_split > 1 means user wants to use radiative "
    " splitting => produce 2*nbr_split annihilation   "
    " photons at once                                 "
DO ibr = 1, nbr_split [
    "Pick random direction for first gamma
    $RANDOMSET costhe; costhe = 2*costhe-1;
    sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    e(np) = prm; iq(np) = 0;
    IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
    $TRANSFER PROPERTIES TO (np) FROM (ip);
    u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
    np = np+1;
    e(np) = prm; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
    np = np+1;
]
np = np-1;
return; end;


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BHABHA;
"                                                                  "
"******************************************************************"
"   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
"   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
"   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
                   "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
                                "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BHABHA;

NPold = NP;      "Set the old stack counter"
PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
EKIN=PEKIN;
T0=EKIN/RM;
E0=T0+1.;
YY=1./(T0+2.);
E02=E0*E0;
"BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
EP0=TE(MEDIUM)/EKIN;
EP0C=1.-EP0;
Y2=YY*YY;
YP=1.-2.*YY;
YP2=YP*YP;
B4=YP2*YP;
B3=B4+YP2;
B2=YP*(3.+Y2);
B1=2.-Y2;
"   SAMPLE BR FROM MINIMUM(EP0) TO 1."
LOOP[$RANDOMSET RNNO03;
BR=EP0/(1.-EP0C*RNNO03);
"   APPLY REJECTION FUNCTION"
$RANDOMSET RNNO04;
"REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
]UNTIL RNNO04.LE.REJF2 ;
"   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
$CHECK-STACK(np+1,'BHABHA');
IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
"THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
"   DIVIDE UP THE ENERGY"
BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
ESE1=PESE1;
ESE2=PESE2;
E(NP)=PESE1;
E(NP+1)=PESE2;
"   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
H1=(PEIP+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"

"AFB modified the following statement 92/10/28 to avoid"
"numerical difficulties"
"DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));

SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(2,1);
NP=NP+1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE BHABHA"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE BREMS;
"                                                                  "
"******************************************************************"
"   Samples bremsstrahlung energy using                            "
"    - Coulomb corrected Bethe-Heitler above 50 MeV                "
"    - Bethe-Heitler below 50 MeV                                  "
"   if ibr_nist = 0, or                                            "
"    - the NIST bremsstrahlung cross section data base             "
"      (prepared in a form of an alias table for rapid sampling)   "
"   if ibr_nist = 1  or                                            "
"    - the NRC bremsstrahlung cross section data base, which is    "
"      the same as the NIST database, but with corrections to      "
"      the electron-electron contribution, which are mostly        "
"      important for low Z and low k                               "
"   if ibr_nist = 2                                                "
"   and direction using                                            "
"    - formula 2BS from from Koch and Motz if IBRDST=1             "
"    - leading term of the brems angular dsstr. if IBRDST=0        "
"    - photon direction = electron direction if IBRDST<0           "
"                                                                  "
"   This version replaces the original EGS4 implementation         "
"   because of a bug discovered in the EGS4 brems routine          "
"   In order to work properly, the parameter DL1,..,DL6            "
"   are re-calculated in subroutine fix_brems which is called      "
"   from HATCH                                                     "
"   In addition, this version has the internal capability of       "
"   bremsstrahlung splitting.                                      "
"   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
"   to the desired number > 1 (1 is the default)                   "
"   Be aware that event-by-event energy conservation is NOT        "
"   guaranteed, so don't use for calculations where this is        "
"   important (e.g. calculation of detector response functions)    "
"   The result will be nbr_split photons, all with the weight      "
"   wt(npold)/nbr_split, and an electron with the original weight  "
"   and energy given by the incident energy - energy of last photon"
"                                                                  "
" I. Kawrakow, January 2000                                        "
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
                           "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-BREMS;
$REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;

IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
                             "by setting nbr_split to zero!"

NPold = NP;      "Set the old stack counter"
PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
weight = wt(np)/nbr_split;

"   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
"   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
L1 = L+1;

ekin = peie-prm;
brmin = ap(medium)/ekin;
"waux = -log(brmin);"
waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
                              "log_ap = log(ap(medium)) is calculated in   "
                              "fix_brems for each medium, elke is needed   "
                              "in electr to calculate the branching ratios "
                              "and therefore it must be known at this point"

IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
                    "angle from KM-2BS (ibrdst=1) or from the leading"
                    "term (ibrdst=0). If nbr_split > 1, we can re-use"
                    "the following quantities several time"

    a = u(np); b = v(np); c = w(np);
    sinpsi = a*a + b*b;
    IF( sinpsi > 1e-20 ) [
       sinpsi = sqrt(sinpsi);
       sindel = b/sinpsi; cosdel = a/sinpsi;
    ]

    ztarg = zbrang(medium);
    tteie = eie/rm;
    beta = sqrt((tteie-1)*(tteie+1))/tteie;
    y2max = 2*beta*(1+beta)*tteie*tteie;
    y2maxi = 1/y2max;
    IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]

]

IF( ibr_nist >= 1 ) [
    ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
    jj = ajj; ajj = ajj - jj;
    IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
]

DO ibr = 1,nbr_split [

    IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
                         "data base"
        IF( ekin > nb_emin(medium) ) [
            $RANDOMSET r1;
            IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
            br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
                               nb_fdata(0,j,medium),
                               nb_wdata(1,j,medium),nb_idata(1,j,medium));
        ]
        ELSE [ $RANDOMSET br; ]
        esg = ap(medium)*exp(br*waux); pesg = esg;
        pese = peie - pesg; ese = pese;
    ]
    ELSE [

        LOOP [ "User wants to use Bethe-Heitler"

            $RANDOMSET rnno06; $RANDOMSET rnno07;
            br = brmin*exp(rnno06*waux);
            esg = ekin*br; pesg = esg;
            pese = peie - pesg; ese = pese;
            delta = esg/eie/ese*delcm(medium); aux = ese/eie;
            IF( delta < 1 ) [
                phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
                phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
                        delta*dl3(l1,medium));
            ]
            ELSE [
                phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
                phi2 = phi1;
            ]
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;

        ] UNTIL (rnno07 < rejf);
    ]

    "   SET UP THE NEW PHOTON                                          "
    np=np+1;
    IF( np > $MXSTACK ) [
        $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
                   ' Increase $MXSTACK and try again' );
    ]
    e(np) = pesg; iq(np) = 0;
    $TRANSFER PROPERTIES TO (np) FROM (np-1);
    wt(np) = weight;
    IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
                        "the electron. This option is given so that "
                        "the user can implement their own brems angle "
                        "schemes via a call to ausgab"
        u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
    ]
    ELSE [
       IF( ibrdst = 1 ) [
           /*
              This is the original implementation
              suggested by Alex Bielajew. Commented out as
              the implementation below is way more efficient.
              IK, Sep. 2004.
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = 3*rjarg1 - 2*esedei;
           rjarg3 = ((1-esedei)/(2*tteie*esedei))**2;
           $SET-BREM-REJECTION-FUNCTION(REJMIN,0.0);
           $SET-BREM-REJECTION-FUNCTION(REJMID,1.0);
           $SET-BREM-REJECTION-FUNCTION(REJMAX,y2max);
           rejtop = max(rejmin,rejmid,rejmax);
           LOOP [
              $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
              $SET-BREM-REJECTION-FUNCTION(REJTST,Y2TST);
              $RANDOMSET rtest;
           ] UNTIL (rtest*rejtop <= REJTST);
           */
           ttese = ese/rm; esedei = ttese/tteie;
           rjarg1 = 1+esedei*esedei;
           rjarg2 = rjarg1 + 2*esedei;
           aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
           IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
           ELSE [ rjarg3 = log(aux/(1+aux1)); ]
           rejmax = rjarg1*rjarg3-rjarg2;
           LOOP [
               $RANDOMSET y2tst; $RANDOMSET rtest;
               aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               rtest = rtest*aux3*rejmax;
               y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               aux2 = log(aux/(1+aux1/aux3**4));
               rejtst = aux4+aux5*aux2;
           ] UNTIL (rtest < rejtst );

       ]
       ELSE [
           $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
       ]
       costhe = 1 - 2*y2tst*y2maxi;
       sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
       $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
       IF( sinpsi >= 1e-10 ) [
           us = sinthe*cphi; vs = sinthe*sphi;
           u(np) = c*cosdel*us - sindel*vs + a*costhe;
           v(np) = c*sindel*us + cosdel*vs + b*costhe;
           w(np) = c*costhe - sinpsi*us;
       ]
       ELSE [
           u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
       ]
    ]
]

e(npold) = pese;

RETURN;
"END OF SUBROUTINE BREMS"   END;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impulse approximation  "
"   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections lead to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"                                                                  "
"   I.Kawrakow, March 2008:                                        "
"      If ibcmp = 2 or 3, the actual bound Compton scattering      "
"      cross section is used and rejections lead to resampling     "
"      instead of rejecting the entire interactions as stated above"
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;

$DEFINE-LOCAL-VARIABLES-COMPT;
$LOGICAL first_time;
$INTEGER ibcmpl;

NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

$RADC_CHECK;

irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);

:resample-compton:;
IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
                   "=>first sample the shell and see whether an    "
                   "  interaction is possible                      "
    $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
    i = int(rnno17); "rnno17 = rnno17 - i;
    IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:;     ]
    ]
    Jo = Jo_array(j);          "Jo is the Compton profile parameter"

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    IF( first_time ) [
        broi2 = broi*broi;
        alph1 = Log(broi);
        bro   = 1/broi;
        alph2 = ko*(broi+1)*bro*bro;
        alpha = alph1+alph2;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)*bro;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
        ]
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        aux = 1+br*br;
        rejf3 = aux - br*sinthe;
        $RANDOMSET rnno19;
    ] UNTIL rnno19*aux.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    IF( first_time ) [
        bro = 1./broi; bro1 = 1 - bro;
        rejmax = broi + bro;
    ]
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 + br*br - br*sinthe;
    ] UNTIL rnno16*br*rejmax.le.rejf3;
]
first_time = .false.;

IF(br < bro | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
        $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE: ;
]

$RADC_REJECTION;

costhe = 1 - temp;
IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0;
    goto :FINISHED-COMPTON-SAMPLING:;
]

" Check for rejection due to the limited range of pzmax "
br2 = br*br;
aux = ko*(ko-Uj)*temp;
aux1 = 2*aux + Uj*Uj;
pzmax = aux - Uj;
IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
pzmax = pzmax/sqrt(aux1);
/*
pzmax = (aux - Uj)/sqrt(2*aux + Uj*Uj);
IF( pzmax <= -1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]
*/
qc2 = 1 + br*br - 2*br*costhe;
qc  = sqrt(qc2);

IF( pzmax > 1 ) [
    pzmax = 1; af = 0; Fmax = 1; fpz = 1;
    goto :RETRY-PZ:;
]

aux3 = 1 + 2*Jo*abs(pzmax);
aux4 = 0.5*(1-aux3*aux3);
fpz  = 0.5*exp(aux4);
af   = qc*(1+br*(br-costhe)/qc2);

IF( af < 0 ) [
    IF( pzmax > 0 ) fpz = 1 - fpz;
    $RANDOMSET eta_incoh;
    IF( eta_incoh > fpz ) [
        IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
        ELSE             [ goto :resample-compton:; ]
    ]
    af = 0; Fmax = 1; goto :RETRY-PZ:;
]

IF( pzmax < -0.15 ) [
    Fmax = 1-af*0.15;
    fpz1 = fpz*Fmax*Jo;
]
ELSE IF( pzmax < 0.15 ) [
    Fmax = 1 + af*pzmax;
    aux3 = 1/(1+0.33267252734*aux3);
            "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
            "of Abramowitz and Stegun, needed for approximating Erf        "
    aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
           erfJo_array(j);
    IF( pzmax > 0 ) [
        "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
        fpz = 1 - fpz;
    ]
    ELSE [
        "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
          "missing factor 1/2 in the above found by Cerneliu Costescu"
          "0.62665706866 is sqrt(Pi/8)"
        fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
    ]
]
ELSE [
    Fmax = 1 + af*0.15;
    fpz1 = (1 - Fmax*fpz)*Jo;
    fpz = 1 - fpz;
]
$RANDOMSET eta_incoh;
IF(eta_incoh*Jo > fpz1 ) [
    IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
    ELSE             [ goto :resample-compton:; ]
]

"At this point, all rejections are handled, now we need to sample pz "
"between -1 and pzmax using the Compton profile of the selected shell"
"and F(pz,cos(theta)) as a rejection function                        "

:RETRY-PZ:;
IF( ibcmpl ~= 2 ) [
  $RANDOMSET rnno18; rnno18 = rnno18*fpz;
  IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
  ]
  ELSE [
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
  ]
  IF( abs(pz) > 1 ) goto :RETRY-PZ:;
      "Due to the non-relativistic approximation"
      "for pz, it has to be between -1 and 1    "
  IF( pz < 0.15  ) [
    IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
    ELSE             [ frej = 1 + af*pz;   ]
    $RANDOMSET eta;
    IF( eta*Fmax > frej ) goto :RETRY-PZ:;
  ]
  "If pz > 0.15, F is always 1 => no need for rejection"
]
ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]

" Calculate energy of scattered photon "
pz2 = pz*pz;
IF( abs(pz) < 0.01 ) [
    br = br*(1 + pz*(qc + (br2-costhe)*pz));
]
ELSE [
    aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
    aux2 = qc2 - br2*pz2*sinthe;
    IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmpl = 1 | ibcmpl = 3 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = pzero;

        call relax(Uj,shn_array(j),iz_array(j));
        "relax will put all particles with energies above ecut,pcut on the "
        "stack, the remaining energy will be scored in edep and deposited  "
        "locally (via the call to ausgab below)                            "
    ]
    ELSE [
        edep = Uj;
        edep_local = edep;
        $AUSCALL($SPHOTONA);
    ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED:
" Create here a zero energy electron if required (check user codes) "
return;
end;

"******************************************************************"
"                                                          NRCC    "
SUBROUTINE old_COMPT;
"                                VERSION 1.00  --  12 JAN 1999     "
"******************************************************************"
"                                                                  "
"   Subroutine for sampling incoherent (Compton) scattering        "
"   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
"   Otherwise scattering is modelled in the impuls approximation   "
"    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
"   As the total cross section from PEGS4 is not modified (and thus"
"   calculated using Klein-Nishina), all rejections leed to an     "
"   unscattered photon and a zero energy electron.                 "
"   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
"   atomic relaxation is treated in RELAX. This has as a           "
"   consequence that more than one particle can be created as a    "
"   result of an incoherent scattering. The user should therefore  "
"   check their user codes for possible inconsistencies.           "
"   This version ignores the function F(cos(theta),pz).            "
"   This leads to a small error (at least compared to the cross    "
"   section we want to sample) at low energies (say, below Z keV)  "
"   The advantage is that it is substantially faster then the      "
"   version with F taken into account.                             "
"                                                                  "
"                                                                  "
"   I.Kawrakow, January 1999                                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
                               "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-COMPT-old;

i_survived_RR = 0;"0=> all survived russian roulette if played"
                  "must set here since, if bound compton and event is"
                  "rejected, this wouldn't be set to the new 0 value"
NPold = NP;       "Set the old stack counter"
peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
ko = peig/rm;     "Gamma energy in units of electron rest energy"
broi = 1 + 2*ko;  "Needed for scattering angle sampling"

irl = ir(np);
IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
                       "=>first sample the shell and see whether an    "
                       "  interaction is possible                      "
    $RANDOMSET rnno17;
    DO i=1,n_shell(medium) [
        rnno17 = rnno17 - eno_array(i,medium);
        IF( rnno17 <= 0 ) EXIT;
    ]
    j = shell_array(i,medium); "j is the shell number in the data list"
    Uj = be_array(j);          "Uj is the binding energy in units of rm"

    " Binding energy rejection "
    IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]

]

" We always sample the scattering angle from Klein-Nishina"
:RESAMPLE-old:
;
IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
    broi2 = broi*broi;
    alph1 = Log(broi);
    alph2 = ko*(broi+1)/broi2;
    alpha = alph1/(alph1+alph2);
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        IF( rnno15 < alpha ) [ "Use 1/br part"
            br = Exp(alph1*rnno16)/broi;
        ]
        ELSE [  "Use the br part."
            br = Sqrt(rnno16 + (1-rnno16)/broi2);
        ]
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = 1 - br*sinthe/(1+br*br);
        $RANDOMSET rnno19;
    ] UNTIL rnno19.le.rejf3;
]
ELSE [ "At low energies it is faster to sample br uniformely"
    bro = 1./broi; bro1 = 1 - bro;
    rejmax = broi + bro;
    LOOP [
        $RANDOMSET rnno15; $RANDOMSET rnno16;
        br = bro + bro1*rnno15;
        temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
        rejf3 = (br + 1./br - sinthe)/rejmax;
    ] UNTIL rnno16.le.rejf3;
]

IF(br < 1./broi | br > 1)  [
    IF( br < 0.99999/broi | br > 1.00001 ) [
    $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
    ]
    goto :RESAMPLE-old: ;
]

IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
    Uj = 0; costhe = 1 - temp;
    goto :FINISHED-COMPTON-SAMPLING-old:;
]

" Sample Doppler broadening using the Compton profile of the selected shell"
br2 = br*br;
costhe = 1 - temp;
aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
:RETRY-PZ-old:;
$RANDOMSET rnno18;
IF( rnno18 < 0.5 ) [
    rnno18 = Max(1e-30,2*rnno18);
    pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
    pz2 = pz*pz;
    IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
]
ELSE [
    IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
    rnno18 = 2*(1-rnno18);
    pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
    pz2 = pz*pz;
    IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
]
IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;

" Calculate energy of scattered photon "
aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
Uj = Uj*prm;

:FINISHED-COMPTON-SAMPLING-old:
pesg = br*peig; pese = peig - pesg - Uj + prm;
sinthe = Sqrt(sinthe);
call uphi(2,1); e(np) = pesg;
aux = 1 + br*br - 2*br*costhe;
IF( aux > 1e-8 ) [
    costhe = (1-br*costhe)/Sqrt(aux);
    sinthe = (1-costhe)*(1+costhe);
    IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
    ELSE [ sinthe = 0; ]
] ELSE [ costhe = 0; sinthe = -1; ]
np = np + 1;
$CHECK-STACK(np,'COMPT');
call uphi(3,2);
e(np) = pese; iq(np) = -1;

IF( ibcmp(irl) = 1 ) [

    " Shell vacancy "
    IF( Uj > 1e-3 ) [
        edep = 0;

        call relax(Uj,shn_array(j),iz_array(j));
          "relax will put all particles with energies above ecut,pcut on the "
          "stack, the remaining energy will be scored in edep and deposited  "
          "localy (via the call to ausgab below)                             "
    ]
    ELSE [ edep = Uj; ]
    IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]

]

" Now play Russian Roulette with resulting electrons if the user asked for it"
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"

return;

:INTERACTION-REJECTED-old:
" Create here a zero energy electron if required (check user codes) "
return;
end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
SUBROUTINE ELECTR(IRCODE);
"******************************************************************"
"   This subroutine has been almost completely recoded to include  "
"   the EGSnrc enhancements.                                       "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Complete recoding            "
"   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
"                                     fictitious method (important "
"                                     for low energy transport     "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE;

$COMIN-ELECTR; "default replacement produces the following:
               "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
                        "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
                        "UPHIOT,USEFUL,USER,RANDOM/;"
;COMIN/EII-DATA/;

$REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
LOGICAL random_tustep;

$DEFINE-LOCAL-VARIABLES-ELECTR;
/******* trying to save evaluation of range.
$LOGICAL  do_range;
$REAL     the_range;
*/

data ierust/0/;         "To count negative ustep's"

save ierust;

$CALL-USER-ELECTRON;

ircode = 1; "Set up normal return-which means there is a photon
            "with less available energy than the lowest energy electron,
            "so return to shower so it can call photon to follow it.
            "(For efficiency's sake, we like to stay in this routine
            " as long as there are electrons to process. That's why this
            " apparently convoluted scheme of STACK contro is effected.)

irold = ir(np);    "Initialize previous region
                   "(ir() is an integer that is attached to the particle's
                   " phase space. It contains the region
                   " number that the current particle is in.
                   " Np is the stack pointer, it points to where on the
                   " stack the current particle is.)
irl    = irold;    "region number in local variable


$start_new_particle;
" Default replacement for the above is medium = med(irl); "
" This is made a macro so that it can be replaced with a call to a "
" user provided function start_new_particle(); for the C/C++ interface "

:NEWELECTRON:LOOP
[
    "Go once through this loop for each 'new' electron whose charge and
    "energy has not been checked

    lelec = iq(np); "Save charge in local variable
                    "(iq = -1 for electrons, 0 for photons and 1 for positrons)
    qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
    peie  = e(np);  "precise energy of incident electron (double precision)
    eie   = peie;   "energy incident electron (conversion to single)

    IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
        "(Ecut is the lower transport threshold.)

    "medium = med(irl);" "(This renders the above assignment redundant!)
    "The above assignment is unnecessary, IK, June 2003"

    IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"

    :TSTEP:LOOP
    [
        "Go through this loop each time we recompute distance to an interaction
        /******* trying to save evaluation of range.
        do_range = .true.; "compute the range in $COMPUTE-RANGE below"
        ********/
        compute_tstep = .true.; "MFP resampled => calculate distance to the
                                "interaction in the USTEP loop
        eke = eie - rm; "moved here so that kinetic energy will be known"
                        "to user even for a vacuum step, IK January 2000"
        IF(medium ~= 0)
        [
            "Not vacuum. Must sample to see how far to next interaction.

            $SELECT-ELECTRON-MFP;
                " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
                "                                       demfp = -log(rnne1);
                "($RANDOMSET is a macro'ed random number generator)
                "(demfp = differential electron mean free path)

            elke = log(eke);
            "(eke = kinetic energy, rm = rest mass, all in units of MeV)
            $SET INTERVAL elke,eke; "Prepare to approximate cross section

            $EVALUATE-SIG0;
               "The fix up of the fictitious method uses cross section per"
               "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               "until the next discrete interaction occures (see below)"
               "As this quantity is a single constant for a material,"
               "$SET INTERVAL is not necessary at this point. However, to not"
               "completely alter the logic of the TSTEP and USTEP loops,"
               "this is left for now"

        ] "end non-vacuum test

        :USTEP:LOOP
        [
            "Here for each check with user geometry.
            "Compute size of maximum acceptable step, which is limited
            "by multiple scattering or other approximations.
            IF(medium = 0)
            [
                    "vacuum
                    tstep = vacdst; ustep = tstep; tustep = ustep;
                    callhowfar = .true.; "Always call HOWFAR for vacuum steps!"

                    "(Important definitions:
                    " tstep  = total pathlength to the next discrete interaction
                    " vacdst = infinity (actually 10^8)
                    " tustep = total pathlength of the electron step
                    " ustep  = projected transport distance in the
                    "          direction of motion at the start of the step
                    " Note that tustep and ustep are modified below.
                    " The above provide defaults.)

                    " EM field step size restriction in vacuum
                    $SET-TUSTEP-EM-FIELD;
                    ustep = tustep;
            ]
            ELSE
            [
                "non-vacuum
                $SET-RHOF;    "density ratio scaling template
                              "EGS allows the density to vary
                              "continuously (user option)

                $SCALE-SIG0;
                IF(sig <= 0)
                [
                    "This can happen if the threshold for brems,
                    "(ap + rm), is greater than ae.  Moller threshold is
                    "2*ae - rm. If sig is zero, we are below the
                    "thresholds for both bremsstrahlung and Moller.
                    "In this case we will just lose energy by
                    "ionization loss until we go below cut-off. Do not
                    "assume range is available, so just ask for step
                    "same as vacuum.  Electron transport will reduce
                    "into little steps.
                    "(Note: ae is the lower threshold for creation of a
                    "       secondary Moller electron, ap is the lower
                    "       threshold for creation of a brem.)
                    tstep = vacdst;
                    sig0 = 1.E-15;
                ]
                ELSE
                [
                    $CALCULATE-TSTEP-FROM-DEMFP;
                ] "end sig if-else

                "calculate stopping power"
                IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
                ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
                dedx  = rhof*dedx0;

                "Determine maximum step-size (Formerly $SET-TUSTEP)
                $EVALUATE tmxs USING tmxs(elke);
                tmxs = tmxs/rhof;

                "Compute the range to E_min(medium) (e_min is the first
                "energy in the table). Do not go more than range.
                "Don't replace this macro and don't override range, because
                "the energy loss evaluation below relies on the accurate
                "(and self-consistent) evaluation of range!
                $COMPUTE-RANGE;

                "The RANDOMIZE-TUSTEP option as coded by AFB forced the
                "electrons to approach discrete events (Moller,brems etc.)
                "only in a single scattering mode => waste of CPU time.
                "Moved here and changed by IK Oct 22 1997
                random_tustep = $RANDOMIZE-TUSTEP;
                IF(random_tustep)
                [
                    $RANDOMSET rnnotu;
                    tmxs = rnnotu*min(tmxs,smaxir(irl));
                ]
                ELSE
                [
                    tmxs = min(tmxs,smaxir(irl));
                ]
                tustep = min(tstep,tmxs,range);
                $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field

                $CALL-HOWNEAR(tperp);
                dnear(np) = tperp;
                $RANGE-DISCARD;       "optional regional range rejection for"
                                      "particles below e_max_rr if i_do_rr set"

                $USER-RANGE-DISCARD;  "default is ;, but user may implement"

                $SET-SKINDEPTH(eke,elke);
                  "This macro sets the minimum step size for a condensed"
                  "history (CH) step. When the exact BCA is used, the minimum"
                  "CH step is determined by efficiency considerations only"
                  "At about 3 elastic MFP's single scattering becomes more"
                  "efficient than CH and so the algorithm switches off CH"
                  "If one of the various inexact BCA's is invoked, this macro"
                  "provides a simple way to include more sophisticated"
                  "decisions about the maximum acceptable approximated CH step"

                tustep = min(tustep,max(tperp,skindepth));

                "The transport logic below is determined by the logical
                "variables callhhowfar, domultiple and dosingle
                "
                "There are the following possibilities:
                "
                "   callhowfar = .false.  This indicates that the
                "   ====================  intended step is shorter than tperp
                "                         independent of BCA used
                "  - domultiple = .false. dosingle = .false. and
                "                         callmsdist = .true.
                "       ==> everything has been done in msdist
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only if exact_bca = .false.
                "           indicates that MS remains to be done
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only if exact_bca = .true.
                "           sampled distance to a single scattering event is
                "           shorter than tperp ==> do single scattering at the
                "           end of the step
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!
                "
                "   callhowfar = .true. This indicates that the intended step
                "   =================== is longer than tperp and forces a
                "                       call to hawfar which returns the
                "                       straight line distance to the boundary
                "                       in the initial direction of motion
                "                       (via a modification of ustep)
                "  - domultiple = .false. and dosingle = .false.
                "       ==> should happen only of exact_bca=.true.
                "           simply put the particle on the boundary
                "  - domultiple = .false. and dosingle = .true.
                "       ==> should happen only of exact_bca=.true.
                "           single elastic scattering has to be done
                "  - domultiple = .true. and dosingle = .false.
                "       ==> should happen only of exact_bca=.false.
                "           indicates that MS remains to be done
                "  - domultiple = .true. and dosingle = .true.
                "       ==> error condition, something with the logic is wrong!

                "IF(tustep <= tperp & tustep > skindepth)"
                "This statement changed to be consistent with PRESTA-I"
                count_all_steps = count_all_steps + 1;
                is_ch_step = .false.;
                IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
                [
                    "We are further way from a boundary than a skindepth, so
                    "perform a normal condensed-history step
                    callhowfar = .false.; "Do not call HAWFAR
                    domultiple = .false.; "Multiple scattering done here
                    dosingle   = .false.; "MS => no single scattering
                    callmsdist = .true.;  "Remember that msdist has been called

                    "Fourth order technique for de
                    $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);

                    tvstep = tustep; is_ch_step = .true.;

                    IF (transport_algorithm = $PRESTA-II)
                    [
                      call msdist_pII
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                    ELSE
                    [
                      call msdist_pI
                      (
                        "Inputs
                        eke,de,tustep,rhof,medium,qel,spin_effects,
                        u(np),v(np),w(np),x(np),y(np),z(np),
                        "Outputs
                        uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
                      );
                    ]
                ]
                ELSE
                [
                    "We are within a skindepth from a boundary, invoke
                    "one of the various boundary-crossing algorithms
                    callmsdist = .false.;
                         "Remember that msdist has not been called
                    IF (exact_bca)
                    [
                        "Cross the boundary in a single scattering mode
                        domultiple = .false.; "Do not do multiple scattering
                        "Sample the distance to a single scattering event
                        $RANDOMSET rnnoss;
                        IF( rnnoss < 1.e-30 ) [
                            rnnoss = 1.e-30;
                        ]
                        lambda = - Log(1 - rnnoss);
                        lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
                        IF( lambda >= 0 & lambda_max > 0 ) [
                            IF( lambda < lambda_max ) [
                                tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
                            ]
                            ELSE [
                              tuss = 0.5 * lambda * ssmfp;
                            ]
                            IF (tuss < tustep) [
                                tustep = tuss;
                                dosingle = .true.;
                            ]
                            ELSE [
                                dosingle = .false.;
                            ]
                        ]
                        ELSE [
                          $egs_warning(*,' lambda > lambda_max: ',
                             lambda,lambda_max,' eke dedx: ',eke,dedx,
                             ' ir medium blcc: ',ir(np),medium,blcc(medium),
                             ' position = ',x(np),y(np),z(np));
                          dosingle = .false.;
                          np=np-1; return;
                        ]
                        ustep = tustep;
                    ]
                    ELSE
                    [
                        "Boundary crossing a la EGS4/PRESTA-I but using
                        "exact PLC
                        dosingle = .false.;
                        domultiple = .true.;
                        $SET-USTEP;
                    ]
                    IF(ustep < tperp)
                    [
                        callhowfar = .false.;
                    ]
                    ELSE
                    [
                        callhowfar = .true.;
                    ]
                ]
            ] "end non-vacuum test

            $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
                                  "default for $SET-USTEP-EM-FIELD; is ;(null)
            irold  = ir(np); "save current region
            irnew  = ir(np); "default new region is current region
            idisc  = 0; "default is no discard (this flag is initialized here)
            ustep0 = ustep; "Save the intended ustep."

            "IF(callhowfar) [ call howfar; ]"
            $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"

            "Now see if user requested discard
            IF(idisc > 0) "(idisc is returned by howfar)
            [
                "User requested immediate discard
                go to :USER-ELECTRON-DISCARD:;
            ]

            $CHECK-NEGATIVE-USTEP;

            IF(ustep = 0 | medium = 0)
            [
                "Do fast step
                IF(ustep ~= 0)
                [
                    "Step in vacuum
                    vstep  = ustep;
                    tvstep = vstep;
                    "( vstep is ustep truncated (possibly) by howfar
                    " tvstep is the total curved path associated with vstep)
                    edep = pzero; "no energy loss in vacuum
                    $VACUUM-ADD-WORK-EM-FIELD;
                        "additional vacuum transport in em field
                    e_range = vacdst;
                    $AUSCALL($TRANAUSB);
                    "Transport the particle
                    x(np) = x(np) + u(np)*vstep;
                    y(np) = y(np) + v(np)*vstep;
                    z(np) = z(np) + w(np)*vstep;
                    dnear(np) = dnear(np) - vstep;
                        "(dnear is distance to the nearest boundary
                        " that goes along with particle stack and
                        " which the user's howfar can supply (option)
                    $SET-ANGLES-EM-FIELD;
                        "default for $SET-ANGLES-EM-FIELD; is ; (null)
                         "(allows for EM field deflection
                ] "end of vacuum step

                IF(irnew ~= irold) [ $electron_region_change; ];

                IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
                IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
                IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
                NEXT :TSTEP: ; "(Start again at :TSTEP:)

            ] "Go try another big step in (possibly) new medium

            vstep = ustep;

            IF(callhowfar)
            [
                IF(exact_bca)
                [
                    "If callhowfar=.true. and exact_bca=.true. we are"
                    "in a single scattering mode"
                    tvstep = vstep;
                    IF(tvstep ~= tustep)
                    [
                       "Boundary was crossed. Shut off single scattering"
                        dosingle = .false.;
                    ]
                ]
                ELSE
                [
                    "callhowfar=.true. and exact_bca=.false."
                    "=>we are doing an approximate CH step"
                    "calculate the average curved path-length corresponding"
                    "to vstep"
                    $SET-TVSTEP;
                ]
                "Fourth order technique for dedx
                "Must be done for an approx. CH step or a
                "single scattering step.
                $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
            ]
            ELSE
            [
               "callhowfar=.false. => step has not been reduced due to
               "                      boundaries
               tvstep = tustep;
               IF ( ~callmsdist )
               [
                  "Second order technique for dedx
                  "Already done in a normal CH step with call to msdist
                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               ]
            ]

            $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
                "( Calculates tvstep given vstep
                " default for $SET-TVSTEP-EM-FIELD; is ; (null)

            save_de = de;     "the energy loss is used to calculate the number
                              "of MFP gone up to now. If energy loss
                              "fluctuations are implemented, de will be
                              "changed in $DE-FLUCTUATION; => save

            "The following macro template allows the user to change the
            "ionization loss.
            "(Provides a user hook for Landau/Vavilov processes)
            $DE-FLUCTUATION;
                "default for $DE-FLUCTUATION; is ; (null)
            edep = de; "energy deposition variable for user
            $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
                "Default for $ADD-WORK-EM-FIELD; is ; (null)
            ekef = eke - de;  "(final kinetic energy)
            eold = eie;       "save old value
            enew = eold - de; "energy at end of transport

            "Now do multiple scattering
            IF ( ~callmsdist )   "everything done if callmsdist = .true.
            [
                IF ( domultiple )
                [
                    "Approximated CH step => do multiple scattering
                    "
                    "ekems, elkems, beta2 have been set in either $SET-TUSTEP
                    "or $SET-TVSTEP if spin_effects is .true., they are
                    "not needed if spin_effects is .false.
                    "
                    "chia2,etap,xi,xi_corr are also set in the above macros
                    "
                    "qel (0 for e-, 1 for e+) and medium are now also required
                    "(for the spin rejection loop)
                    "
                    lambda = blccl*tvstep/beta2/etap/(1+chia2);
                    xi = xi/xi_corr;
                    findindex = .true.; spin_index = .true.;
                    call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
                               spin_effects,findindex,spin_index,
                               costhe,sinthe);
                ]
                ELSE
                [
                    IF(dosingle)
                    [
                       "Single scattering

                       ekems = Max(ekef,ecut(irl)-rm);
                       p2 = ekems*(ekems + rmt2);
                       beta2 = p2/(p2 + rmsq);
                       chia2 = xcc(medium)/(4*blcc(medium)*p2);
                       IF( spin_effects ) [
                         elkems = Log(ekems);
                         $SET INTERVAL elkems,eke;
                         IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
                         ELSE          [$EVALUATE etap USING etap_ms(elkems);]
                         chia2 = chia2*etap;
                       ]
                       call sscat(chia2,elkems,beta2,qel,medium,
                                  spin_effects,costhe,sinthe);
                    ]
                    ELSE
                    [
                       theta  = 0; "No deflection in single scattering model
                       sinthe = 0;
                       costhe = 1;
                    ]
                ]
            ]

            "We now know distance and amount of energy loss for this step,
            "and the angle by which the electron will be scattered. Hence,
            "it is time to call the user and inform him of this transport,
            "after which we will do it.

            "Now transport, deduct energy loss, and do multiple scatter.
            e_range = range;
            /******* trying to save evaluation of range.
            the_range = the_range - tvstep*rhof;
            ********/

            /*
               Put expected final position and direction in common
               block variables so that they are available to the
               user for things such as scoring on a grid that is
               different from the geometry grid
            */
            IF( callmsdist ) [
               "Deflection and scattering have been calculated/sampled in msdist
                u_final = uscat;
                v_final = vscat;
                w_final = wscat;
                x_final = xtrans;
                y_final = ytrans;
                z_final = ztrans;
            ]
            ELSE
            [
                x_final = x(np) + u(np)*vstep;
                y_final = y(np) + v(np)*vstep;
                z_final = z(np) + w(np)*vstep;
                IF ( domultiple | dosingle )
                [
                    u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
                    call uphi(2,1); "Apply the deflection, save call to uphi if
                                    "no deflection in a single scattering mode
                    u_final = u(np); v_final = v(np); w_final = w(np);
                    u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
                ]
                ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
            ]

            $AUSCALL($TRANAUSB);

            "Transport the particle

            x(np) = x_final; y(np) = y_final; z(np) = z_final;
            u(np) = u_final; v(np) = v_final; w(np) = w_final;

            dnear(np) = dnear(np) - vstep;
            irold = ir(np); "save previous region
            $SET-ANGLES-EM-FIELD;
            "Default for $SET-ANGLES-EM-FIELD; is ; (null)


            "Now done with multiple scattering,
            "update energy and see if below cut
            "below subtracts only energy deposited"
            peie  = peie - edep;
            "below subtracts energy deposited + work due to E field"
            "peie = peie - de;"
            eie   = peie;
            e(np) = peie;

            "IF( irnew ~= irl & eie <= ecut(irl)) [
            "IK: the above is clearly a bug. If the particle energy falls "
            "    below ecut, but the particle is actually entering a new "
            "    region, the discard will happen in the current region "
            "    instead the next. If the particle is a positron, all "
            "    resulting annihilation photons will have the new position "
            "    but the old region => confusion in the geometry routine "
            "    is very likely.      Jan 27 2004 "
            IF( irnew = irl & eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            medold = medium;
            IF(medium ~= 0)
            [
                ekeold = eke; eke = eie - rm; "update kinetic energy
                elke   = log(eke);
                $SET INTERVAL elke,eke; "Get updated interval
            ]

            IF(irnew ~= irold) [ $electron_region_change; ]

            "After transport call to user scoring routine
            $AUSCALL($TRANAUSA);

            IF(eie <= ecut(irl)) [
               go to :ECUT-DISCARD:;
            ]

            "Now check for deferred discard request.  May have been set
            "by either howfar, or one of the transport ausgab calls
            IF(idisc < 0) [
              go to :USER-ELECTRON-DISCARD:;
            ]

            IF(medium ~= medold) NEXT :TSTEP:;

            $USER_CONTROLS_TSTEP_RECURSION;
                "NRCC update 87/12/08--default is null

            $UPDATE-DEMFP;

        ] UNTIL(demfp < $EPSEMFP); "end ustep loop

        "Compute final sigma to see if resample is needed.
        "this will take the energy variation of the sigma into
        "account using the fictitious sigma method.

        $EVALUATE-SIGF;

        sigratio = sigf/sig0;

        $RANDOMSET rfict;

    ] UNTIL (rfict <= sigratio) ; "end tstep loop

    " Now sample electron interaction

    IF(lelec < 0)
    [
        "e-,check branching ratio
        $EVALUATE-EBREM-FRACTION;
          "Default is $EVALUATE ebr1 USING ebr1(elke);"
        $RANDOMSET rnno24;
        IF(rnno24 <= ebr1)
        [
            "It was bremsstrahlung
            go to :EBREMS:;
        ]
        ELSE
        [
            "It was Moller, but first check the kinematics.
            "However, if EII is on, we should still permit an interaction
            "even if E<moller threshold as EII interactions go down to
            "the ionization threshold which may be less than thmoll.
            IF(e(np) <= thmoll(medium) & eii_flag = 0)
                 "(thmoll = lower Moller threshold)
            [
                "Not enough energy for Moller, so
                "force it to be a bremsstrahlung---provided ok kinematically.
                IF(ebr1 <= 0) [go to :NEWELECTRON:;]
                    "Brems not allowed either.
                go to :EBREMS:;
            ]
            $AUSCALL($MOLLAUSB);
            call moller;
            "The following macro template allows the user to change the
            "particle selection scheme (e.g., adding importance sampling
            "such as splitting, leading particle selection, etc.).
            "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
            "which in turn has the 'null' replacement ';')
            $PARTICLE-SELECTION-MOLLER;
            $AUSCALL($MOLLAUSA);
            IF( iq(np) = 0 ) return;
        ]

        go to :NEWELECTRON:; "Electron is lowest energy-follow it
    ]

    "e+ interaction. pbr1 = brems/(brems + bhabha + annih
    $EVALUATE-PBREM-FRACTION;
       "Default is $EVALUATE pbr1 USING pbr1(elke);"
    $RANDOMSET rnno25;
    IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
    "Decide between bhabha and annihilation
    "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
    $EVALUATE-BHABHA-FRACTION;
       "Default is $EVALUATE pbr2 USING pbr2(elke);"
    IF(rnno25 < pbr2)
    [
        "It is bhabha
        $AUSCALL($BHABAUSB);
        call bhabha;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-BHABHA;
        $AUSCALL($BHABAUSA);
        IF( iq(np) = 0 ) return;
    ]
    ELSE
    [
        "It is in-flight annihilation
        $AUSCALL($ANNIHFAUSB);
        call annih;
        "The following macro template allows the user to change the
        "particle selection scheme (e.g., adding importance sampling
        "such as splitting, leading particle selection, etc.).  (default
        "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
        "has the 'null' replacement ';')
        $PARTICLE-SELECTION-ANNIH;
        $AUSCALL($ANNIHFAUSA);
        EXIT :NEWELECTRON:; "i.e., in order to return to shower
        "After annihilation the gammas are bound to be the lowest energy
        "particles, so return and follow them.
    ] "end pbr2 else

] REPEAT "newelectron

return; "i.e., return to shower


"---------------------------------------------
"Bremsstrahlung-call section
"---------------------------------------------
:EBREMS:
$AUSCALL($BREMAUSB);
call brems;
"The following macro template allows the user to change the particle
"selection scheme (e.g., adding importance sampling such as splitting,
"leading particle selection, etc.).  (default macro is template
"'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
$PARTICLE-SELECTION-BREMS;
$AUSCALL($BREMAUSA);
IF(iq(np) = 0)
[
    "Photon was selected.
    return;
    "i.e., return to shower
]
ELSE
[
    "Electron was selected
    go to :NEWELECTRON:;
]

"---------------------------------------------
"Electron cutoff energy discard section
"---------------------------------------------
:ECUT-DISCARD:
IF( medium > 0 ) [
    IF(eie > ae(medium)) [
        idr = $EGSCUTAUS;
        IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
    ]
    ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]


$ELECTRON-TRACK-END; "The default replacement for this macros is "
                     "          $AUSCALL(idr);                   "
                     "Use this macro if you wish to modify the   "
                     "treatment of track ends                    "

:POSITRON-ANNIHILATION:; "NRCC extension 86/9/12

IF(lelec > 0) [
    "It's a positron. Produce annihilation gammas if edep < peie
    IF(edep < peie) [
        $AUSCALL($ANNIHRAUSB);
        call annih_at_rest;
        $PARTICLE-SELECTION-ANNIHREST;
        $AUSCALL($ANNIHRAUSA);
        "Now discard the positron and take normal return to follow
        "the annihilation gammas.
        return; "i.e., return to shower
    ]
] "end of positron block

np = np - 1;
ircode = 2; "tell shower an e- or un-annihilated
            "e+ has been discarded

return; "i.e., return to shower"

"---------------------------------------------
"User requested electron discard section
"---------------------------------------------
:USER-ELECTRON-DISCARD:

idisc = abs(idisc);

IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
ELSE                          [edep = e(np) + prm;]

$AUSCALL($USERDAUS);

IF(idisc = 99) goto :POSITRON-ANNIHILATION:;

np = np - 1; ircode = 2;

return; "i.e., return to shower
end;    "End of subroutine electr
"*******************************************************************************


%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE HATCH;
"                                                                  "
"******************************************************************"
"   Setup which the user is expected to do before calling HATCH is:"
"     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
"     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
"        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
"        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
"        THE IM'TH MEDIUM IN A1 FORMAT."
"     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
"        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
"        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
"        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
"     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
"        REGIONS."
"     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
"        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
"        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
"        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
"     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
"        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
"     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
"        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
"
"   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
"   The echo to unit 8 has been removed since it is sent"
"                                          to /dev/null anyway!"
"           To put it back search $UOUTPUT  and $ECHO and uncomment"
"******************************************************************"

$IMPLICIT-NONE;

character*512 toUpper;
$COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
                      "ELECIN,MEDIA,MISC,PHOTIN,STACK,
                      "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;

$DECLARE-PEGS4-COMMON-BLOCKS;

$DEFINE-LOCAL-VARIABLES-HATCH;

character*256 tmp_string;
$INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
                      " support this"

DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;

$INIT-PEGS4-VARIABLES;

"   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
:INT:FORMAT(1X,14I5);
:FLT:FORMAT(1X,1PE14.5,4E14.5);
:BYTE:FORMAT(72A1);

IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
"   DO FIRST TIME INITIALIZATION"

$HATCH-USER-INPUT-INIT;

"   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
"   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
"   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
"   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
"   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
"   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
"   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
"   FOR GOOD MEASURE."
NISUB=MXSINC-2;FNSSS=NSINSS;
WID=PI5D2/FLOAT(NISUB);
WSS=WID/(FNSSS-1.0);
ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;

DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"

XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
"   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
IZ=0; DO IZZ=1,3 [
IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
] "END OF LOOP OVER ZEROS"
IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
YS=SIN(XS+XSI); "SINE OF ANGLE"
SX=SX+XS; "ACCUMULATE SUMS"
SY=SY+YS;
SXX=SXX+XS*XS;
SXY=SXY+XS*YS;
] "END SUB-SUBINTERVAL LOOP"

"   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
"             FOR SMALL REL.ERR.&GOOD"
"   VALUES OF SINTHE/THETA NEAR ZERO"
SIN1(ISUB)=SXY/SXX;
SIN0(ISUB)=-SIN1(ISUB)*XSI;]
ELSE["DO FULL LEAST SQUARES"
DEL=FNSSS*SXX-SX*SX;
SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
] "END SUB-INTERVAL LOOP"

SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
SINC1=1.0/WID;

"   NOW TEST FIT, IF REQUESTED"
IF (ISTEST.NE.0)[
"   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
"   END SUBINTERVALS"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
$egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
$egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                                 ADEV,RDEV,S2C2MN,S2C2MX);
"   NOW DO RANDOM TEST"
ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
CTHET=PI5D2-THETA;
$SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
$EVALUATE SINTHE USING SIN(THETA);
$EVALUATE COSTHE USING SIN(CTHET);
SINT=SIN(THETA); COST=COS(THETA);
ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
ADEV=max(ADEV,ASD,ACD);
IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
S2C2=SINTHE**2+COSTHE**2;
S2C2MN=min(S2C2MN,S2C2);
S2C2MX=max(S2C2MX,S2C2);
] "END RANDOM ANGLE LOOP"
$egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
$egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
                               ADEV,RDEV,S2C2MN,S2C2MX);
] "END OF SINE TABLE TEST"

"   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]

] "END OF FIRST TIME INITIALIZATION"

"FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
$need_rayleigh_data;

"Ali:photonuc, 2 lines"
"FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
$need_photonuc_data;
$egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);

"   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
IF(~is_pegsless) REWIND KMPI;
"explicit file name for HP compiler  Nov 23, 1996   DR"
IUECHO=KMPO;
NM=0; "NUMBER OF MEDIA FOUND"
DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
  "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
  IF(IRAYLM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

"Ali:photonuc, 1 block"
DO IM=1,NMED [
  "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
  IF(IPHOTONUCM(IM).EQ.1) [
     $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
  ]
]

IF(~is_pegsless)[
:MEDIUM:
LOOP["MEDIUM SEARCH LOOP"

:MDLOOK:
LOOP["MEDIUM HEADER SEARCH LOOP"
  "   FIRST LOOK FOR MEDIUM HEADER"
  READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
  DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
  "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
  :MDNAME:
  DO IM=1,NMED [
    DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
    IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
  ] "END :MDNAME: DO"
  "   NOT IN NAME TABLE, SO IGNORE IT"
]REPEAT "MDLOOK"

"   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"

"   NOW READY TO READ IN DATA FOR THIS MEDIUM"
"$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"

"   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
"THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
"The next two lines were line prior to Dec 89 mods to get IUNRST"
"$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,5X,F11.0,4X,I2);"
"following used to pick up IUNRST, IAPRIM and EPSTFL"
"Problem is that GASP may or may not be printed, so we make"
"a kludge which will work with all old data files"
"FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
"Note that this reading scheme counts on there being an"
"error when GASP does exist on the line--an error does"
"occur on most compilers, however, we have found that on"
"the rs6000 an error does not occur.  Instead, a warning"
"is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
"This will make no difference in simulations but will cause"
"a problem when running EXAMIN"

" IK: backspace(kmpi) fails under windows using g77 with I/O error"
"     therefore we read the line in a temporary string and then "
"     use memoty I/O to try to read with and without gasp there. "

read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
goto :no_hatch_read_error1:;
:hatch_read_error1:
$egs_fatal(*,'Error while reading pegs4 file');

:no_hatch_read_error1:;
read(tmp_string,1,ERR=:GASP-THERE:)
"READ(KMPI,1,ERR=:GASP-THERE:)"
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
"IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
GO TO :GASP-NOT-THERE:;

:GASP-THERE:;
"WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
"BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
"READ(KMPI,2)"

"The following output is only there because without it"
"code compiled with the new gfortran GNU compiler "
"fails with run time error. Another bug in their "
"pre-alpha quality I/O system ----IK, Oct 26 2005 "
"write(6,*) 'Found medium with gas pressure';"
$egs_info(*,'Found medium with gas pressure');
read(tmp_string,2)
(MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
IAPRIM(IM);
2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);

:GASP-NOT-THERE:

"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
"(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
"THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
"DO IE=1,NE["
DO IE=1,NNE(IM)[
    "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
    "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
    "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
    "IN COMMON BREMPR. AFB 88/05/31.                                  "
    "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
    $UINPUT(KMPI)
    (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
    ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
    (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
    "$UOUTPUT(KMPO)"
    "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
    "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
    "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
    ]

"   MEDIA AND THRESH"
"$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;

"   ACTUAL ARRAY SIZES FROM PEGS"
"$ECHO" READ(KMPI,:INT:)
$LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);

"   BREMPR"
"$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
"$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
   DELPOS(I,IM)),I=1,2);

"   ELECIN"
"$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
"$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)
($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
   TMXS(I,IM)/0,1/),I=1,NEKE);

"   PHOTIN"
"$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);

"   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"

/* Leave this for compatibility with existing pegs4 data sets.  */
IF (IRAYL.EQ.1) [
"$ECHO" READ(KMPI,:INT:) NGR(IM);
NGRIM=NGR(IM);
"$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
"$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
"$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
 "IF(IRAYLM(IM).NE.1) ["
 $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
          IM, ' in PEGS4 data set.');
 "]"
]

/*******************************************************************
 Rayleigh data picked up directly from pgs4form.data or user-supplied
 ff file in egs_init_rayleigh unless user wants to use PEGS4 data.
*********************************************************************/
IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
  IF(IRAYL.NE.1) ["No data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["Rayleigh not possible"
     $egs_fatal('(a,i3 /,a /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
     ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
    ]
    ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
     $egs_warning('(a,i3 /,a)',
     ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
     IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
    ]
  ]
 ELSE["Rayleigh data in PEGS4"
    IF(toUpper($cstring(photon_xsections))='PEGS4')
    ["PEGS4 data selected"
      "***********************************************************"
      "Preparing data for new Rayleigh angular sampling when using"
      "the pegs4 data set,                                        "
      "***********************************************************"
       call egs_init_rayleigh_sampling(IM);
    ]
    "ELSE[Taking photon data from either si,epdl,xcom or user]"
  ]
]
/*******************************************************************/

"   THAT'S ALL FOR THIS MEDIUM"
]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"

CLOSE (UNIT=KMPI);

"   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
"   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
"   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
"   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
"   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
"   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
DUNITR=DUNIT; "SAVE REQUESTED"
IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
   DUNIT=RLC(ID);]
IF(DUNIT.NE.1.0) [
$egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
         DUNITR,DUNIT,'(CM.)' );
]
DO IM=1,NMED [
DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"

FOR I=1 TO MEKE(IM) [
$SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
$SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
$SCALE TEFF0(IM) BY DFACT;
$SCALE BLCC(IM) BY DFACTI;
$SCALE XCC(IM) BY SQRT(DFACTI);
RLDU(IM)=RLC(IM)/DUNIT;
FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
] "END IM DO"

"   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
VACDST=VACDST*DUNITO/DUNIT;
DUNITO=DUNIT; "SAVE OLD DUNIT"

]"end regular pegs4 intake"
ELSE["pegsless intake of medium data"

$egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');

$GET-PEGSLESS-XSECTIONS;

]

"   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
"   ALSO SET DEFAULT DENSITIES"
$adjust_rhor_ecut_pcut;

"BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 88/05/31"
$INITIALIZE-BREMS-ANGLE;

"PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
"NEXT LINE ADDED AFB 91/05/29"
$INITIALIZE-PAIR-ANGLE;

" See if user has requested PEGS4 photon cross section data "
IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
  $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
  'However, the new Rayleigh angular sampling will be used.',
  'The original EGS4 angular sampling undersamples large scattering ',
  'angles. This may have little impact as Rayleigh scattering ',
  'is forward peaked.',
  '*********************************************************');

]
ELSE["re-calculates photon xsections using available or user data"
"Ali:photonuc, 2 lines"
    call egs_init_user_photon(photon_xsections,comp_xsections,
    photonuc_xsections,xsec_out);
"    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
]

call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"

"Calling order of the subroutines below is important when using"
"detailed atomic relaxation in order to use the binding energies"
"corresponding to the requested photon cross section library"
IF ( eadl_relax & photon_xsections = 'xcom' )[
   call init_compton; "Initialize bound Compton scattering"
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
]
ELSE[
   call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
                      "if requested
   call init_compton; "Initialize bound compton scattering, IK, Jan 99"
                      "if requested
]

IF( xsec_out = 1 & eadl_relax) [
  call egs_print_binding_energies;
]

call fix_brems;    "Re-calculate dl1,... for the different technique"
                   "employed in BREMS. Note that the old EGS sampling"
                   "technique for BREMS had a bug that shows up only"
                   "if AP is not much smaller than electron kinetic energy"

IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
                   "initializes the sampling tables and modifies the total"
                   "brems cross sections if the NIST brems data base is to"
                   "be used                                               "

IF( pair_nrc = 1 ) [ call init_nrc_pair; ]

" Load and initialize EII data if needed. "
call eii_init;

" Load and initialize the triplet data if needed "
call init_triplet;

"   SETUP IS NOW COMPLETE"
IF (NMED.EQ.1)[
   $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
]
ELSE[
   $egs_info('(a,i5,a)',
             'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
]

RETURN;

:MDNOMORE:
$egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
  ' PROGRAM STOPPED IN HATCH BECAUSE THE',
  ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
DO IM=1,NMED [
   IF(LOK(IM).NE.1) [
      $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
   ]
]
STOP;
"END OF SUBROUTINE HATCH"   END;

subroutine fix_brems;
"******************************************************************"
"
" Calculates the parameter for the rejection function used in
" the current implementation of bremsstrahlung sampling
"
" I Kawrakow, January 2000
"
"*******************************************************************"

$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;

$INTEGER medium,i;
$REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
         XSIF,FCOULC;

DO medium = 1,nmed [

    log_ap(medium) = log(ap(medium));
    Zt = 0; Zb = 0; Zf = 0;
    DO i=1, NNE(medium) [
        Zi = ZELEM(medium,i); pi = PZ(medium,i);
        fc = FCOULC(Zi); xi = XSIF(Zi);
        aux = pi*Zi*(Zi + xi);
        Zt = Zt + aux;
        Zb = Zb - aux*Log(Zi)/3;
        Zf = Zf + aux*fc;
    ]
    Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
    fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
    fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;

    "These are used in BREMS"
    dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
    dl2(1,medium) = -3.242/fmax1;
    dl3(1,medium) = 0.625/fmax1;
    dl4(1,medium) = (21.12+4*Zg)/fmax1;
    dl5(1,medium) = -4.184/fmax1;
    dl6(1,medium) = 0.952;
    dl1(2,medium) = (20.029+4*Zg)/fmax1;
    dl2(2,medium) = -1.93/fmax1;
    dl3(2,medium) = -0.086/fmax1;
    dl4(2,medium) = (21.12+4*Zg)/fmax1;
    dl5(2,medium) = -4.184/fmax1;
    dl6(2,medium) = 0.952;
    dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
    dl2(3,medium) = -3.242/fmax2;
    dl3(3,medium) = 0.625/fmax2;
    dl4(3,medium) = (21.12+4*Zv)/fmax2;
    dl5(3,medium) = -4.184/fmax2;
    dl6(3,medium) = 0.952;
    dl1(4,medium) = (20.029+4*Zv)/fmax2;
    dl2(4,medium) = -1.93/fmax2;
    dl3(4,medium) = -0.086/fmax2;
    dl4(4,medium) = (21.12+4*Zv)/fmax2;
    dl5(4,medium) = -4.184/fmax2;
    dl6(4,medium) = 0.952;

    "and these in PAIR"
    dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
    dl2(5,medium) = (3*(-3.242) - (-1.930));
    dl3(5,medium) = (3*(0.625)-(-0.086));
    dl4(5,medium) = (2*21.12+8*Zg);
    dl5(5,medium) = (2*(-4.184));
    dl6(5,medium) = 0.952;
    dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
    dl2(6,medium) = (3*(-3.242) + (-1.930));
    dl3(6,medium) = (3*0.625+(-0.086));
    dl4(6,medium) = (4*21.12+16*Zg);
    dl5(6,medium) = (4*(-4.184));
    dl6(6,medium) = 0.952;
    dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
    dl2(7,medium) = (3*(-3.242) - (-1.930));
    dl3(7,medium) = (3*(0.625)-(-0.086));
    dl4(7,medium) = (2*21.12+8*Zv);
    dl5(7,medium) = (2*(-4.184));
    dl6(7,medium) = 0.952;
    dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
    dl2(8,medium) = (3*(-3.242) + (-1.930));
    dl3(8,medium) = (3*0.625+(-0.086));
    dl4(8,medium) = (4*21.12+16*Zv);
    dl5(8,medium) = (4*(-4.184));
    dl6(8,medium) = 0.952;

    bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
    bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));

]
return;
end;


$REAL function FCOULC(Z);
"************************"
$IMPLICIT-NONE;
$REAL Z;
$REAL fine,asq;
data fine/137.03604/;
asq = Z/fine; asq = asq*asq;
FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
return;
end;

$REAL function XSIF(Z);
"**********************"
$IMPLICIT-NONE;
$REAL    Z;
$INTEGER iZ;
$REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
data     alrad/5.31,4.79,4.74,4.71/;
data     alradp/6.144,5.621,5.805,5.924/;
data     a1440/1194.0/,A183/184.15/;
IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
return;
end;

"******************************************************************"
subroutine init_compton;
"
"  Reads in bound Compton scattering data from unit $INCOHUNIT
"  and performs necessary initializations
"
"  See definitions of variables in egsnrc.macros with definition
"  of COMIN/COMPTON-DATA/
"
"  I.Kawrakow, January 99
"******************************************************************"

implicit none;

$COMIN-INIT-COMPT;

$INTEGER i,j,iz,nsh,j_l,j_h;
$REAL    aux,pztot,atav;
$REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
                        "compiler don't have an intrinsic error function"
$LOGICAL getd;

" Initialize radiative Compton corrections, if needed "
$RADC_HATCH;

$need_bound_compton_data(getd);
IF( ~getd ) [
    IF( eadl_relax & photon_xsections = 'xcom' )[
        $egs_fatal('(a,/a,/a)',
                   'You must turn ON Compton binding corrections when using',
                   'a detailed atomic relaxation (eadl_relax=true) since ',
                   'binding energies taken from incoh.data below 1 keV!');
    ]
    $egs_info('(a/)',' Bound Compton scattering not requested! ');
    return;
]

$egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
rewind($INCOHUNIT);
DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
iz = 0;
DO j=1,$MXTOTSH [
    read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
                       Jo_array(j),be_array(j);
    Jo_array(j) = Jo_array(j)*137.;
    be_array(j) = be_array(j)*1e-6/PRM;
    aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
    erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
                    "0.82436063535 is exp(0.5)/2"

    "For detailed atomic relaxations set shell type
    "to actual shell number and update binding energies
    "with values from the photo-electric cross sections
    IF (eadl_relax)[
       IF (iz_array(j) ~= iz)[
          shn_array(j) = 1; iz = iz_array(j);
       ]
       ELSE[
          shn_array(j) = shn_array(j-1)+1;
       ]
       IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
         be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
       ]
       ELSE IF(photon_xsections = 'xcom') [
         "Use binding energies from incoh.data below 1 keV"
         binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
       ]
    ]

]
$egs_info(*,' Done');
$egs_info('(/a)',' Initializing Bound Compton scattering ......');
DO medium = 1,nmed [
    pztot = 0; nsh = 0;
    DO i = 1, nne(medium) [
        iz = int(zelem(medium,i));
        DO j = 1, $MXTOTSH [
            IF( iz = iz_array(j) ) [
                nsh = nsh + 1;
                IF( nsh > $MXMDSH ) [
                    $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
                              ' the number of shells is > ',$MXMDSH,'!',
                              ' Increase the parameter $MXMDSH! ');
                ]
                shell_array(nsh,medium) = j;
                aux = pz(medium,i)*ne_array(j);
                eno_array(nsh,medium) = aux;
                pztot = pztot + aux;
            ]
        ]
    ]
    IF( nsh = 0 ) [
        $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
    ]
    n_shell(medium) = nsh;
    $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
    DO i=1,nsh [
        j = shell_array(i,medium);
        eno_array(i,medium) = eno_array(i,medium)/pztot;
        $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
                  i,j,shn_array(j),eno_array(i,medium),
                  Jo_array(j),be_array(j)*PRM*1000.);
        eno_array(i,medium) = -eno_array(i,medium);
        eno_atbin_array(i,medium) = i;
    ]
    atav = 1./nsh;
    DO i=1,nsh-1 [
        DO j_h = 1,nsh-1 [
            IF( eno_array(j_h,medium) < 0 ) [
                IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
            ]
        ]
        DO j_l = 1,nsh-1 [
            IF( eno_array(j_l,medium) < 0 ) [
                IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
            ]
        ]
        aux = atav - abs(eno_array(j_l,medium));
        eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
        eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
        eno_atbin_array(j_l,medium) = j_h;
        IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
    ]
    DO i=1,nsh [
        IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
    ]
]

$egs_info('(a/)',' ...... Done.');

$need_relaxation_data(getd);
IF( getd ) return;
$egs_fatal('(/a,/a,/a,/a)',
' In subroutine init_compton: ',
'   Scattering off bound electrons creates atomic vacancies,',
'   potentially starting an atomic relaxation cascade. ',
'   Please turn ON atomic relaxations.');
/*
Turning ON relaxations to setup relaxations for bound Compton
and then turning it back OFF seems inconsistent. One should have
relaxations for all interactions with atomic electrons.

$egs_info('(a/,a/,a/,a//)',
' In subroutine init_compton: ',
'   fluorescence not set but relaxation data are required for ',
'   bound Compton scattering. ',
'   calling EDGSET. ');
iedgfl(1) = 1;              "This was (2) originally  DR"
eadl_relax = .true.;
call edgset(1,1);
iedgfl(1) = 0;              "This was (2) originally  DR"
*/
return;
end;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE MOLLER;
"                                                                  "
"******************************************************************"
"   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
"   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
"   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
"   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
"   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
"   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
"   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
"   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
"   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
"   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
"   LOSS DURING TRANSPORT.                                         "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
                                          "UPHIOT,USEFUL,RANDOM/;"
;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;

$DEFINE-LOCAL-VARIABLES-MOLLER;

$REAL sigm,pbrem,rsh,Uj,sig_j;
$INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;

"IRCODE=1;  appears to be unused, IK Oct 97"
NPold = NP;      "Set the old stack counter"
PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
EKIN=PEKIN;

IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
    "The EII flag is set and this medium has shells for which we want to"
    "simulate EII => sample if the interaction is with a EII shell"
    $SET INTERVAL elke,eke;
    $EVALUATE sigm USING esig(elke);
    $EVALUATE pbrem USING ebr1(elke);
    sigm = sigm*(1 - pbrem);
    $RANDOMSET rsh; rsh = sigm*rsh;
    DO iele=1,nne(medium) [
        iZ = int(zelem(medium,iele)+0.5);
        nsh = eii_no(medium,iele);
        IF( nsh > 0 ) [
            ifirst = eii_first(medium,iele);
            DO ish = 1,nsh [
                Uj = binding_energies(ish,iZ);
                IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
                    jj = ifirst + ish - 1;
                    i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
                    sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
                    sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
                    rsh = rsh - sig_j;
                    IF( rsh < 0 ) [
                        $AUSCALL($EIIB);
                        call eii_sample(ish,iZ,Uj);
                        $AUSCALL($EIIA);
                        return;
                    ]
                ]
            ]
        ]
    ]
]
IF( ekin <= 2*te(medium) ) return;
T0=EKIN/RM;
E0=T0+1.0;
EXTRAE = EIE - THMOLL(MEDIUM);
E02=E0*E0;
"BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
EP0=TE(MEDIUM)/EKIN;
"G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
G2=T0*T0/E02;
G3=(2.*T0+1.)/E02;
"   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
"   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
"   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
"   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
"   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
"   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
"   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
"   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "

"   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
"   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
"   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
"   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
"   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "

GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
LOOP[" TO RETRY IF REJECTED"
$RANDOMSET RNNO27;
BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);

"   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
R=BR/(1.-BR);
$RANDOMSET RNNO28;
REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"

PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
E(NP)=PESE1;
$CHECK-STACK(np+1,'MOLLER');
E(NP+1)=PESE2;
"   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
"   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "

" One possible way of dealing with double counting of angular      "
" deflections in inelastic scattering would be to                  "
" not deflect the 'old' electron as these deflections are          "
" already taken into account in the multiple elastic scattering    "
" This approach has the disadvantage of loosing correlations       "
" between big energy losses and strong angular deflections         "
" The advantage of such an approach is its simplicity.             "
" If spin effects for multiple elastic scattering are turned on,   "
" the double counting is taken into account by the appropriate     "
" modification of the scattering power (which depends on AE)       "
"                                                                  "
"                                                                  "
" IK, June 1999                                                    "

H1=(PEIE+PRM)/PEKIN;
"   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
SINTHE=DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);

"sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"

CALL UPHI(2,1);

"   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
NP=NP+1;
IQ(NP)=-1;
DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
SINTHE=-DSQRT(1.D0-DCOSTH);
COSTHE=DSQRT(DCOSTH);
CALL UPHI(3,2);
RETURN;
"END OF SUBROUTINE MOLLER"  END;

%E

subroutine mscati;
"**********************************************************************"

" Subroutine to read the pre-calculated q^(2+)-surface, prepare data
" required by the mscat and msdist subroutines, initialize spin effect
" corrections
"
" I.Kawrakow, NRC
"**********************************************************************"

implicit none;

$REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
$REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
$INTEGER
    i,leil,leip1l,neke,lelke,lelkef,lelktmp;
$LOGICAL  ise_monoton, isp_monoton;

$declare_write_buffer;

"cross section per energy loss"
$REAL sigee,sigep,sig,sige_old,sigp_old;

"entry mscat variables
"======================

$COMIN-MSCATI;

" moved the following from prestaII_inputs, "
" if transport_algorithm = presta-I, exact_bca = .false. and
" skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"

IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
ELSE                    [ exact_bca = .false.; ]
IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
IF( ximax <= 0  | ximax >= 1 ) [
    IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
    ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
]
IF (transport_algorithm ~= $PRESTA-II &
    transport_algorithm ~= $PRESTA--I &
    transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
IF( skindepth_for_bca <= 1e-4 ) [
    "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
    IF( ~exact_bca ) [
        $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
        $set_ecutmn;
        $egs_info(*,'     minimum ECUT found: ',ecutmn);
        tstbmn = 1e30;
        DO medium = 1,nmed [
            tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
            tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
            aux = Log(tstbm);
            IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
            tstbm = Log(tstbm/aux);
            "Changed the following to the above so that the Intel compiler"
            " does not vectorize the loop with -xK. Vectorizing this loop"
            " on an Athlon CPU results in segmentation fault."
            " IK, Jan 29 2004."
            "tstbm = Log(tstbm/Log(tstbm));"
            tstbmn = Min(tstbmn,tstbm);
        ]
        $egs_info(*,'     default BLCMIN is: ',tstbmn);
        skindepth_for_bca = Exp(tstbmn);
        $egs_info(*,'     this corresponds to ',skindepth_for_bca,
         ' elastic MFPs ');
    ]
    ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
]

" read MS data for screened Rutherford scattering "
call init_ms_SR;

DO medium = 1,nmed
[
    "Absorb Euler constant into the multiple scattering parameter
    "1.16699413758864573 = Exp[2 EulerGamma - 1]
    blcc(medium) = 1.16699413758864573*blcc(medium);

    "Take its square as this is employed throughout
    xcc(medium)  = xcc(medium)**2;
]

IF( spin_effects ) [ call init_spin; ]

"Determine maximum cross section per energy loss for every medium
$egs_info(*,' ');
esige_max = 0;
psige_max = 0;
DO medium = 1,nmed
[

  sigee = 1E-15; sigep = 1E-15;
  neke = meke(medium); "Number of elements in storage array
  ise_monoton = .true.; isp_monoton = .true.;
  sige_old = -1; sigp_old = -1;
  DO i = 1,neke
  [

    ei   = exp((float(i) - eke0(medium))/eke1(medium));
    eil  = log(ei);
    leil = i;
    $EVALUATE ededx USING ededx(eil);
    $EVALUATE sig USING esig(eil);
    sig = sig/ededx;
    IF (sig > sigee) sigee = sig;
    IF( sig < sige_old ) ise_monoton = .false.;
    sige_old = sig;
    $EVALUATE ededx USING pdedx(eil);
    $EVALUATE sig USING psig(eil);
    sig = sig/ededx;
    IF (sig > sigep) sigep = sig;
    IF( sig < sigp_old ) isp_monoton = .false.;
    sigp_old = sig;

  ]
  $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
          ise_monoton,isp_monoton);
  sig_ismonotone(0,medium) = ise_monoton;
  sig_ismonotone(1,medium) = isp_monoton;
  esig_e(medium) = sigee; psig_e(medium) = sigep;
  IF( sigee > esige_max ) esige_max = sigee;
  IF( sigep > psige_max ) psige_max = sigep;
]
$egs_info(*,' ');

$egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
$egs_info(*,' ');

"Determine upper limit in step size for multiple scattering
DO medium = 1,nmed
[
    " Calculate range array first "
    " =========================== "
    ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
    eil  = log(ei);
    leil = 1;
    E_array(1,medium) = ei;
    expeke1(medium) = Exp(1./eke1(medium))-1;
    range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
    neke = meke(medium); "Number of elements in storage array
    DO i = 1,neke - 1
    [
        eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
        E_array(i+1,medium) = eip1;
        " Calculate range. The following expressions result from the"
        " logarithmic interpolation for the (restricted) stopping power "
        " and a power power series expansion of the integral "
        eke = 0.5*(eip1+ei); elke = Log(eke);
        $SET INTERVAL elke,eke;
        $EVALUATE ededx USING pdedx(elke);
        aux = pdedx1(i,medium)/ededx;
        range_ep(1,i+1,medium) = range_ep(1,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        $EVALUATE ededx USING ededx(elke);
        aux = ededx1(i,medium)/ededx;
        range_ep(0,i+1,medium) = range_ep(0,i,medium) +
          (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
        ei = eip1;
    ]

    " Now tmxs "
    " ======== "

    eil = (1 - eke0(medium))/eke1(medium);
    ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
    p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
    chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
    $EVALUATE dedx0 USING ededx(eil);
    estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
    estepx = estepx*ximax;
    IF( estepx > estepe ) [ estepx = estepe; ]
    si = estepx*ei/dedx0;

    DO i = 1,neke - 1
    [

        elke = (i + 1 - eke0(medium))/eke1(medium);
        eke  = Exp(elke); lelke = i+1;
        p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
        chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
        $EVALUATE ededx USING ededx(elke);
        estepx = 2*p2*beta2*ededx/eke/
                  Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
        estepx = estepx*ximax;
        IF( estepx > estepe ) [ estepx = estepe; ]
        ekef = (1-estepx)*eke;
        IF( ekef <= E_array(1,medium) )
        [
            sip1 = (E_array(1,medium) - ekef)/dedx0;
            ekef = E_array(1,medium);
            elkef = (1 - eke0(medium))/eke1(medium);
            lelkef = 1;
        ]
        ELSE
        [
            elkef = Log(ekef);
            $SET INTERVAL elkef,eke;
            leip1l = lelkef + 1;
            eip1l  = (leip1l - eke0(medium))/eke1(medium);
            eip1   = E_array(leip1l,medium);
            aux    = (eip1 - ekef)/eip1;
            elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
            ektmp  = 0.5*(ekef+eip1);
            lelktmp = lelkef;
            $EVALUATE ededx USING ededx(elktmp);
            aux = ededx1(lelktmp,medium)/ededx;
            sip1 = (eip1 - ekef)/ededx*(
                     1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
        ]
        sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);

        "Now solve these equations
        "  si   = tmxs1 * eil   + tmxs0
        "  sip1 = tmxs1 * eip1l + tmxs0

        tmxs1(i,medium) = (sip1 - si)*eke1(medium);
        tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;

        si  = sip1;
    ]

    "Now pick up last table entry which applies only to last energy
    tmxs0(neke,medium) = tmxs0(neke - 1,medium);
    tmxs1(neke,medium) = tmxs1(neke - 1,medium);

]

return;
end;

%E
; "buffer flush

subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
                 spin_effects,find_index,spin_index,
                 cost,sint);
"========================================================================="
"                                                                         "
" Subroutine to sample multiple electron scattering angles from the exact "
" distribution resulting from elastic scattering described by the screened"
" Rutherford cross section (spin_effects=.false.) or by the screened      "
" Rutherford cross times Mott correction (spin_effects=.true.)            "
"                                                                         "
" I.Kawrakow, NRC                                                         "
"========================================================================="

implicit none;

$REAL    lambda, chia2,q1,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects,find_index,spin_index;

COMIN/MS-Data,RANDOM,EGS-IO/;

$declare_write_buffer;

$REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
         cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
$INTEGER icount,i,j,k;

save     i,j,omega2;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

IF(lambda <= 13.8)
[
    "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
    "that contribute to the forward no-scattering amplitude.
    $RANDOMSET sprob;
    explambda = Exp(-lambda);
    IF (sprob < explambda)
    [
        "It was a no scattering event
        cost = 1; sint = 0;
        return;
    ]
    wsum = (1+lambda)*explambda;
    IF ( sprob < wsum )
    [
      :RETRY_1:;
      $RANDOMSET xi;
      xi  = 2*chia2*xi/(1 - xi + chia2);
      cost = 1 - xi;
      IF( spin_effects ) [
          rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
                                spin_index,.false.);
          $RANDOMSET rnno;
          IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
      ]
      sint = sqrt(xi*(2 - xi));
      return;
    ]
    IF ( lambda <= 1 )      "IK introduced this portion because with
                            "alternative BCAs mscat can be called with
                            " lambda < 1 where there are no pre-calculated
                            "data
    [
        wprob = explambda; wsum = explambda;
        cost = 1; sint = 0;
        icount = 0;
        LOOP
        [
            icount = icount + 1;
            IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
            wprob = wprob*lambda/icount;
            wsum = wsum + wprob;
            :RETRY_2:;
            $RANDOMSET xi;
            xi  = 2*chia2*xi/(1 - xi + chia2);
            cosz = 1 - xi;
            IF( spin_effects ) [
                rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
                                      spin_index,.false.);
                $RANDOMSET rnno;
                IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
            ]
            sinz = xi*(2 - xi);
            IF ( sinz > 1.e-20 )
            [
               sinz = Sqrt(sinz);
               $RANDOMSET xi;
               phi = xi*6.2831853;
               cost = cost*cosz - sint*sinz*Cos(phi);
               sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
             ]
        ] UNTIL ( wsum > sprob);
        return;
    ]
]

"It was a multiple scattering event
"Sample the angle from the q^(2+) surface

IF (lambda <= $LAMBMAX_MS ) [

    IF (find_index)
    [
        llmbda = log(lambda);

        " First fix lambda bin
        ai = llmbda*dllambi; i = ai; ai = ai - i;
        $RANDOMSET xi;
        IF(xi < ai) i = i + 1;

        " fix now q1 bin
        IF( q1 < $QMIN_MS ) [ j = 0; ]
        ELSE IF( q1 < $QMAX_MS ) [
            aj = q1*dqmsi; j = aj; aj = aj - j;
            $RANDOMSET xi;
            IF( xi < aj ) j = j + 1;
        ]
        ELSE [ j = $MAXQ_MS; ]

        " Calculate omega2 "
        IF(llmbda < 2.2299) [
          omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
            0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
        ]
        ELSE [
          omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
                   llmbda*(0.1535754 - llmbda*0.00552888)));
        ]

        find_index = .false.;
    ]
    "If this is a re-iteration with the same lambda, then omega2, i, and k
    "should have been defined in the previous iteration

:RETRY_3:;
    $RANDOMSET xi;
    ak = xi*$MAXU_MS; k = ak; ak = ak - k;
    IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
    a = fms_array(i,j,k); u = ums_array(i,j,k);
    du = ums_array(i,j,k+1) - u;
    $RANDOMSET xi;
    IF( abs(a) < 0.2 ) [
        x1 = 0.5*(1-xi)*a;
        u  = u + xi*du*(1+x1*(1-xi*a));
    ]
    ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]

    xi      = omega2*u/(1 + 0.5*omega2 - u);
    IF( xi > 1.99999 ) [ xi = 1.99999; ]
      "some machines have trouble when xi is very close to 2 in subsequent"
      "calculations. IK, April 25 2002"
    cost    = 1 - xi;
    IF( spin_effects ) [
        rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
        $RANDOMSET rnno;
        IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
    ]
    sint    = sqrt(xi*(2-xi));
    return;
]

"This is an error condition

$egs_info(*,' ');
$egs_info(*,' *************************************');
$egs_info(*,' Maximum step size in mscat exceeded! ');
$egs_info(*,' Maximum step size initialized: 100000');
$egs_info(*,' Present lambda: ',lambda);
$egs_info(*,' chia2: ',chia2);
$egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
$egs_info(*,' medium: ',medium);
$egs_fatal(*,' Stopping execution');

end;

%E
; "buffer flush

$REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
                              spin_index,is_single);
"============================================================================="
"                                                                             "
" Determines the rejection function due to spin effects for                   "
"   charge        qel (=0 for e-, =1 for e+)                                  "
"   log(energy)   elke                                                        "
"   speed         beta2                                                       "
"   1. MS moment  q1                                                          "
"   cos(theta)    cost                                                        "
"                                                                             "
" I.Kawrakow, NRC                                                             "
"============================================================================="

implicit none;

$REAL      elke,beta2,q1,cost;
$INTEGER   qel,medium;
$LOGICAL   spin_index,is_single;
$declare_max_medium;
COMIN/Spin-Data,RANDOM/;

$REAL      rnno,ai,qq1,aj,xi,ak;
$INTEGER   i,j,k;

save       i,j;

IF( spin_index ) [  "Determine the energy and q1 index
    spin_index = .false.;
    IF( beta2 >= b2spin_min ) [
        ai = (beta2 - b2spin_min)*dbeta2i;
        i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
    ]
    ELSE IF( elke > espml ) [
        ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
    ]
    ELSE [ i = 0; ai = -1; ]
    $RANDOMSET rnno;
    IF( rnno < ai ) i = i + 1;
    IF( is_single ) [ j = 0; ]
    ELSE [
        qq1 = 2*q1; qq1 = qq1/(1 + qq1);
        aj = qq1*dqq1i; j = aj;
        IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
        ELSE [  aj = aj - j;
                $RANDOMSET rnno;
                IF( rnno < aj ) j = j + 1;
        ]
    ]
]
xi = Sqrt(0.5*(1-cost));
ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
                     ak*spin_rej(medium,qel,i,j,k+1);
return;
end;

%E
; "buffer flush


subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
"============================================================================"
"                                                                            "
" single elastic scattering                                                  "
"                                                                            "
" I.Kawrakow, NRC                                                            "
"============================================================================"

implicit none;

$REAL    chia2,elke,beta2,cost,sint;
$INTEGER qel,medium;
$LOGICAL spin_effects;

COMIN/RANDOM/;

$REAL    xi,rnno,rejf,spin_rejection,qzero;
$LOGICAL spin_index;

$TURN_OFF_SCATTERING;
" default of above is ';' See definition in egsnrc.macros for example"
" of how to turn off all scattering    DR April 2012"

spin_index = .true.;
:RETRY-SPIN:;
$RANDOMSET xi;
xi  = 2*chia2*xi/(1 - xi + chia2);
cost = 1 - xi;
IF( spin_effects ) [
    qzero=0;
    rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
    $RANDOMSET rnno;
    IF( rnno > rejf ) goto :RETRY-SPIN:;
]
sint = sqrt(xi*(2 - xi));
return;
end;

%E
; "buffer flush

subroutine init_ms_SR;
"================================================================"
"                                                                "
" Reads in pre-calculated screened Rutherford multiple elastic   "
" scattering data                                                "
"                                                                "
" I. Kawrakow, NRC                                               "
"================================================================"

implicit none;

COMIN/MS-Data,EGS-IO/;
$declare_write_buffer;

integer*4 i,j,k;

$egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
rewind($MSCAT-DATAFILE);
DO i=0,$MAXL_MS [
    DO j=0,$MAXQ_MS [
        read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
        read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
        read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
        DO k=0,$MAXU_MS-1 [
           fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
           ims_array(i,j,k) = ims_array(i,j,k)-1;
        ]
        fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
    ]
]
$egs_info('(a)',' done ');

llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;

return;
end;

%E
; "buffer flush

subroutine init_spin;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline,dloge,eloge;

real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"

real*4        fmax_array(0:$MAXQ_SPIN);
integer*2     i2_array(512),ii2;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,ii4,irec;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file

$INTEGER      spin_unit, rec_length, want_spin_unit;
integer       egs_get_unit;
character     data_version*32,endianess*4;
$LOGICAL      swap;

$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" stupid GNU compiler complains that the arguments to egs_swap_ are of "
" one kind here, but of some other kind there => need character arrays and "
" equivalence statements"
real*4        tmp_4;
character     c_2(2), c_4(4);
equivalence   (ii2,c_2), (tmp_4,c_4);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
want_spin_unit = 61;
spin_unit = egs_get_unit(want_spin_unit);
IF( spin_unit < 1 ) [
    $egs_fatal(*,'init_spin: failed to get a free fortran unit');
]
rec_length = 276*$RECL-FACTOR;
open(spin_unit,file=spin_file,form='unformatted',access='direct',
     status='old',recl=rec_length,err=:spin-open-error:);
read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
                      espin_min,espin_max,b2spin_min,b2spin_max;
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
    tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
    tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
    tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
]
$egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
$egs_info('(a)',data_version);
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,
        ' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
$egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
        b2spin_min,b2spin_max);
n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
dloge = log(espin_max/espin_min)/n_ener;
eloge = log(espin_min); earray(0) = espin_min;
$FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
DO i=1,n_ener [
    eloge = eloge + dloge; earray(i) = exp(eloge);
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]
dbeta2 = (b2spin_max - b2spin_min)/n_ener;
beta2 = b2spin_min; earray(n_ener+1) = espin_max;
DO i=n_ener+2,2*n_ener+1 [
    beta2 = beta2 + dbeta2;
    IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
    ELSE [ earray(i) = 50585.1; ]
    $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
]

" Convert to MeV and set interpolation interavals"
/*
 * IK: Moved here Feb 4 2004.
 *     Bug found and reported by Dr Helmut Schlattl.
 */
espin_min = espin_min/1000; espin_max = espin_max/1000;
dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
espml = Log(espin_min);
dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            DO i=0,$MAXE_SPI1 [
                irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
                $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
                read(spin_unit,rec=irec,err=:spin-read-error:)
                  dum1,dum2,dum3,aux_o,fmax_array,i2_array;
                IF( swap ) [
                  tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
                  tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
                  tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
                  tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
                ]
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    tmp_4 = fmax_array(j);
                    IF( swap ) call egs_swap_4(c_4);
                    DO k=0,$MAXU_SPIN [
                        ii2 = i2_array((n_point+1)*j + k+1);
                        IF( swap ) call egs_swap_2(c_2);
                        ii4 = ii2;
                        IF( ii4 < 0 ) ii4 = ii4 + 65536;
                        dum1 = ii4; dum1 = dum1*tmp_4/65535;
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*dum1;
                    ]
                ]
            ]
        ]
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
        $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
          c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
    ]

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
         etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
        $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
          q1ce_ms0(i,medium);
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
          q1cp_ms0(i,medium);
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
          q2ce_ms0(i,medium);
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
        $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
          q2cp_ms0(i,medium);
        si1e = si2e;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
close(spin_unit);
return;

:spin-open-error:
$egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));

:spin-read-error:
$egs_fatal(*,'Error while reading spin data file for element',iZ);

return; end;
%E

subroutine init_spin_old;
"======================================================================="
"                                                                       "
" Reads in spin rejection data for multiple elastic scattering and      "
" initializes interpolation arrays for the screening parameter,         "
" elastic cross section, first and second MS moments                    "
"                                                                       "
" This version uses the old EGSnrc ASCII spin data format.              "
" If the installation failed to figure out the byte order of your       "
" machine, rename this subroutine to init_spin, the current init_spin   "
" to init_spin_new (or whatever) and download the old spinms data       "
" directory.
"                                                                       "
" I. Kawrakow, NRC                                                      "
"======================================================================="

implicit none;
$declare_max_medium;
COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
                            "BREMPR is needed for the elemental composition"

$REAL         eta_array(0:1,$0-MAXE_SPI1),
              c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
              earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
              sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
              dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
              eil,e,si1e,si2e,si1p,si2p,aae,etap,
              elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
              af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
              df($0-MAXE_SPI1),spline;

$INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
              ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;

character     spin_file*256;
character*6   string;
integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
                       "do not have lnblnk, we supply lnblnk1 in this file
$declare_write_buffer;

$REAL        fine,TF_constant;
parameter    (fine=137.03604, TF_constant=0.88534138);

" First construct the path to the spin dbase directory "
$set_string(spin_file,' ');
spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
             $file_sep // 'z000';
length = lnblnk1(spin_file);

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
                          ' ..................... ');
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
            DO j=0,$MAXQ_SPIN [
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = 0;
                ]
            ]
        ]
    ]
    /sum_Z2,sum_A,sum_pz,sum_Z/=0;
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele);
        iZ = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*(Z+1);
              "For now, we take into account the contribution of atomic"
              "electrons to elastic scattering by replacing Z**2 with  "
              "Z*(Z+1). The part of the scattering power that is taken "
              "into account by discrete Moller/Bhabha events is        "
              "substracted below => bc is energy dependent. We will    "
              "worry about better approaches in the future (a realistic"
              "inelastic scattering model is needed first)             "
        iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
        iiZ = iZ - iii*100;
        iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
        iiZ = iiZ - 10*iii;
        spin_file(length:length) = char(iiZ+48);
        want_spin_unit = 61;
        spin_unit = egs_get_unit(want_spin_unit);
        IF( spin_unit < 1 ) [
            $egs_fatal(*,'init_spin: failed to get a free fortran unit');
        ]
        open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
        read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
        read(spin_unit,*) n_ener,n_q,n_point;
        IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
            $egs_fatal(*,' Wrong spin file for Z = ',iZ);
        ]
        sum_Z2 = sum_Z2 + tmp;
        sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
        sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
        sum_pz = sum_pz + PZ(medium,i_ele);
        Z23    = Z**0.6666667;
        DO iq=0,1 [
            read(spin_unit,*); read(spin_unit,*);
            DO i=0,$MAXE_SPI1 [
                read(spin_unit,'(a,g14.6)') string,earray(i);
                read(spin_unit,*) dum1,dum2,dum3,aux_o;
                eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
                tau = earray(i)/prm*0.001;  "energy in the file is in keV"
                beta2 = tau*(tau+2)/(tau+1)**2;
                eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
                c_array(iq,i)=c_array(iq,i)+
                  tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
                g_array(iq,i)=g_array(iq,i)+tmp*dum2;
                DO j=0,$MAXQ_SPIN [
                    read(spin_unit,*) tmp_array;
                    DO k=0,$MAXU_SPIN [
                        spin_rej(medium,iq,i,j,k) =
                          spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
                    ]
                ]
            ]
        ]
        close(spin_unit);
    ]

    " spin_rej will be used as a rejection function in MS sampling, "
    " so scale maximum to unity"
    DO iq=0,1 [
        DO i=0,$MAXE_SPI1 [
            DO j=0,$MAXQ_SPIN [
                fmax = 0;
                DO k=0,$MAXU_SPIN [
                    IF( spin_rej(medium,iq,i,j,k) > fmax )
                       [ fmax = spin_rej(medium,iq,i,j,k); ]
                ]
                DO k=0,$MAXU_SPIN [
                    spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
                ]
            ]
        ]
    ]

    " Process eta_array, c_array and g_array to their final form "
    DO i=0,$MAXE_SPI1 [
        tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
        DO iq=0,1 [
            aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
            eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
            eta = aux_o/4/tau/(tau+2);
            gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
                      (Log(1+1/eta)*(1+eta)-1);
            g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
            c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
        ]
    ]

    " Convert to MeV and set interpolation interavals"
    espin_min = espin_min/1000; espin_max = espin_max/1000;
    dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
    espml = Log(espin_min);
    dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
    dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;

    " Prepare interpolation table for the screening parameter "
    eil = (1 - eke0(medium))/eke1(medium);
    e = Exp(eil);
    IF( e <= espin_min ) [
        si1e = eta_array(0,0); si1p = eta_array(1,0);
    ]
    ELSE [
        IF( e <= espin_max ) [
            aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
        ]
        ELSE [
            tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
            aae = (beta2 - b2spin_min)*dbeta2i;
            je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
        ]
        si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
        si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
    ]
    neke = meke(medium);
    DO i = 1,neke - 1 [
        eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
        IF( e <= espin_min ) [
            si2e = eta_array(0,0); si2p = eta_array(1,0);
        ]
        ELSE [
            IF( e <= espin_max ) [
                aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
            ]
            ELSE [
                tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
                aae = (beta2 - b2spin_min)*dbeta2i;
                je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
            ]
            si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
            si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
        ]
        etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
        etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
        etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
        si1e = si2e; si1p = si2p;
    ]
    etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
    etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
    etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
    etap_ms0(neke,medium) = etap_ms0(neke-1,medium);

    "Prepare correction to the first MS moment due to spin effects"
    "first electrons"
    DO i=0,$MAXE_SPIN [
        elarray(i) = Log(earray(i)/1000);
        farray(i) = c_array(0,i);
    ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
        elarray(i) = Log(earray(i+1)/1000);
        farray(i) = c_array(0,i+1);
    ]
    ndata = $MAXE_SPI1+1;
    IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
    ELSE [ elarray(ndata-1) = Log(1e5); ]
    farray(ndata-1) = 1;
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
    q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
    "now positrons"
    DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
    q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);

    "prepare interpolation table for the second MS moment correction"
    "e-"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
        si1e = si2e;
    ]
    q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
    q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
    "e+"
    DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
    DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
    call set_spline(elarray,farray,af,bf,cf,df,ndata);
    eil = (1 - eke0(medium))/eke1(medium);
    si1e = spline(eil,elarray,af,bf,cf,df,ndata);
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        si2e = spline(eil,elarray,af,bf,cf,df,ndata);
        q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
        q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
    ]
    q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
    q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);

    "Now substract scattering power that is already taken into account in"
    "discrete Moller/Bhabha events"
    tauc = te(medium)/prm;
    si1e = 1;
    DO i=1,neke-1 [
        eil = (i+1 - eke0(medium))/eke1(medium);
        e = Exp(eil); leil=i+1; tau=e/prm;
        IF( tau > 2*tauc ) [
            $EVALUATE sig USING esig(eil);
            $EVALUATE dedx USING ededx(eil);
            sig = sig/dedx;
            IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
                $EVALUATE etap USING etae_ms(eil);
                eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
                g_r = (1+2*eta)*Log(1+1/eta)-2;
                g_m = Log(0.5*tau/tauc)+
                 (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
                 0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
                    Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
                 0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
                IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
                si2e = 1 - g_m*sum_Z/sum_Z2;
            ] ELSE [ si2e = 1; ]
        ] ELSE [ si2e = 1; ]
        blcce1(i,medium) = (si2e - si1e)*eke1(medium);
        blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
        si1e = si2e;
    ]
    blcce1(neke,medium) = blcce1(neke-1,medium);
    blcce0(neke,medium) = blcce0(neke-1,medium);

    "We will not bother to do the same for positrons at this time"

    $egs_info('(a)',' done');
]
return;

:SPIN-DBASE-ERROR:
$egs_info(*,' ******************** Error in init_spin ******************* ');
$egs_info('(a,a)','  could not open file ',spin_file);
$egs_fatal(*,' terminating execution ');

end;
%E
; "buffer flush

"======================================================================"
"                 subroutine msdist_pII                                "
"                 =====================                                "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep.                         "
"  For description of input and output variables see below             "
"                                                                      "
"  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
"  March 1997          Alex Bielajew        Adaption for EGS4          "
"  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
"                                           mortran version by Bielajew"
"  June 1997           Iwan Kawrakow        Improved energy loss       "
"                                           corrections                "
"  June 1999           Iwan Kawrakow        spin effects, removed      "
"                                           $SUBSTEP-ELOSS-EVALUATION  "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pII
(
    e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    med,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects;
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    b,         "substep transport distance,
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    c,         "substep transport distance,
    eta,eta1,  "randomization of the substep transport distances
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi1,     "cosine of the first azimuthal angle
    cphi2,     "cosine of the second azimuthal angle
    w1,        "cosine of the first substep polar scattering angle
    w2,        "cosine of the second substep polar scattering angle
    w1v2,      "w1*v2;
    delta,     "transport parameter (see paper)
    e,         "average kinetic energy over the step
    elke,      "Log(e)"
    beta2,     "speed at e in units of c, squared"
    etap,      "correction to the screening parameter derived from PWA
    xi_corr,   "correction to the first MS moments due to spin
    ms_corr,
    tau,       "average kinetic energy over the step divided by electron mass
    tau2,      "tau squared
    epsilon,   "fractional energy loss
    epsilonp,  "fractional energy loss
    temp,temp1,"auxilarity variables for energy loss corrections
    temp2,     "
    factor,    "intermediate factor employed in the energy-loss calculations
    gamma,     "q2/q1
    lambda,    "distance in number of elastic scattering mean free paths
               "for each sample of the multiple scattering angle
    p2,        "average momentum over the step
    p2i,       "inverse of ap2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sint1,     "sine   of the first substep polar scattering angle
    sint2,     "sine   of the second substep polar scattering angle
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    sphi1,     "sine   of the first azimuthal angle
    sphi2,     "sine   of the second azimuthal angle
    u2p,       "intermediate scatter or transport direction cosine
    u2,        "sint2*cphi2;
    v2,        "sint2*sphi2;
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index,  "needed to save locating the q2 index in the 2. call to mscat"
   spin_index   "saves locating the spin rejection index in 2. call to mscat"
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL/;

medium  = med;

count_pII_steps = count_pII_steps + 1;
blccc   = blcc(medium);
xcccc   = xcc(medium);

"Commonly used factors
e       = e0 - 0.5*eloss;
tau     = e/prm;
tau2    = tau*tau;
epsilon = eloss/e0;
epsilonp= eloss/e;
"e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
p2      = e*(e + rmt2);
"p2i     = 1/p2;
beta2   = p2/(p2 + rmsq);
"chia2   = xcccc*p2i/(4*blccc);
chia2   = xcccc/(4*p2*blccc);
lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step

temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
             (epsilonp/((tau+1)*(tau+2)))**2;
lambda = lambda*(1 - temp2);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
       $EVALUATE gamma USING q2ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
       $EVALUATE gamma USING q2cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]

chia2  = chia2*etap;
lambda = lambda/(etap*(1+chia2))*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
xi     = q1*lambda;

"Sample first substep scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w1,sint1);
$SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);

"Sample second substep scattering angle
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           w2,sint2);
$SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);

"Final direction of motion, relative to z-axis motion
u2  = sint2*cphi2;
v2  = sint2*sphi2;
u2p = w1*u2 + sint1*w2;
us  = u2p*cphi1 - v2*sphi1;
vs  = u2p*sphi1 + v2*cphi1;
ws  = w1*w2 - sint1*u2;

"Calculate delta, b, c

xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects

$RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;

"Correct the coefficients for energy loss
temp1 = 2 + tau;
temp = (2+tau*temp1)/((tau+1)*temp1);
"Take logarithmic dependence into account as well
temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
temp = temp * epsilonp;
temp1 = 1 - temp;
delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
          (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
           "0.40824829 is 1/Sqrt(6)"
b      = eta*delta;
c      = eta*(1-delta);

"Calculate transport direction cosines
w1v2 = w1*v2;
ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;

"Calculate transport distance
ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;

"                 subroutine msdist_pI                                 "
"                 ====================                                 "
"                                                                      "
"  This subroutine models multiple elastic scattering and spatial      "
"  deflections for a given path-length tustep                          "
"  resampling PRESTA-I behaviour.                                      "
"                                                                      "
"  October 1997        Iwan Kawrakow        Initial coding             "
"  June    1999        Iwan Kawrakow        spin effects               "
"                                                                      "
"======================================================================"
"                                                                      "
subroutine msdist_pI
(
    e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
    us,vs,ws,xf,yf,zf,ustep                                         "Outputs
);

$IMPLICIT-NONE;

" Input variables
" ===============
$REAL
    e0,     "electron kinetic energy at the beginning of step
    eloss,  "energy loss for this step
    rhof,   "density scaling template (as in EGS)
    tustep, "total pathlength of the step,
    u0,     "x-direction cosine before scattering
    v0,     "y-direction cosine before scattering
    w0,     "z-direction cosine before scattering
    x0,     "initial x-position
    y0,     "initial y-position
    z0      "initial z-position
;
$INTEGER
    medium,"medium number
    qel    "=0 for e-, =1 for e+, needed for spin effects
;
$LOGICAL
    spin_effects
;

" Output variables
" ================
$REAL
    us,    "x-direction cosine after scattering
    vs,    "y-direction cosine after scattering
    ws,    "z-direction cosine after scattering
    xf,    "final x-position after transport
    yf,    "final y-position after transport
    zf,    "final z-position after transport
    ustep  "straight line distance between the initial and final position
;

" Local variables
" ===============
$REAL
    blccc,     "multiple scattering parameter
    xcccc,     "multiple scattering parameter
    z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
    r2max,
    chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
    chilog,    "log(1+1/chia2)
    cphi0,     "cosine of the azimuthal angle of the initial particle relative
               "to its coordinates
    cphi,      "cosine of the azimuthal scattering angle
    sphi,      "sine of the  azimuthal scattering angle
    e,         "average kinetic energy over the step
    elke,      "Log(e)
    beta2,     "speed at e in units of c, squared
    etap,      "correction to the screening angle derived from PWA
    xi_corr,   "correction to the first MS moment due to spin
    ms_corr,
    epsilon,   "fractional energy loss
    temp,      "auxilarity variable for energy loss corrections
    factor,    "intermediate factor employed in the energy-loss calculations
    lambda,    "distance in number of elastic scattering mean free paths
    p2,        "average momentum over the step
    p2i,       "inverse of p2
    q1,        "first moment of the single scattering cross section
    rhophi2,   "xphi**2 + yphi**2 or its inverse
    sint,      "sine of the MS angle
    sint0,     "sine of the initial particle relative to its coordinates
    sint02,    "sint0**2
    sint0i,    "1/sint0
    sphi0,     "sine of the azimuthal angle of the initial particle relative
               "to its coordinates
    u2p,       "intermediate scatter or transport direction cosine
    ut,        "x-direction cosine for transport
    vt,        "y-direction cosine for transport
    wt,        "z-direction cosine for transport
    xi,        "first GS - moment
    xphi,      "x - used to calculated azimuthal angles
    xphi2,     "xphi**2
    yphi,      "y - used to calculated azimuthal angles
    yphi2      "yphi**2
;
$LOGICAL
   find_index, "needed to save locating the q2 index in the 2. call to mscat"
   spin_index
;
$INTEGER
   lelke
;
$declare_max_medium;
;COMIN/ELECIN,THRESH,UPHIOT,RANDOM/;

blccc   = blcc(medium);
xcccc   = xcc(medium);

e       = e0 - 0.5*eloss;
p2      = e*(e + rmt2);
p2i     = 1/p2;
chia2   = xcccc*p2i/(4*blccc);
beta2   = p2/(p2 + rmsq);
lambda  = tustep*rhof*blccc/beta2;

"Account for energy loss in the MS distribution
factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
epsilon= eloss/e0;
epsilon= epsilon/(1-0.5*epsilon);
temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
lambda = lambda*(1 + temp);

IF ( spin_effects ) [
   elke = Log(e);
   $SET INTERVAL elke,eke;
   IF ( lelke < 1 ) [ "This should normally not happen"
       lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
   ]
   IF( qel = 0 ) [
       $EVALUATE etap USING etae_ms(elke);
       $EVALUATE xi_corr USING q1ce_ms(elke);
   ]
   ELSE [
       $EVALUATE etap USING etap_ms(elke);
       $EVALUATE xi_corr USING q1cp_ms(elke);
   ]
   $EVALUATE ms_corr USING blcce(elke);
]
ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]

chia2   = xcccc*p2i/(4*blccc)*etap;
lambda = lambda/etap/(1+chia2)*ms_corr;
chilog = Log(1 + 1/chia2);
q1     = 2*chia2*(chilog*(1 + chia2) - 1);
xi     = q1*lambda;

"Sample multiple scattering angle
find_index = .true.; spin_index = .true.;
call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
           spin_effects,find_index,spin_index,
           ws,sint);
$SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
us  = sint*cphi;
vs  = sint*sphi;

"Correct xi used for the PLC calc. for spin effects
xi     = xi*xi_corr;

"Calculate PLC and lateral transport a la PRESTA-I
"Note that we use here the exact expression for <z>
"because it is much simpler and faster than the original PRESTA-I formulas
"(which are also second order approximations)
IF ( xi < 0.1 )
[
   z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
]
ELSE
[
   z = (1 - Exp(-xi))/xi;
]
r  = 0.5*sint;
r2 = r*r; z2 = z*z;
r2max = 1 - z2;
IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]

"Calculate final position vector
ut   = r*cphi; vt = r*sphi; wt = z;

"Calculate transport distance
ustep = Sqrt(z2 + r2)*tustep;

"Rotate into the final direction of motion and transport
"relative to original direction of motion
sint02 = u0**2 + v0**2;
IF (sint02 > 1e-20)
[
    sint0  = sqrt(sint02);
    sint0i = 1/sint0;
    cphi0  = sint0i*u0;
    sphi0  = sint0i*v0;

    "Scattering angles
    u2p    = w0*us + sint0*ws;
    ws     = w0*ws - sint0*us;
    us     = u2p*cphi0 - vs*sphi0;
    vs     = u2p*sphi0 + vs*cphi0;

    "Transport angles
    u2p    = w0*ut + sint0*wt;
    wt     = w0*wt - sint0*ut;
    ut     = u2p*cphi0 - vt*sphi0;
    vt     = u2p*sphi0 + vt*cphi0;
]
ELSE [ wt = w0*wt; ws = w0*ws; ]

"Transport
xf = x0 + tustep*ut;
yf = y0 + tustep*vt;
zf = z0 + tustep*wt;

return;
end;

;
%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PAIR;
"                                                                  "
"******************************************************************"
"   For a photon energy below 2.1 MeV, the energies of the pair    "
"   particles are uniformly distributed in the allowed range via   "
"   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
"   If the user has a better approach, modify this macro.          "
"   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
"   cross section is employed, above 50 MeV the Coulomb-corrected  "
"   Bethe-Heitler is used.                                         "
"   Modified from its original version to make compatible with the "
"   changes made in BREMS.                                         "
"                                                                  "
"   I. Kawrakow                                                    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
                                 "THRESH,UPHIOT,USEFUL,RANDOM/;"

$DEFINE-LOCAL-VARIABLES-PAIR;

$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;

$REAL    k,xx,abin,rbin,alias_sample1;
$INTEGER ibin, iq1, iq2, iprdst_use;
$LOGICAL do_nrc_pair;
$INTEGER itrip;
$REAL    ftrip;

NPold = NP;      "Set the old stack counter"

IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
                      " it is much more efficient to do it BEFORE the "
                      " actual sampling "
    i_survived_RR = 0;  "flag they all survive inititally"
    IF( prob_RR <= 0 ) [
        IF( n_RR_warning < $MAX-RR-WARNING ) [
          n_RR_warning = n_RR_warning + 1;
          $egs_warning('(a,g14.6)',
                      'Attempt to play Russian Roulette with prob_RR<0! ');
        ]
    ]
    ELSE [
        $RANDOMSET rnno_RR;
        IF( rnno_RR > prob_RR ) [  "The pair was killed "
            i_survived_RR =2; "flag both particles eliminated"
            IF( np > 1 ) [ np = np-1; ]
            ELSE [ " We have just one photon left on the stack. In order to  "
                   " get a proper exit from PHOTO, we have to leave at least "
                   " one particle on the stack                               "
                wt(np) = 0; e(np) = 0;
            ]
            return;
        ]
        ELSE [ "The pair survived, increase the weight"
            wt(np) = wt(np)/prob_RR;
        ]
    ]
]

$CHECK-STACK(np+1,'PAIR');
PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
do_nrc_pair = .false.;

IF( itriplet > 0 & eig > 4*rm ) [
    itrip = dli_triplet*gle + bli_triplet;
    ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
    $RANDOMSET rnno34;
    IF( rnno34 < ftrip ) [  " Triplet production "
        call sample_triplet;
        return;
    ]
]

IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
                      "(privided the energy is within the available range)"
    k = eig/rm;
    IF( k < nrcp_emax ) [
        do_nrc_pair = .true.;
        IF( k <= nrcp_emin ) [ ibin = 1; ]
        ELSE [
            abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
            ibin = abin; abin = abin - ibin;
            $RANDOMSET rbin;
            IF( rbin < abin ) ibin = ibin + 1;
        ]
        xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
                nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
                nrcp_idata(1,ibin,medium));
           " The above returns the energy fraction of the positron "
        IF( xx > 0.5 ) [
            pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
            pese2 = peig - pese1; iq2 = -1;
        ]
        ELSE [
            pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
            pese1 = peig - pese2; iq1 = -1;
        ]
    ]
]


IF( ~do_nrc_pair ) [
IF (EIG.LE.2.1) [
    "   BELOW 2.1,USE APPROXIMATION"
    $SELECT-LOW-ENERGY-PAIR-PRODICTION;
]
ELSE[   "ABOVE 2.1, MUST SAMPLE"

    "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
    "   COULOMB CORRECTED

    IF (EIG.LT.50.) [ "Use BH without Coulomb correction"

        L = 5;
        L1 = L + 1;

        "Find the actual rejection maximum for this photon energy"
        delta = 4*delcm(medium)/eig;
        IF( delta < 1 ) [
           Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
           Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
           aux2 = log(delta+dl6(l,medium));
           Amax = dl4(l,medium)+dl5(l,medium)*aux2;
           Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
        ]
        "and then calculate the probability for sampling from (br-1/2)**2"
        aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
        aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
    ]
    ELSE [
        "Use BH Coulomb-corrected"
        L = 7;
        "The absolute maxima are close to the actual maxima at high energies"
        "=>use the absolute maxima to save time"
        Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
        aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
    ]

    del0 = eig*delcm(medium);
    Eavail = eig - rmt2;

    LOOP [

        $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
        IF( rnno30 > aux1 ) [ "use the uniform part"
            br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
        ]
        ELSE [  "use the (br-1/2)**2 part of the distribution"
            $RANDOMSET rnno32; $RANDOMSET rnno33;
            br = 0.5*(1-max(rnno31,rnno32,rnno33));
            rejmax = Amax; l1 = l;
        ]
        Eminus = br*Eavail + rm;
        Eplus  = eig - Eminus;
        delta = del0/(Eminus*Eplus);
        IF( delta < 1 ) [
           rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
        ]
        ELSE [
          rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
        ]

    ] UNTIL ( rnno34*rejmax <= rejf );

    pese2 = Eminus; pese1 = peig - pese2;
    $RANDOMSET RNNO34;
    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]

]
]

"   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
ESE2=PESE2;
E(NP)=PESE1; E(NP+1)=PESE2;
"   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
"   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
"   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
"   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
"   SET UP A NEW 'ELECTRON'  "
$SET-PAIR-ANGLE;
" DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
" of the angular distribution "
CALL UPHI(1,1);
"   SET UP A NEW 'ELECTRON' "
NP=NP+1;
SINTHE=-SINTHE;
CALL UPHI(3,2);

IQ(NP)=iq2; IQ(NP-1)=iq1;
RETURN;
"END OF SUBROUTINE PAIR"    END;

"***************************************************************************"
"                                                                           "
" Sampling of triplet production events.                                    "
"                                                                           "
" The treatment is based on Borsellino's first Born approximation           "
" result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
" As the kinematic of the process is already complicated enough and the     "
" cross section itself is not simple either, a Markov-chain method is used  "
" to sample triplet events from the Borsellino equation without any         "
" additional approximations (other then the use of the first Born           "
" approximation and the assumption of free electrons implied by             "
" Borsellino's derivation)                                                  "
"                                                                           "
" Iwan Kawrakow, April 2005.                                                "
"***************************************************************************"

subroutine sample_triplet;

"***************************************************************************"
implicit none;
$declare_max_medium;
;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
$declare_write_buffer;

" We use double precision throughout as in many cases the kinematically "
" permitted angular interval is too small to be resolved accurately enough "
" in single precision "

real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
       eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
       eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
       wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);

real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;

real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
       Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
       aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
real*8 Er,pr,pr2,eta_pr;
real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
       eta_costp,Epp,pp_sintp,pp_sntp2;
real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
       eta_costm;
real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
       a,c,sindel,cosdel,sinpsi;

$INTEGER i;
$LOGICAL use_it;
$INTEGER iscore; " needed for BEAM "

$LOGICAL is_initialized;
data is_initialized/.false./;
save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
     eta_costm_array,ebin_array,wp_array,qmin_array,
     kmin,kmax,dlogki,alogkm,prmi,tiny_eta;

IF( ~is_initialized ) [
    is_initialized = .true.;
    tiny_eta = 1e-6;
    " Set current cross section value to -1 in each energy bin "
    DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
    " Find the maximum energy of the cross section data "
    kmax = 0; kmin = 4.1*prm;
    DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
    IF( kmax <= kmin ) return;
    dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
    alogkm = 1 - dlogki*log(kmin);
    prmi = 1/prm;
    DO i=1,$MAX_TRIPLET [
        k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
        qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
        qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
        qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
    ]
]

peig = e(np);
IF( peig <= 4*prm ) return;
$CHECK-STACK(np+2,'sample_triplet');

" Determine energy bin "
IF( peig <= kmin ) [ i = 1; ]
ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
ELSE [
    ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
    $RANDOMSET rnno;
    IF( rnno < ai ) [ i = i+1; ]
]

" First use the bin energy to sample the random numbers "
" that determine recoil momentum and electron/postron angles "
k = ebin_array(i);

/*
   In the following:  k is incident photon energy in units of m*c^2
                      (all energies are in units of m*c^2, momenta in
                       units of m*c)
                      Er,pr is energy, momentum of the recoil electron
                      Ep,pp is energy, momentum of the pair positron
                      Em,pm is energy, momentum of the pair electron
                      cost_p, sint_p is cos, sin of the positron angle
                                     with respect to k
                      cost_m, sint_m same but for the electron
                      cphi is cos of azimuthal angle between positron
                              and pair electron directions.
*/

:retry_triplet:;

" Pick the recoil electron momentum from 1/p.
$RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
pr = qmin_array(i)*exp(eta_pr*wp_array(i));
pr2 = pr*pr; Er = sqrt(1+pr2);

" Determine min./max. kinematically permitted postron energy for "
" this k and p "
aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

" Pick the positron energy "
$RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;

" Now we can determine the pair electron energy from energy conservation "
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

" The minimum cosine of the positron angle follows from the kinematics. "
mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);

" Now pick the positron direction from 1/(Ep-pp*cost_p) "
$RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
wmup = wmup*(cost_p - Epp);
sint_p = 1-cost_p*cost_p;
IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
k2p2x = k2p2 - 2*k*pp*cost_p;

" The minimum amd maximum cosine of the pair electron angle follows from "
" the kinematics "
b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;

" Now pick the electron direction from "
"  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
" We have to take into account the "
" 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
" otherwise we end up with 1/sqrt() singularities near the ends of the "
" allowed cost_m range                                                 "
$RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
cost_m = cost_m/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

" Now we have selected all independent kinematic variables. "
" Determine the azimuthal angle between the pair electrons "
cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

" And now evaluate the Borsellino cross section "
k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
aux4 = k3*Ep-k2*Em;
S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));

" We get the following factor due to the transformation from phi to "
" the recoil momentum pr "
cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);

" We have to also multiply by the various factors from the sampling of "
" pr, Ep, cost_p and cost_m "
sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
IF( sigma < 0 ) [
    $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
]

" Now determine if we accept this new event "
use_it = .true.;
IF( sigma < fmax_array(i) ) [
    $RANDOMSET rnno;
    IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
]
IF( use_it ) [       " Yes, event accepted "
    fmax_array(i) = sigma;
    eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
    eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
] ELSE [             " Nop, event rejected => use last accepted "
    eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
    eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
]

" We now have a set of random number accepted for sampling around "
" the i'th bin energy. We need to recalculate all variables using "
" the actual photon energy "

k = peig*prmi;
aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
qmin = 4*k/aux5; qmax = aux5/(2*k+1);
pr = qmin*exp(eta_pr*log(qmax/qmin));
pr2 = pr*pr; Er = sqrt(1+pr2);

aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
ELSE            [ pp_min = px2; pp_max = px1; ]
Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);

wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
Em = k + 1 - Er - Ep;
pm2 = Em*Em-1; pm = sqrt(pm2);

mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
sint_p = sqrt(1-cost_p*cost_p);
k2p2x = k2p2 - 2*k*pp*cost_p;

b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
D1 = pm2*(aux12+pp_sntp2)-b*b/4;
if( D1 <= 0 ) [ goto :retry_triplet:; ]
D = 2*pp_sintp*sqrt(D1);
aux3 = 0.5/(aux12+pp_sntp2);
xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
aux6 = sqrt((Em-xmin)/(Em-xmax));
aux7 = aux6*tan(1.570796326794897*eta_costm);
uu = (aux7-1)/(aux7+1);
cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;

cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
sphi = sqrt(1-cphi*cphi);

/*
   OK, now the final momenta are
     Positron:     (pp*sint_p,      0,             pp*cost_p)
     Electron:     (pm*sint_m*cphi,pm*sint_m*sphi, pm*cost_m)
 Recoil electron:  k - pp - pm
   This is in a frame where the photon is moving along the z axis.
   We have to pick another azimuthal angle randomly, rotate the
   x- and y- components of pp and pm by that, determine the recoil
   momentum from momentum conservation and then rotate all three
   momenta back into the lab frame.
*/
$RANDOMSET phi; phi = phi*6.283185307179586;
ppx = pp*sint_p; ppy = 0;
pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
cphi = cos(phi); sphi = sin(phi);
tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
ppz = pp*cost_p; pmz = pm*cost_m;
prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
" Set up particles on the stack ";
" We always put the recoil electron on top (even if its energy is higher "
" then the energies of the pair particles) because                       "
"   - that way, we know which particle is the recoil  electron in case   "
"     we want to score some quantity related to it                       "
"   - its energy is, on average, lower than the pair particle energies   "
NPold = np;
$TRANSFER PROPERTIES TO (np)   FROM (np);
$TRANSFER PROPERTIES TO (np+1) FROM (np);
$TRANSFER PROPERTIES TO (np+2) FROM (np+1);
pp = 1/pp; pm = 1/pm; pr = 1/pr;
a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
    IF( Ep > Em ) [
        u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
        v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
        w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
        v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
        w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
    v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
    w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
] ELSE [
    IF( Ep > Em ) [
        u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
        iq(np) = 1; E(np) = Ep*prm;
        u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
        iq(np+1) = -1; E(np+1) = Em*prm;
    ]
    ELSE [
        u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
        iq(np+1) = 1; E(np+1) = Ep*prm;
        u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
        iq(np) = -1; E(np) = Em*prm;
    ]
    np = np + 2;
    u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
    iq(np) = -1; E(np) = Er*prm;
]

return; end;

%E
"******************************************************************"
SUBROUTINE PHOTO;
"******************************************************************"
" Programmers:  I. Kawrakow, complete recoding,                    "
"                            Fluorescent X-rays, Auger,            "
"                            Coster-Kronig treated in RELAX        "
"               A.F. Bielajew (NRC) photoelectric angular distn    "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
/* $REAL ftot,iprob; */
data n_warning/0/;

IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
IF( peig < edge_energies(2,1) ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine PHOTO called with E = ',peig,
                   ' which is below the current min. energy of 1 keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

iZ = iedgfl(irl);
do_relax = .false.;
edep = pzero;
IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
                           " first sample the element "
    IF( nne(medium) = 1 ) [
        iZ = int( zelem(medium,1) + 0.5 );
        DO j=1,edge_number(iZ) [
            IF( peig >= edge_energies(j,iZ) ) EXIT;
        ]
    ]
    ELSE [
        aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
        sigtot = 0;
        DO k=1,nne(medium) [
            iZ = int( zelem(medium,k) + 0.5 );
            IF( iZ < 1 | iZ > $MXELEMENT ) [
                $egs_info(*,' Error in PHOTO: ');
                $egs_fatal(*,'   Atomic number of element ',k,
                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
            ]
            IF( peig > edge_energies(1,iZ) ) [
                j = 1;
                sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
                     edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
            ]
            ELSE [
                DO j=2,edge_number(iZ) [
                    IF( peig >= edge_energies(j,iZ) ) EXIT;
                ]
                sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
                        gle*edge_d(j,iZ) ));
                sigma = Exp(sigma);
            ]
            sigma = sigma * pz(medium,k);
            sigtot = sigtot + sigma;
            probs(k) = sigma;
            ints(k) = j;
        ]
        $RANDOMSET br; br = br*sigtot;
        DO k=1,nne(medium) [
            br = br - probs(k);
            IF( br <= 0 ) EXIT;
        ]
        iZ = int( zelem(medium,k) + 0.5 );
        j  = ints(k);
    ]
    " Now we know the atomic number (iZ) and the energy interval the "
    " photon energy is in (j). It is time to sample the shell the photon "
    " is interacting with. "
    " left for now as before, to be changed!!! "
    IF( peig <= binding_energies($MXSHELL,iZ) )
    [   "Outer shells, no atomic relaxation"
           "EADL relax: Below  M2-shell -> just emit e- "
           iq(np) = -1;
           e(np) = peig + prm;
    ]
    ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
        $RANDOMSET br; /* ftot = 1;  */
        DO k=1,$MXINTER [
            IF( peig > binding_energies(k,iZ) ) [
                IF( br < interaction_prob(k,iZ) ) EXIT;
                br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
            ]
        ]
        "Interaction possible with any shell from k=1 to $MXSHELL"
        "Defaults to $MXSHELL interaction if DO loop completes"
        "****************"
        "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
        "**************** from previous EGSnrc approach as it doesn't"
        "                 generate e- nor x-rays from <M> and <N> shells."
        IF (eadl_relax & k > 4)[
           "No initial vacancy below L3 for now, just emit e-"
           iq(np) = -1;
           e(np) = peig + prm;
        ]
        ELSE["EADL:    Interacts with K,L1..L3 shells"
             "default: Interacts with K,L1..L3,<M>, and <N> shells"
           e_vac = binding_energies(k,iZ);
           e(np) = peig - e_vac + prm; do_relax = .true.;
           iq(np) = -1;
        ]
    ]
]
ELSE [
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

"****************"
"EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
"**************** but vacancies below L3 deposit energy locally. It wont"
"                 produce x-rays from <M> and <N> shells."
"IF ($EADL_RELAX & k > 4)[
"   edep = e_vac; do_relax = .false.;
"]
IF( do_relax ) [
    call relax(e_vac,k,iZ);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

%E
"******************************************************************"
subroutine egs_shellwise_photo;
"******************************************************************"
" Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
" Shellwise implementation and      "
"                                sampling optimizations            "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-PHOTO; "default replacement is:
              "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
                  "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
;COMIN/PE-SHELL-DATA/;

$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
$DEFINE-LOCAL-VARIABLES-PHOTO;
$REAL slope, logE, int_prob;
$INTEGER zpos, ibsearch;
data n_warning/0/;

NPold = NP;      "Set the old stack counter"
PEIG=E(NP); irl = ir(np);
do_relax = .false.;
IF( peig < $RELAX-CUTOFF ) [
    IF( n_warning < 100 ) [
        n_warning = n_warning + 1;
        $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
                    peig,' which is below the current min. energy of ',
                   $RELAX-CUTOFF,' keV! ');
        $egs_info(*,' Converting now this photon to an electron, ');
        $egs_info(*,' but you should check your code! ');
    ]
    iq(np) = -1;
    e(np) = peig + prm;
    return;
]

edep = pzero;

IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
                        " sample element and atomic shell for"
   j = -1;              " the interaction."
   IF( nne(medium) = 1 ) [
    iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
    IF( pe_nshell(zpos) > 0) [
      logE = log(peig);
      j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
    ]
   ]
   ELSE [
      $RANDOMSET br; logE = log(peig);
      "DO k=1,nne(medium) ["
      DO k=nne(medium),1,-1 [
          iZ = int( zelem(medium,k) + 0.5 );zpos = pe_zpos(iZ);
          IF( iZ < 1 | iZ > $MXELEMENT ) [
              $egs_info(*,' Error in egs_shellwise_photo: ');
              $egs_fatal(*,'   Atomic number of element ',k,
                 ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
          ]
          j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
          slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
          slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
          int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
          br -= exp(int_prob);
          IF ( br <= 0 ) EXIT;
      ]
   ]
   " Now we know the atomic number (iZ) and the energy interval the "
   " photon energy is in (j). It is time to sample the shell the photon "
   " is interacting with. "
   IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
   [   "no atomic relaxation, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
   ]
   ELSE ["sample the shell the photon is interacting with"
      $RANDOMSET br; sigtot = 0;
      DO k=1,pe_nshell(zpos) [
          IF( peig > pe_be(zpos,k) ) [
            slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
            slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
            int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
            br -= exp(int_prob); sigtot += exp(int_prob);
            IF ( br <= 0 ) EXIT;
          ]
      ]
      IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
         iq(np) = -1;
         e(np) = peig + prm;
      ]
      ELSE[
         e_vac = pe_be(zpos,k);
         e(np) = peig - e_vac + prm; do_relax = .true.;
         iq(np) = -1;
      ]
   ]
]
ELSE ["No atomic relaxations, just create photo-electron"
    e(np) = peig + prm; iq(np) = -1;
]

IF( iq(np) = -1 ) [
    $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
]

IF( do_relax ) [
    call egs_eadl_relax(iZ,k);
]

IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"

;
$PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"

return;
end;

"*************************************************************************"
subroutine egs_read_shellwise_pe;
"*************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-SHELLWISE-PE-INIT;

$INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,l,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
$REAL      rest_xs($MXNE,$MXELEMENT);
$REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
$REAL      new_e($MXNE),deltaEb,slope;
$INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
character  data_dir*128,pe_sw_file*144;

$INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
real*4    egs_read_real,e_r, e_old,sigma_r;
integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
$LOGICAL  is_open, is_there, shift_required;

character*3 labels(16);
data labels/'  K',' L1',' L2',' L3',
            ' M1',' M2',' M3',' M4',' M5',
            ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;

/*********************************************
   Open PE shellwise data file photo_shellwise.data
 **********************************************/
$egs_info('(/a$)',
' Reading renormalized photoelectric cross sections ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';

/* Open a fortran unit for reading data */
pe_sw_unit = egs_get_unit(0);
IF( pe_sw_unit < 1 ) [
  $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
]
open(pe_sw_unit,file=pe_sw_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=1,
     err=:no-pe-sw-file:);
GOTO :read-pe-sw:;
:no-pe-sw-file:
$egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
           pe_sw_file);
:read-pe-sw:
is_open = .true.;
/******************************
   Array initialization
 ******************************/
DO medio = 1,nmed [
   DO i=1,nne(medio) [
      pe_nshell(i*medio) = 0;
      pe_nge(i*medio) = 0;
      pe_zsorted(i,medio) = 0;
   ]
]
DO l = 1,$MXELEMENT [
   pe_zpos(l) = -1;
   DO k = 1,$MXNE [
      pe_energy(k,l) = 0.0;
      DO m = 1,$MXPESHELL [
         pe_xsection(k,l,m) = 0.0;
      ]
   ]
   DO k = 1,$MXPESHELL [
      pe_be(l,k) = -99;
   ]
]

/******************************
   Get shellwise PE xsections
 ******************************/
curr_rec = 1; iZpos = 0;
nz = egs_read_short(pe_sw_unit,curr_rec);
"$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,medio-1 [
         DO k = 1, nne(j)[
           IF( iZ = pe_zsorted(k,j) ) [
               is_there = .true.; EXIT;
           ]
         ]
      ]
      IF (is_there) NEXT;
      "Read data for this element"
      iZpos += 1; zread(iZpos) = iZ;
      pe_zpos(iZ) = iZpos;
      pos         = 3 + (iZ-1)*4;
      curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
      i_nge       = egs_read_short(pe_sw_unit,curr_rec);
      i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
      "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
      "  ' energy points and ',i_nshell,' shells');
      pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
      e_old = -1.0; ish = 0;
      DO j = 1,i_nge[
         e_r = egs_read_real(pe_sw_unit,curr_rec);
         sigma_r = egs_read_real(pe_sw_unit,curr_rec);
         pe_energy(j,iZpos) = e_r;
         pe_xsection(j,iZpos,0) = sigma_r;
         rest_xs(j,iZpos) = sigma_r;
         DO k = 1, i_nshell[
            sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
            pe_xsection(j,iZpos,k) = sigma_r;
            rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;

         ]
         "Extract binding energies from the data base"
         IF (e_r - e_old < 1e-15)[
            pe_be(iZpos,i_nshell-ish) = e_r;
            ish += 1;
         ]
         e_old = e_r;

      ]
      "DO k = 1, i_nshell[
      "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
      "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
      "]

   ]
]
pe_ne = iZpos;
"$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');

/*********************************************
 Adjust xsections to current binding energies
 Shift energy scale for each subshell when
 required.
 *********************************************/
"$egs_info(*,' Adjusting cross sections to new binding energies ...');
DO i=1,pe_ne[
   iZ = zread(i);
   IF (pe_nshell(i) = 0)[
      DO j=1,pe_nge(i)[
         pe_energy(j,i) =  log(pe_energy(j,i));
      ]
      NEXT;
   ]
   "Shift energy scale for different binding energy sets"
   DO l=1,pe_nshell(i)[
      IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
           shift_required = .true.;
           deltaEb = binding_energies(l,iZ)-pe_be(i,l);
           "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
           "           'Eb_p_',labels(l),' = ',pe_be(i,l),
           "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
           "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
           "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
           "          );
      ]
      ELSE[shift_required =.false.;]
      is_there = .false.;
      DO j=1,pe_nge(i)[
         tmp_e(j,l)  = pe_energy(j,i);
         tmp_xs(j,l) = pe_xsection(j,i,l);
         IF ( shift_required &
              pe_energy(j,i) => pe_be(i,l) )[
            tmp_e(j,l) += deltaEb;
            "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
            "Determine edge position in energy array"
            IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               ib(l) = j; is_there = .true.;
            ]
            "Update new energy grid"
            IF (l = 1)[
               new_e(j) = tmp_e(j,l);
            ]
            "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
            ELSE IF(j < ib(l-1))[
               new_e(j) = tmp_e(j,l);
            ]
         ]
      ]
      pe_be(i,l) = binding_energies(l,iZ);
   ]
   "Re-compute sub-shell xsections for new energy grid new_e"
   "Not needed for K shell"
   DO l=2,pe_nshell(i)[
      DO j=1,pe_nge(i)[
         IF ( new_e(j) >= pe_be(i,l-1) )[
            m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
            slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
            slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
            pe_xsection(j,i,l) = log(tmp_xs(m,l));
            pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
            pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
         ]
      ]
   ]
   "Re-compute total xsections for new energy grid new_e"
   "$egs_info(*,'-> Z = ',iZ);"
   DO j=1,pe_nge(i)[
      IF ( j < ib(pe_nshell(i)))[
         new_e(j) = pe_energy(j,i);
      ]
      m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
      slope = log(rest_xs(m+1,i)/rest_xs(m,i));
      slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
      pe_xsection(j,i,0)  = log(rest_xs(m,i));
      pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
      pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,0) += pe_xsection(j,i,l);
      ]
      "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
      "         new_e(j),pe_xsection(j,i,0));
   ]
   "Normalize shell cross sections to total for sampling"
   "and update energy grid of ith element."
   " Prepare for log/log interpolation."
   DO j=1,pe_nge(i)[
      pe_energy(j,i) =  log(new_e(j));
      DO l=1,pe_nshell(i)[
         pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
      ]
   ]
]

$egs_info('(a/)',' done');

IF( is_open ) close(pe_sw_unit);
return;
end;


"******************************************************************"
SUBROUTINE RELAX(energy,n,iZ);
"******************************************************************"
" Subroutine to fill a vacancy in shell n, element iZ              "
" by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
" Transitions between K,L1,L2,L3,average M,average N are taken into"
" account. Particles with energies above the transport cut-offs    "
" (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
" particles is stored in EDEP.                                     "
" In this version a global cut-off of 1 keV applies                "
"  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
"  1 keV will still be absorbed locally (due to lack of data)      "
"                                                                  "
" Version 1:  I. Kawrakow, December 1998                           "
"******************************************************************"
implicit none;

" Input variables "
"================="
$INTEGER n,iZ;
$REAL    energy;  "

$declare_write_buffer;

" Local variables "
"================="
REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
                            "relaxation cascade                    "

$INTEGER vac_array($MXVAC), "array with shell vacancies            "
         n_vac,             "current number of vacancies           "
         shell;             "current shell                         "
$INTEGER final,finala,      "code of final state                   "
         final1,final2,     "two vacancies in the final state in   "
                            "the case of Auger transitions         "
         iql,               "particle charge                       "
         irl;               "present region"
$INTEGER first_transition($MXINTER),
         last_transition($MXINTER);
                            "first and last transition for a given "
                            "shell in the list of all possible     "
                            "transitions                           "
$INTEGER final_state($MXTRANS);
           " final_state(i) is the final atomic state                "
           " after transition i coded as follows:                    "
           "   * fluorescence - final_state is the shell number      "
           "                    of the new vacancy                   "
           "   * Coster-Kronig - final_state is the shell number     "
           "                     of the new vacancy + 10             "
           "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
           "             are the shell numbers of the 2 new vacancies"

$INTEGER k, np_old, ip, iarg;
$REAL    e_array($MXVAC),   "array with vacancy energies           "
         Ei,Ef,             "initial,final binding energies        "
         Ex,                "kinetic energy of emitted particle    "
         eta,               "a random number                       "
         e_check,           "energy conservation check             "
         min_E,ekcut,pkcut,elcut; "cut-off energies  "

$REAL    xphi,yphi,xphi2,yphi2,rhophi2,
         cphi,sphi;         "for azimuthal angle selection"

" Global EGS4 variables "
"======================="
$COMIN-RELAX;
;COMIN/RELAX-USER/;

data first_transition/1,20,27,33,38/;
data last_transition/19,26,32,37,39/;
data final_state/ "See the final_state definition above"
         4,3,5,6,                           " K-shell fluorescence    "
         202,302,402,404,403,303,           " K-shell Auger           "
         502,503,504,602,603,604,           " K-shell Auger           "
         505,605,606,                       " K-shell Auger           "
         13,14,                             " L1 Coster-Kronig        "
         5,6,                               " L1 fluorescence         "
         505,605,606,                       " L1 Auger                "
         14,                                " L2 Coster-Kronig        "
         5,6,                               " L2 fluorescence         "
         505,605,606,                       " L2 Auger                "
         5,6,                               " L3 fluorescence         "
         505,605,606,                       " L3 Auger                "
         6,                                 " M  fluorescence         "
         606/;                              " M  Auger                "

save first_transition,last_transition,final_state; "to avoid problems with "
                                                   "non-static compiler options"

IF (eadl_relax)[
   call egs_eadl_relax(iZ,n);
   return;
]

IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"

iz_relax = iZ;
irl = ir(np);
ekcut = ecut(irl)-rm; pkcut = pcut(irl);
min_E = $RELAX-CUTOFF;

IF( energy <= min_E ) [
    edep = edep + energy;  "We assume that edep is zeroed "
                        "(or set to the appropriate value) in the routine "
                        "calling RELAX "
    edep_local = energy;

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return;
]

" Set-up the array of vacancies for the relaxation cascade "
n_vac = 1; vac_array(n_vac) = n; np_old = np;
e_check = 0; e_array(n_vac) = energy;

:START: LOOP[     "Until no  >N-shell vacancies"

    shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;

    IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
        edep = edep + Ei;

        edep_local = Ei;

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]

    "Set the relax_user common block variables, IK March 22 2004"
    ish_relax = shell; u_relax = Ei;
    IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
        IF( Ei > ekcut ) [
            np = np + 1;
            $CHECK-STACK(np,'RELAX');
            e(np) = Ei + prm; iq(np) = -1;
            $TRANSFER PROPERTIES TO (np) FROM (np-1);
            $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
            eta = (1-eta)*(1+eta);
            IF( eta > 1e-20 ) [
                eta = Sqrt(eta);
                $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                u(np) = eta*cphi; v(np) = eta*sphi;
            ]
            ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            $AUSCALL($AUGERTRA);
        ]
        ELSE             [
            edep = edep + Ei;

            edep_local = Ei;
            $AUSCALL($SELECTRONA);
        ]
        IF( n_vac > 0 ) goto :START: ;
        EXIT;
    ]
    " Sample transition number for this vacancy "
    $RANDOMSET eta;
    DO k=first_transition(shell),last_transition(shell)-1 [
        eta = eta - relaxation_prob(k,iZ);
        IF( eta <= 0 ) EXIT;
    ]
    final = final_state(k); finala = final;
    IF( final < 100 ) [
        IF( final < 10 ) [ "fuorescence"
            iql = 0; elcut = pkcut;
        ]
        ELSE             [ "Coster-Kronig"
            final = final - 10;
            iql = -1; elcut = ekcut;
        ]
        Ef = binding_energies(final,iZ);
        Ex = Ei - Ef;
        n_vac = n_vac + 1;
        vac_array(n_vac) = final;
        e_array(n_vac) = Ef
    ]
    ELSE [  "Auger"
        final1 = final/100; final2 = final - final1*100;
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final1;
        e_array(n_vac) = binding_energies(final1,iZ);
        n_vac  = n_vac + 1;
        vac_array(n_vac) = final2;
        e_array(n_vac) = binding_energies(final2,iZ);
        iql = -1;
        Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
        elcut = ekcut;
    ]
    IF( Ex <= elcut ) [ "Below cut-off"
        edep = edep + Ex;

        IF( finala <  10 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ]
        ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ]
    ELSE [
        np = np + 1;
        $CHECK-STACK(np,'RELAX');
        iq(np) = iql;
        IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
        $TRANSFER PROPERTIES TO (np) FROM (np-1);
        $RANDOMSET eta;
        eta = 2*eta - 1;
        w(np) = eta;
        eta = (1-eta)*(1+eta);
        IF( eta > 1e-20 ) [
            eta = Sqrt(eta);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = eta*cphi;
            v(np) = eta*sphi;
        ]
        ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
        IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
        ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
        ELSE                    [ $AUSCALL($AUGERTRA);  ]
    ]
]

return;
end;

"*************************************************************************"
subroutine egs_init_relax;
"*************************************************************************"
" Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
" data base was originally created by I. Kawrakow to be used with C++ user"
" codes. It has been re-created using 4 bytes integers instead of using   "
" optimized integer sizes to save space. It is now about 34% larger (760K)"
" than before (557K). Reason for this was that some compilers need a switch"
" to get it to read binary files on byte at a time. This would have been a"
" nuisance for users when configuring the already complex system.         "
"                                                                        "
" The final relaxation state from radiative transitions assumes C-style  "
" array indexing and hence needs to be increased by 1.                   "
" Similarly, for non-radiative transitions, there is need to increase the"
" codified value of the two electron states by 65. The reason is that the"
" two transition states are encoded as 64*state1+state2. Because of the C"
" style indexing, state1 and state2 must be increased by 1, increasing the"
" above codified value by 65.                                            "
"                                                                        "
"Shell information for all media elements stored in one-dimensional arrays:"
"                                                                        "
" ish              => absolute shell index (1...shell_ntot)              "
" shell_be(ish)    => shell binding energy                               "
" shell_type(ish)  => shell type according to EADL notation              "
" shell_Z(ish)     => Z of shell element                                 "
" shell_num(ish)   =>  relative shell position within one element        "
" shell_ntot       => total number of shells for all media elements      "
" relax_first(ish) => initial absolute relaxation position               "
" relax_ntran(ish) => number of transitions                              "
" shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
"                                                                        "
"Transition information for all shells also stored in one-dimensional arrays:"
"                                                                         "
" transition index itran runs from 1...relax_ntot                         "
" relax_prob(itran)  => transition probabilities                          "
" relax_atbin(itran) => holds the alias indices                           "
" relax_state(itran) => final relaxation state:                           "
"                       radiative: relative shell position                "
"                   non-radiative: relative position of shells(64*sh1+sh2)"
"                                                                         "
"                              Originally coded by IK in a standalone code"
"                          Modified for use with EGSnrc by EMH, June 2011 "
"                          Corrected bugs and commented by EMH, April 2012"
"*************************************************************************"
$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-INIT;

$INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
$INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
$REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
character  data_dir*128,relax_file*144;

$INTEGER  ish,medio,iZ,ntran;
$REAL     Ec, Pc, tmp, min_be, sumw,Ex;
$LOGICAL  is_open, is_there;
$REAL     wtmp($MAXTRANS);
$INTEGER  itmp($MAXTRANS);

integer*4 pos, curr_rec, sh_eadl;
integer*4 nz, nshell, tr_type;
integer*4 ttype;
real*4    be_r, prob_r;


DO iZ=1,$MXELEMENT[
 DO k=1,$MXESHLL[
   shell_eadl(iZ,k) = -1;
 ]
]

/*********************************************
   Determine minimum energy
 **********************************************/
/*Pc = 1e30; Ec = 1e30;
DO medio = 1,nmed [
    tmp = AE(medio) - rm; Ec = min(Ec,tmp); Pc = min(Pc,ap(medio));
]
min_be = min(Ec,Pc);  "This is the minimum binding energy for which we need"
                      "relaxation data"
*/
min_be = $RELAX-CUTOFF;
$egs_debug('(a)',' ************ relax_init **************** ');
$egs_debug('(a,f10.7)',
        ' Minimum binding energy requiring relaxation data: ',min_be);

/*********************************************
   Open EADL relaxation data file relax.data
 **********************************************/
$egs_info('(/a)',' Reading EADL relaxation data ......');
data_dir = $cstring(hen_house) // 'data' // $file_sep;
relax_file = $cstring(data_dir) // 'relax.data';

/* Open a fortran unit for reading relaxation data */
relax_unit = egs_get_unit(0);
IF( relax_unit < 1 ) [
   $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
]
open(relax_unit,file=relax_file,status='old',
     form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
     err=:no-relax-file:);
GOTO :read-relax:;
:no-relax-file:
$egs_fatal('(2a)','egs_init_relax: failed to open ',
           relax_file);
:read-relax:
is_open = .true.;
/*********************************************
   Get EADL relaxation data from relax.data
 **********************************************/
curr_rec = 1;
read(relax_unit,rec=curr_rec) nz;
"$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
shell_ntot = 0;relax_ntot = 0;
DO medio = 1,nmed [
   DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
   call egs_heap_sort(nne(medio),z_sorted,sorted);
   DO i=1,nne(medio) [
      iZ = z_sorted(i);
      "Now check whether we have already loaded the data for"
      "this atomic number"
      is_there = .false.;
      DO j = 1,shell_ntot [
         IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
      ]
      IF (is_there) NEXT;
      pos = iZ + 1;
      read(relax_unit,rec=pos) curr_rec;
      read(relax_unit,rec=curr_rec) nshell;
      IF( shell_ntot + nshell > $MAXSHELL ) [
         $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
                shell_ntot + nshell,' (at least).',
                ' Increase the parameter $MAXSHELL and retry ');
      ]
      $egs_info('(a,i3,a,i2,a)',
      '  Z = ',iZ,' has ',nshell,' shells');
      DO ish=shell_ntot+1,shell_ntot+nshell[
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) shell_type(ish);
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) ntran;
        curr_rec  = curr_rec+1;
        read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;

        shell_Z(ish) = iZ;
        shell_num(ish) = ish - shell_ntot;
        shell_eadl(iZ,shell_num(ish)) = ish;
        IF (binding_energies(shell_num(ish),iZ) > 0)[
           shell_be(ish) = binding_energies(shell_num(ish),iZ);
        ]
        ELSE IF( photon_xsections = 'epdl' )[
          "Use binding energies from relax.data below 1 keV"
           binding_energies(shell_num(ish),iZ) = shell_be(ish);
        ]
        DO k=1,ntran[
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) itmp(k);
            curr_rec  = curr_rec+1;
            read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
            /*Relaxation data uses C-style array indexing.
              Hence final relaxation state increased by 1  for
              radiative and by 65 for non-radiative transitions*/
            IF (itmp(k)<64) [itmp(k) +=1;]
            ELSE            [itmp(k) += 65;]
        ]
        IF( shell_be(ish) < min_be ) [
            relax_first(ish) = -1;
            relax_ntran(ish) = -1;
        ]
        ELSE [
            sumw = 0;
            DO k=1,ntran [  sumw = sumw + wtmp(k); ]
            IF( sumw > 1 ) [
                DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
            ]
            ELSE IF( sumw < 1 ) [
                ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
            ]
            IF( relax_ntot + ntran > $MAXRELAX ) [
               $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
                 relax_ntot + ntran,' (at least).',
                 ' Increase $MAXRELAX and retry ');
            ]
            relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
            call prepare_alias_histogram(ntran,wtmp,
                                 relax_atbin(relax_ntot+1));
            DO k=1,ntran [
               j = relax_ntot + k;
               relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
            ]
            relax_ntot = relax_ntot + ntran;
        ]
      ]

      shell_ntot = shell_ntot + nshell;

   ]

]
$egs_debug('(a,i4,a)',' There are ',
        shell_ntot,' shells in the list of shells ');
$egs_info('(a/)',' ...... Done.');
/***********************************************/

IF( is_open ) close(relax_unit);
return;

stop;
end;

"Macro to check that the stack size is not exceeded"
REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
  IF( {P1} > $MXSTACK ) [
      $egs_warning('(3(a,f10.6),a,i2)',
       'Evac = ',Evac, ' Ef = ',Ef,
       "' Z = ',iZ,' Nvac = ',Nvac,"
       ' min_E = ', min_E,' iq = ',iqf);
;  "---------- BUFFER FLUSH SEMICOLON ----------"
      $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
          ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
          ' Increase $MXSTACK and try again ');
  ]
};

"***********************************************************************"
  subroutine egs_eadl_relax(iZ, shell_egs);
"************************************************************************"
" Subroutine, called from subroutine relax, to fill a vacancy in         "
" shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
" and Coster-Kronig electrons.  Uses EADL data.                          "
" Results passed via variables in comins.                                "
"   edep                                                                 "
"   edep_local                                                           "
"   e(np)                                                                "
"                                                                        "
" There are calls to ausgab with IARG values                             "
"   24  A fluorescent transition just occurred                           "
"   26  An Auger transition just occurred                                "
"   32  Sub-threshold fluorescent transition just occurred               "
"   33  Sub-threshold Auger transition just occurred                     "
"                                                                        "
" There is an inconsistency in the binding energies (BE) as COMPT uses   "
" different BE (incoh.data)                                              "
"                                                                        "
" Explain need to reduce new_state by 1 below as alias sampling provides "
" bin number from 1...nbin and not 0...nbin-1                            "
"                                                                        "
"                             Originally coded by IK in a standalone code"
"                         Modified for use with EGSnrc by EMH, June 2011 "
"                         Corrected bugs and commented by EMH, April 2012"
"************************************************************************"

$IMPLICIT-NONE;

$declare_max_medium;
$COMIN-RELAX-EADL;
;COMIN/RELAX-USER/;

$REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
         cost,sint,cphi,sphi;
"Ec      ecut as k.e. for current region"
"Pc      pcut for current region"
"min_E   the minimum energy for transitions to continue"
"rnno    a random number"
"Evac    binding energy of current vacancy"
"Ef      the sum of the binding energies of the new vacancies"
"Ef1     the first new binding energy of for non-radiative transitions"
"Ef2     the second new binding energy of for non-radiative transitions"
"Ex      the change in total binding energy"
"Ecc     the cutoff energy (Ec or Pc)"
"cost,sint,cphi,sphi variables for calculating particle direction"

$INTEGER  shell, shell_egs, iZ, iarg;
"shell       number in master eadl list"
"shell_egs   shell number in current element"
"iZ          atomic number of element"

$INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
"irl           current region"
"vacs($MAXVAC) array of vacancy shell numbers"
"nvac          current number of vacancies in vacs"
"vac           shell number of current vacancy"
"new_state     the state number that represents the new vacancy"
"iqf           the charge of the emitted relaxation particle"
"np_save       the stack index of the particle inducing in relaxations"
"new1          the first new vacancy for non-radiative transitions"
"new2          the second new vacancy for non-radiative transitions"

$INTEGER sample_alias_histogram;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

shell = shell_eadl(iZ,shell_egs);
IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"

irl = ir(np);
Ec = ecut(irl) - rm;
Pc = pcut(irl);
min_E = $RELAX-CUTOFF;

Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
"store some information in comin RELAX-FOR-USER.  This just duplicates"
"various pieces of info so the user can access them."
rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
"
"Local energy deposition for vacancies below L3 shell."
"Added here for consistency in algorithm for as long as"
"<M> and <N> shells considered instead of proper shells."
"AUSGAB call should be updated when charge of particle"
"creating vacancy becomes available."
IF (shell_egs > 4 & ~mcdf_pe_xsections) [
    edep = Evac;        "add energy of vacancy to edep"
    edep_local = Evac;  "set value of edep_local to energy of vacancy"

    "Assign this energy deposition to an electron."
    "Note that this should NOT be treated as though it came from a photon,"
    "even if a photon initiated the relaxations. Rather, energy remaining"
    "in vacancies should be given to an electron or absorbed locally."
    $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

    return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
]

vac = shell; Nvac = 0; np_save = np;
LOOP [ "from here to end of routine over all vacancies created"

    "check if energy of vacancy < cutoff OR no transitions from this shell"
    IF( Evac < min_E | relax_ntran(vac) < 1 ) [
        edep += Evac;         "add energy of vacancy to edep"
        edep_local = Evac;    "set value of edep_local to energy of vacancy"

        "Assign this energy deposition to an electron."
        "Note that this should NOT be treated as though it came from a photon,"
        "even if a photon initiated the relaxations. Rather, energy remaining"
        "in vacancies should be given to an electron or absorbed locally."
        $AUSCALL($SELECTRONA); "call ausgab with iarg=34"

        go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
    ]

    "prepare_alias_histogram is called from subroutine egs_init_relax and"
    "sample_alias_histogram uses the array of bin probabilities and bin"
    "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
    "to return the bin which has been sampled, i.e. new_state"
    "relax_ntran(vac) tells how many transitions are available"
    new_state = sample_alias_histogram(relax_ntran(vac),
                  relax_prob(relax_first(vac)),
                  relax_atbin(relax_first(vac)));
    IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
                          "EADL was < 1. In this case the entire energy is"
                          "given to an electron and no new vacancy is created"
        Ef = 0;
        iqf = -1;
        Ecc = Ec;
    ]
    ELSE[
        new_state = relax_state(relax_first(vac)+new_state-1);
     IF( new_state <= 64 ) [ "It was a radiative transition, i.e. fluorescence"
        iqf = 0;
        new_state += vac - shell_num(vac);
        Ef = shell_be(new_state);
        Nvac += 1;
        vacs(Nvac) = new_state;
        Ecc = Pc;
     ] "end of fluorescence block"

     ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
        iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
        new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
        Ef1 = shell_be(new1); Ef2 = shell_be(new2);
        Nvac += 1; vacs(Nvac) = new1;
        Nvac += 1; vacs(Nvac) = new2;
        Ef = Ef1 + Ef2; Ecc = Ec;
     ] "end Auger or Coster-Kronig block"
    ]
    Ex = Evac - Ef;
    edep_local = 0;
    IF( Ex > Ecc ) [
        np += 1; $CHECK-RELAX-STACK(np,'new_relax');
        iq(np) = iqf;
        $TRANSFER PROPERTIES TO (np) FROM (np_save);
        $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
        IF( sint > 0 ) [
            sint = sqrt(sint);
            $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
            u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
        rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
        rfu_E = shell_be(vac);
        IF( iqf = 0 ) [
            e(np) = Ex; $AUSCALL($FLUORTRA);
        ]
        ELSE [
            e(np) = Ex + rm; $AUSCALL($AUGERTRA);
        ]
    ] ELSE [ "Ex <= Ecc"
        edep += Ex;

        IF( iqf = 0 ) [
            edep_local = Ex;
            $AUSCALL($SPHOTONA);
        ] ELSE [
            edep_local = Ex;
            $AUSCALL($SELECTRONA);
        ]
    ] "end Ex <= Ecc block"
    :VACANCY:;
    IF( Nvac = 0 ) EXIT;
    "get next vacancy to process"
    vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
] "end of main loop"
return;
end;
;

"***************************************************************************"
"     Triplet production stuff                                              "
"***************************************************************************"

REPLACE {$N_TRIPLET_DATA} WITH {55}
REPLACE {$N_ELEMENT} WITH {100}
;
subroutine init_triplet;
implicit none;
$declare_max_medium;
$COMIN-INIT-TRIPLET;
$REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
       sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
       sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
       as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
       ds($N_TRIPLET_DATA);
character*128  triplet_data_file;
$INTEGER want_triplet_unit, triplet_unit, triplet_out;
$INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
$REAL    logE, f_new, f_old, spline;

IF( itriplet = 0 ) return;
$set_string(triplet_data_file,' ');
triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
                    'triplet.data';
want_triplet_unit = 63;
triplet_unit = egs_get_unit(want_triplet_unit);
IF( triplet_unit < 1 ) [
    $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
]
open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
$egs_info('(a,$)',' init_triplet: reading triplet data ... ');
read(triplet_unit,*) ntrip;
IF( ntrip > $N_TRIPLET_DATA ) [
    $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
]
read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
DO iel=1,$N_ELEMENT [
    read(triplet_unit,*);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_pair(iel,i),i=1,ntrip);
    read(triplet_unit,*,err=:error_triplet_data:)
        (sig_triplet(iel,i),i=1,ntrip);
]
$egs_info(*,'OK');
ifirst = 0;
DO i=1,ntrip [
    IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
    energies(i) = log(energies(i));
]
log_4rm = log(4*rm);
energies(ifirst-1) = log_4rm;
dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
dli_triplet = 1/dl_triplet;
bli_triplet = 1 - log_4rm/dl_triplet;

DO imed = 1, nmed [

    $egs_info('(a,i3,a,$)',
      '   Preparing triplet fraction data for medium ',imed,' ... ');
    iz1 = zelem(imed,1) + 0.1;
    DO i=1,ntrip [
        sigp(i) = pz(imed,1)*sig_pair(iz1,i);
        sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
        DO iel=2,nne(imed) [
            izi = zelem(imed,iel) + 0.1;
            sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
            sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
        ]
    ]

    DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
    f_triplet(1) = 0;
    call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);

    logE = log_4rm; f_old = 0;
    DO i=1, $MAX_TRIPLET-1 [
        logE = logE + dl_triplet;
        f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
        a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
        b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
        f_old = f_new;
    ]
    $egs_info(*,'OK');

]
close(triplet_unit);
return;

:no-triplet-file:;
$egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
             triplet_data_file(:lnblnk1(triplet_data_file)));

:error_triplet_data:;
$egs_fatal(*,' init_triplet: error while reading triplet data ');

return; end;

%E
"******************************************************************"
SUBROUTINE EDGSET(NREGLO,NREGHI);
"******************************************************************"
" SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
" and proper handling of photo-electric absorption
"******************************************************************"
" Programmer:   I. Kawrakow, (NRC)                                 "
"******************************************************************"
"                                                                  "
"  Input:  NREGLO and NREGHI, not needed but left there for        "
"                             compatibility with older user codes  "
"
"  This routine is called from HATCH, it checks whether one of the "
"  elements of IEDGFL has been set to an integer number between    "
"  1 and 100 and if so reads in photo-absorption and relaxation    "
"  data. Note that the array IEDGFL, which used to be the          "
"  `effecvtive' atomic number of a medium is not used for any      "
"  purpose other than to indicate that relaxations are requested   "
"  (if non-zero).
"******************************************************************"
"                                                                  "

$IMPLICIT-NONE;

;COMIN/EDGE,X-OPTIONS,EGS-IO/;

"Input variables"
integer  NREGLO,NREGHI;

$INTEGER i,j,k,jj,iz;
logical  do_relax;
logical  got_data;
save     got_data;
data     got_data/.false./;

IF( got_data ) return;
   "EDGSET is now called from HATCH. In older user codes it was called
   "from within the user code. If this happens, and the data is already
   "available, we don't need to read it again. That's why the above
   "statement.

$egs_info('(a/,a)',
          'Output from subroutine EDGSET:',
          '==============================');

$need_relaxation_data(do_relax);
IF( ~do_relax ) [

    IF(eadl_relax)[
        $egs_fatal('(a,/a)',
                   'You must turn ON atomic relaxations when requesting',
                   'detailed atomic relaxation (eadl_relax=true)!');
    ]
    $egs_info('(a/)',' Atomic relaxations not requested! ');
    return;
]

$egs_info('(a/)',' Atomic relaxations requested! ');

$egs_info('(a$)',' Reading simplified photo-absorption data .....');

got_data = .true.;
rewind($PHOTOUNIT);

DO i=1,$MXELEMENT
[
    IF (eadl_relax)[
       "Skip, using binding_energies from *_photo.data file
       read($PHOTOUNIT,*);
    ]
    ELSE[
       read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
       DO k=1,$MXSHELL [
          binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
       ]
    ]
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT
[
    read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
    interaction_prob($MXSHELL,i)=1.01;
]
$egs_info('(a)',' Done');

$egs_info('(/a$)',' Reading simplified relaxation data .....');
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
]
read($PHOTOUNIT,*);
DO i=1,$MXELEMENT [
        read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
]
$egs_info('(a)',' Done');
$egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
rewind($PHOCSUNIT);
DO i=1,$MXELEMENT [
    read($PHOCSUNIT,*) j,edge_number(i);
    DO j=1,edge_number(i) [
        read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
                           edge_d(j,i),edge_energies(j,i);
    ]
]
$egs_info('(a)',' Done');

IF (eadl_relax)[
 call egs_init_relax;
]

RETURN;
END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE PHOTON(IRCODE);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$INTEGER IRCODE; "1 => normal return"

$COMIN-PHOTON;   "default replacement produces the following:
                 "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
                 "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"

$DEFINE-LOCAL-VARIABLES-PHOTON;


IRCODE=1;"set up normal return"
PEIG=E(NP);
EIG=PEIG; "energy of incident gamma"
IRL=IR(NP);
$start_new_particle;

IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

:PNEWENERGY:
LOOP["enter this loop for each photon with new energy"

IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"

GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"

"   here to sample no. mfp to transport before interacting"

$SELECT-PHOTON-MFP;
" DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
"                                      DPMFP=-LOG(RNNO35);"
"NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
"       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."

IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"

:PNEWMEDIUM:
LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
$EVALUATE GMFPR0 USING GMFP(GLE);]

:PTRANS:
LOOP["PHOTON TRANSPORT LOOP"
IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
GMFP=GMFPR0/RHOF;
$RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
"Ali:photonuc, 1 line"
$PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
TSTEP=GMFP*DPMFP;]
"   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
IDISC=0;"ASSUME PHOTON NOT DISCARDED"
USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
TUSTEP=USTEP;

"IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
$CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"


"   NOW CHECK FOR USER DISCARD REQUEST"
IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
GO TO :USER-PHOTON-DISCARD:;]

VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
TVSTEP=VSTEP;
EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"

x_final = x(np) + u(np)*vstep;
y_final = y(np) + v(np)*vstep;
z_final = z(np) + w(np)*vstep;

$AUSCALL($TRANAUSB);

"   TRANSPORT THE PHOTON"
x(np) = x_final; y(np) = y_final; z(np) = z_final;
DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
IROLD=IR(NP); "SAVE PREVIOUS REGION"

MEDOLD=MEDIUM;
IF (IRNEW.NE.IROLD) ["REGION CHANGE"
  $photon_region_change;
]

"   AFTER TRANSPORT CALL TO USER"
$AUSCALL($TRANAUSA);
"oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]

"   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
"   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;

IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;

IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
EXIT :PNEWMEDIUM:;]
]REPEAT ":PTRANS: LOOP"

]REPEAT ":PNEWMEDIUM: LOOP"


"   IT IS FINALLY TIME TO INTERACT."
"   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
$RAYLEIGH-SCATTERING;
"Ali:photonuclear, 1 line"
$PHOTONUCLEAR;
$RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
"   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
$EVALUATE GBR1 USING GBR1(GLE);
IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
    $AUSCALL($PAIRAUSB);
    CALL PAIR;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PAIR;
    $AUSCALL($PAIRAUSA);
    IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
    ELSE [ "this may happen if pair electrons killed via Russian Roulette"
        goto :PAIR-ELECTRONS-KILLED:;
    ]
]
"GBR2=(PAIR+COMPTON)/GTOTAL"
$EVALUATE GBR2 USING GBR2(GLE);
IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
    $AUSCALL($COMPAUSB);
    CALL COMPT;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-COMPT;
    $AUSCALL($COMPAUSA);
    IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
]
ELSE["IT WAS PHOTOELECTRIC EFFECT"
    $AUSCALL($PHOTOAUSB);
    CALL PHOTO;
    "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
    "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
    "   LEADING PARTICLE SELECTION, ETC.))."
    "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
    "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
    $PARTICLE-SELECTION-PHOTO;
    IF (NP = 0 | NP < NPOLD ) [RETURN;]
      "The above may happen if Russian Roulette is on"
      "NP<NPOLD means that only electrons were created in the interaction"
      "and that all of them were killed. Hence, the top particle on the "
      "stack is from a previous interaction and may be in another region"
      "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
      "a return to shower so that ELECTR or PHOTON are properly re-entered."
      "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
      "wrong dose with brems splitting and Russian Roulette on in a low "
      "energy calculation."

    $AUSCALL($PHOTOAUSA);
    IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
] "END OF PHOTO ELECTRIC BLOCK"

:PAIR-ELECTRONS-KILLED:

"   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
PEIG=E(NP);
EIG=PEIG;
IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
]REPEAT ":PNEWENERGY: LOOP"

"   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
RETURN;

"---------------------------------------------"
"PHOTON CUTOFF ENERGY DISCARD SECTION         "
"---------------------------------------------"
:PCUT-DISCARD:
IF( medium > 0 ) [
    IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
] ELSE [ IDR=$EGSCUTAUS; ]
EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
$PHOTON-TRACK-END;
IRCODE=2;
NP=NP-1;
RETURN;

"---------------------------------------------"
"User requested photon discard section        "
"---------------------------------------------"
:USER-PHOTON-DISCARD:
EDEP=PEIG;
$AUSCALL($USERDAUS);
IRCODE=2;
NP=NP-1;
RETURN;

"END OF SUBROUTINE PHOTON"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
"                                                                  "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;

"Input variables"
$REAL EI,      "initial shower energy"
      XI,YI,ZI,"initial co-ordinates"
      UI,VI,WI,"initial direction cosines"
      WTI;     "initial weight"

$INTEGER
      IQI,     "initial particle charge"
      IRI;     "initial region number"

"Local variables"
DOUBLE PRECISION
      DEG,    "energy for pi-zero option"
      DPGL,   "angle factor for pi-zero option"
      DEI,    "incident energy for pi-zero option"
      DPI,    "intermediate factor for pi-zero option"
      DCSTH,  "random number for pi-zero option"
      DCOSTH, "cos(theta) for pi-zero option"
      PI0MSQ; "pi-zero mass squared (in MeV**2)"

$REAL DNEARI, "initial distance to closest boundary"
      CSTH;   "random number for pi-zero option"

$INTEGER
      IRCODE; "status returned by ELECTR or PHOTON"

DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"

NP=1; NPold = NP;      "Set the old stack counter"
DNEARI=0.0;
IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
$TRANSFER PROPERTIES TO (1) FROM I;

IF (IQI = 2) ["PI-ZERO OPTION"
  "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
  "                  noted by      Dr.  Muroyama at Nagoya University
  IF(EI**2 <= PI0MSQ) [
     $egs_fatal('(//a/,a,g15.5,a)',
     ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
     ' but the total energy was too small (EI=',EI,' MeV)');
  ]
  $RANDOMSET CSTH;
  DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
  DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(1)=0; E(1)=DEG/2.;
  CALL UPHI(2,1);
  NP=2;
  DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
  COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
  IQ(2)=0; E(2)=DEG/2.;
  CALL UPHI(3,2);
]"end of pi-zero option"

"The following convoluted logic is difficult to follow"
"when one modifies the outcome of certain interactions"
"using nbr_split, Russian Roulette, or one of the     "
"particle selection macros. I'm simplifying it        "
"so that ircode becomes irrelevant. IK, August 2002   "
":TOPSTACK:"
"LOOP["
"   $KERMA-INSERT;"
"   IF(IQ(NP) = 0) GO TO :PHOTON:;"
"   LOOP ["
"      :ELECTRON:"
"      CALL ELECTR(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT; "
"      :PHOTON:"
"      CALL PHOTON(IRCODE);"
"      IF(IRCODE.EQ.2) EXIT;"
"   ]REPEAT"
"   IF(NP <= 0) EXIT;"
"]REPEAT "

LOOP [
    ;
    IF( np <= 0 ) EXIT;
    $KERMA-INSERT;  " DEFAULT FOR $KERMA-INSERT; IS ; (NULL)"
    IF( iq(np) = 0 ) [ call photon(ircode); ]
    ELSE             [ call electr(ircode); ]

]

RETURN;
"end of subroutine shower"  END;

%E
"******************************************************************"
"                               National Research Council of Canada"
SUBROUTINE UPHI(IENTRY,LVL);
"                                                                  "
"******************************************************************"
"   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
"   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
"   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
"   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
"******************************************************************"

$IMPLICIT-NONE;

$COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
                 "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;

"Input variables"
integer  IENTRY,LVL; "entry switches"

"Local variables"
$REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
      RNNO38, "random number for azimuthal angle selection"
      PHI,    "azimuthal scattering angle"
      CPHI,   "5/2*pi-PHI"
      A,B,C,  "direction cosines before rotation"
      SINPS2, "SINPS2=A*A+B*B"
      SINPSI, "Sqrt(SINPS2)"
      US,VS,  "x- and y- component of scattering vector"
      SINDEL,COSDEL;
              "aux. variables for the rotation algorithm"

$INTEGER
      IARG,   "index for AUSGAB"
      LPHI,LTHETA,LCTHET,LCPHI;
              "indeces for sine table"

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;

$AUSCALL($UPHIAUSB);
GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
"   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;

:UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
        "TABLE LOOK-UP"
$SET INTERVAL THETA,SINC;
$EVALUATE SINTHE USING SIN(THETA);
CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
$EVALUATE COSTHE USING SIN(CTHET);

"   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
"   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
"   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
"   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "

:UPHI2:;

" It is much faster to use the box method for azimuthal angle selection"
" than the following                                                   "
" $RANDOMSET RNNO38;
" PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
" $EVALUATE SINPHI USING SIN(PHI);
" CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
" $EVALUATE COSPHI USING SIN(CPHI);
$SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);

"   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
"   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
"   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
"   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
"   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
"   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
"   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
"   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
"   SO THAT IT CAN BE USED ON BOTH CALLS."

"   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
"   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
"   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
"   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."

:NRK:
GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
"   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;

:OLD-PARTICLE:
A=U(NP);B=V(NP);C=W(NP);
GO TO :ADJUST:;

:BREMS-GAMMA:
A=U(NP-1);B=V(NP-1);C=W(NP-1);

:NEW-PARTICLE:
$TRANSFER PROPERTIES TO (NP) FROM (NP-1);

"   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
"   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
"   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "

:ADJUST:
SINPS2=A*A+B*B;
"   If SINPS2 is small, no rotation is needed    "
IF (SINPS2.LT.1.0E-20)["small polar angle case"
   U(NP)=SINTHE*COSPHI;
   V(NP)=SINTHE*SINPHI;
   W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
] "end small polar angle case"
ELSE["large polar angle case"
   SINPSI=SQRT(SINPS2);
   US=SINTHE*COSPHI;
   VS=SINTHE*SINPHI;
   SINDEL=B/SINPSI;
   COSDEL=A/SINPSI;
   U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
   V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
   W(NP)=-SINPSI*US+C*COSTHE;
]"end large polar angle case"

$AUSCALL($UPHIAUSA);

RETURN;

:ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
$egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);

"END OF SUBROUTINE UPHI"    END;

;
%E
"*************************************************************************
"
" The following is a set of macros and subroutines that implement
" bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
" (which are the basis for ICRU radiative stopping powers, into the
" EGSnrc environment) or the NRC cross sections, which are essentially
" the same as NIST, but with corrections to the electron-electron
" contribution (corrections are only significant for low values of
" atomic number Z and low values of the emitted photon energy k.
"
" In order to use it, you have to `turn on' this option by
" setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
" original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
" data (nrc_brems.data).
"
" If this option is turned on, subroutine HATCH will call
" subroutine init_nist_brems.
" In init_nist_brems the NIST cross sections are read in,
" total bremsstrahlung cross sections are calculated using
" 64 point Gauss-Legendre quadrature, the interpolation arrays
" that are used for total cross sections and brems fraction interpolations
" (esig0, esig1, ebr10, ebr11               for electrons)
" (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
" are updated and alias sampling tables for rapid sampling of brems
" energies are created. These alias sampling tables are then used
" during the simulation in subroutine BREMS.
" Be aware that there is a slight inconsistency when using this option
" as resttricted radiative stopping powers used are the ones coming
" from PEGS and so, they are calculated using Bethe-Heitler.
" This will not matter at all if
"   - AP is much smaller than the electron energy
"       and/or
"   - the restricted radiative stopping power is much smaller
"     then the restricted collision stopping power
" Both conditions are usually satisfied.
"
" I. Kawrakow, NRC, January 2000.
"
" Added NRC brems cross-sections
" F. Tessier, NRC, August 2007.
"
"****************************************************************************

subroutine init_nist_brems;
"**************************"

$IMPLICIT-NONE;

$REAL    energy_array($MXBREN),x_array($MXBRXX),
         cs_array($MXBREN,$MXBRXX,$MXBREL);
$REAL    xi_array($MXBRXX);
real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);

$INTEGER nmix,kmix,i,n,k,j,ii;
$INTEGER ngauss,i_gauss;
$INTEGER lnblnk1,egs_get_unit;
$INTEGER ifirst,ilast,nener,neke,leil;

$REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
$REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
$REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
$REAL    Z,sumA;
$REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
$REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
         sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
$INTEGER iz;
$REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
$INTEGER ndat,k_max_error;
character tmp_string*512, tmp1_string*512;
integer  itmp;

$declare_write_buffer;

$REAL amu;
parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
                              "to cm^2/g"
$LOGICAL ex,is_opened;
$declare_max_medium;
$COMIN-INIT-NIST-BREMS;

$set_string(tmp_string,' ');
tmp_string = $cstring(hen_house) // 'data' // $file_sep;

IF( ibr_nist = 1 ) [
    $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
]
ELSE IF (ibr_nist = 2) [
    $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
]
ELSE [
    $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
    ibr_nist = ', ibr_nist);
]

"Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
"
rewind($NIST-DATA-UNIT);
read($NIST-DATA-UNIT,*);
read($NIST-DATA-UNIT,*) nmix,kmix;
IF (kmix > $MXBRXX) [
    $egs_fatal(*,' init_nist_brems: to many k values in data file!');
]
IF (nmix > $MXBREN) [
    $egs_fatal(*,' init_nist_brems: to many T values in data file!');
]

read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
read($NIST-DATA-UNIT,*);
DO i=1,$MXBREL [
    read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
]
close($NIST-DATA-UNIT);

DO k=1,kmix [
    xi_array(k)=Log(1-x_array(k)+1e-6);
    IF( fool_intel_optimizer ) [
        $egs_info(*,'xi_array(k): ',xi_array(k));
    ]
]

"Get abscissas and weights for Gauss-Legendre quadrature"
"
ngauss = $MXGAUSS;
call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);

"Calculate total brems cross sections and sampling tables"
"for all media                                           "

$egs_info(*,' ');
IF (ibr_nist = 1) [
$egs_info(*,'Using NIST brems cross sections! ');
]
ELSE IF (ibr_nist = 2) [
    $egs_info(*,'Using NRC brems cross sections! ');
]
$egs_info(*,' ');
DO medium=1,nmed [

    log_ap(medium) = log(ap(medium));
    $egs_info(*,' Initializing brems data for medium ',medium,'...');
    emin = max(ae(medium) - rm, ap(medium));
    DO i=1,nmix [
        IF( energy_array(i) >= emin ) EXIT;
    ]
    ifirst = i;
    DO i=nmix,1,-1 [
        IF( energy_array(i) < ue(medium) - rm ) EXIT;
    ]
    ilast = i+1;
    IF( ifirst < 1 | ilast > nmix ) [
        $egs_info(*,' init_nist_brems: data available only for ');
        $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
        $egs_info(*,' will use spline interpolations to get cross ');
        $egs_info(*,' sections beyond the available data but this may');
        $egs_info(*,' produce nonsense!');
        IF( ifirst < 1 ) ifirst=1;
        IF( ilast > nmix ) ilast = nmix;
    ]
    DO i=ifirst,ilast [
        ii = i+1 - ifirst;
        ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
        sumA = 0;
        DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
        sumA = sumA*amu;
        DO k=1,kmix [
            cs(ii,k) = 0;
            DO j=1,NNE(medium) [
                Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
                cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
            ]
            csx(k) = Log(cs(ii,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " Integrate
        "
        cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
        DO i_gauss = 1,ngauss [
            xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
            res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
            cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
        ]
    ]
    nener = ilast - ifirst + 1;
    call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
    "
    " Now replace the PEGS cross sections "
    "
    neke = meke(medium);
    sigee = 1E-15; sigep = 1E-15;
    DO i = 1,neke [
        eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
        leil = i;
        beta2 = ei*(ei+2*rm)/(ei+rm)**2;
        IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
        ELSE [
            sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
            sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
        ]
        $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
        $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
                                         " then the brems cross section "
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( i > 1 ) [
            si_esig = si1_esig;
            si_ebr1 = si1_ebr1;
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
            esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
            esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
            ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
            ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
        ]
        ELSE [
            si1_esig = sigt*(1 - ebr1) + sigb;
            si1_ebr1 = sigb/si1_esig;
        ]

        "
        " Positrons "
        "
        $EVALUATE sigt USING psig(eil);
        $EVALUATE ebr1 USING pbr1(eil);
        $EVALUATE ebr2 USING pbr2(eil);
        IF( sigt < 0 ) sigt = 0;
        IF( ebr1 > 1 ) ebr1 = 1;
        IF( ebr1 < 0 ) ebr1 = 0;
        IF( ebr2 > 1 ) ebr2 = 1;
        IF( ebr2 < 0 ) ebr2 = 0;
        sig_bhabha = sigt*(ebr2 - ebr1);
        IF( sig_bhabha < 0 ) sig_bhabha = 0;
        IF( i > 1 ) [
            si_psig = si1_psig;
            si_pbr1 = si1_pbr1;
            si_pbr2 = si1_pbr2;
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
            psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
            psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
            pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
            pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
            pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
            pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
        ]
        ELSE [
            si1_psig = sigt*(1 - ebr1) + sigb;
            si1_pbr1 = sigb/si1_psig;
            si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
        ]
        $EVALUATE ededx USING ededx(eil);
        sige = si1_esig/ededx;
        IF( sige > sigee ) sigee = sige;
        $EVALUATE ededx USING pdedx(eil);
        sige = si1_psig/ededx;
        IF( sige > sigep ) sigep = sige;
    ]
    esig1(neke,medium) = esig1(neke-1,medium);
    esig0(neke,medium) = esig0(neke-1,medium);
    ebr11(neke,medium) = ebr11(neke-1,medium);
    ebr10(neke,medium) = ebr10(neke-1,medium);
    psig1(neke,medium) = psig1(neke-1,medium);
    psig0(neke,medium) = psig0(neke-1,medium);
    pbr11(neke,medium) = pbr11(neke-1,medium);
    pbr10(neke,medium) = pbr10(neke-1,medium);
    pbr21(neke,medium) = pbr21(neke-1,medium);
    pbr20(neke,medium) = pbr20(neke-1,medium);
    $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
    esig_e(medium) = sigee; psig_e(medium) = sigep;
    IF( sigee > esige_max ) esige_max = sigee;
    IF( sigep > psige_max ) psige_max = sigep;

    "
    " Now prepare the arrays for brems sampling
    "
    nb_emin(medium) = energy_array(ifirst);
    IF( nb_emin(medium) <= ap(medium) ) [
        nb_emin(medium) = energy_array(ifirst+1);
    ]
    nb_emax(medium) = energy_array(ilast);
    nb_lemin(medium) = log(nb_emin(medium));
    nb_lemax(medium) = log(nb_emax(medium));
    nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
    nb_dlei(medium) = 1/nb_dle(medium);
    "
    eil = nb_lemin(medium) - nb_dle(medium);
    DO i=1,$MXBRES [
        eil = eil + nb_dle(medium); ei = exp(eil);
        DO ii=1,nener [
            IF( ei < ee(ii) ) EXIT;
        ]
        ii = ii-1;
        IF( ii < 1) ii = 1;
        IF( ii > nener-1 ) ii = nener-1;
        "
        " ple and qle are energy interpolation coefficients
        "
        ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
        DO k=1,kmix [
            csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
        ]
        call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
        "
        " fill the abscissas for this energy
        "
        x = ap(medium)/ei; aux = -log(x);
        xi = log(1 - x+1e-6);
        res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
        nb_xdata(0,i,medium) = 0;
        nb_fdata(0,i,medium) = exp(res);

        DO k=1,kmix [
            IF( x_array(k) > x ) EXIT;
        ]
        IF( k > kmix ) k = kmix;
        ndat = 0;
        DO j=k+1,kmix-1 [
            ndat = ndat+1;
            nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
            nb_fdata(ndat,i,medium) = exp(csx(j));
            IF( fool_intel_optimizer ) [
                $egs_info(*,'nb_xdata(ndat,i,medium): ',
                        nb_xdata(ndat,i,medium));
            ]
        ]
        ndat = ndat+1;
        nb_xdata(ndat,i,medium) = 1;
        nb_fdata(ndat,i,medium) = exp(csx(kmix));
        "
        " Now expand the arrays by filling intermediate points
        " at the positions that show the maxium relative error
        " when using linear interpolation in x.
        " If arrays were allocated dynamically one could use
        " a certain condition to stop the iteration but in our case
        " memory is allocated anyway and so we use the maximum
        " space provided
        "
        IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
        LOOP [
            x_max_error = 0; f_max_error = 0; k_max_error = 0;
            max_error = 0;
            DO k=0,ndat-1 [
                x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
                f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
                xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
                res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
                res = exp(res);
                error = abs(1-f/res);
                IF( error > max_error ) [
                    x_max_error = x;
                    f_max_error = res;
                    max_error = error;
                    k_max_error = k;
                ]
            ]
            ndat = ndat+1;
            DO k=ndat,k_max_error+2,-1 [
                nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
                nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
            ]
            nb_xdata(k_max_error+1,i,medium) = x_max_error;
            nb_fdata(k_max_error+1,i,medium) = f_max_error;
        ] UNTIL (ndat = $MXBRXS);

        :SKIP-LOOP:
        "
        " Now generate the alias tables for rapid brems sampling
        " during run time
        "
        call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));

    ]
]
$egs_info(*,' ');
$egs_info(*,' ');
return;
" Errors "
:data_file_error:
$egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
return;
end;

%E
/***************************************************************************
 *
 * A subroutine to initialize pair energy sampling from the NRC
 * cross sections differential in the positron energy.
 * These cross sections are calculated as the product of the
 * exact cross section without screening times the ratio
 * of the first Born approximation with screening to the first
 * Born approximation without screening.
 * At high energies (above, say, 50 MeV) the NRC cross sections are
 * are very close to the Bethe-Heitler cross sections but
 * there are significant differences at low energies. In particular,
 * the asymetrie in the energy distribution between the positron
 * and the electron is properly taken into account.
 *
 * I. Kawrakow, April 2005.
 *
 ***************************************************************************/

subroutine init_nrc_pair;
implicit none;
$declare_max_medium;
;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
$declare_write_buffer;

character     nrcp_file*256, endianess*4;
integer       egs_get_unit;
$INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
$INTEGER      i, lnblnk1;
$REAL         tmp, ddx, xx, Z;
real*4        emin, emax;
integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
character     endian, cdum($cdum_size);
$LOGICAL      swap;
real*4        tmp_4, tarray($NRC-PAIR-NXX);
integer*4     itmp_4;
character     c_4(4), ic_4(4);
equivalence   (tmp_4,c_4), (itmp_4, ic_4);

$set_string(nrcp_file,' ');
nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
want_nrcp_unit = 62;
nrcp_unit = egs_get_unit(want_nrcp_unit);
IF( nrcp_unit < 1 ) [
    $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
]

rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
        status='old',recl=rec_length,err=:nrcp-open-error:);
read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
swap = endianess.ne.$BYTE_ORDER;
IF( swap ) [
    tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
    tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
    itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
    itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
]
$egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
$egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
$egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
$egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
IF( nb ~= $NRC-PAIR-NXX ) [
    $egs_fatal(*,'Inconsistent x-grid size');
]
IF( ne ~= $NRC-PAIR-NEE ) [
    $egs_fatal(*,'Inconsistent energy grid size');
]
nrcp_emin = emin; nrcp_emax = emax;
nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;

nbb = nb/2; ddx = sqrt(0.5)/nbb;
DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]

DO medium = 1,NMED [
    $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
    DO ie=1,$NRC-PAIR-NEE [
        DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
    ]
    DO i_ele=1,NNE(medium) [
        Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
        tmp = PZ(medium,i_ele)*Z*Z;
        irec = (iz-1)*ne + 2;
        DO ie=1,$NRC-PAIR-NEE [
            read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
            DO ix=1,$NRC-PAIR-NXX [
                tmp_4 = tarray(ix);
                IF( swap ) [ call egs_swap_4(c_4); ]
                nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
            ]
            irec = irec + 1;
        ]
    ]
    DO ie=1,$NRC-PAIR-NEE [
        call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
                nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
    ]

    $egs_info('(a)',' done');

]
$egs_info(*,' ');
close(nrcp_unit);
return;

:nrcp-open-error:;
$egs_fatal(*,'Failed to open NRC pair data file');

:nrcp-read-error:;
$egs_fatal(*,'I/O error while reading NRC pair data file');

end;

%E
"******************************************************************"
"                               NATIONAL RESEARCH COUNCIL OF CANADA"
"                                                                  "
subroutine vmc_electron(ircode);
"                                                                  "
"******************************************************************"
"   This subroutine performs condensed history simulation of       "
"   electron/positron transport according to VMC                   "
"                                                                  "
"   Version 1.0   Iwan Kawrakow       Initial coding               "
"                                     coding is in EGSnrc style    "
"                                     for maximum compatibility    "
"                                     with EGSnrc user codes       "
"******************************************************************"

$IMPLICIT-NONE;

;COMIN/EGS-IO/;

$INTEGER ircode;
$egs_fatal('(//a//)',
' ********* VMC Transport option not in this distribution ****** ');
end;

" Subroutine versions of the random number generator "
" Included here because it makes life easier for using the EGSnrc RNG"
" from within the C-interface. "
subroutine egs_init_default_rng;
;COMIN/RANDOM/;
$RNG-DEFAULT-INITIALIZATION;
return; end;

subroutine egs_init_rng(arg1,arg2);
$INTEGER arg1,arg2;
;COMIN/RANDOM/;
$declare_write_buffer;
$INITIALIZE RNG USING arg1 AND arg2;
return; end;

subroutine egs_get_rndm(ran);
$REAL ran;
;COMIN/RANDOM/;
$RANDOMSET ran;
return; end;

subroutine egs_get_rndm_array(n,rarray);
$INTEGER n;
$REAL    rarray(*);
;COMIN/RANDOM/;
$REAL    rtmp;
$INTEGER i;
IF( n < 1 ) return;
DO i=1,n [
    $RANDOMSET rtmp; rarray(i) = rtmp;
]
return; end;

/****************************************************************************
 *
 * Subroutines for modelling Electron Impact Ionization (EII) in EGSnrc.
 * This implementation uses EII cross section derived from a GOS
 * approach using photo-ionization cross sections from EPDL97 for the
 * OOS. It is called "simple" because
 *   - Ionizations of only K-, LI-, LII- and LIII-shell with binding
 *     energies above 1 keV are taken into account
 *   - Simplified versions of the differential cross sections are used
 *     (but it is made sure that the total energy loss is still
 *      correctly reproduced).
 *
 * EII is turned on by setting the flag eii_flag in COMIN/EII-DATA/ to 1.
 *
 * Iwan Kawrakow, March 2004.
 *
 *****************************************************************************/

"**************************************************************************"
"Init EII. This subroutine is called from HATCH after all media are known, "
"threshold energies and interpolation data have been initialized.          "
"**************************************************************************"
subroutine eii_init;
"**************************************************************************"
implicit none;
$COMIN-EII-INIT;
$INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
$INTEGER jj,jjj;
integer*4 lnblnk1;
$INTEGER tmp_array($MXELEMENT);
$INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
integer  egs_get_unit;
$REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
$REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
$REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
$REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
$REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
$REAL    sigma,sigma_old,wbrem_old,sig_j,de;
$INTEGER lloge;
$LOGICAL check_it,is_monotone,getd;
$REAL    sigma_max;
character eii_file*128;
character*512 toUpper;
$INTEGER occn_numbers(4);
$declare_write_buffer;
$REAL    cons;
parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
data     occn_numbers/2,2,2,4/;

DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
DO j=1,$MXMED [ eii_nsh(j) = 0; ]
IF( eii_flag = 0 ) [ return; ]

$need_relaxation_data(getd);
IF( ~getd )[
  $egs_fatal('(/a,/a,/a,/a)',
          ' In subroutine eii_init: ',
          '   Scattering off bound electrons creates atomic vacancies,',
          '   potentially starting an atomic relaxation cascade. ',
          '   Please turn ON atomic relaxations.');
]

/*
  find minimum of all threshold energies
 */
e_eii_min = 1e30;
DO imed = 1,nmed [
    IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
    IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
]
$egs_info(*,' ');
$egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);

/*
  determine elements that need to load EII data
 */
DO imed = 1,nmed [
    DO iele = 1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        IF( eii_nshells(iZ) = 0 ) [
            nsh = 0;
            DO ish=1,4 [
                IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
            ]
            eii_nshells(iZ) = nsh;
        ]
    ]
]

/* total number of shells that need to be loaded */
nsh = 0;
DO iZ=1,$MXELEMENT [
    nsh = nsh + eii_nshells(iZ);
]
IF( nsh = 0 ) [
    $egs_info(*,'*** EII requested but no shells with binding energies ');
    $egs_info(*,'    above the specified threshold found');
    $egs_info(*,'    => turning off EII');
    eii_flag = 0;
]
IF( nsh > $MAX_EII_SHELLS ) [
    $egs_info(*,'*** Number of shells with binding energies greater than ');
    $egs_info(*,'    the specified thresholds is ',nsh);
    $egs_info(*,'    This is more than the allocated arrays can hold');
    $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
]
$egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
nsh_tot = nsh;
tmp_array(1) = 0;
DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]

/* set EII active shells per medium and for each element */
DO imed=1,nmed [
    nsh = 0;
    DO iele=1,nne(imed) [
        iZ = int(zelem(imed,iele)+0.5);
        eii_no(imed,iele) = eii_nshells(iZ);
        nsh = nsh + eii_nshells(iZ);
        IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
        ELSE [ eii_first(imed,iele) = 0; ]
    ]
    eii_nsh(imed) = nsh;
]

/* read EII data */
$set_string(eii_file,' ');
eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
           $cstring(eii_xfile) //'.data';
want_eii_unit = 62;
eii_unit = egs_get_unit(want_eii_unit);
IF( eii_unit < 1 ) [
    $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
]
open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
$egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
$egs_info('(a,$)',' eii_init: reading EII data ... ');
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
DO j=1,nskip [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
]
read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
IF( nbin ~= $N_EII_BINS ) [
    $egs_fatal(*,'Inconsistent EII data file');
]
IF (xsec_out = 1)[
   eii_out = egs_open_file(93,0,1,'.eiixsec');
]
ii = 0;
DO j=1,$MXELEMENT [
    read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
    IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
     write(eii_out,*) '=================================';
     write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
     write(eii_out,*) '=================================';
    ]
    IF( nsh < eii_nshells(iZ) ) [
        $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
        $egs_info(*,iZ,' but according');
        $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
        $egs_info(*,'shells are required');
        $egs_fatal(*,'This is a fatal error.');
    ]
    DO ish=1,nsh [
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
        read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
           aux_array;
        "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
        IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
        IF( ish <= eii_nshells(iZ) ) [
            IF (xsec_out = 1)[
              IF(ish = 1)[
               write(eii_out,'(a,f10.2,a)')
               'K-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 2)[
               write(eii_out,'(a,f9.2,a)')
               '=> LI-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 3)[
               write(eii_out,'(a,f8.2,a)')
               '=> LII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSEIF (ish = 4)[
               write(eii_out,'(a,f8.2,a)')
               '=> LIII-shell sigma_max = ',fmax,' b/atom';
              ]
              ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
              write(eii_out,*) '   E/keV     sigma/(b/atom)';
              write(eii_out,*) '---------------------------';
            ]
            ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
            eii_a(ii) = nbin;
            eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
            eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
            DO k=1,nbin [
                IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
                ELSE [ sigo = 0; ]
                loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
                eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
                eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
                IF (xsec_out = 1)[
                   write(eii_out,'(f12.2,2X,10f9.2)')
                   Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
                ]
            ]
        ]
    ]
    IF( ii = nsh_tot ) [ EXIT; ]
]
close(eii_unit);
IF (xsec_out = 1)[ close(eii_out); ]
$egs_info(*,' OK '); $egs_info(*,' ');

/*
   Adjust restricted stopping power and discrete inelastic cross sections

   Discrete interaction cross sections for all shells that come from PEGS4
   are calculated using the Moller cross section
     => we must subtract the Moller cross section for the shells that will
        have EII and then add the EII cross sections for these shells
   The restricted stopping power that comes from PEGS4 is calculated assuming
   that all shells will be producing secondaries according to Moller
     => we must add the energy lost in Moller events in EII shells to the
        restricted stopping power and then subtract the average energy lost
        in EII events.
 */
DO imed = 1,nmed [
    Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
    /sum_z,sum_pz,sum_a,sum_wa/=0;
    DO iele=1,nne(imed) [
        sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
        sum_pz = sum_pz + pz(imed,iele);
        sum_wa = sum_wa + rhoz(imed,iele);
        sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
    ]
    con_med = rho(imed)/1.6605655/sum_a;
    eii_cons(imed) = con_med;
    IF( eii_nsh(imed) > 0 ) [
        is_monotone = .true.;
        sigma_max = 0;
        DO j=1,meke(imed) [
            loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
            tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
            p2 = 2*rm*tau*(tau+2);
            lloge = j;
            medium = imed;
            $EVALUATE dedx USING ededx(loge);
            IF( e > ap(medium) | e > 2*Ec ) [
                $EVALUATE sig USING esig(loge);
            ] ELSE [ sig = 0; ]
            IF( e > 2*Ec ) [
                $EVALUATE wbrem USING ebr1(loge);
                sigm = sig*(1-wbrem);
            ] ELSE [ sigm = 0; wbrem = 1; ]
            /sum_occn,sum_sigma,sum_dedx/=0;
            DO iele=1,nne(imed) [
                iZ = int(zelem(imed,iele)+0.5);
                sum_sh = 0;
                DO ish = 1,eii_no(imed,iele) [
                    "jj is the shell index in the list of EII shells "
                    jj = eii_first(imed,iele) + ish - 1;
                    "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
                    jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
                    Wmax = (e+U)/2; uwm = U/Wmax;
                    "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
                    IF( U < e & U > Ecc ) [
                        " At this energy interactions with this shell will "
                        " be done using the EII differential x-section "
                        sum_sh = sum_sh + occn_numbers(jjj);
                        ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
                          (beta2+0.833333)*(1-uwm**3))/3/U;
                        sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
                          - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
                        ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
                          (beta2+1)*(1-uwm**2);
                        sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
                          +(Wmax**2-U**2)/(e+rm)**2/2
                          -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
                        av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
                          "av_E is the average energy lost in a collision"
                          "with this shell"
                        i = eii_a(jjj)*loge + eii_b(jjj);
                        i = (jj-1)*$N_EII_BINS + i;
                        sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
                        sig_j = sig_j*pz(imed,iele)*con_med;
                        sum_sigma = sum_sigma + sig_j;
                        sum_dedx = sum_dedx + sig_j*av_E;
                    ]
                ]
                sum_occn = sum_occn + sum_sh*pz(imed,iele);
            ]
            sigm = sigm + sum_sigma;
            dedx = dedx - sum_dedx;
            aux = Ec/e;
            IF( e > 2*Ec ) [
                sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
                        (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
                        (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
                de = cons*sum_occn*rho(imed)/beta2*(
                  log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
                  (tau/(tau+1))**2*(1-4*aux*aux)/8-
                  (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
                sigm = sigm - sigo;
                "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
                dedx = dedx + de;
            ]
            sigma = sigm + wbrem*sig;
            IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
            IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
            ELSE [ wbrem = 1; ]
            IF( j > 1 ) [
                ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
                ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
                esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
                esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
                ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
                ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
                IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
            ]
            dedx_old = dedx; sigm_old = sigm;
            sigma_old = sigma; wbrem_old = wbrem;
        ]
        ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
        ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
        esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
        esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
        ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
        ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
        $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
                sigma_max,' monotone = ',is_monotone);
        sig_ismonotone(0,imed) = is_monotone;
        esig_e(imed) = sigma_max;
    ]
]
return;

:eii-reading-error:
$egs_fatal(*,'I/O error while reading EII data');

:no-eii-file:
$egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
          'Make sure file exists in your $HEN_HOUSE/data directory!',
          '****BEWARE of case sensitive file names!!!');

return; end;

"*****************************************************************************"

subroutine eii_sample(ish,iZ,Uj);
implicit none;
$INTEGER ish,iZ;
$REAL    Uj;

$COMIN-EII-SAMPLE;

$REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
$REAL r1,r2,r3,wx,wxx,aux,frej;
real*8 peie,pese1,pese2,dcosth,h1;
$INTEGER iarg;
$REAL    eta,cphi,sphi;
$INTEGER np_save,ip,j;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;

/* calculate some useful constants */
peie = e(np);
T = peie - rm; tau = T/rm; tau1 = tau+1;
tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
beta2 = p2/tau12;
"c1 = tau2/tau12; "
Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
c1 = (Wmax/peie)**2;
c2 = (2*tau+1)/tau12;
fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
"fm_h = 1 + c1 - c2;"
fm_h = 2 + c1 - c2;
IF( fm_h < 1 ) fm_h = 1;
prob = fm_h + prob_s;

LOOP [
    $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
    IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
        wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
        frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
    ] ELSE [               "Use the soft collision cross section "
        wx = 1/(r2*xmax**3+1-r2)**0.333333333;
        frej = 1 - log(wx)/fm_s;
    ]
] UNTIL ( r3 < frej );

wx = wx*Uj;

/* set-up new particles */
h1 = (peie + prm)/T; pese1 = peie - wx;
e(np) = pese1;
dcosth = h1*(pese1-prm)/(pese1+prm);
sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
call uphi(2,1);

pese2 = wx - Uj + prm;
edep_local = 0;
IF( pese2 > ae(medium) ) [
    $CHECK-STACK(np+1,'eii_sample');
    np = np+1; e(np) = pese2;
    dcosth = h1*(pese2-prm)/(pese2+prm);
    sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
    iq(np) = -1; call uphi(3,2);
    edep = 0;
] ELSE [
    edep = wx - Uj;
    edep_local = edep;
    $AUSCALL($SELECTRONA);
]
"ish ranges from 1 to 4 for K,L1,L2,L3 shells"
call relax(Uj,ish,iZ);

IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]

/*
IF( nbr_split > 1 ) [
    np_save = np;
    DO ip=NPold+1,np_save [
        IF( iq(ip) = 0 ) [
            wt(ip) = wt(ip)/nbr_split;
            DO j = 1,nbr_split-1 [
                np = np + 1; $CHECK-STACK(np,'eii_sample');
                iq(np) = 0; e(np) = e(ip);
                $TRANSFER PROPERTIES TO (np) FROM (ip);
                $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
                eta = (1-eta)*(1+eta);
                IF( eta > 1e-20 ) [
                    eta = Sqrt(eta);
                    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
                    u(np) = eta*cphi; v(np) = eta*sphi;
                ] ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
            ]
        ]
    ]
]
*/


return; end;

"============================================================================"
subroutine egs_scale_photon_xsection(imed,fac,which);
"============================================================================"
"
"  Scale the photon cross section 'which' by factor fac for medium imed.
"  which = 0 for all cross sections
"        = 1 for Rayleigh scattering
"        = 2 for Compton scattering
"        = 3 for Pair production
"        = 4 for photo-absorption
"  If imed = 0, scaling is done for all media.
"============================================================================"
implicit none;
$INTEGER imed,which;
$REAL    fac;
$declare_max_medium;
;COMIN/MEDIA,PHOTIN,EGS-IO/;
$INTEGER ifirst,ilast,medium,j;
$LOGICAL has_r;
$REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
character*8 strings(5);
data       strings/'photon','Rayleigh','Compton','pair','photo'/;

IF( which < 0 | which > 4 ) [ return; ]
IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
ELSE [ ifirst = 1; ilast = nmed; ]
IF( which = 1 ) [
    has_r = .false.;
    DO medium = ifirst, ilast [
        IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
    ]
    IF( ~has_r ) return;
]
$egs_info(*,' ');
DO medium = ifirst,ilast [

    $egs_info('(a,a,a,i3,a,f9.5)',
            'Scaling ',strings(which+1),' x-section data for medium',
            medium,' with ',fac);

    DO j = 1,mge(medium) [

        gle = (j - ge0(medium))/ge1(medium);
        gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
        gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
        gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
        IF( iraylm(medium) = 1 ) [
            cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
        ] ELSE [ cohfac = 1; ]
        IF( which = 0 ) [ gmfp = gmfp/fac; ]
        ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
        ELSE [
            IF( which = 2 ) [
                aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
                gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
            ]
            ELSE IF( which = 3 ) [
                aux = fac*gbr1 + 1 - gbr1;
                gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
            ]
            ELSE [
                aux = gbr2 + fac*(1-gbr2);
                gbr1 = gbr1/aux; gbr2 = gbr2/aux;
            ]
            gmfp = gmfp/aux;
            cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
        ]
        IF( j > 1 ) [
            gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
            gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
            gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
            cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
            cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;

    ]
    gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
    gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
    gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
    gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
    gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
    gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
    cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
    cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
]

return; end;

/*============================================================================

 Subroutines to initialize photon cross section data.
 The data is read from string_photo.data, string_pair.data,
 string_triplet.data, and string_rayleigh.data, where string is the argument
 passed to the subroutine.

============================================================================*/

REPLACE {$OPEN-UNIT(#,#,#);} WITH {
    {P1} = {P2};
    {P1} = egs_get_unit({P1});
    IF( {P1} < 1 ) [
        $egs_fatal(*,
         'egs_init_user_photon: failed to get a free Fortran I/O unit');
    ]
    tmp_string = {P3};
    open({P1},file={P3},status='old',err=:no-user-data-file:);
};

REPLACE {$MXINPUT} WITH {2000};
REPLACE {$MXBCINP} WITH {183};

"============================================================================="
"Ali:photonuc, 1 line"
 subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
"subroutine egs_init_user_photon(prefix,comp_prefix,out);"
"============================================================================="
implicit none;
$declare_max_medium;
character*(*) prefix, comp_prefix,
"Ali:photonuc, 1 line"
              photonuc_prefix;
$INTEGER      out;
;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
$INTEGER   lnblnk1,egs_get_unit,medium,
           photo_unit,pair_unit,rayleigh_unit,triplet_unit,
           ounit,egs_open_file,compton_unit,
"Ali:photonuc, 1 line"
           photonuc_unit;
$INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
$REAL      z_sorted($MXEL),pz_sorted($MXEL);
$REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
           sig_rayleigh($MXGE),sig_compton($MXGE);
$REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
$REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
"Ali:photonuc, 3 lines"
           sig_photonuc($MXGE),
           photonuc,
           photonuc_old;

$REAL      etmp($MXINPUT),ftmp($MXINPUT);
$REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
$REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
$INTEGER   bc_ne;
$LOGICAL   input_compton_data,
"Ali:photonuc, 1 line"
           input_photonuc_data;
character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
           triplet_file*142,tmp_string*144,compton_file*144,
"Ali:photonuc, 1 line"
           photonuc_file*144;

$egs_info('(/a$)','(Re)-initializing photon cross sections');
$egs_info('(a,a/)',' with files from the series: ',
      prefix(:lnblnk1(prefix)));

$egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 $egs_info('(a,a)',' Photonuclear cross sections: ',
 $cstring(photonuc_prefix));
 input_photonuc_data = .false.;
 IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
   input_photonuc_data = .true.;
 ]
]

input_compton_data = .false.;
IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
    IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
]
data_dir = $cstring(hen_house) // 'data' // $file_sep;
photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
IF( input_compton_data ) [
    compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
                   '_compton.data';
]
ELSE [
    compton_file = $cstring(data_dir) // 'compton_sigma.data';
]
"Ali: I moved this info line from inside the IF statement
" because it's useful to print the cross section file either way
$egs_info('(a,a)',' Using Compton cross sections from ',
          $cstring(compton_file));

"Ali:photonuc, 1 block"
IF(iphotonuc = 1) [
 IF( input_photonuc_data ) [
    photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
                    '_photonuc.data';
 ]
 ELSE [
    photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
 ]
 $egs_info('(a,a)',' Using photonuclear cross sections from ',
  $cstring(photonuc_file));
]

$OPEN-UNIT(photo_unit,83,photo_file);
$OPEN-UNIT(pair_unit,84,pair_file);
$OPEN-UNIT(triplet_unit,85,triplet_file);
$OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
" Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
"       without rejections. For this we have to use the actual bound   "
"       Compton scattering cross section, which is now available in a  "
"       file called bound_compton.data (the file actually contains the "
"       ratio of the Bound Compton to the KN cross section).           "
"       Because this option is not available on a region by region     "
"       basis, we just need to check ibcmp(1)                          "
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]

IF( out = 1 ) [
    ounit = egs_open_file(87,0,1,'.xsections');
    write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
       $cstring(prefix),' data files';
    write(ounit,'(a,/)')
'============================================================================';
    write(ounit,'(a,/)') 'Grid energies and cross sections are output';
"Ali:photonuc, 1 block"
    IF(iphotonuc = 1) [
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
         'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
         ' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
         '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
         'w/ Ray + photnuc';
    ]
    ELSE[
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
            'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
       write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
            '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
   ]
]
/* Replace binding energies with the edges in the photo-absorption file */
DO iz=1,100 [
    read(photo_unit,*) ndat;
    read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
    k = 0;
    DO j=ndat,2,-1 [
        IF( etmp(j)-etmp(j-1) < 1e-5 ) [
            k = k+1;
            IF ( k <= $MXSHXSEC )[
               binding_energies(k,iz) = exp(etmp(j));
            ]
            ELSE[
              $egs_fatal('(i3,a,i3,//a)',
                         k,' binding energies read exceeding array size of',
                         $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
            ]
            IF( ~eadl_relax & k >= 4 ) EXIT;
        ]
    ]
]

IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]

DO medium = 1,nmed [

    mge(medium) = $MXGE; nge = $MXGE;
    ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
    ge0(medium) = 1 - ge1(medium)*log(ap(medium));

    $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
    IF( out = 1 ) [
        write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
          (media(k,medium),k=1,24);
    ]
    /sumZ,sumA/ = 0;
    DO i=1,nne(medium) [
        z_sorted(i) = zelem(medium,i);
        sumZ = sumZ + pz(medium,i)*zelem(medium,i);
        sumA = sumA + pz(medium,i)*wa(medium,i);
    ]
    con1 = sumZ*rho(medium)/(sumA*1.6605655);
    con2 = rho(medium)/(sumA*1.6605655);
    call egs_heap_sort(nne(medium),z_sorted,sorted);
    DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]

    IF (mcdf_pe_xsections)[
       call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
                                ge1(medium),ge0(medium),sig_photo);
    ]
    ELSE[
       call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_photo);
    ]
    call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_rayleigh);
    call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_pair);
    call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
                       ge1(medium),ge0(medium),sig_triplet);
"Ali:photonuc, 1 block"
    IF( iphotonuc = 1 ) [
      call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
                        ge1(medium),ge0(medium),sig_photonuc);
    ]

    IF( ibcmp(1) > 1 ) [
        "Get the bound compton cross section data"
        IF( input_compton_data ) [
            call egsi_get_data(0,compton_unit,nge,nne(medium),
                    z_sorted,pz_sorted,ge1(medium),ge0(medium),
                    sig_compton);
        ]
        ELSE [
            rewind(compton_unit);
            read(compton_unit,*) bc_emin,bc_emax,bc_ne;
            IF( bc_ne > $MXBCINP ) [
              $egs_fatal(*,'Number of input Compton data exceeds array size');
            ]
            "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
            bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
            DO j=1,bc_ne [ bc_data(j) = 0; ]
            iz_old = 1;
            DO i=1,nne(medium) [
                iz = int(z_sorted(i)+0.5);
                "write(6,*) ' reading bc data for ',iz;
                DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
                DO j=1,bc_ne [
                    bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
                ]
                iz_old = iz+1;
            ]
            DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
        ]
    ]

    /* prepare data needed for Rayleigh scattering sampling */
    call egs_init_rayleigh(medium,sig_rayleigh);

    DO i=1,nge [

        gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
        sig_KN = sumZ*egs_KN_sigma0(e);
        IF( ibcmp(1) > 1 ) [
            IF( input_compton_data ) [
                sig_KN = sig_compton(i);
            ]
            ELSE [
                "Apply the bound Compton correction to sig_KN"
                IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
                ELSE IF( e < bc_emax ) [
                    aj = 1 + log(e/bc_emin)/bc_dle;
                    j = int(aj); aj = aj - j;
                    bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
                ]
                ELSE [ bcf = 1; ]
                sig_KN = sig_KN*bcf;
                "write(6,*) 'e = ',e,' bcf = ',bcf;
            ]
        ]
        sig_p  = sig_pair(i) + sig_triplet(i);
        sigma  = sig_KN + sig_p + sig_photo(i);
        gmfp   = 1/(sigma*con2);
        gbr1   = sig_p/sigma;
        gbr2   = gbr1 + sig_KN/sigma;
        cohe   = sigma/(sig_rayleigh(i) + sigma);
"Ali:photonuc, 1 line"
        photonuc = sigma/(sig_photonuc(i) + sigma);

        IF( out = 1 ) [
"Ali:photonuc, 1 block"
           IF(iphotonucm(medium) = 1) [
              write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
              gmfp*cohe,gmfp*cohe*photonuc;
           ]
           ELSE[
              write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
           ]
        ]
        IF( i > 1 ) [
            gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
            gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
            gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
            gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
            gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
            gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
            cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
            cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
"Ali:photonuc, 2 lines"
            photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
            photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
        ]
        gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
"Ali:photonuc, 1 line"
        photonuc_old = photonuc;
    ]

    gmfp1(nge,medium) = gmfp1(nge-1,medium);
    gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
    gbr11(nge,medium) = gbr11(nge-1,medium);
    gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
    gbr21(nge,medium) = gbr21(nge-1,medium);
    gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
    cohe1(nge,medium) = cohe1(nge-1,medium);
    cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
"Ali:photonuc, 2 lines"
    photonuc1(nge,medium) = photonuc1(nge-1,medium);
    photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;

    $egs_info('(a)','OK');
]

close(photo_unit); close(pair_unit);
close(triplet_unit); close(rayleigh_unit);
"Ali:photonuc, 1 line"
IF( iphotonuc = 1 ) [ close(photonuc_unit);]
IF( ibcmp(1) > 1 ) [ close(compton_unit);]
IF( out = 1 )      [ close(ounit); ]
return;

:no-user-data-file:;
$egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh(medium,sig_rayleigh);
/*********************************************************************
 This routine is called after Rayleigh data has been read from one of
 the available data bases (si, xcom, epdl). Therefore total Rayleigh
 xsections are already available. Here one reads in either custom FF
 for a medium or builds the FF using the atomic FF (default) and the
 IAM (Independent Atom Model). The total Rayleigh xsection must also
 be calculated for the media with user-supplied FF.
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/*****************************************************************
   Figure out if custom ff needed for medium: check that medium
   is in the list iray_ff_media, else the default atomic ff used.
   This used to be done in subroutine get_transport_parameter
   but was moved here, since it is up to the the user-code to
   read in the information and it is not ensured that the media
   information will be read before getting the transport parameters.
****************************************************************/
ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
   ff_file = iray_ff_file(i);
];]

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

/***********************************************************
   Read the FF and calculate the xsections for the custom FF
   or calculate the FF for a molecule using the IAM in the
   atomic case.
 ***********************************************************/
IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
     open(ff_unit,file=$cstring(ff_file),
          status='old',err=:no-ff-file:);
     GOTO :read-ff:;
     :no-ff-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
             $cstring(ff_file));
     :read-ff:
     $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
     " read Rayleigh molecular form factor data from a file"
     " which is given as Fmol/sqrt(MW) hence no need to compute"
     " MW to get the xsections in cm-1. See conv variable below"
     j = 0;
     LOOP [
       j = j + 1;
       read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
       IF (EOF < 0) EXIT;
       IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
     ] REPEAT
     nff = j-1;
     IF (nff > $MXRAYFF)[
        $egs_fatal('(a,/,a,i5,a,i5,/,a)',
        'subroutine egs_init_rayleigh: form factors size too small!!',
        '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
        ' and try again!!!');
     ]
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
     /* Now calculate Rayleigh xsections */
     "Since MW already included in the molecular FF,"
     "must multiply by sumA which is MW for compound"
     "or unity for mixtures."
     sumA = 0.0;
     DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
     DO j=1,MGE(medium) [
       gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
       sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
                       xgrid(1,medium),ff(1,medium))*sumA;
     ]
]
ELSE[
     $set_string(afac_file,' ');
     afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
     open(ff_unit,file=$cstring(afac_file),
       status='old',err=:no-afac-file:);
     GOTO :read-afac:;
     :no-afac-file:
     $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
             $cstring(afac_file));
     :read-afac:
     " read Rayleigh atomic form factor data from a file"
     read(ff_unit,*) xval, aff;
     "calculate form factor using independent atom model"
     DO i=1,$MXRAYFF[
       ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
       DO j=1,nne(medium)[
        ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
       ]
       ff(i,medium) = sqrt(ff(i,medium));
     ]
     nff = $MXRAYFF;
     "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
     "and much less for higher energies"
     IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
     $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
]
close(ff_unit);
/* call routine for preparing sampling data */
/* The following is inconsistent with the $SET INTERVAL macro. IK, July 21 2009
   This is because the actual min/max energy of the interpolation
   grid coming from PEGS might be lower/higher than ap/up.
   The medium specific constants ge0(medium) and ge1(medium) come
   from PEGS => one has to use those to find the actual emin/emax.
   If not done that way, the tabulated data will be inconsistent
   with the $SET INTERVAL macro.
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),ap(medium),up(medium),
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));
*/
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
dlei=1/dle;
DO i=1,ne-1 [
   /*  The stuff below is inconsistent with the
       $SET INTERVAL macro (see above) IK, July 21 2009
   gle = log(ap(medium)) + dle*(i-1);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*dlei;
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
   */
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/*********************************************************************/
subroutine egs_init_rayleigh_sampling(medium);
/*********************************************************************
 This routine is called from HATCH if user requested to use the photon
 xsection data from the pegs4 file. Here one reads in atomic FF and
 builds the FF using the IAM (Independent Atom Model).
 *********************************************************************/
$IMPLICIT-NONE;
$declare_max_medium;
;COMIN/THRESH,          "for threshold energies"
       EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
       rayleigh_inputs,rayleigh_sampling/;

$REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
$REAL xsc, fsc;
$REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
$REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
$REAL totRayleigh2,pzmin;
$REAL emin, emax;
$INTEGER i,j,k,ff_unit, egs_get_unit, ne;
$INTEGER lnblnk1, EOF, nff, medium, ncustom;
character dummy*24, afac_file*128, ff_file*128;

IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"

/* Open a fortran unit for reading form factors */
ff_unit = egs_get_unit(0);
IF( ff_unit < 1 ) [
   $egs_fatal(*,
   'egs_init_rayleigh: failed to get a free Fortran I/O unit');
]

$set_string(afac_file,' ');
afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
GOTO :read-afac:;
:no-afac-file:
$egs_fatal('(2a)',
        'egs_init_rayleigh_sampling: failed to open atomic ff file ',
        $cstring(afac_file));
:read-afac:
" read Rayleigh atomic form factor data from a file"
read(ff_unit,*) xval, aff;
"calculate form factor using independent atom model"
DO i=1,$MXRAYFF[
  ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
  DO j=1,nne(medium)[
   ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
  ]
  ff(i,medium) = sqrt(ff(i,medium));
]
nff = $MXRAYFF;
"To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
"and much less for higher energies"
IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
"write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
$egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');

close(ff_unit);
/* call routine for preparing sampling data */
emin = exp((1 - ge0(medium))/ge1(medium));
emax = exp((mge(medium) - ge0(medium))/ge1(medium));
call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
                             mge(medium),emin,emax,
                             pe_array(1,medium),$RAYCDFSIZE,
                             fcum(1,medium),i_array(1,medium),
                             b_array(1,medium),c_array(1,medium));

/* prepare coefficients for pmax interpolation */
ne=MGE(medium);
DO i=1,ne-1 [
   gle = (i - ge0(medium))/ge1(medium);
   pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
   pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
]
pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);

return; end;

/**********************************************************
   Analytic expression of the Rayleigh xsection in barns.
 **********************************************************/
$REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
$IMPLICIT-NONE;
$INTEGER i, j, k,imed, ndat;
$REAL hc2,conv,b,hc;
parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
           hc2 = 0.0001537222280); "h*c squared"
$REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
egs_rayleigh_sigma = 0.0;
DO i=1,ndat-1[
   IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
   IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
   b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
   x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
   pow_x1=x1**(2*b);pow_x2=x2**(2*b);
   raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
   raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
   raysig = raysig*f(i)*f(i)/pow_x1;
   egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
   IF(x(i+1)>xmax)[EXIT;]"exit loop"
]
/*totRayleigh = 2.*Pi*R02*1E24*C*totRayleigh;"in barns"
 2*Pi*Ro^2*1E24 = 0.49893439187842413747
 */
egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
return;
end;
/******************************************************
   Rayleigh run time sampling routine
 *******************************************************/
subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
$IMPLICIT-NONE;
$declare_max_medium;
real*8 e;
$REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
$REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
parameter(hc_i=80.65506856998,      "h*c inverse"
          twice_hc2=0.000307444456);"2*(hc)^2"
          "h*c=0.0123984768438 [Armstrong]*[MeV]"
$INTEGER lgle,ib,ibin,medium, trials;
;COMIN/RANDOM,rayleigh_sampling/;
dwi = $RAYCDFSIZE-1;
$EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
LOOP [
    $RANDOMSET rnnray1;
    LOOP [
        $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
        ibin = 1 + rnnray0*dwi; /* rnno = rnno + 1 - ibin; */
        ib = i_array(ibin,medium);
        IF( i_array(ibin+1,medium) > ib ) [
          LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
        ]
        rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
        xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
    ] UNTIL (xv < xmax);
    xv = xv/e;
    costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
] UNTIL ( 2*rnnray1 < 1 + csqthe );
sinthe=sqrt(1.0-csqthe);
return;
end;
/******************************************************
   Prepares Rayleigh run time sampling data
 *******************************************************/
subroutine prepare_rayleigh_data(ndat,x,f,
                                 ne,emin,emax,pe_array,
                                 ncbin,fcum,i_array,
                                 b_array,c_array);
$IMPLICIT-NONE;

/******* input F (form factor) data ********************************/
$INTEGER    ndat;         " number of F data points "
$REAL       x(ndat),      " x values of F data "
            f(ndat);      " F data "

/******* energy range to initialize ********************************/
$INTEGER    ne;           " number of energy bins "
$REAL       emin,         " minimum photon energy (i.e. AP(medium))"
            emax,         " maximum photon energy (i.e. UP(medium))"
            pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
                          " i.e., pe_array(E) = fcum(xmax(E))      "


/******* cumulative distribution **********************************/
$INTEGER    ncbin;          " number of cumulative bins (input)"
$REAL       fcum(ndat);     " cumulative distribution (output)"
$INTEGER    i_array(ncbin); " original data bin in which the i'th "
                            " cumulative bin edge falls.          "

/******* sampling data ********************************************/
$REAL       b_array(ndat),  " F interpolation coefficient "
            c_array(ndat);  " needed for sampling at run time "

$REAL zero;

real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
       anorm,anorm1,anorm2,w,dw,xold,t,aux;
$INTEGER i,j,k,ibin;

;COMIN/USEFUL/;

write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';

/* this to avoid NAN in the log(f(i)) below */
DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]

/**********************************************************
 *
 * Calculate the cumulative distribution
 *
 *********************************************************/
sum0=0; fcum(1)=0;
DO i=1,ndat-1 [
    b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
    x1 = x(i); x2 = x(i+1);
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
    fcum(i+1) = sum0;
]

/*************************************************************
 *
 * Now the maximum cumulative probability as a function of
 * incident photon energy. We have xmax = 2*E*20.60744/m, so
 * pe_array(E) = fcum(xmax)
 *
 **************************************************************/
dle = log(emax/emin)/(ne-1); i = 1;
DO j=1,ne [
    e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
    DO k=i,ndat-1 [
        IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
    ]
    i = k; b = b_array(i);
    x1 = x(i); x2 = xmax;
    pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
    pe_array(j) = fcum(i) +
      f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
]
i_array(ncbin) = i;

/***********************************************************************
 *
 * Now renormalize data so that pe_array(emax)=1
 * Note that we make pe_array(j) slightly larger so that fcum(xmax) is
 * never underestimated when interpolating
 *
 ***********************************************************************/
anorm = 1d0/sqrt(pe_array(ne));
anorm1 = 1.005d0/pe_array(ne);
anorm2 = 1d0/pe_array(ne);
DO j=1,ne [
    pe_array(j) = pe_array(j)*anorm1;
    IF( pe_array(j) > 1 ) pe_array(j) = 1;
]
DO j=1,ndat [
    f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
    c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
]

/***********************************************************************
 *
 * Now prepare uniform cumulative bins
 *
 ***********************************************************************/
dw = 1d0/(ncbin-1);
xold = x(1); ibin = 1;
b = b_array(1);
pow_x1 = x(1)**(2*b);
i_array(1) = 1;
DO i=2,ncbin-1 [
    w = dw;
    LOOP [
        x1 = xold; x2 = x(ibin+1);
        t = x1*x1*x1**(2*b);
        pow_x2 = x2**(2*b);
        aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
        IF( aux > w ) [
            xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
            i_array(i) = ibin;
            EXIT;
        ]
        w = w - aux; xold = x2; ibin = ibin+1;
        b = b_array(ibin); pow_x1 = xold**(2*b);
    ]
]

/*************************************************************************
 *
 * Change definition of b_array because that's what is needed at run time
 *
 **************************************************************************/
DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]


write(*,'(a /)') 'done';

return; end;

"============================================================================="
$REAL function egs_KN_sigma0(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm;
IF( ko < 0.01 ) [
    egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
    return;
]
c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
                eps1*(c3+0.5*eps1))/e*con;
return; end;

"============================================================================="
$REAL function egs_KN_sigma1(e);
"=========================================================================="
implicit none;
$REAL    e;
$REAL    con,ko,c1,c2,c3,eps1,eps2;
data     con/0.1274783851/;
;COMIN/USEFUL/;
ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
eps2 = 1; eps1 = 1./(1+2*ko);
egs_KN_sigma1 = c1*(1./eps1-1./eps2);
egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
egs_KN_sigma1 = egs_KN_sigma1 +
         (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
egs_KN_sigma1 = egs_KN_sigma1*con;
return; end;

"============================================================================="
subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
COMIN/EGS-IO/;
$REAL    eth;
$INTEGER flag,iunit,n,ne;
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    etmp($MXINPUT),ftmp($MXINPUT);
$REAL    gle,sig,p,e;
$INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;

;COMIN/USEFUL/;

"Ali:photonuc. The whole routine is commented out and re-written
"to accommodate reading photonuclear cross sections. A copy of the
"commented original routine is at the bottom.
" flag = 0: photoelectric, Rayleigh, Compton
" flag = 1: pair
" flag = 2: triplet
" flag = 3: photonuclear

rewind(iunit);
iz_old = 0;
DO k=1,n [ data(k) = 0; ]
DO i=1,ne [
    iiz = int(zsorted(i)+0.5);
    DO iz=iz_old+1,iiz [
        read(iunit,*,err=:user-data-failure:) ndat;
        IF( ndat > $MXINPUT ) [
            $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
        ]
        IF( flag = 0 | flag = 3) [
            read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
        ]
        ELSE [
            read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
                k=1,ndat);
            IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
            ndat = ndat + 1;
            DO k=2,ndat [
                ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
            ]
            ftmp(1) = ftmp(2); etmp(1) = log(eth);
        ]
    ]
    iz_old = iiz;
    DO k=1,n [
        gle = (k - ge0)/ge1; e = exp(gle);
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            IF( flag = 0 ) [
                $egs_fatal(*,'Energy ',exp(gle),
                   ' is outside the available data range of ',
                   exp(etmp(1)),exp(etmp(ndat)));
            ]
            ELSEIF (flag = 1 | flag = 2) [
                IF( gle < etmp(1) ) [ sig = 0; ]
                ELSE [ sig = exp(ftmp(ndat)); ]
            ]
            ELSE [ "photonuclear, zero it before and after
             sig = 0;
            ]
        ] ELSE [
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            IF( flag ~= 3) ["log/log interpolation"
               p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
            ]
            ELSE["lin/lin interpolation for photonuc"
               p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
            ]
        ]
        IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
        data(k) = data(k) + pz_sorted(i)*sig;
    ]
]

return;

:user-data-failure:;
$egs_fatal(*,'Error while reading user photon cross sections from unit ',
     iunit);

return; end;

/*****************************************************************
   Prepare photoelectric cross section data base for medium imed
   on same energy grid as for the other photon interactions.
   Normalize elemental PE cross sections to medium cross section
   to use for selecting element the photon interacts with.
 *****************************************************************/
"============================================================================="
subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
"=========================================================================="
implicit none;
$declare_max_medium;
;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
$INTEGER n,   "number of data points requested"
         ne,  "number of elements in medium"
         ndat;"number of data points from original grid"
$REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
$REAL    sigma($MXNE),sigmaMedium;
"$INTEGER sorted(*);
real*4    etmp($MXINPUT),ftmp($MXINPUT);
real*4    gle,sig,p;
$INTEGER i,j,k,kk,iz,zpos,imed;

DO k=1,n  [ data(k)  = 0;]
DO k=1,ne [ sigma(k) = 0;]
DO i=1,ne [
    iz = int(zsorted(i)+0.5);
    zpos = pe_zpos(iz); ndat = pe_nge(zpos);
    "Total cross sections for a given element"
    "on initial energy grid"
    DO k=1,ndat[
       pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
       "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
       etmp(k) = pe_energy(k,zpos);
       ftmp(k) = log(pe_xsection(k,zpos,0));
    ]
    "Total cross sections for a given element"
    "on requested energy grid"
    DO k=1,n [
        gle = (k - ge0)/ge1;
        IF( gle < etmp(1) | gle >= etmp(ndat) ) [
            $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
                         ' is outside the available data range of ',
                         exp(etmp(1)),exp(etmp(ndat)));
        ] ELSE [
            "Find energy interval gle falls in"
            DO kk=1,ndat-1 [
                IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
            ]
            "log/log interpolation"
            p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
            sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
        ]
        data(k) = data(k) + pz_sorted(i)*sig;
        "data(k) = data(k) + pz(imed,sorted(i))*sig;
    ]
]
"Normalize elemental cross section to medium cross section"
"Prepare for log/log interpolation"
DO i=1,ne [
   iz = int(zsorted(i)+0.5);
   zpos = pe_zpos(iz); ndat = pe_nge(zpos);
   DO k=1,ndat[
      sig = sigmaMedium(imed,pe_energy(k,zpos));
      pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
   ]
]

return; end;

/***************************************************************
   Calculate photoelectric cross section for medium imed using
   log/log linear interpolation and binary search to find energy
   interval
 ***************************************************************/
$REAL function sigmaMedium(imed, logE);

implicit none;
$declare_max_medium;
;COMIN/BREMPR,PE-SHELL-DATA/;
$REAL logE, slope, sigma;
$INTEGER k,imed,Z,zpos,m,ibsearch;

sigmaMedium = 0;
DO k=1,nne(imed) [
   Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
   m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
   slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
   slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
   sigma = log(pe_xsection(m,zpos,0));
   sigma += slope*(logE - pe_energy(m,zpos));
   sigma = exp(sigma);
   sigmaMedium += pz(imed,k)*sigma;
]
return; end;

"============================================================================="
subroutine egs_heap_sort(n,rarray,jarray);
"************************************************************************
"  egs_heap_sort will sort the real array rarray of dimension n in
"  ascending order and at the same time put into the integer array
"  jarray the original position of the elements, e.g.
"  if rarray was on input (5,14,8,2), it will be after completion
"  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
"  heap_sort uses the heap sort algorithm, the implementation is
"  based  on hpsort from Numerical Recipies with a couple of
"  modifications.
"
"  Iwan Kawrakow, NRC, July 2001
"*************************************************************************

implicit none;

$INTEGER n,jarray(*);
$REAL    rarray(*);
$INTEGER i,ir,j,l,ira;
$REAL    rra;

DO i=1,n [ jarray(i)=i; ]
IF (n < 2) return;
l=n/2+1; ir=n;

LOOP [
   IF (l > 1)  [
       l=l-1; rra=rarray(l); ira=l;
   ]
   ELSE [
       rra=rarray(ir); ira=jarray(ir);
       rarray(ir)=rarray(1); jarray(ir)=jarray(1);
       ir=ir-1;
       IF (ir = 1) [
           rarray(1)=rra; jarray(1)=ira; return;
       ]
   ]
   i=l; j=l+l;
   LOOP [
       IF( j > ir ) EXIT;
       IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
       IF (rra < rarray(j)) [
           rarray(i)=rarray(j); jarray(i)=jarray(j);
           i=j; j=j+j;
       ] ELSE [ j=ir+1; ]
   ]
   rarray(i)=rra; jarray(i)=ira;
]
return; end;

%E
"Ali:photonuc, 1 subroutine"
"******************************************************************"
SUBROUTINE PHOTONUC;
"******************************************************************"
" Placeholder for photonuclear modelling. Currently the photon is
" discarded and its energy is thrown away (i.e. not deposited).
"******************************************************************"
$IMPLICIT-NONE;
$COMIN-PHOTONUC; "current default replacement is:
                 "COMIN/STACK,EPCONT,USEFUL/"
$DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"

npold = np; "set the old stack counter"
edep = pzero; e(np) = pzero; wt(np) = 0;

return;
end;
"******************************************************************"
