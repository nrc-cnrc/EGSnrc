%C80
"#############################################################################"
"                                                                             "
"  EGSnrc xoshiro256++ random number generator                                "
"  Copyright (C) 2024 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Ernesto Mainegra-Hing, 2024                               "
"                                                                             "
"                                                                             "
"  Contributors:                                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Sum-rotate-sum scrambled linear pseudorandom number generator (64-bit).    "
"                                                                             "
"  This fast generator has a state space that is large enough for any parallel" 
"  application, and passes all tests the authors were aware of.               "
"  It notably passes the powerful BigCrush suite of tests, a comprehensive    "
"  testing framework for pseudo random number generators (PRNGs) developed by "
"  Pierre L'Ecuyer and Richard Simard. Since simple operations are used, it   "
"  can be easily parallelized. Although xoshiro256++ is just 3-dimensionally  "
"  equidistributed, this has no practical effect. On the other hand, the bits "
"  have high linear complexity due to the strong ++ scrambler(sum-rotate-sum)."
"                                                                             "
"  Footprint (bits): 256     Period: 2**256 - 1                               "
"                                                                             "
"  References:                                                                "
"                                                                             "
"  D. Blackman and S. Vigna.  ACM Trans.Math.Softw., 47:1-32, 2021            "
"  P. L'Ecuyer and R. Simard. ACM Trans.Math.Softw., 33(4), Article 22, 2007  "
"                                                                             "
"#############################################################################"
#define RNGSIZE $RNGSIZE
%Q1
%F
      !> Returns real normalized random number U(0,1)
      function unif01() result(res_f)
        implicit none

        !> Inverse of largest integer
        real*8 :: twom53
        common/constant/twom53

        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8 :: s
     
        integer*8 :: s_loc(4)
        integer*8 :: t
        integer*8 :: res
        real*8    :: res_f
    
        s_loc = s
        
        !> Sum, left-rotation and sum
        res = ior(shiftl(s_loc(1) + s_loc(4), 23),  
     >            shiftr(s_loc(1) + s_loc(4), 41)) + 
     >            s_loc(1)
    
        ! Convert to real
        res_f = shiftr(res, 11)*twom53
    
        t = shiftl(s_loc(2), 17)
    
        s_loc(3) = ieor(s_loc(3), s_loc(1))
        s_loc(4) = ieor(s_loc(4), s_loc(2))
        s_loc(2) = ieor(s_loc(2), s_loc(3))
        s_loc(1) = ieor(s_loc(1), s_loc(4))
            
        s_loc(3) = ieor(s_loc(3), t)
    
        !> Left-rotation
        s_loc(4) = ior(shiftl(s_loc(4), 45),  
     >                 shiftr(s_loc(4), 19))
        
        s = s_loc
    
      end function unif01

      !> Get the next value (returned as 64 bit signed integer)
      !  From: https://prng.di.unimi.it/xoshiro256pplus.c
      function next()
        implicit none

        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8  :: s
        integer*8  :: next, t
        integer*8  :: s_loc(4)
        
        s_loc = s
            
        !> Sum, left-rotation and sum
        next = ior(shiftl(s_loc(1) + s_loc(4), 23),  
     >            shiftr(s_loc(1) + s_loc(4), 41)) + 
     >            s_loc(1)
        
        t = shiftl(s_loc(2), 17)
        
        s_loc(3) = ieor(s_loc(3), s_loc(1))
        s_loc(4) = ieor(s_loc(4), s_loc(2))
        s_loc(2) = ieor(s_loc(2), s_loc(3))
        s_loc(1) = ieor(s_loc(1), s_loc(4))
                
        s_loc(3) = ieor(s_loc(3), t)
        
        !> Left-rotation
        s_loc(4) = ior(shiftl(s_loc(4), 45),  
     >                 shiftr(s_loc(4), 19))
            
        s = s_loc
      
      end function next

      subroutine fill_rng_array
        implicit none
        common/rndarray/rnd_int(RNGSIZE), rnd_ptr
        integer*8 :: rnd_int
        integer*4 :: rnd_ptr, i
        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8  :: s
        integer*8  :: t, next
        integer*8  :: s_loc(4)

        rnd_ptr = 1

        s_loc = s

        do i=1,RNGSIZE
          !rnd_int(i) = next()
          rnd_int(i) = ior(shiftl(s_loc(1) + s_loc(4), 23),  
     >                     shiftr(s_loc(1) + s_loc(4), 41)) + 
     >                            s_loc(1)
          t = shiftl(s_loc(2), 17)
          s_loc(3) = ieor(s_loc(3), s_loc(1))
          s_loc(4) = ieor(s_loc(4), s_loc(2))
          s_loc(2) = ieor(s_loc(2), s_loc(3))
          s_loc(1) = ieor(s_loc(1), s_loc(4))
          s_loc(3) = ieor(s_loc(3), t)
          s_loc(4) = ior(shiftl(s_loc(4), 45),  
     >                   shiftr(s_loc(4), 19))
        end do

        s = s_loc

      end subroutine fill_rng_array


      ! This is the jump function for the generator. It is equivalent
      ! to 2^64 calls to next(); it can be used to generate 2^64
      ! non-overlapping subsequences for parallel computations.
      subroutine jump
        implicit none    
        ! A 64 bit integer type
        integer, parameter :: i8 = selected_int_kind(18)
        !> Current rng state (seeds)
        common/randomm/s(4)
        integer*8 :: s
        integer   :: i, b
        integer*8 :: t(4), next, dummy
        ! The signed equivalent of the unsigned constants
        integer*8, parameter :: jmp_c(4) = (/1733541517147835066_i8,
     +                                      -3051731464161248980_i8, 
     +                                      -6244198995065845334_i8,
     +                                       4155657270789760540_i8/)
        
        t = 0
        do i = 1, 4
           do b = 0, 63
              if (iand(jmp_c(i), shiftl(1_i8, b)) /= 0) then
                 t = ieor(t, s)
              end if
              dummy = next()
           end do
        end do
                         
        s = t
        
      end subroutine jump
            
      !> Set a seed for the rng
      subroutine set_seed(the_seed)
        implicit none
      
        !Inverse of largest integer
        common/constant/twom53
        real*8 :: twom53
      
        ! Current rng state (seeds)
        common/randomm/s(4)
        integer*8 :: s
        integer*8 :: the_seed(4)
      
        s = the_seed
        
        !Perform calls to next() to improve randomness of initial state
        call jump
      
        twom53 =  1.0/2.0**53

        call fill_rng_array
      
      end subroutine set_seed

      !> Returns current seeds
      subroutine get_state( state )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer*8 :: state(4)
        state = s
      end subroutine get_state

      !> Reset current seeds
      subroutine set_state( state )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer*8 :: state(4)
        s = state
      end subroutine set_state
      
      !> Output current seeds to ounit with fixed format
      subroutine show_seeds( ounit )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer ounit
        write(ounit,"(4(/a,i0))") " s(1) = ",s(1)," s(2) = ",s(2),
     +                           " s(3) = ",s(3)," s(4) = ",s(4)
      end subroutine show_seeds

      !> Output current seeds to ounit with fixed format
      subroutine print_seeds( ounit, fmt )
        implicit none
        common/randomm/s(4)
        integer*8 :: s
        integer   :: ounit
        character *(*) fmt
        write(ounit,fmt) s
      end subroutine print_seeds
%M
;
