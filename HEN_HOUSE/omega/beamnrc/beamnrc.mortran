%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc core source code                                            "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Dave Rogers, 1995                                         "
"                                                                             "
"  Contributors:    Rock Mackie                                               "
"                   Alex Bielajew                                             "
"                   Bruce Faddegon                                            "
"                   George Ding                                               "
"                   Charlie Ma                                                "
"                   Jiansu Wei                                                "
"                   Blake Walters                                             "
"                   Geoff Zhang                                               "
"                   Daryoush Sheikh-Bagheri                                   "
"                   Jiangshen Sun                                             "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Frederic Tessier                                          "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%Q1
%C80
!INDENT F4;
!INDENT M4;
;
REPLACE {$BEAM_VERSION}
WITH {,'Vnrc(Rev 1.78 of 2004-01-12 11:44:06-05)',}
;
"*****************************************************************************
"*****************************************************************************
"
"                             *************                            ""toc:
"                             *           *                            ""toc:
"                             * BEAMnrc   *                            ""toc:
"                             *           *                            ""toc:
"                             *************                            ""toc:
"                                                                      ""toc:
"*******************************************************************************
"*******************************************************************************
;
;
"                          GENERAL DESCRIPTION                         ""toc:
"                          *******************
"
"   The code is used to determine the full phase-space spectra of electrons,
"   photons, and positrons that are produced by  a radiotherapy unit.
"   The output spectrum file can be used as a source input file to either
"   BEAMnrc or various other routines, in particular, DOSXYZnrc. The latter code
"   is used to determine 3-D dose distributions in arbitrary voxel geometries.
"
"   This code system is designed to work under the standard NRC Unix
"   system for running EGSnrc but needs extended buffers in MORTRAN3.

"   The names of the additional MORTRAN files required to complete this code
"   are listed in beamnrc.configuraion.
"
"   This code is maintained un SCCS control and a complete history of
"   changes is available via that utility.
"
"   The code is kept on $OMEGA_HOME/beam.
"
"*******************************************************************************
;
"                            ROUTINES CALLED                           ""toc:
"                            ***************
"
"   User-written routines common to all component modules:
"       HOWFAR, INPUTS, ISUMRY, OSUMRY, ISOURCE, MXRNGE, SRCHST, SRCOTO,
"       SRCOUT, WHERE_AM_I.
"   These routines are all contained in this file along with AUSGAB, which is
"   called from various EGSnrc routines.
"
"   User-written routines needed for each component module:
"       INPUT_$CMNAME, ISUMRY_$CMNAME, HOWFAR_$CMNAME, WHERE_AM_I_$CMNAME.
"   $CMNAME is a 1-8-character alphanumeric tag which uniquely defines a
"   component module. These routines are contained in $CMNAME_cm.mortran.
"   Associated macros are in $CMNAME_macros.mortran.
"
"   EGSnrc routines:
"       HATCH, SHOWER, SIGMA, WATCH.
"
"*******************************************************************************
"
"                                IO Units                              ""toc:
"                               ********
"
"        Unit number  file
"
"       1    listing file for user
"       2    state of random no. generator at start of history(ISTORE non-zero)
"       3    ploting file
"       4    stored scoring arrays written end each batch for restart
"       5    user input from keyboard or input file
"       6    echo of user input / log file
"       7    echo of input file - for restart or creating a file interactively
"       8    EGSnrc echos the cross section data read in to this unit
"      17    EGS_windows geometry file
"      12    HATCH reads the cross section data prepared by PEGS4 from this unit
"      13    EGS_windows file  for graphical display particle histories
"      15    File for output of EGSnrc input warnings/errors
"      42    input phase space file
"      44    output phase space data
"      45    output phase space data
"      46    output phase space data
"      99    input energy spectrum  (file named & opened internally)
"
"      Unit numbers are associated with file names at run time via
"      $OMEGA_HOME/beamnrc/beamnrc.environment
"
"*******************************************************************************
;
"                                COMMONS USED                          ""toc:
"                                ************
"
"   The MAIN routine requires the following common blocks.  A * indicates that
"   MORTRAN replacement macros are used in BEAMnrc or $CMNAME_macros to define
"   the common.
"
"   Common blocks written specifically for BEAMnrc:
"      CMs*, CM_$CMNAME*, ENERGYSRC, GEOM, IO_INFO, SCORE, SOURCE,
"      USER*.
"   One common block /CM_$CMAME/ is associated with each component module. These
"   common blocks are intended to be used together.  Variable names in
"   /CM_$CMNAME/ all end with _$CMNAME.
"   MORTRAN replacement macros for the component module common blocks
"   reside in $CMNAME_macros.mortran.
"   The common block USER is comprised of the following common blocks:
"     USER-PHOTON-FORCING* -- photon forcing variables
"     USER-RANGE-REJECTION* -- range rejection variables
"     USER-SPLITTING* -- variables for arbitrary splitting (some global
"                        variables for bremsstrahlung splitting and rus. rou.)
"     USER-STACK* -- additional variables that must be added to the stack
"
"   Common blocks also used by other OMEGA-BEAM user codes:
"      BMODEL*, RWPHSP.
"         BMODEL -- variables for beam characterization models.  Stored
"                   in beammodel_macros.mortran, but replaced by ;
"                   (from beamnrc_user_macros.mortran) if beammodel_macros.
"                   mortran is not available.
"         RWPHSP -- variables for handling phase space data.  Stored in
"                   phsp_macros.mortran.
"
"   EGSnrc common blocks:
"      BOUNDS, BREMPR, EDGE, ELECIN, EPCONT, MEDIA, MISC, PHOTIN, STACK,
"      THRESH, UPHIOT, USEFUL, RANDOM.
"
"*******************************************************************************
;
"                                 KNOWN BUGS/RESTRICTIONS
"                                 **********
"
"  RESTRICTIONS discussed in manuals etc
"
"*******************************************************************************
"*******************************************************************************
;
"                            DESCRIPTION OF VARIABLES                  ""toc:
"                            ************************
"
"
"  Each variable in the common blocks is defined on a line containing the
"  character sequence 'V>'.
"
"  Each local variable is defined on a line that contains the character
"  sequence 'T>'.
"
;
"*******************************************************************************
"I>
"I>                     FORMAT OF PARAMETER-DEFINITION(input) FILE     ""toc:
"I>                     ******************************************     ""toc:
"
"  This section describes the variables input from the parameter-definition
"  file, FORTRAN unit 5, file extension of '.egs4inp'.  These variables
"  define the parameters specific to each simulation.  Each line in this
"  section and the related sections in the component module subroutines
"  is preceeded with the character sequence 'I>'.
"
"I>                       GENERAL INPUT/OUTPUT PARAMETERS
"I>                       *******************************
"I>
"I>  First record    TITLE   80A1
"I>  ************
"I>
"I>  Next Record  MEDIUM for nominal air (as in pegs4dat file)
"I>  ***********
"I>               In many CMs, the region about the central-axis or at the
"I>               front or back of the CM, is assumed to be this medium.
"I>               It is thought of and refered to as air, but can be anything.
"I>               Default is VACUUM. MEDIUM must exactly match name in pegs4dat
"I>-----------------------------------------------------------------------------
;
"%A00
"I>  Next Record
"I>  ***********
"I>     IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION,IZLAST
"I>
"I>             IWATCH = 0 for normal output (the default)
"I>                    = 1 output for every discrete interaction
"I>                    = 2 output for every electron/photon step as well
"I>                    = 4 outputs file for graphics
"I>                    = -N set to 2 on history N, set to 0 on all other
"I>                         histories (for debugging purposes)
"I>             ISTORE = 0 store rn seeds for the 1st history of a batch
"I>                    = 1 store initial rn status (unit 2) for each history
"I>                        being simulated
"I>                    =-1 start first history with rn status from file (unit 2)
"I>                        This is a debugging tool. If run quits, rerun with
"I>                        ISTORE=1, then again ISTORE=-1 and IWATCH = 1/2
"I>                        and/or the debugger on.
"I>           IRESTART = 0 first run for this data set (the default)
"I>                    = 1 restart of a previous run
"I>                    = 2 just create the input file and exit
"I>                    = 3 read in the raw data from a previous run and do
"I>                       the statistical analysis on dose etc.
"I>                    = 4 read in the .egsdat files from parallel jobs
"I>                        having the same base name as the input file but
"I>                        with the extension _w#, where #
"I>                        can be any positive integer.  These .egsdat files
"I>                        will be summed and then the result analyzed similar
"I>                        to IRESTART=3.
"I>             IO_OPT = 0 phase-space output at each scoring plane(the default)
"I>                    = 1 no phase-space output when particles cross scoring
"I>                        plane
"I>                    = 2 no phase-space output but do data analysis for
"I>                        simplified source models
"I>                    = 3 phase-space output up to 100 k particle histories
"I>                        then do analysis only for simplified source models
"I>                    = 4 output phase space in IAEA format
"I>             IDAT   = 0 store data arrays for re-use (takes time but safer)
"I>                    = 1 don't store them
"I>      LATCH_OPTION  = 0 defaults to 2
"I>                    = 1 LATCH for secondaries not inherited from primaries
"I>                        Bits 1-23 set for all regions particle is in
"I>                    = 2 LATCH bits set for all regions particle is in
"I>                        and inherited by secondaries
"I>                        also record bit regions where secondaries created
"I>                        and whether they were created by brem photons
"I>                    = 3 = option 2 but the region numbers are recorded
"I>                        for photons where they interact rather than where
"I>                        they pass through
"I>            IZLAST  = 0 do not score ZLAST etc. (the default)
"I>                    = 1 score the z-position of the last site of interaction
"I>                        for photons and creation of electrons by a photon.
"I>                    = 2 score the xyz-position of the last site of
"I>                        interaction in the file $.egs4gph to be used by
"I>                        EGS_WINDOWS. IWATCH=4 must not be used at same time.
"I>                        Note that for phase space inputs, ZLAST is passed
"I>                        through, but XLAST and YLAST are not.
"I>----------------------------------------------------------------------------
;
"%A01
"I>  Next Record            MONTE CARLO CONTROL INPUT
"I>  ***********            *************************
"I>
"I>     NCASE,IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT
"I>             NCASE  = # of histories to run for this simulation
"I>                      (min:$NCASEMIN = 100 for IWATCH=0)
"I>             IXXIN  = 1st random number initial seed (blank or 0 OK)
"I>                      Note that, if using the ranlux random no. generator,
"I>                      this input is the luxury level and should have a
"I>                      value >=0 and <=4.  Otherwise, a default luxury
"I>                      level of 1 will be used.
"I>             JXXIN  = 2nd random number initial seed (blank or 0 OK)
"I>             TIMMAX = max cpu time allowed for this run in hours
"I>                      (default=0.99)
"I>             IBRSPL = 0 no brem splitting
"I>                    = 1 with uniform brem splitting
"I>                    = 2 with directional bremsstrahlung splitting (DBS)
"I>             NBRSPL = brem splitting number AND
"I>                      annihilation splitting number (if IRRLTT=2)
"I>             IRRLTT = 0 no Russian Roulette (the default).  Also, no
"I>                        annihilation or higher-order splitting.
"I>                    = 1 no longer used.  This defaults to IRRLTT=2
"I>                    = 2 perform Russian Roulette--eliminates all but one
"I>                        of secondary charged particles created by split
"I>                        photons.
"I>                        If the surviving particle undergoes another (higher-
"I>                        order) bremsstrahlung event or an annihilation,
"I>                        resulting photons are split again by NBRSPL for
"I>                        IBRSPL=1. (ie uniform splitting)
"I>
"I>             Note: The input IRRLTT is automatically set to 0 if IBRSPL=2
"I>                   This is because Directional Bremsstrahlung Splitting
"I>                   does not use the built-in Russian Roulette of EGSnrc
"I>
"I>          ICM_SPLIT = 0 no splitting of photons and electrons as they cross
"I>                        a plane at the start of a user-specified CM
"I>                    > 0 Split photons and electrons a user-specified number
"I>                        of times as soon as they cross the arbitrary
"I>                        splitting plane at the top of this CM #.
"I>
;
"I>  Next record (if IBRSPL=2)
"I>  ***********
"I>
"I>     FS,SSD,ICM_DBS,ZPLANE_DBS,IRAD_DBS,ZRR_DBS  (6F12.0)
"I>                 FS = radius of field (cm) into which bremsstrahlung photons
"I>                      must be directed if they are to be split.
"I>                SSD = distance from bremsstrahlung target where FS
"I>                      is defined.
"I>        ICM_DBS and   These are only required to define the splitting
"I>                      plane if IBRSPL=2.  As soon as
"I>         ZPLANE_DBS   a fat electron reaches ZPLANE_DBS within CM number
"I>                      ICM_DBS, it gets split NBRSPL times.  This is designed
"I>                      to improve electron statistics in the current
"I>                      implementation of directional bremsstrahlung
"I>                      splitting (DBS).  If ICM_DBS=0, then no electron
"I>                      splitting is done (recommended if only good photon
"I>                      statistics are required).  Note that ZPLANE_DBS is
"I>                      the index of the plane within ICM_DBS, not the Z
"I>                      position of the plane.  Usually, ICM_DBS will
"I>                      be the CM number of the flattening filter in the
"I>                      accelerator.  If this is modelled using FLATFILT
"I>                      or CONESTAK, then ZPLANE_DBS will denote the layer
"I>                      no. (starting from the top).  If the flattening
"I>                      filter is modelled using CONS3R, then only two
"I>                      planes are available: ZPLANE_DBS=1 is the plane
"I>                      at the top of the structure and ZPLANE_DBS=2 is the
"I>                      plane at the bottom of the structure.  Currently,
"I>                      only FLATFILT, CONESTAK and CONS3R support these
"I>                      inputs.  Usually ZPLANE_DBS is the plane defining the
"I>                      bottom of the flattening filter.
"I>           IRAD_DBS   Set to 1 if you want the NBRSPL split electrons
"I>                      to be distributed in a radially-symmetric manner
"I>                      about the beam axis.  Note that the beam must be
"I>                      radially symmetric above the splitting plane for this
"I>                      to make sense.  Set to 0 (the default) otherwise.
"I>           ZRR_DBS    Z position of the russian roulette plane (cm).  Only
"I>                      required if IBRSPL=2.  This defines the Z
"I>                      position of a plane within the geometry below which
"I>                      non-fat photons about to undergo a compton, pair
"I>                      or photoelectric event will NOT be subject to
"I>                      russian roulette and compton, pair or photoelectric
"I>                      events from fat photons will be split NBRSPL times.
"I>                      This is designed to increase the number of electrons
"I>                      (albeit with a lower weight) below this plane and
"I>                      is only used if electron splitting is on (ie
"I>                      ICM_DBS above is > 0).  Note that radiative events
"I>                      (bremsstrahlung, annihilation) of non-fat electrons
"I>                      below this plane are not split. Usually, the Russian
"I>                      Roulette plane is above the electron splitting plane,
"I>                      and so it is within the flattening filter
"I>                      but somewhere above the bottom.  Note that ZRR_DBS is
"I>                      in cm whereas the electron splitting plane must be
"I>                      on a horizontal boundary in a CM.
"I>
"I>  Next record (if ICM_SPLIT>0)
"I>  ***********
"I>
"I>     NSPLIT_PHOT,NSPLIT_ELEC (2I3)
"I>            NSPLIT_PHOT = The photon splitting number.
"I>            NSPLIT_ELEC = The electron splitting number.
"I>     This input is unrelatted to bremm splittin and is designed to improve
"I>     efficiency in phantom depth-dose calculations.
"I>------------------------------------------------------------------------
;
"%A02
"I>
"I>                SOURCE GEOMETRICAL CONFIGURATION INPUT
"I>                **************************************
"I>
"I>  Next Record  specifies charge and type of source of incident particles
"I>               The meaning of parameters depends on source type
"I>
"I>  ISOURC = 0   PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS)
"I>  **********
"I>
"I>     IQIN,ISOURC,RBEAM,UINC,VINC,WINC
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  0
"I>             RBEAM   radius of parallel beam in cm (defaults to max radius
"I>                     if RBEAM < 0 or > max radius
"I>                     max radius =RMAX_CM(1) for circular CM boundary
"I>                                =RMAX_CM(1)*SQRT(2) for square CM )
"I>             UINC    incident x-axis direction cosine
"I>             VINC    incident y-axis direction cosine
"I>             WINC    incident z-axis direction cosine
"I>                     Note: (UINC,VINC,WINC) get automatically normalized
"I>                           defaults to (0.0,0.0,1.0)
"I>------------------------------------------------------------------------
;
"%A03
"I>  ISOURC = 1   POINT SOURCE ON Z-AXIS INCIDENT FROM THE FRONT
"I>  **********                circular or square
"I>
"I>     IQIN,ISOURC,DISTZ,RBEAM,GAMMA,XINL,XINU,YINL,YINU
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  1
"I>             DISTZ   distance of the point source above front of first
"I>                     CM at Z=Z_min_CM(1). Defaults to  100 cm
"I>             RBEAM   radius of the beam on front of first CM
"I>                     defaults to max radius of first CM if GAMMA is also 0.
"I>                     or:
"I>                     If negative, denotes that that field on front of
"I>                     first CM is rectangular
"I>             GAMMA   1/2 angle about z-axis(degrees) of source,
"I>                     ONLY if RBEAM=0.0
"I>             XINL,XINU,YINL,YINU  Lower and upper X boundaries and
"I>                     Y boundaries of rectangular field on first CM in
"I>                     cm.  ONLY if RBEAM<0.
"I>------------------------------------------------------------------------
;
"%A04
"I>  ISOURC = 3  UNIFORM ISOTROPICALLY RADIATING SOURCE WITHIN CMs
"I>  **********        Circular: Vertical ring centred on Z-axis
"I>                       or     horizontal cylinder centred parallel to X-axis
"I>
"I>     IQIN,ISOURC,RMINBM,RBEAM,ZSMIN,ZSMAX,i_dsb,splitcm_dsb,dsb_delta
"I>             IQIN    charge of particles from source (defaults to 0)
"I>             ISOURC  =  3
"I>             RMINBM  inner radius of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     Z position of centre of horizontal cylinder
"I>                     (RBEAM < 0) (cm)
"I>             RBEAM   outer radius of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     -radius of horizontal cylinder (RBEAM < 0) (cm)
"I>             ZSMIN   Z of top of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     min. X of horizontal cylinder (RBEAM < 0) (cm)
"I>             ZSMAX   Z of bottom of vertical ring (RBEAM >= 0) (cm)
"I>                     or:
"I>                     max. X of horizontal cylinder (RBEAM < 0) (cm)
"I>             i_dsb   Set to 1 to use directional source biasing.  Note that
"I>                     directional bremsstrahlung splitting (IBRSPL=2) must
"I>                     also be used.  Splitting number (NBRSPL), splitting
"I>                     field radius (FS), source to surface distance
"I>                     (SSD) and electron splitting parameters (if e-
"I>                     contamination is desired) are read from the DBS
"I>                     inputs.
"I>       splitcm_dsb   The CM no. at which primary photons are split and
"I>                     radially redistributed about the Z-axis.  Photons
"I>                     are split/redistributed immediately upon entering
"I>                     CM no. splitcm_dsb.  Note that this should be the
"I>                     the no. of the first CM in the treatment head without
"I>                     radial symmetry.  The number of times a photon is
"I>                     split depends upon the radial bin into which it
"I>                     is directed.  Bin radii are determined by the input
"I>                     dsb_delta below.  Set splitcm_dsb=0 for no splitting/
"I>                     redistribution.
"I>         dsb_delta   The min. linear distance, in cm, between split/
"I>                     redistributed photons, projected to the SSD of the
"I>                     splitting field. dsb_delta is used to divide the
"I>                     splitting field into radial bins, where photons
"I>                     directed into bin i are split i times.
"I>
"I>         NOTE: The sign of RBEAM determines if the source will be a
"I>                      vertical ring a horizontal cylinder.
"I>               The Z-span of the source must be in the range
"I>                      Z_min_CM(1)-Z_min_CM(MAX_CMs+1).
"I>               Currently, this source is limited to being placed within
"I>                      CONESTAK, FLATFILT or SIDETUBE
"I>------------------------------------------------------------------------
;
"%A04a
"I>  ISOURC = 3a  A cylindrical, isotropically radiating Co60 source within CMs
"I>  **********  using directional source biasing (DSB).
"I>
"I>     IQIN,ISOURC,RMINBM,RBEAM,ZSMIN,ZSMAX,i_dsb,DSB_DELTA
"I>           (same is source 3)
"I>------------------------------------------------------------------------
;
"%A05
"I>  ISOURC = 5   NRC SWEPT BEAM SOURCE
"I>  **********
"I>
"I>     IQIN,ISOURC,GAMMA,RBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  5
"I>             GAMMA   1/2 angle of cone in degrees
"I>             RBEAM   radius of beam spot at Z = 0.0 (cm)
"I>
"I>     Note apex of cone is at x=y=0,z=Z_min_CM(1)
"I>---------------------------------------------------------------------
;
"%A06
"I>  ISOURC = 6   RECTANGULAR BEAM INCIDENT FROM THE FRONT
"I>  **********
"I>
"I>     IQIN,ISOURC,XBEAM0,YBEAM0,XBEAM,YBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  = 6
"I>             XBEAM0  X position of centre of beam (cm)
"I>             YBEAM0  Y position of centre of beam (cm)
"I>             XBEAM   half-width in X direction (cm)
"I>             YBEAM   half-width in Y direction (cm)
"I>---------------------------------------------------------------------
;
"%A07
"I>  ISOURC = 7   SCANNING BEAM SOURCE (sawtooth like Therac20)
"I>  **********
"I>
"I>     IQIN,ISOURC,FD_AT100, IRATIO_YXF, RBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  7
"I>             FD_AT100   length & width of scanning field at  SSD=100cm
"I>             IRATIO_YXF =  the number of Y scans per X scan
"I>                          (rounds 2*IRATIO_YXF up to nearest odd
"I>                          number--default IRATIO_YXF = 6.5)
"I>             RBEAM   radius of the beam at Z=0, defaults to 0.01cm
"I>----------------------------------------------------------------------
;
"%A08
"I>  ISOURC = 8   SCANNING BEAM FOR MM50 (uniform circular beam from
"I>  *********                            a point on axis at Z=0)
"I>
"I>     IQIN,ISOURC,DISTZ,RBEAM
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  8
"I>             DISTZ   SSD (default to 100 cm)
"I>             RBEAM   radius of scanned beam at SSD.  If set <=0 or
"I>                     too large, then RBEAM gets reset to
"I>                     RMAX_CM(1)*DISTZ/Z_min_CM(1) (circular CM 1) or
"I>                     SQRT(2)*RMAX_CM(1)*DISTZ/Z_min_CM(1) (square CM 1)
"I>                     so that particles strike the front of
"I>                     CM 1 within a circle of radius RMAX_CM(1)
"I>                     or SQRT(2)*RMAX_CM(1).
"I>             RBEAM0  Radius of beam spot at Z=0cm.  Defaults to 0
"I>                     if RBEAM0<0 and gets reset to
"I>                     RMAX_CM(1)*DISTZ/Z_min_CM(1)-RBEAM (circular CM 1)
"I>                     or SQRT(2)*RMAX_CM(1)*DISTZ/Z_min_CM(1)-RBEAM
"I>                     (square CM 1) if RBEAM+RBEAM0 >
"I>                     RMAX_CM(1)*DISTZ/Z_min_CM(1) or >
"I>                     SQRT(2)*RMAX_CM(1)*DISTZ/Z_min_CM(1).
"I>    For this source the particles start at Z_min_CM(1) and hence
"I>    Z_min_CM(1) must be >= 0.0
"I>----------------------------------------------------------------------
;
"%A09
"I>  ISOURC = 9   SCANNING BEAM FOR MM50 (discrete field coverage from
"I>  *********                            a point source at Z=0)
"I>
"I>     IQIN,ISOURC,DISTZ,NPTS_SRC9
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  9
"I>             DISTZ   SSD (default to 100 cm)
"I>         NPTS_SRC9   the number of discrete points at the SSD
"I>                     defaults to $MAXPTS_SRC9 if NPTS_SRC9 > $MAXPTS_SRC9
"I>                     or 1 if NPTS_SRC9 <= 0.
"I>
"I>  Next record (if ISOURC=9)
"I>  *************************
"I>
"I>     Repeat for I=1,NPTS_SRC9
"I>
"I>     X_SRC9(I),Y_SRC9(I),PROB_SRC9(I) (3F15.0)
"I>              X_SRC9(I)     X coordinate of point I at the SSD (cm)
"I>              Y_SRC9(I)     Y coordinate of point I at the SSD (cm)
"I>              PROB_SRC9(I)  probability of a particle being at point I
"I>
"I>     Note that PROB_SRC9(I) need not be normalized; they are
"I>     automatically normalized in the source routine.
"I>    For this source the particles start at Z_min_CM(1) and hence
"I>    Z_min_CM(1) must be >= 0.0
"I>----------------------------------------------------------------------
;
"%A10
"I>  ISOURC = 10   PARALLEL CIRCULAR BEAM INCIDENT FROM THE SIDE
"I>  ***********
"I>                (NOTE: beam facing X-AXIS, I.E., UINC should be < 0.0   )
"I>                (this source should only be used together with CM XTUBE )
"I>                (for simulating the target of an X-ray tube.            )
"I>                (XTUBE should always be the first CM in the geometry.   )
"I>
"I>     IQIN,ISOURC,RBEAM,UINC,VINC,WINC
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  10
"I>             RBEAM   radius of parallel beam in cm (defaults to max radius)
"I>             UINC    incident X-axis direction cosine (UINC < 0.0)
"I>             VINC    incident Y-axis direction cosine
"I>             WINC    incident Z-axis direction cosine
"I>                     Note: (UINC,VINC,WINC) get automatically normalized
"I>                           defaults to (-1.0,0.0,0.0)
"I>---------------------------------------------------------------------
;
"%A11
"I>  ISOURC = 13   PARALLEL RECTANGULAR BEAM INCIDENT FROM THE SIDE
"I>  ***********
"I>                (Note beam facing X-axis, i.e., UINC should be < 0.0    )
"I>                (this source should only be used together with CM XTUBE )
"I>                (for simulating the target of an X-ray tube.            )
"I>                (XTUBE should always be the first CM in the geometry.   )
"I>
"I>     IQIN,ISOURC,YBEAM,ZBEAM,UINC,VINC
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  =  13
"I>             YBEAM   half-width of parallel beam in cm (defaults to 0.2 cm)
"I>             ZBEAM   half-height of parallel beam in cm (defaults to 0.2 cm)
"I>             UINC    incident X-axis direction cosine (UINC < 0.0)
"I>             VINC    incident Y-axis direction cosine
"I>                     (incident Z-axis direction cosine WINC default to 0.0)
"I>                     Note: (UINC,VINC) get automatically normalized
"I>                           defaults to (-1.0,0.0,0.0)
"I>------------------------------------------------------------------------
;
"%A20
"I>  ISOURC = 15   NRC SWEPT BEAM WITH BEAM DIVERGENCE AND RADIAL INTENSITY
"I>  ***********                                                DISTRIBUTION
"I>
"I>     IQIN,ISOURC,GAMMA,ZFOCUS,RTHETAIN,THETAIN
"I>             IQIN       charge of the incident beam (defaults to 0)
"I>             ISOURC     =  15
"I>             GAMMA      half angle of the cone swept by the beam (degrees)
"I>             ZFOCUS     Z position of the apex of the cone (cm)
"I>             RETHETAIN  radius at which THETAIN, the divergence angle of the
"I>                        beam, is specified (cm).  RTHETAIN must be > 0.
"I>             THETAIN    divergence angle of the beam (degrees).  If GAMMA
"I>                        is not 0, then THETAIN can be set to 0; otherwise
"I>                        it must be > 0.
"I>
"I>      Note that particles are always incident at Z_min_CM(1), regardless of
"I>      the value of ZFOCUS
"I>
"I>  Next record (If ISOURC=15)
"I>  ***********
"I>      SPCNAM       FILENAME (with EXT) containing description of the radial
"I>                   intensity distribution of the incident particles
"I>                                               (maximum 256 characters)
"I>             _______________________________________________________
"I>             FILE FORMAT for SPCNAM:
"I>               NRDIST
"I>               (RDISTF(I),RPDF(I),I=1,NRDIST)
"I>                     NRDIST     # radial bins
"I>                     RDISTF(I)  upper radius of bin I (cm)
"I>                     RPDF(I)    probability of particle being in bin I.
"I>------------------------------------------------------------------------
;
"%A21
"%A22
"I>  ISOURC = 19   PARALLEL ELLIPTICAL BEAM FROM FRONT GAUSSIAN IN X AND Y
"I>  ***********
"I>
"I>     IQIN,ISOURC,RBEAM,UINC,VINC,WINC,sigma_src19,RBEAMY
"I>             IQIN    charge of the incident beam (defaults to 0)
"I>             ISOURC  = 19
"I>             RBEAM   sigma of the 2-D gaussian distribution (RBEAM > 0)
"I>                     in the X-direction in cm
"I>                       or
"I>                     -FWHM of 2-D gaussian distribution (RBEAM < 0) in
"I>                     the X-direction in cm
"I>                     Note: sigma of gaussian distribution is limited to
"I>                           <RMAX_CM(1) for circular CM 1 and
"I>                           <SQRT(2)*RMAX_CM(1) for square CM 1
"I>             UINC    incident x-axis direction cosine
"I>             VINC    incident y-axis direction cosine
"I>             WINC    incident z-axis direction cosine
"I>                     Note: (UINC,VINC,WINC) get automatically normalized
"I>                           defaults to (0.0,0.0,1.0)
"I>      sigma_src19    mean angular spread of particles about Z axis
"I>                     in degrees (none if set <=0).  Overrides incident
"I>                     direction cosines if set > 0, so that beam is assumed
"I>                     to be centred on Z axis.
"I>           RBEAMY    same as RBEAM but for Y-direction.  If set to 0,
"I>                     then RBEAMY=RBEAM for a circular beam.
"I>------------------------------------------------------------------------
;
"%A12
"I>  ISOURC = 21   FULL PHASE-SPACE SOURCE
"I>  ***********
"I>
"I>     IQIN,ISOURC,INIT_ICM,NRCYCL,IPARALLEL,PARNUM,ISRC_DBS,RSRC_DBS,
"I>                                                  SSDSRC_DBS,ZSRC_DBS
"I>             IQIN       dummy NOT USED. Set = 9 for this source by BEAMnrc
"I>             ISOURC     = 21
"I>             INIT_ICM   particles start at front surface of this CM
"I>                        (INIT_ICM is actually read as a real)
"I>             NRCYCL     Number of times to recycle each particle in a phase
"I>                        space source.  Each particle in the phase space
"I>                        file is used a total of NRCYCL+1 times before
"I>                        going on to the next particle.
"I>                        If NRCYCL is set <=0 then NRCYCL is automatically
"I>                        calculated to use the entire phase space file with no
"I>                        restarts.  The calculated NRCYCL does not take into
"I>                        account particles that are rejected because they
"I>                        miss the geometry.
"I>                        If NRCYCL is set > 0, then the user-input value is
"I>                        used.
"I>                        If NCASE > no. of particles in the phase space file,
"I>                        then use of NRCYCL is essential for accurate
"I>                        statistics.  If you are unsure of how many times to
"I>                        recycle, use the automatically-calculated value of
"I>                        NRCYCL.  If this still results in many restarts
"I>                        (because of multiple passers being rejected and/or
"I>                        photons rejected because they fall outside the DBS
"I>                        splitting radius--see below)
"I>                        then re-run the simulation with NRCYCL set manually
"I>                        to:
"I>                        NCASE/(NNPHSP-NNPHSP*(NPASS_ph_sp+NFAT_ph_sp)/
"I>                                    (NTOT_ph_sp+NPASS_ph_sp+NFAT_ph_sp) ) -1
"I>                        where NNPHSP is the no. of particles in the file,
"I>                        NTOT_ph_sp is total no. of particles used (not
"I>                        including recycling), NPASS_ph_sp is total no.
"I>                        of multiple passers ignored (not including
"I>                        recycling), and NFAT_ph_sp is the no. of photons
"I>                        rejected (not including recycling because they fall
"I>                        outside the DBS splitting radius at the SSD (only
"I>                        if ISRC_DBS=1--see below)). These numbers are
"I>                        available in the .egslst file.  Always round your
"I>                        calculated value of NRCYCL up.
"I>            IPARALLEL   set >1 if you are distributing the job among
"I>                        IPARALLEL machines.  IPARALLEL is used with PARNUM
"I>                        (see below) to partition a phase space source into
"I>                        IPARALLEL equal parts.
"I>            PARNUM      For each of the IPARALLEL parallel jobs, PARNUM
"I>                        should have a different integer value in the range
"I>                        1<=PARNUM<=IPARALLEL.  The partition of the phase
"I>                        space source that is used for a particular job is
"I>                        then given by:
"I>                           (PARNUM-1)*(NNPHSP/IPARALLEL)<INPHSP<=
"I>                                                (PARNUM)*(NNPHSP/IPARALLEL)
"I>                        where NNPHSP is the total number of particles in the
"I>                        phsp source and INPHSP is the particle no. chosen.
"I>            ISRC_DBS    Set to 1 if you used directional bremsstrahlung
"I>                        splitting (DBS) in the BEAM simulation used to
"I>                        generate this phase space source and you wish to
"I>                        reject photons not aimed into the splitting
"I>                        field(which are fat).  These fat photons compromise
"I>                        statistics.  Set to 0 otherwise.
"I>            RSRC_DBS    DBS splitting radius in BEAM simulation used to
"I>                        generate this source (cm).  Only used if ISRC_DBS=1.
"I>            SSDSRC_DBS  SSD at which RSRC_DBS was defined in the BEAM sim.
"I>                        used to generate this source (cm). Only used if
"I>                        ISRC_DBS=1.
"I>            ZSRC_DBS    Z where the phase space source was collected in
"I>                        the BEAM simulation used to generate this source(cm).
"I>                        Only used if ISRC_DBS=1.
"I>
"I>      Photons are projected from ZSRC_DBS to SSDSRC_DBS and if they will fall
"I>      outside of RSRC_DBS (based on their trajectory) then they will
"I>      be rejected.  This prevents fat photons from compromising statistics.
"I>
"I>  Next record (If ISOURC=21)
"I>  ***********
"I>     SPCNAM        FILENAME (with EXT) contains phase space information
"I>                   (maximum of 256 characters)
"I>------------------------------------------------------------------------
;
"%A32
"I>  ISOURC = 23   BEAM SIMULATION SOURCE
"I>  ***********
"I>
"I>     IQIN,ISOURC,INIT_ICM,ISRC_DBS,ALPHA24,BETA24,DIST24
"I>             IQIN       dummy NOT USED. Set = 9 for this source by BEAMnrc
"I>             ISOURC     = 23
"I>             INIT_ICM   particles start at front surface of this CM
"I>                        (INIT_ICM is actually read as a real)
"I>             ISRC_DBS   Set to 1 if you are using directional bremsstrahlung
"I>                        splitting (DBS) in the BEAM simulation source
"I>                        and you wish to reject fat photons (not aimed into
"I>                        the splitting field).  These fat photons compromise
"I>                        statistics.  Set to 0 otherwise.
"I>              ALPHA24   Angle of rotation of source plane about X-axis
"I>                        in degrees.  Positive angle is clockwise rotation.
"I>                        (-90 < ALPHA24 < 90)
"I>               BETA24   Angle of rotation of source plane about Y-axis
"I>                        in degrees.  Positive angle is counter-clockwise
"I>                        rotation. (-90 < ALPHA24 < 90)
"I>               DIST24   Distance of point of rotation above INIT_ICM.
"I>
"I>     Note restriction that if ALPHA24~=0 and/or BETA24 ~=0, then INIT_ICM
"I>     must be > 1.  This is because the rotation will result in some
"I>     particles incident within INIT_ICM-1.  Also, both INIT_ICM and
"I>     INIT_ICM-1 must be SLABS, SIDETUBE or FLATFILT, since these are the
"I>     only CMs currently capable of determining initial regions for particles
"I>     incident within them.
"I>
"I>  Next record (If ISOURC=23)
"I>  ***********
"I>
"I>     the_beam_code, the_pegs_file, the_input_file (3A80)
"I>
"I>       the_beam_code    The name of the BEAM code you are running as a
"I>                        source (ie BEAM_sourceaccelname).  This must have
"I>                        been compiled as a shared library
"I>                        (libBEAM_accelname.so or BEAM_accelname.dll) and
"I>                        exist in EGS_HOME/bin/config.
"I>       the_pegs_file    The pegs data set used by the BEAM simulation source
"I>                        (no .pegs4dat extension).  This must be in
"I>                        HEN_HOUSE/pegs4/data or EGS_HOME/pegs4/data.
"I>       the_input_file   The input file used to run the BEAM simulation
"I>                        source (no .egsinp extension).  This must exist in
"I>                        your EGS_HOME/BEAM_sourceaccelname directory.  It
"I>                        must be a working input file and must be set up to
"I>                        write a phase space file at a single scoring plane.
"I>                        This plane becomes where particles are sampled from
"I>                        for the second-stage BEAMnrc simulation (no phase
"I>                        space file is scored, however).
"I>------------------------------------------------------------------------
;
"%A33
"I>  ISOURC = 24   FULL PHASE-SPACE SOURCE INCIDENT FROM USER-DEFINED ANGLE
"I>  ***********
"I>
"I>  Inputs identical to ISOURC = 21 with the following additional line of
"I>  inputs after SPCNAM:
"I>
"I>     ALPHA24,BETA24,DIST24
"I>
"I>              ALPHA24   Angle of rotation of source plane about X-axis
"I>                        in degrees.  Positive angle is clockwise rotation.
"I>                        (-90 < ALPHA24 < 90)
"I>               BETA24   Angle of rotation of source plane about Y-axis
"I>                        in degrees.  Positive angle is counter-clockwise
"I>                        rotation. (-90 < ALPHA24 < 90)
"I>               DIST24   Distance of point of rotation above INIT_ICM.
"I>
"I>     Note restriction that if ALPHA24~=0 and/or BETA24 ~=0, then INIT_ICM
"I>     must be > 1.  This is because the rotation will result in some
"I>     particles incident within INIT_ICM-1.  Also, both INIT_ICM and
"I>     INIT_ICM-1 must be SLABS, SIDETUBE or FLATFILT, since these are the
"I>     only CMs currently capable of determining initial regions for particles
"I>     incident within them.
"I>
"I>     The initial idea and much of the coding for Source 24 is courtesy of
"I>     Patrick Downes at University of Cardiff, Wales.
"I>------------------------------------------------------------------------
;
"%A13
"I>  ISOURC =  31     BEAM CHARACTERIZATION MODEL,
"I>  ************
"I>     IQIN,ISOURC,CMSOU
"I>             IQIN    charge of incident beam (not used)
"I>             ISOURC  = 31
"I>             CMSOU   particles start at the front surface of this CM
"I>
"I>  Next record (If ISOURC=31)
"I>  ***********
"I>     SPCNAM        FILENAME (with EXT) contains information on beam model
"I>                   (maximum of 256 characters)
"I>  --------------------------------------------------------------------------
;
"%A14
"I>
"I>  Next Record (IF ISOURC <21)     SOURCE ENERGY INPUT
"I>  ***********                     *******************
"I>
"I>     MONOEN (I8)
"I>                      = 0 if monoenergetic beam (the default)
"I>                      = 1 if energy spectrum to be used
"I>                          Note: BEAMnrc sets MONOEN=2 for phase space inputs
"I>
"I>   Next Record (IF MONOEN = 0)
"I>   ***********
"I>     EIN (F15.0)
"I>                  kinetic energy of the incident beam in MeV
"I>                  (defaults to 1.25), only for MONOEN=0
"I>
"I>   Next Record (IF MONOEN = 1)
"I>   ***********
"I>     FILNAM(256A1)  FILENAME(WITH EXT) contains spectrum information
"I>                   which must be in  NRC's ensrcV format.
"I>             _______________________________________________________
"I>             FILE FORMAT:
"I>             SPEC_TITLE   (A80)
"I>               NENSRC,ENMIN,IMODE (I10,F15.0,I5)
"I>               (ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC) (2F20.0)
"I>                     NENSRC  # Energy bins in spectrum histogram
"I>                     ENMIN   Lower energy of first bin
"I>                     IMODE   =0 assuming counts/bin, =1 counts/MeV
"I>                     ENSRCD(I),SRCPDF(I)  I=1,NENSRC
"I>                             Top of energy bin and probability of
"I>                             initial particle being in this bin.
"I>                             Probability does not need to be normalized
"I>             _______________________________________________________
"I>
"I>   Next Record (IF MONOEN = 1)
"I>   ***********
"I>     IOUTSP (I5):
"I>             = 0 no spectrum data in output summary
"I>             = 1 include spectrum data in output summary
"I>
"I>---------------------------------------------------------------------------
;
"%A15
"I>                     TRANSPORT CONTROL INPUT
"I>                     ***********************
"I>   Next Record
"I>   ***********
"I>     ESTEPIN,SMAX,ECUTIN,PCUTIN,IDORAY,IREJCT_GLOBAL,ESAVE_GLOBAL,IFLUOR
"I>
"I>             ESTEPIN Dummy variable (used to be ESTEPE -- max. fractional
"I>                     energy loss/electron step)
"I>             SMAX    Dummy variable (used to be SMAX -- max. step length)
"I>             ECUTIN  electron cut off in MeV - total energy
"I>                     If this is > ECUT as input in the EGSnrc input section
"I>                     (see below), then ECUT is set to ECUTIN.  Default
"I>                     value for ECUT is AE.
"I>             PCUTIN  photon cut off in MeV.  If this is > PCUT as input
"I>                     in the EGSnrc input section (see below), then PCUT
"I>                     is set to PCUTIN.  Default value for PCUT is AP.
"I>             IDORAY  Dummy variable (used to turn Rayleigh scattering on/off)
"I>      IREJCT_GLOBAL = 0 no electron range rejection
"I>                    = 1 do electron range rejection--if residual
"I>                        range to ECUTRR(IRL) is < DNEAR and
"I>                        electron energy is < ESAVE_GLOBAL, terminate
"I>                        history.  ECUTRR(IRL) may vary from component
"I>                        module to component module and is calculated based
"I>                        on the particle making it to the bottom of the
"I>                        accelerator with energy > ECUT
"I>                    = 2 as in =1, but use a non-calculated ECUTRR = ECUT(IRL)
"I>                        this should be used if interested in more
"I>                        than phase-space data at base of simulation
"I>                 =-1,-2 Same as above, but now Russian Roulette is played
"I>                        with ALL electrons that can not escape the region
"I>                        and are not fat. Only applicable with DBS.
"I>       ESAVE_GLOBAL  energy below which an electron will be discarded
"I>                     If E<ESAVE_GLOBAL & the electron cannot escape from the
"I>                     current region with E>ECUTRR(IRL). This ignores brem
"I>                     losses.
"I>             IFLUOR  Dummy variable (used to turn X-ray fluorescence on/off)
"I>
"I>        The dummy inputs are retained for compatibility with EGS4/BEAM input
"I>        files.
"I>----------------------------------------------------------------------------
;
"%A16
"I>  Next Record        Photon Forcing Controls
"I>  ***********        ***********************
"I>      IFORCE,NFMIN,NFMAX,NFCMIN,NFCMAX
"I>             IFORCE = 0 normal photon transport (the default)
"I>                    = 1 force photon interaction in the geometry
"I>             NFMIN  number of photon interaction/history at which to start
"I>                    photon-interaction-forcing (defaults to 1)--this
"I>                    option has been deleted and NFMIN is now always treated
"I>                    as 1.
"I>             NFMAX  number of photon interaction/history after which to
"I>                    stop forcing photon to interact (defaults to 1)
"I>             NFCMIN number of CM to start photon interaction forcing
"I>                    ( default to 1 )
"I>             NFCMAX number of last CM in which photons forced to interact
"I>                    ( default to max_cms )
"I>                    If a particle passes thru NFCMIN to NFCMAX, it is
"I>                    forced to interact there for the first NFMAX
"I>                    interactions. The WEIGHT
"I>                    of this photon is reduced and the remaining WEIGHT is
"I>                    carried by another photon which will be transported
"I>----------------------------------------------------------------------------
;
"%A17
"I>  Next record             SCORING PLANE INPUT
"I>  ***********             *******************
"I>
"I>    NSC_PLANES, (IPLANE_to_CM(I), I=1,NSC_PLANES)
"I>
"I>       NSC_PLANES     number of scoring planes >=0
"I>       IPLANE_to_CM   CM numbers corresponding to the scoring planes
"I>                      fluence is scored at the back of a component module
"I>                      phase space data written from same planes
"I>
"I>       (Note only IPLANE_to_CM(1) is used for beam model analysis);
"I>
"I>  Next record            SCORING ZONE TYPE/DIMENSIONS
"I>  ***********            ****************************
"I>
"I>  Repeat the next pair of lines for ISCORE=1,...,NSC_PLANES
"I>
"I>     NSC_ZONES(ISCORE), MZONE_TYPE(ISCORE)
"I>          NSC_ZONES     number of scoring zones within each scoring plane
"I>                        (= 0: maximum number available with equal zone area)
"I>          MZONE_TYPE    0 annular zones (default)
"I>                        1 square (ring) zones
"I>                        2 grid
"I>
"I>  Next record (for NSC_ZONES(ISCORE)>0 and MZONE_TYPE = 0 or 1)
"I>  ***********
"I>     (RSCORE_ZONE(ISCORE,I), I=1,NSC_ZONES)  (up to 10/line)
"I>          RSCORE_ZONE   outer radius of each scoring zone in order of
"I>                           increasing radius (MZONE_TYPE = 0)
"I>                        half width from origin of each scoring zone
"I>                           in order of increasing width (MZONE_TYPE = 1)
"I>
"I>  Next record (for NSC_ZONES(ISCORE)>0 and MZONE_TYPE = 2)
"I>  ***********
"I>     XMIN_ZONE, XMAX_ZONE, YMIN_ZONE, YMAX_ZONE, NX_ZONE, NY_ZONE
"I>            XMIN_ZONE     lower x bound of grid area (cm)
"I>            XMAX_ZONE     upper x bound of grid area (cm)
"I>            YMIN_ZONE     lower y bound of grid area (cm)
"I>            YMAX_ZONE     upper y bound of grid area (cm)
"I>            NX_ZONE       number of grid zones in x direction
"I>            NY_ZONE       number of grid zones in y direction
"I>----------------------------------------------------------------------------
;
"%A18
"I>  Next record           DOSE COMPONENTS CALCULATION INPUT
"I>  ***********           *********************************
"I>     ITDOSE_ON
"I>         ITDOSE_ON  = 0 (DEFAULT) only total dose is calculated
"I>                    = 1 total dose and dose components may be calculated
"I>
"I>     There are 2 classes of components. First is selected as dose from
"I>     particles or descendents of particular charge as they cross a
"I>     specified boundary.  Second is based on bit selections in the
"I>     variable LATCH, either inclusive or exclusive sets - i.e. depends
"I>     on where particle has been or interacted.
"I>
"I>  Next record (if ITDOSE_ON=1)
"I>  ***********
"I>     ICM_CONTAM, IQ_CONTAM (2I5)
"I>          All particles of type IQ_CONTAM (0=photons, 1=charged
"I>          particles) are identified as contaminants when they enter
"I>          the front of CM number ICM_CONTAM and their dose is scored as
"I>          contaminant dose in all dose zones.
"I>          If ICM_CONTAM = 0, no contaminant dose is scored.
"I>          LATCH_OPTION = 1 is not allowed with ICM_CONTAM non-zero
"I>
"I>  Next record (if ITDOSE_ON=1)
"I>  ***********
"I>     LNEXC (I5)
"I>           LNEXC: # of dose components scored which exclude dose from
"I>                  particles with certain LATCH bits set - i.e. which have
"I>                  not been in certain regions.
"I>                  LNEXC = 0 is allowed. LNEXC <= $MAXIT - 3
"I>
"I>  Next records (if LNEXC > 0)
"I>  ************
"I>     (L_N_EXC(I,J), J=1, 31 ) (31I5) (repeat LNEXC times, line by line)
"I>           L_N_EXC(I,J): Bit #s in LATCH for dose component I
"I>                 (will exclude dose from component I if these bits set)
"I>
"I>  Next record (if ITDOSE_ON=1)
"I>  ***********
"I>     LNINC (I5)
"I>           LNINC: # of dose components scored for particles
"I>                  from specified regions (with designated bit settings
"I>                  in LATCH).  LNINC <= $MAXIT - LNEXC - 3
"I>
"I>  Next records (if LNINC > 0)
"I>  ************
"I>     (L_N_INC(I,J), J=1, 31 ) (31I5) (repeat LNINC times, line by line)
"I>           L_N_INC(I,J): Bit #s in LATCH for dose component I.
"I>                         These are in two groups/line, separated by a zero.
"I>                         Of the first group of bits, at least one must
"I>                         be set to be in this dose component.
"I>                         The second group need not be present, but if
"I>                         it is, none of these bits can be set to be in
"I>                         this dose component.
"I>
"I>---------------------------------------------------------------------------
;
"%A19
"I>  Next record           INPUT FRONT SURFACE (Z) FOR CM 1
"I>  ***********           ********************************
"I>
"I>     Z_min_CM(1)  Z-coordinate of front surface for component module 1
"I>                  This includes any air gap and defines front of model.
"I>                  A common value will be 0.0 except for sources 8 & 9.
"I>                  For most sources except for ISOURC=3, 21 & 31, this is
"I>                  also the source plane on which the particles are incident
"I>          Note that the front of all CMs is given w.r.t. z = 0.0, not
"I>          w.r.t. Z_min_CM(1).
"I>
"I>  Next record         Blank or dummy line indicating start of
"I>  ***********         input for component modules
"I>
"I>
"I>  Next records (many)       COMPONENT MODULE INPUT
"I>  *************             **********************
"I>
"I>  Component module parameters are input in order of their appearance in the
"I>  code, that is, in the order they occur in $CM_LIST.  See the 'INPUT FROM
"I>  UNIT 5' section in each CM subroutine for the list of input parameters.
"I>
"I>   There are two lines before the input of parameters for each CM:
"I>   one is *********************************************** ,
"I>   the other is RMAX_CM, the outer boundary(radius or 1/2 of square) of CM
"I>
"I>  ---------------------------------------------------------------------------
;
"%A23
"I>                          EGSnrc INPUTS
"I>                          *************
"I>    (modified from the description in $HEN_HOUSE/src/get_inputs.mortran)
"I>
"I>  The input for parameters associated with EGSnrc follows a format
"I>  used by all the standard EGSnrc user codes.  The rest of the BEAMnrc
"I>  input has not been changed because the GUI's make the details of the
"I>  format irrelevant.
"I>
"I>  All input associated with selection of EGSnrc transport parameters
"I>  is not crucial for the execution as there are default values set.
"I>  Therefore, if some of the input options in this section are
"I>  missing/misspelled, this will be ignored and defualt parameter assumed
"I>  As the transport parameter input routine uses get_inputs, a lot
"I>  of error/warning messages may be produced on UNIT 15, though.
"I>  If you don't have the intention of changing default settings,
"I>  simply ignore the error messages.
"I>
"I>  The delimeters are
"I>               :start mc transport parameter:
"I>               :stop mc transport parameter:
"I>
"I>  Currently, the following options are available (case does not matter and
"I>             the internal variables are shown in [ ] brackets):
"I>
"%A24
"I>       Global ECUT=     Global (in all regions) electron transport cut
"I>                        off energy (in MeV). If this imput is missing,
"I>                        or is < ECUTIN from the main BEAMnrc inputs
"I>                        (See above) then ECUTIN is used for Global ECUT.
"I>                        Global ECUT defaults to AE(medium).
"I>                        [ ECUT ]
"I>       Global PCUT=     Global (in all regions) photon transport cut
"I>                        off energy (in MeV). If this imput is missing,
"I>                        or is < PCUTIN from the main BEAMnrc inputs
"I>                        (See above) then PCUTIN is used for Global PCUT.
"I>                        Global PCUT defaults to AP(medium).
"I>                        [ PCUT ]
"I>       Global SMAX=     Global (in all regions) maximum step-size
"I>                        restriction for electron transport (in cm).
"I>                        No SMAX restriction is necessary if the electron
"I>                        step algorithm is PRESTA-II and the EXACT boundary
"I>                        crossing algorithm (the default) is used.  In this
"I>                        case, SMAX will default to 1e10.  However, if either
"I>                         Electron-step algorithm= PRESTA-I
"I>                         or
"I>                         Boundary crossing algorithm= PRESTA-I,
"I>                        then a step-size restriction is necessary, and
"I>                        SMAX will default to 5 cm.
"I>                        [ SMAXIR ]
"%A25
"I>       ESTEPE=          Maximum fractional energy loss per step.
"I>                        Note that this is a global option only, no
"I>                        region-by-region setting is possible. If missing,
"I>                        the defualt is 0.25 (25%).
"I>                        [ ESTEPE ]
"I>       XImax=           Maximum first elastic scattering moment per step.
"I>                        Default is 0.5, NEVER use value greater than 1 as
"I>                        this is beyond the range of MS data available.
"I>                        [ XIMAX ]
"I>       Boundary crossing algorithm=
"I>                        There are two selections possible: EXACT and
"I>                        PRESTA-I.  PRESTA-I means that boundaries will
"I>                        be crossed a la PRESTA.  That is, with lateral
"I>                        correlations turned off at a distance given by
"I>                        `Skin depth for BCA' (see below) from the boundary
"I>                        and MS forced at the boundary.  EXACT means
"I>                        the algorithm will cross boundaries in a single
"I>                        scattering (SS) mode, the distance from a boundary
"I>                        at which the transition to SS mode is made is
"I>                        determined by `Skin depth for BCA' (see below).
"I>                        Default is EXACT since PRESTA-I may result in
"I>                        significant dose overestimates when CHAMBER is
"I>                        used as a phantom, and EXACT will not significantly
"I>                        increase CPU time in most accelerators.
"I>                        [ bca_algorithm, exact_bca ]
"I>       Skin depth for BCA=
"I>                        If Boundary crossing algorithm= PRESTA-I
"I>                        then this is the distance from the boundary (in
"I>                        elastic MFP) at which lateral correlations will be
"I>                        switched off.  The default in this case is to
"I>                        calculate a value based on the scattering power at
"I>                        ECUT (same as PRESTA with EGS4).  If
"I>                        Boundary crossing algorithm= EXACT (default) then
"I>                        this is the distance from the boundary (in elastic
"I>                        MFP) at which the algorithm will go into single
"I>                        scattering mode and defaults to 3 mfp.
"I>                        Note that if you choose EXACT boundary crossing and
"I>                        set Skin depth for BCA to a very large number (e.g.
"I>                        1e10), the entire calculation will be in SS mode.
"I>                        If you choose PRESTA-I boundary crossing and make
"I>                        Skin depth for BCA large, you will get default EGS4
"I>                        behaviour (no PRESTA).
"I>                        [ skindepth_for_bca ]
"I>
"I>            The new transport mechanics of EGSnrc are maintained away from
"I>            boundaries.
"%A26
"I>       Electron-step algorithm=
"I>                        PRESTA-II (the default), the name is
"I>                        used for historical reasons
"I>                        or PRESTA-I
"I>                        Determines the algorithm used to take into account
"I>                        lateral and longitudinal correlations in a
"I>                        condensed history step.
"I>                        [ transport_algorithm ]
"I>       Spin effects=    Off, On, (default is On)
"I>                        Turns off/on spin effects for electron elastic
"I>                        scattering. Spin On is ABSOLUTELY necessary for
"I>                        good backscattering calculations. Will make a
"I>                        difference even in `well conditioned' situations
"I>                        (e.g. depth dose curves for RTP energy range
"I>                        electrons).
"I>                        [ spin_effects ]
"I>       Brems angular sampling= Simple, KM, (default is Simple)
"I>                        If Simple, use only the leading term of the Koch-Motz
"I>                        distribution to determine the emission angle of
"I>                        bremsstrahlung photons. If KM, complete
"I>                        modified Koch-Motz 2BS is used (modifications
"I>                        concern proper handling of kinematics at low
"I>                        energies, makes 2BS almost the same as 2BN at low
"I>                        energies).
"I>                        [ IBRDST ]
"I>       Brems cross sections= BH, NIST, NRC, default is BH
"I>                        If BH is selected, the Bethe-Heitler bremsstrahlung
"I>                        cross sections (Coulomb corrected above 50 MeV)
"I>                        will be used. If NIST is selected, the NIST brems
"I>                        cross section data base (which is the basis for
"I>                        the ICRU radiative stopping powers) will be employed.
"I>                        Differences are negligible for E > ,say, 10 MeV,
"I>                        but signifficant in the keV energy range.  If NRC is
"I>                        selected, NIST data including corrections for
"I>                        electron-electron brems will be used (typically only
"I>                        significant for low values of the atomic number Z
"I>                        and for k/T < 0.005).
"I>       Bound Compton scattering=  On, Off or Norej (Default is Off)
"I>                        If Off, Compton scattering will be treated with
"I>                        Klein-Nishina, with On Compton scattering is
"I>                        treated in the Impulse approximation.
"I>                        Make sure to turn on for low energy applications,
"I>                        not necessary above, say, 1 MeV.  Option Norej
"I>                        uses full bound Compton cross section data
"I>                        supplied in input below and does not reject
"I>                        interactions.
"I>                        [ IBCMP ]
"I>       Compton cross sections= Bound Compton cross-section data.  User-
"I>                        supplied bound Compton cross-sections in the file
"I>                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"I>                        comp_xsections is the name supplied for this input.
"I>                        This is only used if Bound Compton scattering= Simple
"I>                        and is not available on a region-by-region basis
"I>                        (see below).  The default file (ie in the absence
"I>                        of any user-supplied data) is compton_sigma.data.
"I>                        [ comp_xsections ]
"I>       Radiative Compton corrections= On or Off (default). If on, then
"I>                        include radiative corrections for Compton scattering.
"I>                        Equations are based on original Brown & Feynman
"I>                        equations (Phys. Rev. 85, p 231--1952).  Requires
"I>                        a change to the user codes Makefile to include
"I>                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
"I>                        SOURCES (just before
"I>                        $(EGS_SOURCEDIR)get_inputs.mortran).
"I>                        [ radc_flag ]
"%A27
"I>       Pair angular sampling= Off, Simple or KM (Default is Simple)
"I>                        If off, pairs are set in motion at an angle m/E
"I>                        relative to the photon direction (m is electron rest
"I>                        energy, E the photon energy). Simple turns on
"I>                        the leading term of the angular distribution
"I>                        (this is sufficient for most applications),
"I>                        KM (comes from Koch and Motz) turns on using 2BS
"I>                        from the article by Koch and Motz.
"I>                        Always use Simple or KM.
"I>                        [ IPRDST ]
"I>       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"I>                        Bethe-Heitler pair production cross-sections.  If set
"I>                        to NRC, then use NRC pair production cross-sections
"I>                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"I>                        of interest at low energies, where the NRC cross-
"I>                        sections take into account the assymmetry in the
"I>                        positron-electron energy distribution.
"I>                        [ pair_nrc ]
"I>       Photoelectron angular sampling= Off or On (Default is Off)
"I>                        If Off, photo-electrons get the direction of the
"I>                        `mother' photon, with On, Sauter's furmula is
"I>                        used (which is, striktly speaking, valid only for
"I>                        K-shell photo-absorption).
"I>                        If the user has a better approach, replace the macro
"I>                            $SELECT-PHOTOELECTRON-DIRECTION;
"I>                        The only application that
"I>                        Only situation encountered where this made a
"I>                        small difference was a big ion chamber (cavity size
"I>                        comparable with electron range) with high-Z walls
"I>                        in a low energy photon beam.
"I>                        [ IPHTER ]
"I>       Rayleigh scattering= Off, On, custom
"I>                       If On, turned on coherent (Rayleigh) scattering.
"I>                        Default is Off. Should be turned on for low energy
"I>                        applications. Not set to On by default because
"I>                        On requires a special PEGS4 data set.  If set to
"I>                        custom, then media for which custom form factors
"I>                        are to be specified are listed in the input:
"I>                        ff media names=
"I>                        and the corresponding files containing custom data
"I>                        are listed in:
"I>                        ff file names=
"I>                        [ IRAYLR ]
"I>       Atomic relaxations= Off, On (Default is Off)
"I>                        The effect of using On is twofold:
"I>                        - In photo-electric absorption events, the element
"I>                          (if material is mixture) and the shell the photon
"I>                          is interacting with are sampled from the
"I>                          appropriate cross seections
"I>                        - Shell vacancies created in photo-absorption events
"I>                          are relaxed via emission of fluorescent X-Rays,
"I>                          Auger and Koster-Cronig electrons.
"I>                         Make sure to turn this option on for low energy
"I>                         applications.
"I>                         [ IEDGFL ]
"%A28
"I>       Electron impact ionization= Off, On, Casnati, Kolbenstvedt, Gryzinski
"I>                                   (Default is Off)
"I>                         Determines which, if any, theory is used to model
"I>                         electron impact ionization. If set to 'On' then the
"I>                         theory of Kawrakow is used.  Other settings use the
"I>                         theory associated with the name given.  See future
"I>                         editions of the EGSnrc Manual (PIRS-701) for more
"I>                         details.  This is only of interest in keV X-Ray
"I>                         simulations.  Otherwise, leave it Off.
"I>                         [ eii_flag ]
"I>       Photon cross sections= epdl,xcom,custom (Default is Storm-Israel
"I>                         cross-sections from PEGS4)
"I>                         The name of the cross-section data for photon
"I>                         interactions.  This input line must be left out
"I>                         to access the default Storm-Israel cross-sections
"I>                         from PEGS4.  'edpl' uses cross-sections from the
"I>                         evaluated photon data library (EPDL) from Lawrence
"I>                         Livermore.  'xcom' will use the XCOM cross-sections
"I>                         from Burger and Hubbell.  The user also has the
"I>                         option of using their own customized cross-section
"I>                         data.  See the BEAMnrc manual for more details.
"I>                         [ photon_xsections ]
"I>       Photon cross-sections output= Off (default) or On.  If On, then
"I>                        a file $EGS_HOME/user_code/inputfile.xsections is
"I>                        output containing photon cross-section data used.
"I>                        [ xsec_out ]
"I>
"I>       Atomic relaxations, Rayleigh scattering, Photoelectron angular
"I>       sampling and Bound Compton scattering can also be turned On/Off
"I>       on a region-by-region basis. To do so, put e.g.
"I>       Atomic relaxations= On in Regions   or
"I>       Atomic relaxations= Off in regions
"I>                         in your input file. Then use the relevant one of:
"I>       Relaxations start region=
"I>       Relaxations stop region=
"I>                or
"I>       Bound Compton start region=
"I>       Bound Compton stop region=
"I>                or
"I>       Rayleigh start region=
"I>       Rayleigh stop region=
"I>                or
"I>       PE sampling start region=
"I>       PE sampling stop region=
"I>
"I>             each followed by a list of one or more
"I>             start and stop regions separated by commas.
"I>        Example:
"I>        Atomic relaxations= On in Regions
"I>        Relaxations start region=  1, 40
"I>        Relaxations stop region=  10, 99
"I>                         will first turn off relaxations everywhere and
"I>                         then turn on in regions 1-10 and 40-99.
"I>                         Note that input is checked against min. and max.
"I>                         region number and ignored if
"I>                         start region < 1 or stop_region > $MXREG or
"I>                         start region > stop region.
"I>
"%A29
"I> ---------------------------------------------------------------------------
"I>
"I>                          Rejection Plane Inputs
"I>                          **********************
"I>
"I>  Used to define a rejection plane for use in conjunction with directional
"I>  bremsstrahlung splitting (DBS, IBRSPL=2, see above).
"I>  Inputs can exist without IBRSPL=2, but they will not be used.
"I>
"I>  Inputs must appear between the delimiters:
"I>  :Start DBS rejection plane:
"I>  :Stop DBS rejection plane:
"I>
"I>  Inputs are:
"I>
"I>     Use a rejection plane= Off, On (default is Off)
"I>                           Set to On if you want to define a rejection
"I>                           plane.
"I>                           [USE_REJPLN]
"I>     Z(cm) from zero reference plane= Z position of reference plane.
"I>                           [Z_REJPLN]
"I>
"I>     Fat photons and electrons will be discarded if they are about
"I>     to interact at Z>=Z_REJPLN.  Used to prevent correlated particles
"I>     from being created close to a scoring plane, compromising
"I>     statistics.
"%A30
"I>  ---------------------------------------------------------------------------
"I>
"I>          Bremsstrahlung Cross Section Enhancement (BCSE) Inputs
"I>          ******************************************************
"I>
"I>  Inputs for the BCSE variance reduction technique.
"I>
"I>  Inputs must appear between delimiters:
"I>  :Start BCSE:
"I>  :Stop BCSE:
"I>
"I>  Inputs are:
"I>
"I>      Use BCSE= Off, On (default is Off)
"I>              Set to On to use BCSE.
"I>              [USE_BCSE]
"I>      Media to enhance= A list of media in
"I>              which to enhance the bremsstrahlung cross-section.  If
"I>              none of the media is found in the accelerator, then no
"I>              BCSE is done.
"I>              [is_bcse_medium]
"I>      Enhancement constant= Floating point factor by which bremsstrahlung
"I>              cross-sections are enhanced. Typical values are in the range
"I>              20 (megavoltage accelerators) -- 500 (x-ray tubes in
"I>              mammography energy range).
"I>              [BCSE_FACTOR_C]
"I>      Enhancement power= Floating point number that us used for an energy
"I>              dependent BCSE. If this input is <=0, then a constant
"I>              BCSE factor is used that is given by BCSE_FACTOR_C. But if
"I>              this input is >0, then the BCSE factor is computed on-th-fly
"I>              using 1 + BCSE_FACTOR_C*(E(np)-rm)**BCSE_POWER_N.
"I>              Typical values for BCSE_POWER_N are 2...4. Note that
"I>              BCSE_FACTOR_C must be adjusted accordingly so that the above
"I>              equations gives a factor of 20 (megavoltage accelerators) --
"I>              500 (low energy x-ray tubes) for the maximum energy of the
"I>              incident electron spectrum.
"I>              If in doubt, just set to <=0 because the gain from an
"I>              energy dependent BCSE is modest (~20%).
"I>
"I>  Note that if BCSE is used in conjunction with uniform bremsstrahlung
"I>  splitting (UBS) then
"I>  Russian Roulette is automatically turned on (IRRLTT=2--see above).
"I>
"I>  BCSE is most efficient when used in conjunction with DBS or UBS
"I>
"%A31
"I>  ---------------------------------------------------------------------------
"I>
"I>                          CUSTOMIZED USER INPUTS
"I>                          **********************
"I>
"I>  This section contains inputs that are unique to the user.  In general
"I>  the user must modify beamnrc.mortran to read these inputs from the
"I>  .egsinp file.  Also, the GUI will not give access to these inputs.
"I>  If no custom inputs are required, then this section can be omitted
"I>  entirely.
"I>
"I>  Custom user inputs must appear in the .egsinp file between the delimiters:
"I>       :Start user inputs:
"I>       :Stop user inputs:
"I>
"I>  This section can appear either just before or just after the EGSnrc
"I>  inputs (see above).
"I>
"I>  Currently, the only custom user input hard-coded in beamnrc.mortran
"I>  is:
"I>
"I>   PHSP OUTPUT DIRECTORY= /full directory path to where phase space files
"I>                           are to be output, or blank
"I>             This allows the user to specify a directory other than
"I>             $EGS_HOME/BEAM_accelname in which to write phase space data.
"I>             Useful if phase space files are large and, due to disk space
"I>             limitations, must be written to a /temp area.  If left blank
"I>             or omitted entirely, then phase space files are output to the
"I>             default $EGS_HOME/BEAM_accelname directory.
"I>             [ PHSP_OUTDIR ]
"I>
"I>*****************************************************************************
;
"                        MORTRAN REPLACEMENT MACROS                    ""toc:
"                        **************************
"
"   The replacement macros which define the component module common blocks
"   are situated in $CMNAME_macros.mortran, one set for each component module.
"   beamnrc_user_macros.mortran contains macros available for modification
"   by the user.  All of these files are placed before beamnrc.mortran (this
"   file) before compilation is carried out.
"
"*******************************************************************************
;
"                               EGSnrc MACROS                            ""toc:
"                               ***********
;
"
" The following macro is used in the EGSnrc code system and replaces
" the definition of this macro found in egsnrc.macros
"
" ***************
" Negative USTEP:
" ***************
" Following macro used in ELECTR.  Negative values of USTEP set to 0.  Prints
" USTEP if <-1E-4.  Stops printing after 1000 negative USTEP values encountered
" to prevent filling the log file.  For BEAMnrc, set IAUSFL(6) to 0 since
" negative USTEP values are often encountered on boundaries and this may have
" been preceeded by a call to WHERE_AM_I where IAUSFL(6) is set to 1.  Since a
" negative USTEP will prevent an immediate call to AUSGAB, if this change were
" not made, IAUSFL(6) would remain set to 1 on exit from ELECTR
" and AUSGAB would be called the next time through ELECTR with IAUSFL(6)=1,
" giving an error in AUSGAB since in this case, ICMNEW=ICM.
"
REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
"         ============================"
  ;IF (USTEP<-1.E-4) [
"reset USTEP to 0 for fast step to set region number and medium only"
     IERUST=IERUST+1;
     IF (IERUST<1000) [
        ICM = IR_to_CM(IR(NP));
        OUTPUT IERUST,USTEP,IR(NP),IRNEW,IROLD,
           IRL-IR_start_CM(ICM)+1,ICM,
           X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2),E(NP),IQ(NP),
           U(NP),V(NP),W(NP);
           (4X,I4,' *** WARNING *** NEGATIVE USTEP=',E10.3,/10X,
            'IR,IRNEW,IROLD=',3I5,', Local IR=',I3,', ICM=',I3,
            /10X,'X,Y,Z,R=',4(1PE13.5)/10X,'E(NP),IQ(NP)=',1PE13.5,I5,
            /10X,'U,V,W = ',3(1PE13.5));
     ]
     ELSE IF (IERUST=1000) [
        OUTPUT;(///' *** ERROR ***  More than 1000 USTEP errors'///);
        WRITE(IOUTLIST,
                '(///'' *** ERROR ***  More than 1000 USTEP errors''///)');
        OUTPUT IHSTRY;(///' Number of histories sofar completed = ',I10///);
        WRITE(IOUTLIST,
                '(///'' Number of histories sofar completed ='',I10///)');
        $CALL_EXIT(1);
     ]
  ]
  USTEP=0.0;
  }
;

"the following calculates BLCMIN on the fly if using PRESTA-I as the"
"BCA--can save a lot of time, overrides macro of the same name in egsnrc.macros"
"This has been commented out because it produced real differences in"
"electron dosxyz calculations.  New default is to use PRESTA-I BCA with"
"fixed BLCMIN"
"REPLACE {$SET-SKINDEPTH(#,#);} WITH {"
"   ;IF( exact_bca ) ["
"        $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});"
"        skindepth = skindepth_for_bca*ssmfp;"
"    ]"
"    ELSE ["
"        p2 = {P1}*({P1}+rmt2); beta2 = p2/(p2 + rmsq);"
"        xccl = xcc(medium); blccl = blcc(medium); chia2 = xccl/(4*blccl*p2);"
"        skindepth ="
"          skindepth_for_bca*2*p2*beta2/xccl/(log(1+1./chia2)*(1+chia2)-1);"
"        IF( skindepth > 5 ) skindepth = 5;"
"    ]"
"};"

"the following change the defaults for the EGSnrc input parameters"
"override the values in egsnrc.macros"

"Brems angular sampling= Simple"
REPLACE {$IBRDST-DEFAULT} WITH {0}
;

"Bound Compton scattering= Off"
REPLACE {$IBCMP-DEFAULT} WITH {0}
;

"Atomic relaxations= Off"
REPLACE {$IEDGFL-DEFAULT} WITH {0}
;

"Photoelectron angular sampling= Off"
REPLACE {$IPHTER-DEFAULT} WITH {0}
;

"required to prevent needless calls to interaction subroutines"
"if a zero weight particle is placed on the stack--in DBS"
REPLACE {$AUSCALL(#);} WITH
   {IARG={P1} ;
    IF (IAUSFL(IARG+1).NE.0) CALL AUSGAB(IARG);
   IF(WT(NP)=0) RETURN;} ;

"
"*******************************************************************************
;
"                               BEAMnrc MACROS                          ""toc:
"                               ***********
"*******************************************************************************
"
%E    "beamnrc.mortran - start of range rejection macro                   "
" **************************************************
" Range rejection macro:
" **********************
" BEAMnrc bypasses the EGSnrc built-in range rejection (implemented in
" the $RANGE-DISCARD macro in EGSnrc) because EGSnrc range rejection
" uses particle range to AE, while we want to use particle range to
" ECUTRR(IRL), where ECUTRR(IRL)=ECUT(IRL) (IREJCT_GLOBAL=2) or
" ECUTRR(IRL)=energy required to leave region IRL and still have energy
" > ECUTIN at the bottom of the accelerator (IREJCT_GLOBAL=1).  In the
" macro below, DNEAR(NP) is the perpendicular distance from the particle to the
" nearest region boundary, range is the particle range to AE (calculated in
" EGSnrc) and RANGE_ECUTRR(IRL) is the range from ECUTRR(IRL) to AE
" (calculated at the beginning of the simulation).  Thus,
" range-RANGE_ECUTRR(IRL) is the particle range to ECUTRR(IRL), and if
" DNEAR is >= this, we can discard the particle.
"
" No range rejection is done in vacuum, if IREJCT=0, or if the particle energy
" exceeds ESAVE.
"
REPLACE {$USER-RANGE-DISCARD;} WITH {
"        ===================="
;
IF( i_rr_global = 1 & ibrspl = 2 & iphat(np)<nbrspl & dnear(np) > range ) [
    $RANDOMSET rnno24;
    IF( rnno24*nbrspl > iphat(np) ) [ np=np-1; return; ]
    wt(np) = wt(np)*nbrspl/iphat(np); iphat(np)=nbrspl;
]
IF( IREJCT_GLOBAL > 0 & MEDIUM ~= 0 & E(NP) < ESAVE(IRL) & IREJCT(IRL)=1 &
    DNEAR(NP) >= range-RANGE_ECUTRR(IRL))[

    "Perform charged-particle range-rejection using ecutrr"
    "range-RANGE_ECUTRR is the range to ECUTRR"

     IF(LELEC =  -1)[ IDISC=1;"electron" ] ELSE [IDISC=99;"positron"]
     IAUSFL(6)=0;
     "We re-set the flag to 0 because"
    "if the flag is 1 for this particle and we discard it "
    "before it is scored, the next particle on stack may be scored"
    "instead if USTEP<DNEAR and the flag is not re-set to 0 in HOWFAR "
     GOTO :USER-ELECTRON-DISCARD:;

]"end of perform range-rejection block"
}

;
" HOWNEAR replacement macros for PRESTA.  User must provide replacement macro
" for CM_HOWNEAR_$CMNAME which returns TPERP, the distance to closest boundary.
" Used in $SET-TUSTEP.
REPLACE {$CALL-HOWNEAR(#);} WITH {
"       ================"
        ;ICM = IR_to_CM(IRL);
        ;$GOTO_CM_LIST(HOWNEAR) ICM;
        ;$CM_LIST$CM_HOWNEAR({P1});
        :HOWNEAR_DONE: CONTINUE;
}

;REPLACE {CMLIST(#)$CM_HOWNEAR(#);} WITH {
:HOWNEAR_{P1}:  {P1}_CM_HOWNEAR({P2});
}
;REPLACE {CMLIST(#,#)$CM_HOWNEAR(#);} WITH {
        ;CMLIST({P2})$CM_HOWNEAR({P3});
        GOTO :HOWNEAR_DONE:;
:HOWNEAR_{P1}:  {P1}_CM_HOWNEAR({P3});
}
;
" *********************************
" Revised LATCH and NPASS features:
" *********************************
"
" At NRCC the variable LATCH is added to the stack and then passed on
" to a particles descendants - so we can use it to track a particles
" history   - e.g. add 1 to LATCH each time there is a Compton event, then
"             the current value tells how often the photon has scattered
"             so far - etc.
" In the version used for BEAMnrc, NPASS is 2-dimensional array specifying
" the number of times that particle NP or its ancestors have crossed
" scoring plane ISCORE.  The variable NPASS, like LATCH, is passed on to
" a particles descendants.  NPASSI is required for the initial call to
" SHOWER.  Note: We need NPASSI in common since it is not a call parameter to
" SHOWER.
" above comments about LATCH is not implemented. The implemented LATCH
" number is obtained through the bit set. ( for more detail information
" about the LATCH in BEAMnrc see 'BEAMnrc technical notes.)

REPLACE {$TRANSFER PROPERTIES TO (#) FROM (#);} WITH {
   X({P1})=X({P2});Y({P1})=Y({P2});Z({P1})=Z({P2});IR({P1})=IR({P2});
   WT({P1})=WT({P2});DNEAR({P1})=DNEAR({P2});
   LATCH({P1})=LATCH({P2});
   ZLAST({P1})=ZLAST({P2});
   NFTIME({P1})=NFTIME({P2});
   DO ISCORE=1,$MAX_SC_PLANES[ NPASS({P1},ISCORE)=NPASS({P2},ISCORE); ]
   NSPLIT({P1})=NSPLIT({P2});
   IPHAT({P1})=IPHAT({P2});
}

REPLACE {$TRANSFER PROPERTIES TO # FROM I;} WITH {
"        ================================="
   X{P1}=XI;Y{P1}=YI;Z{P1}=ZI;IR{P1}=IRI;
   WT{P1}=WTI; DNEAR{P1}=DNEARI;LATCH({P1})=LATCHI;
   DO ISCORE=1,$MAX_SC_PLANES [NPASS({P1},ISCORE)=NPASSI;]
   NSPLIT({P1})=NSPLITI; IPHAT({P1})=IPHATI;
}
"Note ZLAST is not transfered at start"
;
%E    "beamnrc.mortran - start of bremsstrahlung splitting macro          "
" **********************************************************"

"IBRSPL = 0 => NO ADDITIONAL BREMSSTRAHLUNG PHOTONS (DEFAULT)       "
"       = 1 => PERFORM UNIFORM BREMSSTRAHLUNG SPLITTING             "
"       = 2 => PERFORM DIRECTIONAL BREMSSTRAHLUNG SPLITTING         "
"THIS MACRO IS INVOKED AFTER THE FIRST CALL THE SUBROUTINE BREMS    "
"                                                                   "
; "BUFFER FLUSH"

" ***************** replacing the default $AUSCALL macro ************** "
"    With the definition below, which differs from the default          "
"    replacement in egsnrc.macros only by the last line, one can        "
"    cancel or modify interactions in AUSGAB. For instance, if one      "
"    wants to use an alternative implementation of Rayleigh scattering, "
"    one sets iausfl(20)=1, does own Rayleigh in ausgab when iarg=19    "
"    call occurs, puts an extra particle with weight 0 on the stack and "
"    returns. For the DBS stuff, the most elegant way of doing things   "
"    (at least for my taste) is to call ausgab just before a given      "
"    interaction occures, perform the interaction within ausgab the     "
"    desired number of times (0, 1, or nbrspl), and then skip the       "
"    call to the interaction routine by having a weight zero particle   "
"    on top of the stack.                                               "

REPLACE {$AUSCALL(#);} WITH {
    iarg = {P1};
    IF( iausfl(iarg+1) ~= 0 ) [
        call ausgab(iarg);
        IF( wt(np) <= 0 ) [ np = np-1; return; ]
    ]
};

/******************************************************************************

   The following macro implements photon cross section
   enhancement (CSE). CSE may be usefull for improving the statistics
   of electron contamination in photon beams and should be applied in
   the last air slab before the phantom.

   IK, Jan 29 2005.

 *****************************************************************************/

REPLACE {$RAYLEIGH-CORRECTION;} WITH {;

    IF(IRAYLR(IRL) = 1) [
        $EVALUATE COHFAC USING COHE(GLE); GMFP=GMFP*COHFAC;
    ]
    IF( use_cs_enhance ) [
        iarg = IR_to_CM(IR(NP));
        IF( cs_enhance(iarg) > 1 ) [ gmfp = gmfp/cs_enhance(iarg); ]
    ]

};


;

REPLACE{$FORCING-REMINDER} WITH {;
OUTPUT IRNEW,IRNEW,PCUT(IRNEW),E(NP),IRODUM,IR(NP);(/
            /' *** NO photon interaction forcing in region',I4/
             '     for particles of energies < PCUT(',I4,') =',
            F8.3,'MeV'/
             '     which differs from the pcut values elsewhere.'//
             '     This photon (E=',F8.3,'MeV) is forced to interact in'/
             '     regions',I4,' TO',I4,'.'//);
WRITE(IOUTLIST,
'(//'' *** NO photon interaction forcing in region'',I4/
''     for particles of energies < PCUT('',I4,'') ='',F8.3,''MeV''/
''     which differs from the pcut values elsewhere.''//
''     This photon (E='',F8.3,''MeV) is forced to interact in''/
''     regions'',I4,'' TO '',I4//)') IRNEW,IRNEW,PCUT(IRNEW),
             E(NP),IRODUM,IR(NP);
}

%E    "beamnrc.mortran - start photon forcing interaction scheme          "
"New photon interaction forcing scheme"

REPLACE {$SELECT-PHOTON-MFP;} WITH {
; CALL SELECT_PHOTON_MFP(DPMFP);
}

REPLACE {$SELECT-PHOTON-MFP-FOR-FORCING(#);} WITH
"         =================="
{;"We enter this macro if a photon is entering a new CM AND it should"
"be forced.  It is called either from SELECT_PHOTON_MFP or directly"
"from AUSGAB when a photon gets to the boundary of the forcing regions."
"Conditions to determine whether or not it should be forced"
"are:"
"1. the CM is NFCMIN and W(NP)>0 or the CM is NFCMAX and W(NP)<0"
"   In other words, the CM is one that we want to do forcing in"
"2. 1 <= NFTIME(NP) <= NFMAX--in other words, the number of times"
"   the photon will have interacted in the relevant CMs"
"   falls in the range of interaction numbers that we"
"   want to force."
"See the macro $SELECT-PHOTON-MFP for a detailed description of"
"most of the variables relevant to photon forcing"

"An additional variable used in this macro is MFORCF:"
"   MFORCF is a flag set to 0 at the beginning of the simulation.  However,"
"   if one region in which forcing is in effect has a PCUT higher than the"
"   rest of the forcing regions AND the energy of the photon before"
"   forcing is < PCUT in this region, a message is printed to the"
"   effect that photons with energy < this higher PCUT will only be"
"   forced up to the region with the higher PCUT.  Then MFORCF is set to 1"
"   to prevent repeated printouts of this warning."

"On exit from this macro, we have created two photons, one which is forced"
"to interact and occupies stack position NP-1 and a fictitious photon which"
"steps right through the forcing regions without interacting, in stack"
"position NP.  This macro does not actually transport either photon and"
"leaves both of them at the X,Y,Z position that the original, single photon"
"occupied before forcing.  However, the macro does calculate a"
"{P1} for the fictitious (non-interacting) photon based on the total"
"distance through the forcing regions with no interactions and then"
"a randomly selected distance past that (in which interactions may occur)."
"After dealing with the fictitious photon, the forced"
"photon is transported.  The forced photon is identified by having "
"NP_INC(NP)=1 (set in this macro) and is dealt with in the"
"$SELECT-PHOTON-MFP macro, where"
"a value of {P1} is calculated based on the distance to the first"
"interaction."

"force this photon to interact in the specified CMs"

NP_INC(NP)=1;    "flag, we are doing photon interaction forcing now"

NP=NP+1;
"set up 2 photons: top of stack will be non-interacting, fictitious photon"
"NP-1 will be photon that is forced"

;$TRANSFER PROPERTIES TO (NP) FROM (NP-1);
U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
DUMU=USTEP;IRODUM=IROLD;IRNDUM=IRNEW;ICMNEWDUM=ICMNEW;ICMOLDDUM=ICM;
MEDDUM=MEDIUM;IDUM=IDISC;PATHL=0.0;MEDTMP=0;
IF(IWATCH = 1 | IWATCH =2)[
   OUTPUT NP;(' Ficticious photon put on stack with NP =',I4);
]

"In the following loop, we calculate PATHL: the total number of photon"
"mean free paths required to pass right through the CMs where forcing"
"is on without interacting."
LOOP[
    USTEP=VACDST;IROLD=IR(NP);MEDIUM=MED(IROLD);
    IF(MEDIUM=0)["vacuum"
        DELTAP=0.;
    ]
    ELSE[
        IF(MEDTMP ~= MEDIUM)[
          MEDTMP=MEDIUM;
          $SET INTERVAL GLE,GE;
          $EVALUATE DELTAP USING GMFP(GLE);
        ]
        IF(IRAYLR(IROLD) =  1)[ $EVALUATE COHFAC USING COHE(GLE); ]
        ELSE[ COHFAC=1.0;]
    ]

    CALL HOWFAR;

    IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
    "only add to PATHL if this was not vacuum"

    IF( (IR_to_CM(IRNEW)<NFCMIN) | (IR_to_CM(IRNEW)>NFCMAX)
            | (IRNEW=1) ) EXIT;
    IF(E(NP)<PCUT(IRNEW))[
        IF(MFORCF=0)[ MFORCF=1;$FORCING-REMINDER;]
        EXIT;"get out from here because during transport the particle"
              "will be terminated in the next region. Thus we stop"
              "calculating effective thickness from here  "
    ]
    IR(NP)=IRNEW;
    X(NP)=X(NP)+USTEP*U(NP);
    Y(NP)=Y(NP)+USTEP*V(NP);
    Z(NP)=Z(NP)+USTEP*W(NP);
]

;$TRANSFER PROPERTIES TO (NP) FROM (NP-1);
"recover the position, etc. of the fictitious photon"
U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);E(NP)=E(NP-1);
USTEP=DUMU;IROLD=IRODUM;IRNEW=IRNDUM;ICMNEW=ICMNEWDUM;ICM=ICMOLDDUM;
MEDIUM=MEDDUM;IDISC=IDUM;

"we now calculate the weighting factor for the photon that will be"
"forced to interact in the required CMs (see eq 17 in RB90 review)"
IF(PATHL <= 1.0E-3)[GWAIT(NP-1)=PATHL*(1.-0.5*PATHL);]"for numerical accuracy"
ELSE[GWAIT(NP-1)=1.-EXP(-PATHL);]
GWTOLD=WT(NP-1);"save GWTOLD for below"
WT(NP-1)=GWTOLD*GWAIT(NP-1);"weight of forced photon"
"in fact, if PATHL = 0 there should be no photon interactions and  "
"therefore we should only have one photon rather than two. It is OK"
"now because WT(NP-1)=0 if this happens. See earlier comments.     "

"we now calculate the weighting factor for the photon which will   "
"carry the remaining weight and not interact again in relevant CMs "
GWAIT(NP)=1.-GWAIT(NP-1);
WT(NP)=GWTOLD*GWAIT(NP);
EPSLON=RNNO35*GWAIT(NP);
"This photon can only interact outside the"
"specified CMs for photon interaction forcing   "
"Now calculate {P1}, the number of mean free paths that the fictitious"
"photon goes before interaction.  It cannot interact in the first PATHL."
"The coding corresponds to {P1}=PATHL(in forcing region)-LOG(RNN035)"
"(ie it allows transport through the forcing CMs without interaction"
"and then interacts naturally past them)."
IF( (1.-GWAIT(NP)+EPSLON) <= 1.0E-3)[
    {P1}=(1.-GWAIT(NP)+EPSLON)*(1.+0.5*(1.-GWAIT(NP)+EPSLON));
]
ELSE[
    IF(GWAIT(NP)=EPSLON)[{P1}=1.0E30;]
    ELSE[{P1}=-LOG(GWAIT(NP)-EPSLON);]
]
"Note that this macro is somewhat inefficient since we will eventually"
"duplicate the transport done above in the loop.  We could someday recode."
}

REPLACE {$SCORE(#,#:#)} WITH {;

"Scoring macro:"
"{P1}{P2}=scoring array (eg SCDOSE(ID,ITDOSE))"
"{P3}=quantity to be scored (eg FTMP)"

"If the (primary) history number, NHSTRY_LAST, is the same as the history"
"that last scored in this array, {P1}_LAST{P2}, then {P3} is added"
"to a temporary array, {P1}_TMP{P2}.  Otherwise, we add"
"{P1}_TMP{P2} to {P1}{P2}, {P1}_TMP{P2}*{P1}_TMP{P2} to {P1}2{P2},"
"set {P1}_TMP{P2}={P3}, and set {P1}_LAST{P2}=NHSTRY."
"This scoring method allows us to calculate  uncorrelated value"
"of {P1}2{P2} which is then used to calculate the uncertainty"
"in {P1}{P2}.  This macro is only used for scoring energy deposited"
"(for dose calculations) and no. of steps."

IF(NHSTRY_LAST={P1}_LAST{P2})[
  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
]
ELSE[
  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
  {P1}_TMP{P2}={P3};
  {P1}_LAST{P2}=NHSTRY_LAST;
]
;
}

REPLACE {$ANALYZE(#,#:#)} WITH {;

"Macro to analyze uncertainty:"
"{P1}{P2}=scoring array (eg SCDOSE,(ID,ITDOSE))"
"{P3}=quantity to normalize by (eg incident no. of particles)"

"We add any portion of {P1}_TMP{P2} that remains unscored at"
"the end of the run to {P1}{P2} and {P1}2{P2} if we have not created a"
".egsdat file and then calculate the uncertainty on {P1}{P2}/{P3}.  The "
"uncertainty is stored in {P1}2{P2} and is expressed as a percentage of"
"{P1}{P2}/{P3} (max 99.9%).  Note that you must define the REAL*8 variable"
"SCORE_TEMP in any subroutine where this macro is used.  This macro"
"is only used in the analysis of dose and no. of steps."

IF(IDAT=1)[
  {P1}{P2}= {P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}= {P1}2{P2} +{P1}_TMP{P2}*{P1}_TMP{P2};
]

SCORE_TEMP={P1}{P2}/{P3};
{P1}2{P2}={P1}2{P2}/{P3};
{P1}2{P2}=({P1}2{P2}-SCORE_TEMP*SCORE_TEMP)/({P3}-1);
IF({P1}2{P2}>=0.) {P1}2{P2}= SQRT({P1}2{P2});
IF(SCORE_TEMP~=0.)[
    {P1}2{P2}= MIN({P1}2{P2}/SCORE_TEMP*100.D0,99.9D00);
]
ELSE[
    {P1}2{P2}=99.9D00;
]
;
}

"*******************************************************************************
;
"                        GENERAL-USE MACROS FOR BEAMnrc PROPER         ""toc:
"                        *************************************
;
" *********
" Data I/O:
" *********
"
" General input statement that exits correctly when end-of-file is reached

REPLACE {;MINPUT (#) #;} WITH {
;@LG@LS1READ(i_input,@LC10,END=:EOF_{P1}:,ERR=:ERROR_{P1}:){P2};@LC10FORMAT@LU1}

" ************
" Data typing:
" ************
"
" Data type definition for global change of precision
"
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"
" How often do I need to change this ???????????????????????????????????????
" It is defined in machine.macros (or in beamnrc_user_macros.mortran, if   "
" the user wants to overwrite), not here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"REPLACE {$REAL} WITH {REAL*4 }

"REPLACE {$INTEGER} WITH {INTEGER*4}

"REPLACE {$LONG_INT} WITH {INTEGER*8}

" $LONG_INT=INTEGER*8 is used to define a few variables, such as
" IHSTRY and NCASE in order to allow > 2.15x10^9 histories to be run
" This is particularly useful for parallel runs, where it is relatively
" easy to have a high total number of histories.
" However, this is non-standard Fortran on many systems.  We have compiled
" successfully on PC Linux, SGI, DEC Alpha and Sun Sparc systems.
" On rs6000 systems, the compiler may give warnings saying length specified
" is not valid for the specified type and revert to INTEGER*4, but compilation
" will be successful.  On HP9000 systems, the compilation may fail with error
" messages saying incompatible type-length combination.
" If compilation fails, replace $LONG_INT with INTEGER*4 in the macro above.
 "       ====="

"REPLACE {$SHORT_INT} WITH {INTEGER*2}

"This is used for variables which store the last primary history no. that
"scored a quantity of interest.  If your compiler has trouble with this
"change it to INTEGER*4.

" ****************
" Colour graphics:
" ****************
" Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM viewed with EGS_Windows
"
REPLACE {;$SELECT-COLOUR;} WITH {;ICOLOUR = MOD(ICM,4)+1;}
"       ================"
"
"*******************************************************************************
;
"                   GENERAL-USE MACROS FOR COMPONENT MODULES           ""toc:
"                   ****************************************
;
" **************************************************************
" Expansion macros for list-oriented GOTO for component modules:
" **************************************************************
"
REPLACE {;$GOTO_CM_LIST(#)} WITH {;GOTO ({REDUCE GOTO_CM_LIST/{P1}/$CM_LIST })}
"       ================="

REPLACE {GOTO_CM_LIST/#/CMLIST(#)}
WITH { :{P1}_{P2}: }
;
REPLACE {GOTO_CM_LIST/#/CMLIST(#,#)} WITH {
    :{P1}_{P2}:,GOTO_CM_LIST/{P1}/CMLIST({P3}) }

"  The following is used to expand ;CALL_INPUT; into a series of calls to
"  the input routines for each CM contained in $CM_LIST defined above
"
REPLACE {$INFORMAT} WITH {OLD};
;
REPLACE {;CALL INPUT_OLD_CMLIST(#);} WITH {
          ;CALL INPUT_{P1};
          OUTPUT;('  Input blank line to signify end of component module');
          read(i_input,*);
          }
REPLACE {;CALL INPUT_OLD_CMLIST(#,#);} WITH {
"       ================"
          ;CALL INPUT_{P1};
          ICM=ICM+1;
          ;IF (ICM > $MAX_CMs) GOTO :ERR_ICM_GT_MAX_CMs:;
          OUTPUT; (/1x,79('=')/
                '  Input blank line to signify start of component module');
          read(i_input,*); "skip an input line"
          OUTPUT ICM; (1x,79('=')/' Outer boundary of CM',I3,': ',$);
          ;MINPUT (MAIN) RMAX_CM(ICM);(F10.0);
          IF(RMAX_CM(ICM) = 0.0)RMAX_CM(ICM) = 100.;
          OUTPUT RMAX_CM(ICM);(F10.5);
          RMAX_CM2(ICM) = RMAX_CM(ICM)**2;
          ;CALL INPUT_OLD_CMLIST({P2});
          }
;
REPLACE {;CALL INPUT_NEW_CMLIST(#);} WITH {
          ;CALL INPUT_NEW_{P1};
          OUTPUT;('  Input blank line to signify end of component module');
          ;read(i_input,*);
          }
REPLACE {;CALL INPUT_NEW_CMLIST(#,#);} WITH {
"       ================"
          ;CALL INPUT_NEW_{P1};
          ICM=ICM+1;
          ;IF (ICM > $MAX_CMs) GOTO :ERR_ICM_GT_MAX_CMs:;
          " Input boundary of component module.  HOWFAR terminates particle "
          " histories that reach RMAX_CM(ICM)"
          OUTPUT; (/1x,79('=')/
                '  Input blank line to signify start of component module');
          ;read(i_input,*);
          OUTPUT ICM; (1x,79('=')/' Outer boundary of CM',I3,': ',$);
          ;MINPUT (MAIN) RMAX_CM(ICM);(F10.0);
          IF(RMAX_CM(ICM) = 0.0)RMAX_CM(ICM) = 100.;
          OUTPUT RMAX_CM(ICM);(F10.5);
          RMAX_CM2(ICM) = RMAX_CM(ICM)**2;
          ;CALL INPUT_NEW_CMLIST({P2});
          }
;
REPLACE {;CALL_INPUT;} WITH {
          ;IF (ICM > $MAX_CMs) GOTO :ERR_ICM_GT_MAX_CMs:;
          " Input radius of component module.  HOWFAR terminates particle "
          " histories that reach RMAX_CM(ICM)"
          OUTPUT;(/1x,79('=')/
           '  Input blank line to signify start of component module');
          ;read(i_input,*);
          :CMLAB1: FORMAT(' **************start of CM ',A8,2X,A8,
          '  *************');
          OUTPUT ICM; (/1x,79('=')/' Outer boundary of CM',I3,': ',$);
          ;MINPUT (MAIN) RMAX_CM(ICM);(F10.0);
          IF(RMAX_CM(ICM) = 0.0)RMAX_CM(ICM) = 100.;
          OUTPUT RMAX_CM(ICM);(F10.5);
          :CMLAB2:FORMAT(F10.5,',',T50,'Outer boundary') ;
          RMAX_CM2(ICM) = RMAX_CM(ICM)**2;
          {REDUCE ;CALL INPUT_$INFORMAT_$CM_LIST;}
                        "Set of calls to INPUT_$CMNAME"
          GOTO :SKIP_ERR_ICM_GT_MAX_CMs:;
          :ERR_ICM_GT_MAX_CMs: OUTPUT $MAX_CMs;
              (//' ******Number of component modules requested',
              ' is greater than the',I3,' available *******');
              $CALL_EXIT(1);
          :SKIP_ERR_ICM_GT_MAX_CMs: CONTINUE;}

;
" Macro to determine region number in adjacent CM when crossing CM boundary:
" {P1} is the current component module IICM (before crossing the boundary),
" {P2} is the direction, +1 for forward and -1 for backward.  Used in
" conjunction with $GOTO_CM_LIST.
"
REPLACE {;$WHERE_AM_I;} WITH {
"       ============="
   {REDUCE ;CALL WHAMI_$CM_LIST;}
   :WHAMI_DONE: CONTINUE;
   }
;REPLACE {;CALL WHAMI_CMLIST(#);} WITH {
; :WHAMI_{P1}:  ;CALL WHERE_AM_I_{P1}(IDIR);
   GOTO :WHAMI_DONE:;
   }
;
REPLACE {;CALL WHAMI_CMLIST(#,#);} WITH {
   ;CALL WHAMI_CMLIST({P2});
   :WHAMI_{P1}:  ;CALL WHERE_AM_I_{P1}(IDIR); GOTO :WHAMI_DONE:;
   }
;
" MACRO's to expand the call into a series of labelled
" calls to the individual CM's ISUMRY. The last CM ends up being the statement
" immediately after the original statement.
"
REPLACE {;$CALL_ISUMRY;} WITH { {REDUCE ;CALL ISUMRY__$CM_LIST;} }
"       =============="
;
REPLACE {;CALL ISUMRY__CMLIST(#);} WITH {CALL ISUMRY_{P1};}
;
REPLACE {;CALL ISUMRY__CMLIST(#,#);} WITH {
   ;CALL ISUMRY_{P1};
   ;CALL ISUMRY__CMLIST({P2});
   }
;
" ******************
" Media input macro:
" ******************
;
" Media input and sort to avoid repetition in /MEDIA/.  Checks whether last
" medium in character array MEDIA is repeated.  If not, NMED, the number of
" different media in the simulation, is incremented by 1 and MED_INDEX is set
" to NMED.  If so, MED_INDEX is set to the index of the matching medium in
" MEDIA.  NMED and MEDIA are in /MEDIA/, and MED_IN, the character array for the
" current medium, is in /CMs/.  Medium 0 is vacuum, medium 1 is ``AIR'',
" additional media start at medium 2.  Vacuum is chosen in input parameter
" file with VACUUM.  There is no default.
"
REPLACE {;$MED_INPUT(#);} WITH {
    ;OUTPUT ; (' MEDIUM (left justify): ',$);
    READ(i_input,'(24A1)',END=:EOF_{P1}:,ERR=:ERROR_{P1}:) (MED_IN(J),J=1,24);
    OUTPUT (MED_IN(J),J=1,24); (' ',24A1);
    IF(MED_IN(1) = 'V' & MED_IN(2)='A' & MED_IN(3)='C' &
       MED_IN(4) = 'U' & MED_IN(5)='U' & MED_IN(6)='M') [
       MED_INDEX=0; "Medium is vacuum"
    ]
    ELSE ["Medium is not vacuum"
       IF(NMED ~= 0)["if nominal air is vacuum, nmed might be zero"
          DO I = 1,NMED[
             MED_FLAG = 0;
             DO J = 1,24[
                IF(MEDIA(J,I) ~= MED_IN(J))[MED_FLAG = 1;EXIT;]
             ]
             IF(MED_FLAG =  0)[MED_INDEX = I;EXIT;]
             IF(I =  NMED)[
                NMED = NMED+1;
                MED_INDEX = NMED;
                DO J = 1,24[MEDIA(J,NMED) = MED_IN(J);]
                EXIT;
             ]
          ] "end of loop over I"
       ]"end NMED ~=0 block"
       ELSE ["NMED = 0 CASE"
          NMED = 1;
          MED_INDEX = NMED;
          DO J = 1,24[MEDIA(J,NMED) = MED_IN(J);]
       ]
    ]
}
;
"*******************************************************************************
;
"                             COMMON BLOCK MACROS                      ""toc:
"                             *******************
;
"V>******************************************
"V>Common block macros for component modules:
"V>******************************************
"V>
"V>COMMON/CMs/  Geometrical and range rejection information of interest to
"V>===========  all component modules:
"V>
"V>E_min_out(ICM) = minimum energy of electron leaving a CM ICM which can reach
"V>     the nearest downstream scoring region with energy greater than ECUT in
"V>     the scoring region. For use in range rejection.  Set in MAIN because
"V>     needs info from all CMs past the current one.
"V>MAX_CMs = number of CMs.
"V>MED_IN = 24-character name of last medium input in INPUT_$CMNAME.
"V>ICM = CM index, incremented before call to INPUT_$CMNAME, set in SRCHST and
"V>     HOWFAR during particle transport.
"V>ICMNEW = Next CM, set in WHERE_AM_I, different than ICM (only?) if particle
"V>     transported to CM boundary.
"V>ICM_to_SCORE(ICM) = scoring plane associated with ICM, 0 => none.  Set in
"V>     main based on IPLANE_to_CM(I) which is read in.
"V>IERR_GEOM(ICM) = geometry-checking flag for each CM, 0 if no errors detected,
"V>     1-99 specifies number of errors detected within CM, >100 specifies that
"V>     CM above overlaps
"V>IR_start_CM(ICM) = region number of first region in CM, set by previous CM,
"V>     read in subroutine INPUT_$CMNAME.
"V>IR_to_CM(IR) = pointer used in HOWFAR which says which CM a region IR is in.
"V>     Set in step 4 in MAIN.
"V>RMAX_CM(ICM) = outer boundary of treatment head, particles discarded if they
"V>     move outside of this boundary.  Read in step 2 in MAIN.
"V>RMAX_CM2(ICM) = square of outer boundary.
"V>RMAX_CM_FLAG(ICM) = flag for boundary of CM:  set in INPUT_$CMNAME.
"V>     0--bounds of CM are all set in  HOWFAR_$CMNAME,
"V>     1--CM is bounded by cylinder of radius RMAX_CM(ICM),
"V>     2--CM is bounded by square box at RMAX_CM(ICM) and  -RMAX_CM(ICM).
"V>Z_min_CM(ICM) = min Z value for each CM, set by previous CM in INPUT_$CMNAME
"V>     (back of previous CM) following the convention that the downstream
"V>     surface of source or accelerator exit window is at Z = 0.0.  Last value
"V>     (with ICM=MAX_CMs+1) is maximum Z of model.
"V>Z_gap_THICK(ICM) = thickness of air gap at front of CM to fill in space
"V>     between Z_min_CM and front of CM, set in INPUT_$CMNAME.
"V>Z_min_thick(ICM,j) minimum thickness in cm of up to j = 5 regions in
"V>     ICM for an electron going through ICM. It is used for range
"V>     rejection. It is set in each CMs input routine. j=1 is closest
"V>     to the bottom plane. Often only one = total thickness (air).
"V>MED_min_thick(ICM,j)  medium values corresponding to min thicknesses.
"V>ITDOSE_ON    if dose components to be scored, this flag is 1, otherwise 0
"V>ICM_CONTAM   If ITDOSE_ON is 1, and ICM_CONTAM is >= 1
"V>             then dose is broken into 2 components based on the charge
"V>             entering front of ICM ICM_CONTAM.
"V>IQ_CONTAM    type of the particles considered to be the contaminant
"V>             on entering ICM = ICM_CONTAM (identified via bit 30 in LATCH).
"V>XTUBE_EXISTS flag is 0 unless first CM in accelerator is XTUBE, in
"V>             which case it is 1.  It is set in XTUBE_INPUTS.
"V>ANGLE        = angle between X-ray target surface and z-axis
"V>CMTYPE(ICM)  8 character ordered array with names of CM types (SLABS etc)
"V>CMLIST(ICM)  8 character ordered array with identifiers for CMs
"V>AIR_INDEX    index for the ``air'' region =1 unless 0 for vacuum
"V>IDIRG        stores value of IDIR for use in AUSGAB to determine if a
"V>             particle is turned back before exiting a CM

REPLACE {;COMIN/CMs/;} WITH {
;COMMON/CMs/
   Z_min_CM,Z_gap_THICK,E_min_out,RMAX_CM,RMAX_CM2,Z_min_thick,ANGLE,
   BEAM_MU_INDEX,BEAM_MU_INDEX_OLD,
   ICM,ICMNEW,ICM_to_SCORE,IERR_GEOM,
   IR_start_CM,MAX_CMs,IR_to_CM,RMAX_CM_FLAG,
   MED_min_thick,
   ITDOSE_ON,ICM_CONTAM, IQ_CONTAM,XTUBE_EXISTS,AIR_INDEX,IDIRG,
   MED_IN, CMTYPE, CMLIST;
$REAL Z_min_CM($MAX_CMsP1),$LGN(Z_gap_THICK,
   E_min_out,RMAX_CM,RMAX_CM2($MAX_CMs)),Z_min_thick($MAX_CMs,5),ANGLE,
   BEAM_MU_INDEX,BEAM_MU_INDEX_OLD;
INTEGER ICM,ICMNEW,ICM_to_SCORE($MAX_CMs),IERR_GEOM($MAX_CMs),
   IR_start_CM($MAX_CMsP1),MAX_CMs,IR_to_CM($MXREG),RMAX_CM_FLAG($MAX_CMs),
   MED_min_thick($MAX_CMs,5),
   ITDOSE_ON,ICM_CONTAM, IQ_CONTAM,XTUBE_EXISTS,AIR_INDEX,IDIRG;
CHARACTER*4 MED_IN(24);
CHARACTER*8 CMTYPE($MAX_CMs), CMLIST($MAX_CMs);
}   "end of definition of /CMs/

"
" set of macros to generate lists of CM NAMEs and IDENTIFIERS
" ************************************
REPLACE {$CHAR_DATA} WITH {
   {SETR C=0} {SETR D=0}
   {REDUCE $CHAR_$CM_LIST; $CHAR_$CM_TYPE;}
}
;REPLACE {$CHAR_CMLIST(#)} WITH {
   {INCR C}
   CMLIST({COPY C}) = '{P1}';
}
REPLACE {$CHAR_CMLIST(#,#)} WITH {
   {INCR C}
   CMLIST({COPY C}) = '{P1}';
   $CHAR_CMLIST({P2});
}
;
REPLACE {$CHAR_CMTYPE(#)} WITH {
   {INCR D}
   CMTYPE({COPY D}) = '{P1}';
}
REPLACE {$CHAR_CMTYPE(#,#)} WITH {
   {INCR D}
   CMTYPE({COPY D}) = '{P1}';
   $CHAR_CMTYPE({P2});
}
;
"  COMIN/CM_LIST/  To include all component module commons
"  ==============
"
REPLACE {COMIN/CM_LIST/;} WITH { {REDUCE ;COMIN_CM_LIST/$CM_LIST/;} }

;REPLACE {;COMIN_CM_LIST/CMLIST(#)/;} WITH { ;COMIN/CM_{P1}/;}
;REPLACE {;COMIN_CM_LIST/CMLIST(#,#)/;} WITH {
   ;COMIN/CM_{P1}/;
   ;COMIN_CM_LIST/CMLIST({P2})/;
}

" **************************
" Other common block macros:
" **************************
"
"------------------------------------------------------------------"
"V>COMMON/GEOM/  Geometrical information:
"V>============
"V>
"V>NREG = number of regions.
"V>
REPLACE {;COMIN/GEOM/;} WITH {
;COMMON/GEOM/ NREG;
INTEGER NREG; }
;
"V>COMMON/IO_INFO/  Input and output information and unit numbers:
"V>===============
"V>
"V>Variables passed in common:
"V>TITLE = 80 character max, input by user for descriptive purposes
"V>
"V>Unit numbers passed in common:
"V>IOUTLIST = listing
"V>IOUTPLOT = plot file
"V>IORSTRT  = restart file, mainly containing scoring arrays (input)
"V>IOUTGPH  = EGS_Windows file for graphical display of particle history
"V>           note this is hardwired as 13 in the WATCH subroutine
"V>IOUTGEOM = EGS_Windows geometry file
"V>IOUTRN   = storage of initial random number for each history
"V>IINSRC   = unit number for input of phase-space source (input)
"V>IOUTFLU(I) particle phase-space output for scoring plane I
"V>DNTIME   = variable needed in date routine on suns
"V>DATEN,TIMEN = machine variables for time and date
"V>IXXIN,JXXIN = input random number seeds
"V>DATCOUNT = no. of .egsdat files added for recombining parallel job
"V>

REPLACE {;COMIN/IO_INFO/;} WITH {
;COMMON/IO_INFO/TITLE,IORSTRT,IINSRC,IOUTLIST,IOUTPLOT,
   IOUTGPH,IOUTGEOM,IOUTRN,IOUTFLU,IXXIN,JXXIN,DATCOUNT,
   DNTIME,TIMEN,DATEN;
CHARACTER*80 TITLE;
CHARACTER TIMEN*8,DATEN*11,DNTIME*24;
INTEGER IOUTLIST,IOUTPLOT,IORSTRT,IOUTGPH,IOUTGEOM,IOUTRN,
   IINSRC,IOUTFLU($MAX_SC_PLANES),IXXIN,JXXIN,DATCOUNT;
}   "end of definition of /IO_INFO/

;
"V>COMMON/SCORE/  Common used for scoring in AUSGAB:
"V>==============
"V>
"V>MXNP =   Maximum level to which the stack of daughter particles from an
"V>         incident particle rises (stack may include incident particle).
"V>ISTORE = 0 store the initial RNs for the 1st history of a batch(the default)
"V>       = 1 store the initial random numbers before the current history starts
"V>       =-1 start the 1st history with the RN seeds previously stored.
"V>IWATCH = 0 for normal output (the default)
"V>       = 1 output on every discrete interaction
"V>       = 2 output on every electron/photon step as well
"V>       = 4 prints out file for graphics.
"V>       = -N set to 2 for history N, set to 0 for all other histories
"V>IHSTRY = counter for total number of histories successfully simulated.
"V>NHSTRY = counter for number of primary (non-phsp source) histories
"V>         that score particles in a phsp source
"V>NHSTRY_LAST = INTEGER*2 version of NHSTRY -- resets at 32700 -- allows
"V>              us to get away with INTEGER*2 versions of SCFLU_LAST,
"V>              SCDOSE_LAST and SCSTP_LAST arrays
"V>INPHSP = counter for the particle number being read from the ph-sp file
"V>NPPHSP(3)= counters for total number of particles in phase space files
"V>NPFLU(3)= counters for total number of particles crossing scoring planes
"V>IO_OPT = 0 normal output
"V>       = 1 no phase-space output when particles cross scoring planes.
"V>       = 2 no ph-sp output,  do data analysis for source models
"V>       = 3 ph-sp output for up to 100 K particle histories and then only
"V>           do data analysis for source models
"V>       = 4 same as 0 but phase space files output in IAEA format
"V>IOUTSP = 0 no energy input spectrum data in output summary
"V>       = 1 include energy input spectrum data in output summary.
"V>TMCPUO = CPU time used in previous sessions.
"V>TIMMAX = maximum allowed CPU hours for a given calculation.
"V>EIN = kinetic energy of the external beam.
"V>IDAT = 0 store data arrays for re-use
"V>     = 1 don't store them.
"V>NCASE = number of histories remaining to be done.
"V>NCASEO = number of histories done in previous sessions.
"V>NHSTRYO = number of histories from primary (non-phsp) sources simulated
"V>          in previous runs (ISOURC=21 only)
"V>NCASET = number of histories already done.
"V>JCASE  = no. of histories in each batch
"V>IRESTART = 0 => initial run
"V>         = 1 => restarted run
"V>         = 2 => creation of input file only
"V>         = 3 => data analysis only
"V>is_finished = .true. on finishing the last job in a parallel run
"V>IQIN = charge of the external beam.
"V>SCSTP = scores total number of charged particle steps
"V>SCSTP2 = holds sum of squares of number of charged particle steps.
"V>         After analysis, holds fractional uncertainty in SCSTP
"V>SCSTP_TMP = scores total number of charged particle steps in 1 primary
"V>            history
"V>SCSTP_LAST = last primary history to contribute to SCSTP_TMP
"V>PIISTP = no. of PRESTA-II steps read from .egsdat files
"V>DOSE_STAT = 0 if primary history or can get no. of primary histories from
"V>            phsp source = 1 otherwise
"V>
"V>Dose scoring variables:
"V>AMASS(ID) = mass of scoring zone ID.
"V>SCDSTP/SCDSTP2/SCDSTP_TMP/SCDSTP_LAST = SCSTP, SCSTP2, SCSTP_TMP, SCSTP_LAST
"V>                                        for dose region
"V>ID = index of dose scoring zone.
"V>DOSE_ZONE(IR) = dose zone, 0 if IR not a dose scoring region.
"V>NDOSE_ZONE = number of dose scoring zones.
"V>SCDOSE(ID,IT) = array for scoring energy deposited in dose zone ID for
"V>                dose component IT.  Eventually holds normalized dose
"V>SCDOSE2(ID,IT) = array for storing sum of squares of energy deposited in
"V>                 zone ID for dose component IT.  After analysis, holds
"V>                 fractional uncertainty in dose.
"V>SCDOSE_TMP(ID,IT) = array stores energy deposited in zone ID for dose
"V>                    component IT over one primary history.
"V>SCDOSE_LAST(ID,IT) = last primary history to contribute energy to
"V>                     SCDOSE_TMP(ID,IT)
"V>
"V>Fluence scoring variables:
"V>ISCORE = index of scoring plane.
"V>ISZ = index of radial scoring zone on scoring plane.
"V>IPLANE_to_CM(ISCORE) = CM immediately upstream of scoring plane.
"V>NSC_PLANES = number of planes for fluence scoring and phase space data.
"V>NSC_ZONES(ISCORE)  = number of zones in scoring planes for fluence scoring.
"V>MZONE_TYPE(ISCORE) = type of scoring zones for fluence scoring:
"V>                     0-annular, 1-square.
"V>RSCORE_ZONE(ISCORE,ISZ) outer dimension(radius or half-side)for scoring zones
"V>RSCORE_ZONE2(ISCORE,ISZ) = square of outer radius of scoring zone .
"V>SCFLU(IQ+2,ISCORE,ISZ,IP) = array for scoring particle number, energy, and
"V>     angle wrt z-axis.  The scoring parameter index IP is defined as follows:
"V>         1 to 4 - 1st crossing of scoring plane:
"V>           1-number, 2-fluence, 3-energy, 4-angle wrt z-axis
"V>         5 to 8 - particle or ancestors crossed scoring plane at least once:
"V>           5-number, 6-fluence, 7-energy, 8-angle wrt z-axis.
"V>                            After uncertainty, analysis, this array actually
"V>                            holds normalized particle number, fluence,
"V>                            energy and angle wrt z-axis.
"V>SCFLU2(IQ+2,ISCORE,ISZ,IP) = array for holding the sum of the squares of
"V>                             the quantities scored in SCFLU.  After
"V>                             uncertainty analysis, it holds the fractional
"V>                             uncertainty for the quantities scored in
"V>                             SCFLU.  Array indices have same meaning as in
"V>                             SCFLU.
"V>SCFLU_TMP(IQ+2,ISCORE,ISZ,IP) = array that holds scored particle number,
"V>                                energy and angle wrt z-axis for 1 primary
"V>                                history.  Array indices same as for SCFLU
"V>SCFLU_LAST(IQ+2,ISCORE,ISZ,JP) = array that stores last primary history to
"V>                                score particle of charge IQ, crossing
"V>                                plane ISCORE in scoring zone ISZ.  JP=1 if
"V>                                this is a first time crossing; JP=2 for
"V>                                multiple crossers.
"V>SCFLU_COV(IQ+2,ISCORE,ISZ,KP) = for particles of charge IQ, crossing zone
"V>                                ISZ of scoring plane ISCORE, this array
"V>                                stores energy*no. (weighted) summed over
"V>                                all primary histories for first time
"V>                                crossers (KP=1) and multiple crossers
"V>                                (KP=2) and also stores angle*no. (weighted)
"V>                                summed over all primary histories for
"V>                                first time (KP=3) and multiple (KP=4)
"V>                                crossers.  It is eventually used to
"V>                                calculate the covariance between energy
"V>                                and no. and angle and no. so that the
"V>                                uncertainties on energy/no. and angle/no.
"V>                                can be estimated properly
"V>SCFLU_NUM(IQ+2,ISCORE,ISZ,JP) = array that stores the no. of particles
"V>                                of charge IQ, crossing zone ISZ of scoring
"V>                                plane ISCORE.  Does not take into account
"V>                                particle weight.  JP has same meaning as
"V>                                in SCFLU_LAST.
"V>SCFLU_NOCOV(IQ+2,ISCORE,ISZ,JP)= 1 if SCFLU_NUM(IQ+2,ISCORE,ISZ,JP) <
"V>                                 $COVNUM, 0 otherwise.  $COVNUM is the
"V>                                 minimum no. of particles
"V>                                 required to include covariance in the
"V>                                 uncertainty estimate of average energy
"V>                                 and average angle.  It is defined in
"V>                                 beamnrc_user_macros.mortran.
"V>MAX_BIT  = maximum number of bit set
"V>IREGION_TO_BIT = region which set to bit number
"V>EKMAXPHSP(ISCORE) = the max kinetic energy of particles in a phsp file
"V>EKMINPHSPE(ISCORE) = min kinetic energy of e-'s in a phsp file
"V>NINCPHSP = # of incident particles (non-phsp source) used (replaces
"V>            the variable EKMINPHSPG(ISCORE))
"V>NPHOTPHSP(ISCORE) = the total number of photons in a phsp file
"V>ZPHSP(ISCORE) = the value of Z of the phsp file (currently not used)
"V>FLUENCERR(ISCORE)=0 if fluence in scoring zone 6 is okay
"V>IPLOTFLAG=1 if CHAMBER is used for dose scoring
"V>ZPLOTCHM($MAX_DOSE_ZONE+1) z-position of each dose zone in CHAMBER
"V>MAXWEIGHT = max. weight of particles crossing all scoring planes
"V>MINWEIGHT = min. weight of particles crossing all scoring planes
"V>ECUTIN = stores global ECUT--variable kept here because it is used in CMs
"V>PCUTIN = stores global PCUT--variable kept because it is used in CMs
"V>NUM_BREM = total number of bremsstrahlung interactions in this run
"V>data_unit = unit number of .egsdat file (4)
"V>PHSP_OUTDIR = directory to output phase space file to (an option)

REPLACE {;COMIN/SCORE/;} WITH {
;COMMON/SCORE/
   "Ali:GRID"
   NX_ZONE,NY_ZONE,XMIN_ZONE,XMAX_ZONE,YMIN_ZONE,YMAX_ZONE,
   SCDOSE,SCDOSE2, SCFLU, SCFLU2,
   SCFLU_COV, SCSTP,SCDSTP,SCSTP2,SCDSTP2, PIISTP,PHSP_OUTDIR,
   AMASS,TMCPUO,TIMMAX,EIN, RSCORE_ZONE, RSCORE_ZONE2,
   EKMAXPHSP, EKMINPHSPE, NINCPHSP, ZPHSP, ZPLOTCHM,MAXWEIGHT,
   MINWEIGHT,ECUTIN,PCUTIN, SCDOSE_TMP, SCFLU_TMP,
   SCSTP_TMP,SCDSTP_TMP, IHSTRY,NHSTRY,NCASE,NCASEO,NHSTRYO,NCASET,JCASE,
   NPPHSP, NPHOTPHSP, INPHSP,NPFLU, SCFLU_NUM,
   is_finished, data_unit,MXNP,ISTORE,IWATCH,IO_OPT,IOUTSP,ID,
   NSC_PLANES,NSC_ZONES, IPLANE_to_CM,IZLAST,I_MU_PHSP,IZSCORE,JHSTRY,
   ISCORE,ISZ,IDAT, IRESTART, IQIN,MZONE_TYPE,NDOSE_ZONE,DOSE_ZONE,
   MAX_BIT,IREGION_TO_BIT, LNEXC, LNINC, L_N_EXC,L_N_INC,
   FLUENCERR,IPLOTFLAG,DOSE_STAT,NUM_BREM,
   SCFLU_NOCOV,NHSTRY_LAST,SCSTP_LAST,SCDSTP_LAST, SCDOSE_LAST, SCFLU_LAST;
REAL*8 SCDOSE($MAX_DOSE_ZONE,$MAXIT),SCDOSE2($MAX_DOSE_ZONE,$MAXIT),
   SCFLU(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
   SCFLU2(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
   SCFLU_COV(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,4),
   SCSTP,SCDSTP,SCSTP2,SCDSTP2, PIISTP;
CHARACTER*80 PHSP_OUTDIR;
$REAL AMASS($MAX_DOSE_ZONE),TMCPUO,TIMMAX,EIN,
   RSCORE_ZONE($MAX_SC_PLANES,$MAX_SC_ZONES),
   RSCORE_ZONE2($MAX_SC_PLANES,$MAX_SC_ZONES),
   EKMAXPHSP($MAX_SC_PLANES), EKMINPHSPE($MAX_SC_PLANES),
   NINCPHSP, ZPHSP($MAX_SC_PLANES),
   ZPLOTCHM($MAX_DOSE_ZONE+1),MAXWEIGHT,MINWEIGHT,ECUTIN,PCUTIN,
   SCDOSE_TMP($MAX_DOSE_ZONE,$MAXIT),
   SCFLU_TMP(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
   SCSTP_TMP,SCDSTP_TMP,
   "Ali:GRID"
   XMIN_ZONE($MAX_SC_PLANES),XMAX_ZONE($MAX_SC_PLANES),
   YMIN_ZONE($MAX_SC_PLANES),YMAX_ZONE($MAX_SC_PLANES);

$LONG_INT IHSTRY,NHSTRY,NCASE,NCASEO,NHSTRYO,NCASET,JCASE,
   NPPHSP($MAX_SC_PLANES),NPHOTPHSP($MAX_SC_PLANES),INPHSP,
   NPFLU($MAX_SC_PLANES),
   SCFLU_NUM(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2);
$LOGICAL is_finished;
INTEGER data_unit,MXNP,ISTORE,IWATCH,IO_OPT,IOUTSP,ID,
   NSC_PLANES,NSC_ZONES($MAX_SC_PLANES),
   IPLANE_to_CM($MAX_SC_PLANES),IZLAST,I_MU_PHSP,IZSCORE,JHSTRY,
   ISCORE,ISZ,IDAT, IRESTART,
   IQIN,MZONE_TYPE($MAX_SC_PLANES),NDOSE_ZONE,DOSE_ZONE($MXREG),
   MAX_BIT,IREGION_TO_BIT($MXREG),
   LNEXC, LNINC, L_N_EXC($MAXIT, 32),L_N_INC($MAXIT,32),
   FLUENCERR($MAX_SC_PLANES),IPLOTFLAG,DOSE_STAT,NUM_BREM,
   SCFLU_NOCOV(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2),

   "Ali:GRID"
   NX_ZONE($MAX_SC_PLANES),NY_ZONE($MAX_SC_PLANES);

$SHORT_INT NHSTRY_LAST,SCSTP_LAST,SCDSTP_LAST,
           SCDOSE_LAST($MAX_DOSE_ZONE,$MAXIT),
           SCFLU_LAST(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2);
}   "end of definition of /SCORE/

;
"V>
"V>COMMON/SOURCE/  Particle source information:
"V>==============
"V>
"V>Variables passed in common:
"V>GAMMA = 1/2 angle in degrees of swept beam or point source(ISOURC=5or1)
"V>ONEMCOSGAM = 1 - COSGAMMA   used in sampling for ISOURC=1
"V>COSGAMMA = cos of gamma(ISOURC=5, and ISOURC=1)
"V>RBEAM = radius (side of square if<0) of beam at the front of 1st CM.
"V>RBEAM0 = beam spot radius at Z=0 for source 8
"V>WBEAM = -RBEAM/2  for RBEAM < 0, i.e. square point source beams
"V>UINC = incident x-axis direction cosine (ISOURC=0).
"V>VINC = incident y-axis direction cosine (ISOURC=0).
"V>WINC = incident z-axis direction cosine (ISOURC=0).
"V>XBEAM = half-width of the beam in X direction
"V>ZBEAM = half-height of the beam
"V>YBEAM = half-width of the beam in y direction
"V>XBEAM0 = x coordinate of the beam centre
"V>YBEAM0 = y coordinate of the beam centre
"V>XINL = lower X bound of beam on CM 1 (ISOURC=1)
"V>XINU = upper X bound of beam on CM 1 (ISOURC=1)
"V>YINL = lower Y bound of beam on CM 1 (ISOURC=1)
"V>YINU = upper Y bound of beam on CM 1 (ISOURC=1)
"V>XINDEL = XINU-XINL for ISOURC=1 as a rectangular beam
"V>YINDEL = YINU-YINL for ISOURC=1 as a rectangular beam
"V>DISTRH = distance of the source from the middle of the target.
"V>DSTRH2 = DISTRH**2.
"V>DISTZ = distance of the point source from the front of the target.
"V>DISTZ2 = DISTZ**2.
"V>DISTB = distance of the point source from the back of the target.
"V>DISTB2 = DISTB**2.
"V>RCYL1 = radius of the target.
"V>RCYL2 = RCYL1**2.
"V>FD_AT100 = SCANNING FIELD SIZE USED IN ISOURC=7
"V>IRATIO_YXF/2 = THE RATIO OF THE SCANNING BET Y/X DIRECTION
"V>XSCAN_UNIT = SCANNING STEP IN HALF SCANNING CYCLE
"V>PROBFC = probability that incident beam strikes the flat face (ISOURC=12).
"V>PROBBK = probability that incident beam strikes the flat face (ISOURC=12).
"V>PROBSD = probability that incident beam strikes the curved side (ISOURC=12).
"V>ASIDE = rectangular area of the target seen by the beam.
"V>ZCOFST = Z-axis offset of the center of the target.
"V>ZSOFST = Z-axis offset of the source.
"V>NRDIST = # radial bin distribution histogram (ISOURC=20).
"V>NSRCRG = source region for isotropically radiating source (ISOURC=3).
"V>RMINBM = minimum beam radius for ISOURC=14, and ISOURC=3.
"V>RMINSQ = RMINBM**2.
"V>EINSRC = highest possible particle energy from phase-space (ISOURC=21).
"V>NSHIST = number of particles in source file (ISOURC=21).
"V>NSLEFT = number of particles remaining in source file (ISOURC=21).
"V>SPCNAM = 256-character file name of source data file (ISOURC=21 AND 31).
"V>Z_SOURCE = distance from source to reference plane.
"V>INIT_ICM = init ICM # for isourc=21 case, input from temp2 on source line
"V>N_ph_sp_e(g,p) = # of elec, gamma, positrons started from phase space file
"V>E_ph_sp_e(g,p) = energy of elec, gamma, pos started from phase space file
"V>E_MAX_ph_sp =max energy of any particle started from phase space file
"V>NPASS_ph_sp = number of particles rejected from phase space for NPASS=1
"V>NPASS_ph_spO = no. of particles rejected from phase space source in past
"V>               run
"V>SINGAMM = sine of gamma(ISOURC=5)
"V>XYBEAM = X or Y size of the beam at the front of the target.
"V>NNPHSP =number of particles in source 21
"V>NPHOTSRC = number of photons in source 21
"V>EKMAXSRC = max kinetic energy of particles in source 21
"V>EKMAX = max. kinetic energy of particles in source
"V>EKMINSRCE = min kinetic energy of e-'s in source 21
"V>NINCSRC = # of incident particles (from non-phsp source) used to generate
"V>          the source (replaces EKMINSRCG)
"V>ZSRC = Z at which phsp file for source 21 file was written (not used yet)
"V>OLDSRC = 1 if the phsp file was generated by an older version of BEAM
"           and does not contain EKMAXSRC in record 1 and/or does not
"           contain NINCSRC in record 1
"V>FILNAM = 256-character file name for energy spectrum file
"V>NPTS_SRC9 = number of discrete points for source 9
"V>X_SRC9,Y_SRC9 = X,Y at SSD of discrete points for source 9
"V>PROB_SRC9 = probability for each discrete point of source 9
"V>ZSMIN = min Z for source 3
"V>ZSMAX = max Z for source 3
"V>MIN_CM_SRC3 = min CM spanned by source 3
"V>MAX_CM_SRC3 = max CM spanned by source 3
"V>CHOSEN_SRC18 = 0 at start or if we've taken both gaussian distributed
"                 radii from the routine for source 18
"               = 1 if we've only taken the first gaussian distributed
"                 radius from source 18 routine
"V>RIN1_SRC18 = first gaussian-distributed radius calculated by source 18
"V>RIN2_SRC18 = second gaussian-distributed radius calculated by source 18
"V>RINMAX = max radius of source as defined by RMAX_CM(1)
"V>ISOURC = flag for source type.
"V>OUTCNT Keeps track of # of times phsp file for source 21 is
"V>        exhausted
"V>IFPB = flags if ISOURC = 0,2 OR 4.
"V>MONOEN = 0 if use monoenergetic beam,
"V>       = 1 if use source dist'n,
"V>       = 2 if use phase-space of each particle from source.
"V>SPEC_TITLE = 80 char title at top of energy spectrum
"V>NRCYCL = no. of times to recycle each particle from a phsp source before
"V>         moving on to the next one (ISOURC=21)
"V>CYCLNUM  keeps track of how many times a particle has been used
"V>IPARALLEL = no. of parallel jobs into which a simulation is split(ISOURC=21)
"V>PARNUM = set to a different integer value in the range 1<=PARNUM<=IPARALLEL
"V>         for the IPARALLEL parallel jobs (ISOURC=21)
"V>WEIGHTOLD holds WEIGHT for recycled particles (ISOURC=21)
"V>UINOLD    holds UIN for recycled particles (ISOURC=21)
"V>VINOLD    holds VIN for recycled particles (ISOURC=21)
"V>WINOLD    holds WIN for recycled particles (ISOURC=21)
"V>XINOLD    holds XIN for recycled particles (ISOURC=21)
"V>YINOLD    holds YIN for recycled particles (ISOURC=21)
"V>ZINOLD    holds ZIN for recycled particles (ISOURC=24)
"V>INIT_ICMOLD holds ICM for recycled particles (ISOURC=24)
"V>ISRC_DBS  set to 1 if DBS used to generate the source and you wish to
"V>          reject fat photons that will fall outside the DBS splitting
"V>          radius (ISOURC=21)
"V>i_iaea_in = 1 if the phase space source is in IAEA format.  This
"V>          is done automatically based on detecting .IAEAphsp at the end
"V>          of the file name as input
"V>RSRC_DBS  DBS splitting radius used to generate source (ISOURC=21)
"V>SSDSRC_DBS SSD where RSRC_DBS was defined when source was generated
"V>           (ISOURC=21)
"V>ZSRC_DBS  Z where source was generated (ISOURC=21)
"V>NFAT_ph_sp  no. of photons rejected because their trajectory would take
"V>          them beyond the RSRC_DBS at SSDSRC_DBS (ie fat photons) (ISOURC=21)
"V>NFAT_ph_spO no. of fat photons rejected in previous run
"V>sigma_src19 mean angular spread of incident particles in degrees
"              (ISOURC=19)
"V>i_dsb set to 1 for directional source biasing
"V>splitcm_dsb CM no. where particles are split/rotated upon entering
"V>dsb_delta distance between rotated particles in source biasing
"V>dsb_rbin  array of radii corresponding to different splitting no.s
"V>ALPHA24,BETA24  angles of rotation about X- and Y-axes (source 23, 24)
"V>SALPHA24,CALPHA24 sin and cos of ALPHA24 (angle of rotation about X-axis)
"V>                  for source 24 and 23
"V>SBETA24,CBETA24 sin and cos of BETA24 (angle of rotation about Y-axis)
"V>                  for source 24 and 23
"V>DIST24    distance of point of rotation from INIT_ICM (source 24 and 23)

;
REPLACE {$INVDIM} WITH {1000}
;
REPLACE {$NENSRC} WITH {240}
;
REPLACE {;COMIN/ENERGYSRC/;} WITH {
;COMMON/ENERGYSRC/NENSRC,IMODE,ENSRCD,SRCPDF,SRCCDF,ENMIN,CDFINV,
     DELTAK,IB, FILNAM;
$REAL ENSRCD($NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),ENMIN,
     CDFINV($INVDIM,2),DELTAK;
INTEGER IMODE,NENSRC,IB;
CHARACTER*256 FILNAM;}
;
" IK: reordered common block to start with largest members first "
"     (that's what one should always do) "

REPLACE {$DSB_MAX_BIN} WITH {1000};
REPLACE {;COMIN/SOURCE/;} WITH {
;COMMON/SOURCE/
   COSGAMMA,GAMMA,ONEMCOSGAM,THETAIN,RTHETAIN,
   THETAI,COSTHETA,SINTHETA,
   DUMMY15,DUMMY11,DUMMY22,UINP,VINP,WINP,SIGN1,SIGN2,RIN1_SRC18,
   RIN2_SRC18,RINMAX,SALPHA24,CALPHA24,SBETA24,
   CBETA24, NNPHSP,NPHOTSRC,WBEAM,
   RBEAM,RBEAM0,RBEAM2,UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
   DISTZ,DISTZ2,
   DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,ASIDE,ZCOFST,ZSOFST,
   RMINBM,RMINSQ,EINSRC,Z_SOURCE,E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp,
   SINGAMMA,FD_AT100,XSCAN_UNIT,XYBEAM,XBEAM0,YBEAM0,
   XINL,XINU,YINL,YINU,XINDEL,YINDEL,
   EKMAXSRC, EKMAX, EKMINSRCE, NINCSRC, ZSRC, X_SRC9,
   Y_SRC9, PROB_SRC9, ZSMIN, ZSMAX,
   RNNO1, RNNO2,AK, RCDFIN,RDISTF,RPDF,RCDF,
   FNORM20, IBNSOK, GRIDSZ, RIN, ZFOCUS,
   COSRNG,SINRNG,WEIGHTOLD,UINOLD,VINOLD,WINOLD,XINOLD,YINOLD,ZINOLD,
   RSRC_DBS,SSDSRC_DBS,ZSRC_DBS,sigma_src19,DIST24,ALPHA24,BETA24,RBEAMY,
   xo_src19, yo_src19,
   NRDIST,NSRCRG,NSHIST,NSLEFT,N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,
   NPASS_ph_sp, NPASS_ph_spO, NFAT_ph_sp, NFAT_ph_spO,
   INIT_ICM, IRATIO_YXF, OLDSRC,NPTS_SRC9,
   MIN_CM_SRC3, MAX_CM_SRC3, MODEIN, ICOUNT, IERROR,
   RLAST, IB20, K20,IRDIST,CHOSEN_SRC18,ISOURC,OUTCNT,IFPB,MONOEN,
   NRCYCL,CYCLNUM,IPARALLEL,PARNUM,ISRC_DBS,i_iaea_in,INSIDE_FLAG,
   INIT_ICMOLD,I_MUPHSP_IN,SPCNAM,
   the_beam_code,the_input_file,the_pegs_file,SPEC_TITLE,phsp_open;
REAL*8 COSGAMMA,GAMMA,ONEMCOSGAM,THETAIN,RTHETAIN,
       THETAI,COSTHETA,SINTHETA,
       DUMMY15,DUMMY11,DUMMY22,UINP,VINP,WINP,SIGN1,SIGN2,RIN1_SRC18,
       RIN2_SRC18,RINMAX,SALPHA24,CALPHA24,SBETA24,
       CBETA24;
$LONG_INT NNPHSP, NPHOTSRC;
$REAL WBEAM,
   RBEAM,RBEAM0,RBEAM2,UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,
   DISTZ,DISTZ2,
   DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,ASIDE,ZCOFST,ZSOFST,
   RMINBM,RMINSQ,EINSRC,Z_SOURCE,E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp,
   SINGAMMA,FD_AT100,XSCAN_UNIT,XYBEAM,XBEAM0,YBEAM0,
   XINL,XINU,YINL,YINU,XINDEL,YINDEL,
   EKMAXSRC, EKMAX, EKMINSRCE, NINCSRC, ZSRC, X_SRC9($MAXPTS_SRC9),
   Y_SRC9($MAXPTS_SRC9), PROB_SRC9($MAXPTS_SRC9), ZSMIN, ZSMAX,
   RNNO1, RNNO2,AK, RCDFIN($MXRDIST,2),RDISTF($MXRDIST),
   RPDF($MXRDIST),RCDF($MXRDIST),
   FNORM20, IBNSOK, GRIDSZ, RIN, ZFOCUS,
   COSRNG,SINRNG,WEIGHTOLD,UINOLD,VINOLD,WINOLD,XINOLD,YINOLD,ZINOLD,
   RSRC_DBS,SSDSRC_DBS,ZSRC_DBS,sigma_src19,DIST24,ALPHA24,BETA24,RBEAMY,
   xo_src19, yo_src19;
INTEGER NRDIST,NSRCRG,NSHIST,NSLEFT,N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,
      NPASS_ph_sp, NPASS_ph_spO, NFAT_ph_sp, NFAT_ph_spO,
      INIT_ICM, IRATIO_YXF, OLDSRC,NPTS_SRC9,
      MIN_CM_SRC3, MAX_CM_SRC3, MODEIN, ICOUNT, IERROR,
      RLAST, IB20, K20,IRDIST,CHOSEN_SRC18,ISOURC,OUTCNT,IFPB,MONOEN,
      NRCYCL,CYCLNUM,IPARALLEL,PARNUM,ISRC_DBS,i_iaea_in,INSIDE_FLAG,
      INIT_ICMOLD,I_MUPHSP_IN;
CHARACTER*256 SPCNAM;
CHARACTER*80 the_beam_code,the_input_file,the_pegs_file,SPEC_TITLE;
$LOGICAL phsp_open;

}


" COMIN/USER/
" ===========
"
REPLACE {;COMIN/USER/;} WITH {
;COMIN/USER-PHOTON-FORCING,USER-RANGE-REJECTION,USER-SPLITTING,
       USER-STACK,
       USER-DIRECTIONAL-BREM-SPLITTING,USER-CS-ENHANCEMENT,
       USER-CUSTOM-VARIABLES,USER-DYNVMLC,USER-DIRECTIONAL-SOURCE-BIASING,
       USER-DYNJAWS,USER-SYNCJAWS,USER-SYNCMLCE,USER-SYNCVMLC,USER-SYNCHDMLC,
       USER-BCSE/;
}

"V>COMMON/USER-CS-ENHANCEMENT/   Common for cross section enhancement,
"V>                              included in COMIN/USER/
"V>                              Added by IK July 13 2005
"V>
"V> cs_enhance(icm) = photon cross section enhancement factor in CM icm.
"V>                   Default is 1 (i.e. no cross section enhancement).
"V> use_cs_enhance  = true, if any of cs_enhance(i) > 1, false otherwise.
REPLACE {;COMIN/USER-CS-ENHANCEMENT/;} WITH {;
    common/cs_enhancement/ cs_enhance($MAX_CMs), cse_return($MXAUS),
                           use_cs_enhance;
    $REAL                  cs_enhance;
    $LOGICAL               cse_return, use_cs_enhance;
};

"Ali:BCSE"
"IK: modified BCSE"
REPLACE {;COMIN/USER-BCSE/;} WITH {;
    COMMON/BCSE/ BCSE_FACTOR_C,BCSE_POWER_N,BCSE_FACTOR,ENPOLD_ORGNL,
                 is_bcse_medium($MXMED),
                 MED_BCSE,NBRSPL_ORGNL,nmed_enhance,USE_BCSE;
    $LOGICAL     USE_BCSE,is_bcse_medium;
    $INTEGER     MED_BCSE,NBRSPL_ORGNL,nmed_enhance;
    $REAL        BCSE_FACTOR_C,BCSE_POWER_N,BCSE_FACTOR,ENPOLD_ORGNL;
};

;
"V>COMMON/USER-RANGE-REJECTION/  Common used for range rejection, included in
"V>============================  COMIN/USER/
"V>
"V>ESAVE_GLOBAL = global upper energy for range rejection, may differ for
"V>     specific regions.
"V>ECUTRR(IR) = minimum energy of particle on exit from region IR.
"V>     Set in main using E_min_out.
"V>RANGE_ECUTRR(IR) = range in cm at ECUTRR to AE - calculated in main
"V>IREJCT(IR) = 0 => no electron range rejection
"V>           = 1 => use restricted stopping power for range calculation,
"V>                  discard if particle range is less than DNEAR.
"V>           > 1 These options were never really used and removed
"V>IREJCT_GLOBAL = global setting for IREJCT, only has effect when 0, 1 or 2
"V>              = 0 => sets IREJCT to 0 for all regions.
"V>              = 1 => initializes IREJCT(IRL)=1 for all regions and sets up
"V>                     ECUTRR arrays automatically
"V>                     Note CMs can turn it off in individual regions
"V>              = 2 => as for = 1 but do not set up ECUTRR array
"V>ESAVE(IR) = upper energy for range rejection in region IR, in COMIN
"V>            USER-STEP-CONTROLS, set by CM.
;
REPLACE {;COMIN/USER-RANGE-REJECTION/;} WITH {
;COMMON/USERRR/ESAVE_GLOBAL,ECUTRR,
RANGE_ECUTRR,ESAVE,
IREJCT,IREJCT_GLOBAL,i_rr_global;
$REAL ESAVE_GLOBAL,ECUTRR($MXREG),RANGE_ECUTRR($MXREG),
      ESAVE($MXREG);
INTEGER IREJCT($MXREG),IREJCT_GLOBAL,i_rr_global;
}

;
"V>COMMON/USERPF/  User photon forcing, included in COMIN/USER/
"V>==============
"V>
"V>GWTOLD = old weight
"V>GWAIT($MXSTACK) = weight adjustment in photon forcing scheme.
"V>IFORCE = only force photons to interact if this is non-zero.
"V>NFMIN = for force photon interactions macro.
"V>NFMAX = for force photon interactions macro.
"V>NFCMIN = for force photon interactions macro.
"V>NFCMAX = for force photon interactions macro.
"V>NFTIME($MXSTACK) = for force photon interactions macro.
"V>NP_INC($MXSTACK) = flag for photon interaction forcing. When doing
"V>         photon forcing a new photon is created (which carries the
"V>         remaining weight) and transported first. The photon (which
"V>         is forced to interact in the specified CMs) is transported
"V>         later and we set NP_INC(NP) = 1 for this photon.
"V>MFORCF = a flag for printing out a warning message that forcing will
"V>         not be done in regions where PCUT > energy of the photon
"V>DUMU = holds value of ustep during transfer of properties
"V>PATHL stores total number of mean free paths through forcing regions
"V>DELTAP = MFP in medium
"V>EPSLON = random # times weight of forced particle
"V>ARG = 1./(1.-EPSLON)
"V>IRODUM = holds IROLD during transfer of particle properties
"V>IRNDUM holds IRNEW during transfer of properties
"V>ICMNEWDUM holds ICMNEW during transfer
"V>ICMOLDDUM holds ICMOLD during transfer
"V>MEDDUM holds MEDIUM during transfer
"V>IDUM holds IDISC during transfer
"V>MEDTMP holds value of MEDIUM

REPLACE {;COMIN/USER-PHOTON-FORCING/;} WITH {
"         ============================="
;COMMON/USERPF/GWTOLD,GWAIT,IFORCE,NFMIN,NFMAX,NFCMIN,NFCMAX,NFTIME,
         NP_INC,MFORCF,DUMU,PATHL,DELTAP,EPSLON,ARG,
         IRODUM,IRNDUM,ICMNEWDUM,ICMOLDDUM,MEDDUM,IDUM,MEDTMP;
$REAL GWTOLD,GWAIT($MXSTACK),DUMU,PATHL,DELTAP,EPSLON,ARG;
INTEGER IFORCE,NFMIN,NFMAX,NFCMIN,NFCMAX,NFTIME($MXSTACK),
         NP_INC($MXSTACK),MFORCF,IRODUM,IRNDUM,ICMNEWDUM,
         ICMOLDDUM,MEDDUM,IDUM,MEDTMP;
}

"V>COMMON/USERSPL/  arbitrary splitting and some global variables for
"                   bremsstrahlung splitting and russian roulette--included
"                   in COMIN/USER/
"V>
"V>IBRSPL = 0 => NO ADDITIONAL BREMSSTRAHLUNG PHOTONS (DEFAULT)
"V>       = 1 => PERFORM BREMSSTRAHLUNG SPLITTING
"V>       = 2 => PERFORM DIRECTIONAL BREMSSTRAHLUNG SPLITTING
"V>NBRSPL = NUMBER OF BREMSSTRAHLUNG PHOTONS CREATED/INTERACTION
"V>IRRLTT = 0 (default) no Russian Roulette
"V>       = 1 gets set to 2
"V>       = 2 is the default RusRou
"V>ICM_SPLIT = CM # at top of which to set an arbitrary splitting planea
"V>            set to 0 for no arbitrary splitting
"V>NSPLIT_PHOT = splitting no. for arbitrary splitting of photons
"V>NSPLIT_ELEC = splitting no. for arbitrary splitting of electrons
"V>NSPLITI = required to set NSPLIT(NP) at initial call to SHOWER.
"V>NSPLIT(NP) = set to 1 if particle NP or its ancestors have been split at
"V>             the arbitrary splitting plane.
"V>SSD = SSD of field (cm)
"V>FS = radius of circular field (directional bremsstrahlung splitting) (cm)

REPLACE {;COMIN/USER-SPLITTING/;} WITH {
;COMMON/USERSPL/SSD,FS,
               IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT,NSPLIT_PHOT,NSPLIT_ELEC,
               NSPLITI,NSPLIT;
INTEGER IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT,NSPLIT_PHOT,NSPLIT_ELEC,
        NSPLITI,NSPLIT($MXSTACK);
$REAL SSD,FS;
}

"V>COMMON/USER-DIRECTIONAL-BREM-SPLITTING/ global variables used for
"                                          directional bremsstrahlung
"                                          splitting--included in COMIN/USER/
"V>
"V>U_DBS,V_DBS,W_DBS = saved direction cosines so that we can split
"V>                    compton, pair and photoelectric events
"V>X_DBS,Y_DBS,Z_DBS = saved position so that we can split pair and
"V>                    photoelectric events
"V>WT_DBS = saved weight for splitting pair and pe events
"V>DNEAR_DBS = saved DNEAR for splitting pair and pe events
"V>ZLAST_DBS = saved ZLAST for splitting pair and pe eventsa
"V>DIST_DBS = distance along particle trajectory to SSD of field defined
"V>           for DBS
"V>R2_DBS = R^2 where particle strikes SSD
"V>RNNO_DBS = stores random numbers during DBS
"V>COSTHE_DBS,SINTHE_DBS,CPHI_DBS,SPHI_DBS = variables used to calculate
"V>                                          random angles for split X-Rays
"V>                                          after pair and pe events
"V>E_DBS = saved energy for splitting compton, pair and pe events
"V>IR_DBS = saved region number for splitting pair and pe events
"V>LATCH_DBS = saved LATCH value for splitting pair and pe events
"V>NFTIME_DBS = saved NFTIME for splitting pair and pe events
"V>NPASS_DBS(ISCORE) = saved value of NPASS(ISCORE) for splitting pair
"V>                    and pe events
"V>NSPLIT_DBS = saved value of NSPLIT for splitting pair and pe events
"V>NP_DBS = used to store stack locations during DBS
"V>IDBS,JDBS = looping indices used during DBS
"V>IPHAT($MXSTACK) = additional stack variable for DBS.  Set to 1 if this
"V>                  is a fat particle (ie one that was aimed out of the field
"V>                  but survived Russian Roulette and has, thus, had its
"V>                  weight increased).
"V>IPHAT_DBS = temporary storage for IPHAT(NP) during bremsstrahlung
"V>            splitting so that IPHAT=1 is not passed on to split
"V>            descendants
"V>PLAYRR_DBS = 0 if photon is directed into the field defined by FS, SSD
"V>           = 1 if not -- ie Russian Roulette is to be played
"V>ICM_DBS    = CM no. in which ZPLANE_DBS, the plane at which to split
"V>             electrons NBRSPL times to improve e- statistics, is defined.
"V>             Usually the flattening filter.  Set to 0 to not split e- at all
"V>ZPLANE_DBS = Plane no. in ICM_DBS at which e- are to be split NBRSPL time.
"V>             Note, this is the plane no., not the Z position of a plane.
"V>IRAD_DBS   = 1 to distribute the NBRSPL split electrons in a radially
"V>             symmetric manner about the beam axis.
"V>ZRR_DBS    = Z position of russian roulette plane below which non-fat
"V>             photons about to undergo interactions will not be subject to
"V>             russian roulette and interactions due to fat photons will be
"V>             split
"V>ZPOSN_DBS  = Z position of ZPLANE_DBS, for output only
"V>ESPLIT_DBS = 1 if electron splitting in DBS to be done, subject to
"V>             W>0 after electron reaches splitting plane.  Set in
"V>             HOWFAR or WHERE_AM_I of ICM_DBS.  0 otherwise.

" For efficiency, it is better to have common block members aligned at "
" 8 byte boundaries => always start with the 8 byte (double precision) "
" variables "
REPLACE {;COMIN/USER-DIRECTIONAL-BREM-SPLITTING/;} WITH {
;COMMON/USERDBS/
    E_DBS,time_brem,time_comp,time_start,time_end,
    U_DBS,V_DBS,W_DBS,X_DBS,Y_DBS,Z_DBS,WT_DBS,DNEAR_DBS,
ZLAST_DBS,DIST_DBS,R2_DBS,RNNO_DBS,COSTHE_DBS,SINTHE_DBS,CPHI_DBS,SPHI_DBS,
ZRR_DBS,ZPOSN_DBS,
IR_DBS,LATCH_DBS,NFTIME_DBS,NPASS_DBS($MAX_SC_PLANES),
NSPLIT_DBS,
NP_DBS,IDBS,JDBS,IPHAT($MXSTACK),IPHAT_DBS,PLAYRR_DBS,
ICM_DBS,ZPLANE_DBS,IRAD_DBS,ESPLIT_DBS,
count_nbrem,count_ncomp,count_npair,count_nphoto,count_nannih,
count_kill_brem,count_kill_comp,count_kill_photo,count_kill_annih,
count_kill_tmp,count_esplit,

"Ali:REJPLN"
USE_REJPLN,Z_REJPLN,FLAG_REJPLN;
$LOGICAL USE_REJPLN;
$REAL Z_REJPLN;
$INTEGER  FLAG_REJPLN;

$REAL U_DBS,V_DBS,W_DBS,X_DBS,Y_DBS,Z_DBS,WT_DBS,DNEAR_DBS,
ZLAST_DBS,DIST_DBS,R2_DBS,RNNO_DBS,COSTHE_DBS,SINTHE_DBS,CPHI_DBS,SPHI_DBS,
ZRR_DBS,ZPOSN_DBS;
$ENERGY PRECISION E_DBS;
$INTEGER IR_DBS,LATCH_DBS,NFTIME_DBS,NPASS_DBS,NSPLIT_DBS,
NP_DBS,IDBS,JDBS,IPHAT,IPHAT_DBS,PLAYRR_DBS,
ICM_DBS,ZPLANE_DBS,IRAD_DBS,ESPLIT_DBS,
count_nbrem,count_ncomp,count_npair,count_nphoto,count_nannih,
count_kill_brem,count_kill_comp,count_kill_photo,count_kill_annih,
count_kill_tmp,count_esplit;
real*8 time_brem,time_comp,time_start,time_end;
}

"below is for debugging DBS only"
APPEND {; real*4 time_array(2),etime; } TO {
 $DEFINE-LOCAL-VARIABLES-ELECTR;}
APPEND {; real*4 time_array(2),etime; } TO {
 $DEFINE-LOCAL-VARIABLES-PHOTON;}

REPLACE {;COMIN/USER-DIRECTIONAL-SOURCE-BIASING/;} WITH {
;COMMON/USERDSB/rsq_dsb,rnno_dsb,
   i_dsb, do_dsb,splitcm_dsb,k_dsb,
   dsb_delta,dsb_rbin($DSB_MAX_BIN+1),dsb_prob($DSB_MAX_BIN),
   dsb_ibin($DSB_MAX_BIN),dsb_aeff,dsb_nbin;
$REAL rsq_dsb,rnno_dsb,
      dsb_delta,dsb_rbin,dsb_prob,dsb_aeff;
$INTEGER i_dsb,do_dsb,splitcm_dsb,k_dsb,
         dsb_ibin,dsb_nbin;
}

"V>COMMON/USERST/  User variables that used to be in COMIN/STACK--now
"V>==============  included in COMIN/USER
"V>
"V>ZLAST(NP) = Z of last site of interaction for photons or Z of site of
"V             creation of an electron
"V>LATCH_OPTION =1: secondaries don't inherit primaries' latch values
"V>              2: pass on the primaries' latch values to the secondaries &
"V>                 also record where the secondaries are created
"V>              3: = 2 but record where a photon interacts rather than where
"V>                 it passes through
"V>LNOB29: a constant for shifting the region number in order to record it
"V>using LATCH
"V>NPASSI = required for the initial call to SHOWER.
"V>IPHATI = required for initial call to SHOWER
"V>XLAST(NP),YLAST(NP) = X,Y of last site of interaction for photons or of
"V>                      site of creation of an electron
"V>NPASS(NP,ISCORE) = number of times that particle NP or its ancestors have
"V>     crossed scoring plane ISCORE.
"V>FDUMMY,IDUMMY = temp variables used during stack exchange
"V>LATCHIN,LATCHOUT = LATCH value for primaries and secondaries after
"V>                   interactions.  DBS only.
"V>LATCHOLD,ZLASTOLD = values of LATCH and ZLAST for primary before interaction
"V>                    used with DBS in case compton rejected

REPLACE {;COMIN/USER-STACK/;} WITH {
;COMMON/USERST/ZLAST,XLAST,YLAST,FDUMMY,ZLASTOLD,LATCH_OPTION,LNOB29,NPASSI,
             IPHATI,NPASS,IDUMMY,LATCHIN,LATCHOUT,LATCHOLD;
$REAL ZLAST($MXSTACK),XLAST($MXSTACK),YLAST($MXSTACK),FDUMMY,ZLASTOLD;
INTEGER LATCH_OPTION,LNOB29,NPASSI,IPHATI,
       NPASS($MXSTACK,$MAX_SC_PLANES),IDUMMY,LATCHIN,LATCHOUT,LATCHOLD;
}

APPEND {;COMIN/CMs,CM_LIST,SCORE/;} TO {$COMIN-ELECTR;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-ANNIH;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-ANNIH-ATREST;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-BREMS;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-SHOWER;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-RELAX;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-RELAX-EADL;}

APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-UPHI;}

"Added by IK for radiative Compton corrections. Sep 6 2005"
APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-RADC-SAMPLE;}

"Added by IK for cross section enhancement. July 13 2005 "
APPEND {;COMIN/CMs/;} TO {$COMIN-PHOTON;}

"Added by IK for the new EII stuff. April 1 2004"
APPEND {;COMIN/USER,SCORE/;} TO {$COMIN-EII-SAMPLE;}

APPEND {;
$REAL xphi, xphi2, yphi, yphi2, rhophi2; } TO
{$DEFINE-LOCAL-VARIABLES-PHOTON;} "necessary for $SELECT-AZIMUTHAL-ANGLE macro"
                                 "used by directional bremsstrahlung splitting"
;

/********************************************************************
  timing variables: need to be in a common so that timing info
  can be passed between beam_init, beam_shower and beam_finish
 *******************************************************************/
REPLACE {;COMIN/TIMING-INFO/;} WITH {;
    common/timing_info/ etimetot, timcpu, tzero, timeb, ibatch;
    $REAL               etimetot, timcpu, tzero, timeb;
    $INTEGER            ibatch;
};


$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;
"append variables that allow us to keep track of min, max particle"
"in a phase space source chunk"
APPEND {;COMMON/SCORE_FORPARALLEL/INPHSP_MAX, INPHSP_MIN;
$LONG_INT INPHSP_MAX, INPHSP_MIN; } TO
{;COMIN/SCORE/;}

#endif;

/********************* begin IK: modified BCSE *******************************/
REPLACE {$EVALUATE-SIG0;} WITH {;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        IF(lelec < 0) [
            $EVALUATE sigf USING esig(elke); $EVALUATE dedx0 USING ededx(elke);
            $EVALUATE ebr1 USING ebr1(elke); sig0 = esig_e(medium);
        ]
        ELSE [
            $EVALUATE sigf USING psig(elke); $EVALUATE dedx0 USING pdedx(elke);
            $EVALUATE ebr1 USING pbr1(elke); sig0 = psig_e(medium);
        ]
        sigf = sigf/dedx0;
        IF( bcse_power_n > 0 ) [
            bcse_factor = 1 + bcse_factor_c*(E(np)-prm)**bcse_power_n;
        ] ELSE [ bcse_factor = bcse_factor_c; ]
        IF( ibrspl = 2 & bcse_factor > iphat(np) ) bcse_factor = iphat(np);
        sigf = sigf*(1 + ebr1*(bcse_factor-1));
        IF( sigf > sig0 ) sig0 = sigf;
    ]
    ELSE [
        IF( sig_ismonotone(qel,medium) ) [
            IF(lelec < 0) [
                $EVALUATE sigf USING esig(elke);
                $EVALUATE dedx0 USING ededx(elke);
            ]
            ELSE [
                $EVALUATE sigf USING psig(elke);
                $EVALUATE dedx0 USING pdedx(elke);
            ]
            sig0 = sigf/dedx0;
        ]
        ELSE [
            IF( lelec < 0 ) [sig0 = esig_e(medium);]
            ELSE            [sig0 = psig_e(medium);]
        ]
    ]
};

REPLACE {$EVALUATE-SIGF;} WITH {;
    IF(lelec < 0) [
        $EVALUATE sigf USING esig(elke); $EVALUATE dedx0 USING ededx(elke);
    ] ELSE [
        $EVALUATE sigf USING psig(elke); $EVALUATE dedx0 USING pdedx(elke);
    ]
    sigf = sigf/dedx0;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        IF(lelec < 0) [ $EVALUATE ebr1 USING ebr1(elke); ]
        ELSE          [ $EVALUATE ebr1 USING pbr1(elke); ]
        IF( bcse_power_n > 0 ) [
            bcse_factor = 1 + bcse_factor_c*(E(np)-prm)**bcse_power_n;
        ] ELSE [ bcse_factor = bcse_factor_c; ]
        IF( ibrspl = 2 & bcse_factor > iphat(np) ) bcse_factor = iphat(np);
        sig = sigf*(1 + ebr1*(bcse_factor-1));
        IF( sig <= sig0 ) [ sigf = sig; ]
        ELSE [
            " somehow the final cross section is larger than the initial  "
            " => adjust (lower) the enhancement factor so that they become"
            "    the same                                                 "
            bcse_factor = 1 + (sig0/sigf-1)/ebr1;
            IF( bcse_factor < 1 ) [
                $egs_fatal(*,'In $EVALUATE-SIGF: bcse_factor = ',bcse_factor);
            ]
            sigf = sig0;
        ]
    ]
    ELSE [ bcse_factor = 1; ]
};

REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        ebr1 = ebr1*bcse_factor/(1 + ebr1*(bcse_factor-1));
    ]
    ELSE [
        $EVALUATE ebr1 USING ebr1(elke);
    ]
};

REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {;
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        pbr1 = ebr1*bcse_factor/(1 + ebr1*(bcse_factor-1));
    ] ELSE [
        $EVALUATE pbr1 USING pbr1(elke);
    ]
};

REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
    $EVALUATE pbr2 USING pbr2(elke);
    IF( use_bcse & is_bcse_medium(medium) & (ibrspl < 2 | iphat(np) > 1) ) [
        pbr2 = (ebr1*(bcse_factor-1) + pbr2)/(1 + ebr1*(bcse_factor-1));
    ]
};

/*********************** end IK: modified BCSE *******************************/





"*******************************************************************************
"*******************************************************************************
"
"                             BEAMnrc PROPER (MAIN)                    ""toc:
"                             ********************                     ""toc:
"
"*******************************************************************************
"
"                 TYPE DECLARATIONS AND COMMON BLOCKS FOR MAIN
"                 ********************************************
"

subroutine beam_init(ircode);

$IMPLICIT-NONE;

$INTEGER ircode,IERR;

;COMIN/BOUNDS, BREMPR, CMs, EDGE, ELECIN, ENERGYSRC, EPCONT, GEOM,
  IO_INFO,MEDIA, MISC, PHOTIN, SCORE, SOURCE, STACK, THRESH, UPHIOT,
  USEFUL, USER, RANDOM, BMODEL, RWPHSP, EGS-VARIANCE-REDUCTION, CH-Steps,
  EGS-IO,TIMING-INFO,GetInput/;
"V>**************************
"T>TYPE DECLARATIONS FOR MAIN
"T>**************************
"T>
INTEGER
   I,IS,I1,I2,I3,I4,IT,J,k, "T>DO loop indices
   LATCHM,NHSTRYM,NPASSM,IQINM,"T> temp. variables
   IERR_INPUTS,  "T>non-zero if error detected on input from parameter-defn file
   IRL,          "T>local region number
   ITMAX,        "T>Number of dose components
   LELKE,        "T>used when computing E_min_out and RANGE_ECUTRR
   lelktmp,      "T>used when computing RANGE_ECUTRR
   lelec,        "T>used when computing RANGE_ECUTRR
   NPPHSPSP,     "T>INTEGER*4 version of NPPHSP for writing/reading to/from
                 "T>header of phsp file
   egs_open_datfile, "T> EGSnrc subroutine
   egs_open_file, "T> EGSnrc subroutine for assigning Fortran units
   lnblnk1,      "T> built-in lnblnk function
   IZLAST1;


$REAL
   DEDXE,          "T> used calculating E_min_out
   EKEM,           "T> used calculating E_min_out
   EKEI,           "T> used in calculating RANGE_ECUTRR
   ELKEI,          "T> used in calculating RANGE_ECUTRR
   fedep,          "T> used in calculating RANGE_ECUTRR
   elktmp,         "T> used in calculating RANGE_ECUTRR
   dedxmid,        "T> used in calculating RANGE_ECUTRR
   aux,            "T> used in calculating RANGE_ECUTRR
   EI,             "T>
   RSCORE_MAX2,     "T>Square of maximum radius of scoring zone = RMAX_CM
   EINM,XINM,YINM,UINM,VINM,WTM,ZINM,WINM, "T> temp. variables
   WEIGHT,Z_SCORE;          "T>

REAL*4 Z_SCORE_SHORT; "T> used to pass Z position of scoring plane to
                      "   IAEA phsp header

$LONG_INT long_tmp; "for MOD functions"


CHARACTER*8 AUNIT;    "T> for use assigning file=fort.   units"
CHARACTER*256 phsp_fn,phsp_fn_base; "T> temp. storage for phase space file name

external combine_results;

/*
   Well, I just wanted to make it compiler with EGSnrcMP =>
   quick hack to define DATEN_FORMAT and TIMEN_FORMAT         IK
 */
REPLACE {$DATEN_FORMAT} WITH {A};
REPLACE {$TIMEN_FORMAT} WITH {A};


"*******************************************************************************
"
"                       START OF EXECUTABLE CODE                       ""toc:
"                       ************************
"
;

IBATCH=0;
ETIMETOT=0;
ircode = 0;

$INIT_PHSP_COUNTERS;

$CHAR_DATA;   "expands to a list of CMLIST and CMTYPE assignments"
              "ie CMLIST(i) and CMTYPE(i) contain identifier and name"
              "of CM(i). They are in COMIN CMs"
              "This uses $CM_LIST and $CM_TYPE definitions from build step"

CALL DATETIME(1);
OUTPUT TIMEN, DATEN;(//' BEAMnrc  '$BEAM_VERSION $USER_MACROS_VERSION/
        ' ON '$MACHINE' WITH EGSnrc.',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT/);
OUTPUT $MAX_CMs, $MXMED, $MXREG, $MXSTACK, $MAXBRSPLIT, $MAX_DOSE_ZONE,
       $MAX_SC_PLANES, $MAX_SC_ZONES, $MAXIT, $MIN_GAP;
(/' The following internal parameters are set:'/
' Max number of CMs:',I3,           T40,'Max number of media',I4/
' Max number of regions:',I4,       T40,'Max stack:',I10/
' Max bremsstrahlung split:',I10,    T40,'Max number dose zones:',I4/
' Max number of scoring planes:',I3,T40,'Max number of scoring zones:',I4/
' Max number dose components:',I3,  T40,'Minimum air gap:',F12.4,' cm'/
'   All of above can be adjusted in beamnrc_user_macros.mortran'/);


"*******************************************************************************
"*******************************************************************************
"
"        PRE-HATCH-CALL INITIALIZATION, INCLUDING ALL INTERACTIVE INPUT
"        **************************************************************
"
"*******************************************************************************
"
"                          I/O INITIALIZATION of UNITS                 ""toc:
"                          ***************************

IOUTLIST   = 1;   "unit number for listing
IOUTRN     = 2;   "starting random number status for each history
IOUTPLOT   = 3;   "plot file
IORSTRT    = 4;   ".egsdat file
IOUTGPH    = 13;  "EGS_Windows file for graphical display of particle history
IOUTGEOM   = 17;  "EGS_Windows geometry file
IINSRC     = 42;  "unit number for input of phase-space source (input)
OUTCNT     =0;    "# of times isourc=21 phsp file exhausted

"note files for phase space data(units 44,45,46..)  are explicitly opened"
DO I=1,$MAX_SC_PLANES [ IOUTFLU(I) = I+43;"phase-space for scoring plane I"]


"explicitly open .egslst file"
IOUTLIST=egs_open_file(IOUTLIST,0,1,'.egslst');
"open .egstmpa file

"*******************************************************************************
"
"               INPUT FROM PARAMETER-DEFINITION FILE (UNIT 5)          ""toc:
"               *********************************************
CALL INPUTS;        "reads in general info re simulation

OUTPUT; (/' Finished general beamnrc input, now input re component modules');

" Geometry input for the component modules
" ****************************************

IF(IREJCT_GLOBAL > 0) [ DO IRL=1,$MXREG [ IREJCT(IRL) = 1; ]]
"    above done here so individual CMs can turn it off"
NREG = 1;                 "Number of regions
MED(1) = 0;               "Start with vacuum at front
IR_start_CM(1) = 2;       "First region in first CM is region 2
NDOSE_ZONE = 0;           "Number of dose scoring zones (each zone
                          "has 1 or more regions)
IERR_INPUTS = 0;          "Error-checking flag for INPUTS
DO ICM=1,$MAX_CMs ["set flag for checking outer boundary of CM in HOWFAR
   RMAX_CM_FLAG(ICM) = -1; "if flag=-1 after CM input, it was not properly set
]
ICM = 1;                  "CM index is incremented each time a new CM is read

;CALL_INPUT; "Expands to a series of calls to all INPUT_$CMNAME subroutines,
             "the set of component modules {$CMNAME} is specified by $CM_LIST.
             "ICM is incremented before the call to each INPUT_$CMNAME routine

;OUTPUT;(/' Back in main of beamnrc.mortran after inputs from CMs'/);


MAX_CMs = ICM;

" Get cross section enhancement factors, if any.
" Added by IK July 13 2005.
" Moved after hatch call "
"call get_cse_factors;"

"It is possible to set up the inputs with all regions vacuum, but EGSnrc"
"chokes on this in HATCH, so bail out here"
IF(NMED = 0)[
   OUTPUT;(//'  EXITING because entire geometry input as VACCUUM'/
          '          EGSnrc does not like this: set it up so there is at'/
          '          least one region with a material in it'///);
   $CALL_EXIT(1);
]

"if ISOURC=21, check that INIT_CM <= MAX_CMs"
"NB this check used to be in ISOURCE, where MAX_CMs is not yet set"
IF(ISOURC = 21 | ISOURC=23 |ISOURC=24) [
   IF(INIT_ICM > MAX_CMs)|(INIT_ICM < 1)[
       INIT_ICM=1;
       OUTPUT;(//'***ERROR IN INPUT FOR ISOURC=21 or 23 or 24'/
                'INIT_ICM>MAX_CMs or INIT_ICM<1'/
                'INIT_ICM reset to 1'//);
       WRITE(IOUTLIST,'(//''***ERROR IN INPUT FOR ISOURC=21 or 23 or 24''/
                ''INIT_ICM>MAX_CMs or INIT_ICM<1''/
                ''INIT_ICM reset to 1''//)');
   ]
]

"check that ICM_CONTAM <= MAX_CMs"
IF(ITDOSE_ON=1 & ICM_CONTAM > MAX_CMs)[
   ICM_CONTAM=MAX_CMs;
   OUTPUT ICM_CONTAM;
   (//'***WARNING:'/ 'ICM_CONTAM > # of CMs'/ 'ICM_CONTAM reset to ',I4//);
]

"check that ICM_SPLIT is <= MAX_CMs"
IF(ICM_SPLIT > MAX_CMs)[
   OUTPUT ICM_SPLIT, MAX_CMs; (//' ***WARNING***'/ ' ICM_SPLIT > # of CMs'/
                                 ' ICM_SPLIT reduced to ',I4,' from ',I4//);
]

"check that number of dose scoring zones is within limits"
"This should also be done in CMs"
IF (NDOSE_ZONE > $MAX_DOSE_ZONE)["limit exceeded"
    OUTPUT NDOSE_ZONE,$MAX_DOSE_ZONE;(///'***Number of dose zone=',
    I4,' is greater than max allowed =',I5/' Increase $MAX_DOSE_ZONE',
    ' in beamnrc_user_macros.mortran'///);
    $CALL_EXIT(1);
]

DO IRL=2,NREG [
   IF(DOSE_ZONE(IRL)<0)[
        OUTPUT IRL;(//' ****WARNING:'/
                      ' Dose zone in region ',I10,' is < 0'/
                      ' Reset to 0 (no dose scoring).'//);
        DOSE_ZONE(IRL)=0;
   ]
]

"check that radii/half widths of scoring zones do not put them"
"beyond the boundaries of their associated CM"
DO ISCORE=1,NSC_PLANES [
  IF(MZONE_TYPE(ISCORE) = 0)["annular zones"
    DO I=1, NSC_ZONES(ISCORE)[
      IF(RSCORE_ZONE(ISCORE,I)>RMAX_CM(IPLANE_to_CM(ISCORE)))[
        OUTPUT ISCORE, IPLANE_to_CM(ISCORE), I, RSCORE_ZONE(ISCORE,I),
        RMAX_CM(IPLANE_to_CM(ISCORE));
        (//'***ERROR IN INPUT FOR SCORING PLANE ',I4,' ON CM ',I4/
        'Outer radius of zone ',I4,' =',F10.3,' cm, which is > RMAX_CM/SMAX_CM'/
        'Radius reduced to ',F10.3,' cm'//);
        WRITE(IOUTLIST,
'(//''***ERROR IN INPUT FOR SCORING PLANE '',I4,'' ON CM '',I4/
''Outer radius of zone '',I4,'' ='',F10.3,'' cm, which is > RMAX_CM/SMAX_CM''/
''Radius reduced to '',F10.3,'' cm''//)') ISCORE, IPLANE_to_CM(ISCORE),
                      I, RSCORE_ZONE(ISCORE,I),RMAX_CM(IPLANE_to_CM(ISCORE));
                 RSCORE_ZONE(ISCORE,I)=RMAX_CM(IPLANE_to_CM(ISCORE));
                 RSCORE_ZONE2(ISCORE,I)=RSCORE_ZONE(ISCORE,I)**2;
      ]
    ]
  ]
  ELSEIF(MZONE_TYPE(ISCORE) = 1)["square zones"
    DO I=1, NSC_ZONES(ISCORE)[
      IF(RMAX_CM_FLAG(IPLANE_to_CM(ISCORE))=1 &
         SQRT(2.)*RSCORE_ZONE(ISCORE,I)>RMAX_CM(IPLANE_to_CM(ISCORE)))[
             OUTPUT ISCORE, IPLANE_to_CM(ISCORE),
                       I, RSCORE_ZONE(ISCORE,I),
                       RMAX_CM(IPLANE_to_CM(ISCORE))/SQRT(2.);
      (//'***ERROR IN INPUT FOR SCORING PLANE ',I4,' ON CM ',I4/
'Outer half-width of zone ',I4,' =',F10.3,' cm, which goes beyond RMAX_CM'/
                     'Half-width reduced to ',F10.3,' cm'//);
             WRITE(IOUTLIST,
'(//''***ERROR IN INPUT FOR SCORING PLANE '',I4,'' ON CM '',I4/
''Outer half-width of zone '',I4,'' ='',F10.3,
'' cm, which goes beyond RMAX_CM''/
''Half-width reduced to '',F10.3,'' cm''//)') ISCORE, IPLANE_to_CM(ISCORE),
                                             I, RSCORE_ZONE(ISCORE,I),
                                    RMAX_CM(IPLANE_to_CM(ISCORE))/SQRT(2.);
              RSCORE_ZONE(ISCORE,I)=RMAX_CM(IPLANE_to_CM(ISCORE))
                                       /SQRT(2.);
              RSCORE_ZONE2(ISCORE,I)=RSCORE_ZONE(ISCORE,I)**2;
      ]
      ELSEIF(RMAX_CM_FLAG(IPLANE_to_CM(ISCORE))=2 &
             RSCORE_ZONE(ISCORE,I)>RMAX_CM(IPLANE_to_CM(ISCORE)))[
                OUTPUT ISCORE, IPLANE_to_CM(ISCORE),
                       I, RSCORE_ZONE(ISCORE,I),
                       RMAX_CM(IPLANE_to_CM(ISCORE));
      (//'***ERROR IN INPUT FOR SCORING PLANE ',I4,' ON CM ',I4/
 'Outer half-width of zone ',I4,' =',F10.3,' cm, which is > SMAX_CM'/
 'Half-width reduced to ',F10.3,' cm'//);
                WRITE(IOUTLIST,
'(//''***ERROR IN INPUT FOR SCORING PLANE '',I4,'' ON CM '',I4/
''Outer half-width of zone '',I4,'' ='',F10.3,'' cm, which is > SMAX_CM''/
''Half-width reduced to '',F10.3,'' cm''//)') ISCORE, IPLANE_to_CM(ISCORE),
                          I, RSCORE_ZONE(ISCORE,I),
                          RMAX_CM(IPLANE_to_CM(ISCORE));
                RSCORE_ZONE(ISCORE,I)=RMAX_CM(IPLANE_to_CM(ISCORE));
                RSCORE_ZONE2(ISCORE,I)=RSCORE_ZONE(ISCORE,I)**2;
      ]
    ]
  ]
]

IF(IBRSPL=2 & ICM_DBS>0)["check that CM no. for e- splitting is not"
                         "> MAX_CMs or is not of a type supported"
    IF(ICM_DBS>MAX_CMs)[
       ICM_DBS=0;
       OUTPUT MAX_CMs;
   (/' ****DBS WARNING*****'/
     ' CM no. for electron splitting > max. CM no. in accelerator (',I4,')'/
     ' No electron splitting will be done.'/);
    ]
    ELSEIF(CMTYPE(ICM_DBS)~='FLATFILT' & CMTYPE(ICM_DBS)~='PYRAMIDS')[
       ICM_DBS=0;
       OUTPUT CMTYPE(ICM_DBS);
       (/' ****DBS WARNING****'/
         ' You have selected to split electrons in a ',A8,' CM.'/
         ' Electron splitting is only supported in FLATFILT.'/
         ' No splitting will be done.'/);
    ]
]


" Open output data files for scoring planes
" *****************************************
"
IF(IO_OPT = 0  | IO_OPT >= 3) ["requested phase space files be output"

  "$DIRECTORY-FOR-PHSP is defined in beamnrc_user_macros.mortran"
  "default is $cstring(egs_home)//$cstring(user_code)"
  "The default is always on the accelerator directory, not in"
  "  the subdirectory used for other files while running"
  "However, the path does not need to be the same as accelerator"
  " directory, it could be anywhere the user wants. To change it,"
  "redefine $DIRECTORY-FOR-PHSP in beamnrc_user_macros.mortran code"

  IF(PHSP_OUTDIR~=' ')[
      "assume the user wants definition of output directory in the"
      "input file to overwrite that in beamnrc_user_macros.mortran"
      phsp_fn_base=$cstring(PHSP_OUTDIR) // $file_sep //
                   $cstring(output_file);
  ]
  ELSE[
      phsp_fn_base=$DIRECTORY-FOR-PHSP // $file_sep //
                   $cstring(output_file);
  ]
  IF( i_parallel > 0 ) ["add an _w"
      phsp_fn_base=$cstring(phsp_fn_base)// '_w';
      call egs_itostring(phsp_fn_base,i_parallel,.false.);
  ]

  I_MU_PHSP=0; "default to not store fractional MU index"
  "loop through CMs and determine if there are any synchronized ones"
  DO I=1,MAX_CMs[
    IF(CMTYPE(I)='SYNCJAWS' | CMTYPE(I)='SYNCVMLC' |
       CMTYPE(I)='SYNCMLCE' | CMTYPE(I)='SYNCHDMLC')[
      "store fractional MU index in IAEA phsp files"
      I_MU_PHSP=1;
      EXIT;
    ]
  ]

  IF(IRESTART = 0)["start a new run"
     DO I=1,NSC_PLANES [
         $BEAM_OPEN_PHSP_FOR_WRITE;
     ]
  ] "end of IRESTART = 0 block"

  ELSEIF(IRESTART =  1)["restart from a previous run"
      $BEAM_OPEN_PHSP_FOR_READ;
  ] "end of IRESTART = 1 block"
]  "end of block opening phase space files if there"

"initialize counters for phase space output for 1st scorig plane only"
/N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NPASS_ph_sp,NFAT_ph_sp/=0;
/E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
"
"   get default CM  for scoring planes and zones, if not read in inputs
"
"IPLANE_to_CM(J) is CM at back of which J-th scoring plane is"
IF(IPLANE_to_CM(1) <= 0)["default to last CM in case was not input"
   IPLANE_to_CM(1) = MAX_CMs;
]
DO ISCORE=1,NSC_PLANES ["check CM exists for each scoring plane"
   IF (IPLANE_to_CM(ISCORE)>MAX_CMs) [
      IERR_INPUTS = 1; "Flag to stop after input parameters written to listing
      OUTPUT ISCORE,IPLANE_to_CM(ISCORE); (' *** ERROR *** ',
          ' Scoring plane',I3,' at back of CM',I3,', CM does not exist');
   ]"end if"
]"end of do loop"

" Set default scoring zones for fluence
" *************************************
"
DO ISCORE=1,NSC_PLANES ["loop through scoring planes"
   IF(NSC_ZONES(ISCORE) =  0)["default requested, set radii or half-widths of "
                   "equal-area radial-scoring zones"
      NSC_ZONES(ISCORE) = $MAX_SC_ZONES;
      "Note, particle coming back can be outside these scoring regions"
      "since the next CM may have been bigger"
      OUTPUT;(' Default equal area fluence scoring zones now being set');
      RSCORE_MAX2 = RMAX_CM2(IPLANE_to_CM(ISCORE));
      DO ISZ=1,NSC_ZONES(ISCORE) [
        RSCORE_ZONE2(ISCORE,ISZ) = ISZ*RSCORE_MAX2/NSC_ZONES(ISCORE);
        RSCORE_ZONE(ISCORE,ISZ) = SQRT(RSCORE_ZONE2(ISCORE,ISZ));
      ]
      IF(MZONE_TYPE(ISCORE) = 0)[
          OUTPUT ISCORE,(RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
          (' For scoring plane',I2,', zone radii  are:',(5F8.4));
      ]
      ELSE[
          OUTPUT ISCORE,(RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
          (' For scoring plane',I2,', zone half-widths  are:',(5F8.4));
      ]
   ]
]

" Geometry checking
" *****************
"
" IERR_GEOM is geometry-checking flag and is set in INPUT_$CMNAME as follows:
"    0 if no errors detected,
" 1-99 number of errors detected within CM
"  >99 if CM above overlaps,

DO ICM=1,MAX_CMs [ "Loop over CM's to check if errors in geometry were detected"
   IF (IERR_GEOM(ICM) ~= 0) [
      IF (IERR_GEOM(ICM)>99) [
         IERR_INPUTS = 1; "Flag to stop after input parameters written to
                          "listing
         OUTPUT ICM-1,ICM;
            (' *** ERROR *** Component modules',I3,' and',I3,' overlap');
      ]
      IF (IERR_GEOM(ICM)-(IERR_GEOM(ICM)/100)*100>0) [
         IERR_INPUTS = 1; "Flag to stop after input parameters written to
                          "listing
         OUTPUT IERR_GEOM(ICM)-(IERR_GEOM(ICM)/100)*100,ICM;
            ('***ERROR:'/
            I2,' errors detected in the geometry of component module',I3);
      ]
   ]
]"end loop on ICM"


DO ICM=1,MAX_CMs ["check flag specifying outer boundary of CM in HOWFAR
   "These were all initialized to -1 above, but the CMs should have set them
   IF (RMAX_CM_FLAG(ICM)=-1) ["flag not properly set
      IERR_INPUTS = 1; "Flag to stop after input parameters written to listing
      OUTPUT ICM; (' *** ERROR *** ',
          ' RMAX_CM_FLAG not properly set for CM ',I4 );
   ]
]

"*******************************************************************************
"
"                        INITIALIZE SCORING ARRAYS                     ""toc:
"                        *************************
"
" Prepare for fluence and dose scoring.  Fluence scoring includes full
" phase-space, number, energy, and z-axis direction cosines.

ITMAX=3+LNEXC+LNINC; "Number of dose components"
                     "here lnexc and lninc added to score the different "
                     "dose components contributed by the various latch  "
                     "setting, JWEI, 12/29, 1992 "

"for steps:
SCSTP=0; SCSTP2=0; SCDSTP=0; SCDSTP2=0; PIISTP=0;
SCSTP_LAST=0; SCDSTP_LAST=0;

"for dose:
DO IT=1,ITMAX[
    DO ID=1,NDOSE_ZONE[
          SCDOSE_LAST(ID,IT)=0;
          SCDOSE(ID,IT)=0.0;
          SCDOSE2(ID,IT)=0.0;
          SCDOSE_TMP(ID,IT)=0.0;
    ]
]
"for fluence:
[I1=1,3;
     [I2=1,$MAX_SC_PLANES;
         [I3=1,$MAX_SC_ZONES+1;
                   SCFLU_LAST(I1,I2,I3,1)=0;
                   SCFLU_LAST(I1,I2,I3,2)=0;
                   SCFLU_NUM(I1,I2,I3,1)=0;
                   SCFLU_NUM(I1,I2,I3,2)=0;
                   SCFLU_NOCOV(I1,I2,I3,1)=0;
                   SCFLU_NOCOV(I1,I2,I3,2)=0;
                   DO I4=1,4[
                     SCFLU_COV(I1,I2,I3,I4)=0.;
                   ]
                   [I4=1,$MAX_SC_PARAMETERS;
                      SCFLU(I1,I2,I3,I4)=0.;
                      SCFLU2(I1,I2,I3,I4)=0.;
                      SCFLU_TMP(I1,I2,I3,I4)=0.;
                   ]
]]] "End of loop over I1"

"
" Set scoring flag to 1 if fluence is to be scored at back of CM
DO I=1,MAX_CMs ["Zero scoring flag" ICM_to_SCORE(I)=0; ]
DO I=1,NSC_PLANES [
   NPFLU(I)=0; "initialize no. of particles crossing each plane to 0"
   ICM_to_SCORE(IPLANE_to_CM(I))=I;  "ICM_to_SCORE is inverse of IPLANE_to_CM"
                                     "ICM associated with scoring plane I"
                                     "in COMIN CMs            "
]

NCASEO=0;NCASET=0;TMCPUO=0;NHSTRYO=0;NPASS_ph_spO=0;NFAT_ph_spO=0;

IF(ISOURC~=21 & ISOURC~=24)[
    NNPHSP=1.;
    NINCSRC=1.;
    NRCYCL=0;
]

IF(IRESTART =  0)[ "Fresh start, set everything to zero"

   DO I=1,NSC_PLANES [
       NPPHSP(I)=0;"Initialize the counters + variables for the ph-sp I/O"
       EKMAXPHSP(I)=0.;
       EKMINPHSPE(I)=99999.; "start with a huge number"
       NPHOTPHSP(I)=0;
   ]
   NINCPHSP=0;
] "END IF IRESTART=0"

ELSEIF(IRESTART = 1)["Restart, read old data from unit 4"
    "Open unit 4 as an old file"
    OUTPUT; (/' *** About to read dose/fluence data from previous run ***');
    data_unit=egs_open_datfile(IORSTRT,0,1,'.egsdat');
    READ(data_unit,*) SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
    READ(data_unit,*)
           ((SCDOSE(ID,IT),SCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
    READ(data_unit,*) ((((SCFLU(I1,I2,I3,I4),SCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
    READ(data_unit,*) ((((SCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
    READ(data_unit,*) ((((SCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
    $RETRIEVE RNG STATE FROM UNIT data_unit;
    READ(data_unit,*)NCASEO,NHSTRYO,TMCPUO,(NPPHSP(I),I=1,NSC_PLANES),
                   NPASS_ph_spO,NFAT_ph_spO;
    "read in any extra variables"
    $USER-READ-DAT(data_unit);

    CLOSE(data_unit);

    OUTPUT;(/' ***Successfully read previous dose and fluence data file ***'/);

    $BEAM_READ_PHSP_FOR_RESTART;

] "end of IRESTART=1 block"

ELSEIF(IRESTART = 3)[
    "Analysis only, read old data from unit 4"
    "Open unit 4 as an old file"
    OUTPUT; (/' *** About to read dose/fluence data from previous run ***');
    data_unit=egs_open_datfile(IORSTRT,0,1,'.egsdat');
    READ(data_unit,*) SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
    READ(data_unit,*)
           ((SCDOSE(ID,IT),SCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
    READ(data_unit,*) ((((SCFLU(I1,I2,I3,I4),SCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
    READ(data_unit,*) ((((SCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
    READ(data_unit,*) ((((SCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
    $RETRIEVE RNG STATE FROM UNIT data_unit;
    $PUT RNG STATE ON UNIT 6;
    READ(data_unit,*)NCASEO,NHSTRYO,TMCPUO,(NPPHSP(IS),IS=1,NSC_PLANES),
                   NPASS_ph_spO,NFAT_ph_spO;
    $USER-READ-DAT(data_unit);
    CLOSE(data_unit);
    NCASE=0;"no new cases, just analyze old data"

] "end of IRESTART = 3 loop"

ELSEIF(IRESTART = 4)[
    call egs_combine_runs(combine_results,'.egsdat');
    NCASE=0;"no new cases, just analyze old data"
] "end of IRESTART = 4 loop"

IF(IRESTART=1|IRESTART=3)[
"set NPFLU(I)=the total no. of particles that have already crossed"
"scoring plane I"
    DO I=1,NSC_PLANES[
       DO I4=1,2[
          DO I3=1,NSC_ZONES(I)+1[
             DO I1=1,3[
                NPFLU(I)=NPFLU(I)+SCFLU_NUM(I1,I,I3,I4);
             ]
          ]
       ]
    ]
]

NCASET=NCASE+NCASEO;

"*******************************************************************************
"*******************************************************************************
"
"                                 HATCH CALL                           ""toc:
"                                 **********
"
DUNIT=1; "Set length units to cm"
OUTPUT NMED, (I,(MEDIA(J,I),J=1,24), I=1,NMED);
     (/' There are', I3,' different media:'/
     (10x,' Medium(',I3,') is: ',24A1));

CALL DATETIME(1);  OUTPUT TIMEN;(/' CALL TO HATCH AT  ',$TIMEN_FORMAT);

CALL HATCH; "Input the pegs generated data"

" Get cross section enhancement factors, if any.
" Added by IK July 13 2005.
call get_cse_factors;

"Ali:REJPLN"
CALL GET_REJPLN;

"Ali:BCSE"
CALL GET_BCSE_PARAMETERS;

"initialize any extra user variables"
$USER-INIT;

CALL DATETIME(1);OUTPUT TIMEN;(/' HATCH COMPLETED AT ',$TIMEN_FORMAT);

call show_transport_parameter(6);

"see if the user wants to scale elastic scattering cross sections"
call set_elastic_parameter;

"Note: default region densities (RHOR=0) set to those of PEGS files in HATCH
;
"*******************************************************************************
"*******************************************************************************
"
"             INITIALIZATION FOR PHOTON FORCING                        ""toc:
"             *********************************
"
"  MFORCF is a flag set to 0 in the begging of the simulation. If photon
"  interaction forcing scheme is used in the simulation and a photon is
"  terminated when entering a region where PCUT is lower than in other
"  regions. A message will be printed and the flag will be set to 1 in order
"  to inform the user that forcing will not be done in this region for photons
"  of energies below PCUT but it may still be done elsewhere
"
MFORCF=0;
"*******************************************************************************
"*******************************************************************************
"
"                     INITIALIZATION FOR HOWFAR                        ""toc:
"                     *************************
"
"  Load array IR_to_CM (passed in COMIN CMs)
"  The purpose of these arrays is to speed up the calls to HOWFAR.
"
IRL = 0; ICM = 0;
LOOP [IRL = IRL + 1;
     IF(IRL = IR_start_CM(ICM+1))["start a new CM in this region"
          ICM = ICM + 1;
     ] "end of if block"
     IR_to_CM(IRL) = ICM;  "note for first region this points to CM=0.
]UNTIL (IRL = NREG);


"           Range rejection initialization                             ""toc:
"           ******************************
IF (IREJCT_GLOBAL = 0) ["no range rejection to be done"
   "override any values set in CMs input or value 1 set at start"
   DO IRL=1,$MXREG [
          IREJCT(IRL) = 0;
          ECUTRR(IRL)=0.;
   ]
"Setting ECUTRR to zero here overrides any default settings of ECUTRR"
"in the individual CMs.  Some CMs set ECUTRR to ECUT; others do not"
"set ECUTRR at all."
]
ELSE[ "doing range rejection
  IF(IREJCT_GLOBAL=1)["automatically increase ECUTRR away from bottom"
      "Calculate and use E_min_out values"
      "for each CM to set ECUTRR for each region"
      "start with ECUT just before scoring plane, assumed to be last CM"
      IF(ICM_to_SCORE(MAX_CMs) ~= 1)[
         OUTPUT;(///' ****************************************************'/
         ' IREJECT_GLOBAL=1 ASSUMES only scoring plane is at back of last CM'
         /' and it isnt!'/
          '**************************************************************'/);
         WRITE(IOUTLIST,'(//'' *********************************************''
         /'' IREJECT_GLOBAL=1 ASSUMES 1 scoring plane is at back of last CM''
         /'' and it isnt!''/
        ''**********************************************************''//)');
      ]
      E_min_out(MAX_CMs) = ECUTIN; "This assumes the global ECUT controls"
        "what we want from the scoring plane - If the user has a higher"
        "value close to the scoring plane, then ECUTIN should be raised"

      "OUTPUT;(//' in BEAMnrc main: Temporary output re calculation of ECUTRR');
      DO ICM = MAX_CMs,2,-1 ["loop over CMs starting from last"
         "calc minimum energy at exit of previous CM which will leave"
         "electrons above required min energy at exit"
         EKE = E_min_out(ICM);  "starting min energy"
         IF (Z_min_thick(ICM,1) = 0.0)["This CM did not set the value"
           "default to whole CM being AIR (i.e MEDIUM 1)"
           Z_min_thick(ICM,1) = Z_min_CM(ICM+1) - Z_min_CM(ICM);
          "Z_min_CM is front of each CM, and for MAX_CMs+1=back of last CM"
           MED_min_thick(ICM,1)=1;
           /******************************************************************
            Check whether user set surrounding to vacuum and nominal air
            was set to medium one which is not necessarily air-like material.
            This could cause the minimum energy needed to reach the bottom of
            the accelerator to become larger than the upper energy limit of
            the available data.
                                                               EMH April 2011
           ******************************************************************/
           IF (AIR_INDEX = 0 &          "surrounding medium is vacuum and"
             RHO(MED_min_thick(ICM,1)) > 0.12048)["air med 100X heavier"
              "Find index of lightest medium available"
              aux=1.0E+10;MED_min_thick(ICM,1)=1;
              DO j=1,nmed [
                 IF (rho(j)<aux)[aux=rho(j);MED_min_thick(ICM,1)=j;]
              ]
              j = MED_min_thick(ICM,1);
              $egs_warning('(a,i3/,3(a/),a,i3,a,e10.5,a,24a1)',
              'Range rejection initialization CM # ',ICM,
              '========================================',
              'Surrounding medium set to VACUUM but AIR-like medium 1',
              'is 100 times more dense than AIR. Resetting MED_min_thick',
              'to least dense medium #',j,' with RHO = ',
              rho(j),' g/cm3 named ',(media(k,j),k=1,24));
           ]
           /*****************************************************************/
         ]
         DO I=1,5[ "loop over minimum thicknesses set in INPUT"
           MEDIUM = MED_min_thick(ICM,I);
           IF(MEDIUM ~= 0)[
             IF (EKE <= UE(MEDIUM)) [ "prevent array index overrun"
                ELKE = LOG(EKE); $SET INTERVAL ELKE, EKE;
                $EVALUATE DEDXE USING EDEDX(ELKE);
                EKEM = EKE + 0.5*DEDXE*Z_min_thick(ICM,I);
                "EKEM is roughly mid-point of energy-assumes const DEDXE"
                "iterate once to get better average stopping power"
                IF (EKEM <= UE(MEDIUM)) [ "prevent array index overrun"
                    ELKE = LOG(EKEM); $SET INTERVAL ELKE, EKE;
                    $EVALUATE DEDXE USING EDEDX(ELKE);
                ]
                EKE = EKE + DEDXE*Z_min_thick(ICM,I);
                "EKE is min energy starting this slab which can exit above"
                "required minimum - assuming DEDX varies linearly"
             ]
             "constrain EKE to UE at most, and warn user"
             IF (EKE > UE(MEDIUM)) [
              $egs_warning('(a,i3/,a/,a/,a,f7.2,a,f7.2,a/,2a/,'//
                           '2a,f7.2,a/,/a/,a,f7.2,a,24a1/)',
              'Setting up range rejection (rr) with varying ECUTRR in CM # ',
               ICM,
               '============================================================',
               'Minimum E needed from previous CM to reach the bottom of ',
              'this CM is ',EKE,
              ' MeV. This is larger than UE (',UE(medium),' MeV).',
              'Hence all charged  particles will be range-rejected before ',
              'entering this CM.',
              'Switching off rr in this CM by setting the minimum energy to',
              ' ECUTIN = ', ECUTIN,' MeV.',
              'Are you using a high density surrounding medium?',
              'Nominal "AIR" (MEDIUM 1) with RHO = ',rho(medium),'g/cm3 is ',
              (media(J,medium),J=1,24));

                EKE = E_min_out(ICM);
             ]
           ]"end MEDIUM non-zero block"
         ]"end loop on I for various slabs"
         E_min_out(ICM-1) = EKE;
      ]"end loop on ICM"
      "now set ECUTRR values for each region = E_min_out for that CM"
      DO IRL = 2,NREG[ECUTRR(IRL) = max(ECUT(IRL),E_min_out(IR_to_CM(IRL)));]
              "IR_to_CM from comin CMs tells which CM each region is"
              "in.  It is set just above in main"
  ]
  ELSEIF(IREJCT_GLOBAL=2)["do not calculate ECUTRR"
      DO IRL = 2,NREG[ECUTRR(IRL) =ECUT(IRL);]
  ]

  "For both IREJCT_GLOBAL=1,2 calculate RANGE_ECUTRR, range of electron"
  "with lowest energy to be transported in this region - in COMIN USER"
  lelec=-1; "need to set this for EGSnrc macros used to compute range"
  DO IRL = 2,NREG[
    IF(IREJCT(IRL)>0)[
      MEDIUM = MED(IRL);"MED in COMIN MISC, MEDIUM in COMIN USEFUL"
      "only want range above AE"
      IF(MEDIUM=0 | ECUTRR(IRL) = AE(MEDIUM))[RANGE_ECUTRR(IRL)=0.0;]
      ELSE[
         EKE = ECUTRR(IRL)- RM;
         ELKE = LOG(EKE);
         $SET INTERVAL ELKE, EKE;
         EKEI = E_array(LELKE,MEDIUM);
         ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
         $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RANGE_ECUTRR(IRL));
         RANGE_ECUTRR(IRL)=(RANGE_ECUTRR(IRL)+range_ep(0,LELKE,MEDIUM))*
                         (RHO(MEDIUM)/RHOR(IRL));
                       "RHOR = RHO(MEDIUM) unless overrides used"
                       "add the mult to avoid doing on each step"
      ]
       "Range of electron with energy ECUTRR of this region"
    ]"end IREJCT>0 block"
  ]"end loop on IRL"
]"end of if IREJCT_GLOBAL>0"
;
"*******************************************************************************
"
"                     INITIALIZATION FOR AUSGAB                        ""toc:
"                     *************************
"
;
" Set up AUSGAB calls for normal execution (not necessary, as fed through BLOCK
" DATA, but do it anyway).
DO J=1,5[ IAUSFL(J)=1; ]
DO J=6,29[ IAUSFL(J)=0; ]
"NB IAUSFL(6) is set =1 to flag when leaving a CM and then set=0 in AUSGAB"
"This means it must not be used in any other manner."

IAUSFL(7)=1; "call before bremsstrahlung so we can count bremsstrahlung events"

"if uniform bremsstrahlung splitting is on and IRRLTT=0 then,"
"if the particle is the result of a bremsstrahlung or annihilation event, we"
"want to set nbr_split=1 before a bremsstrahlung or annihilation event to avoid"
"higher-order splitting."
"Conversely, if the particle is a primary, then we want to make sure"
"nbr_split=NBRSPL before the bremsstrahlung or annihilation event (provided
"that the particle falls inside the defined field in the case of DBS)."
"Finally, if using DBS, we want to potentially split annihilation events"
IF((IBRSPL=1 & IRRLTT=0) | IBRSPL=2)[
    IAUSFL(13)=1; "before annih in flight"
    IAUSFL(29)=1; "before annih at rest"
]

"When bremsstrahlung splitting is done, we play russian roulette with
"secondaries from split bremsstrahlung photons so we don't get swamped
"following the electrons (usually after just the photons).  For uniform
"bremsstrahlung splitting, russian roulette is taken care of in egsnrc.mortran
"but for directional bremsstrahlung splitting, we need to set prob_RR
"according to the variable splitting number before egsnrc.mortran can
"take care of it.  Thus, we need to set up extra calls to AUSGAB
IF( IBRSPL=2)[
    IAUSFL(16) = 1; " before call to PAIR         "
    IAUSFL(18) = 1; " before COMPTON      "
    IAUSFL(20) = 1; " before PHOTO      "
    IAUSFL(24) = 1; " before RAYLEIGH: wasn't there => things will go wrong "
                    " if someone decides to turn Rayleigh on "
]
IF( IBRSPL=2 ) [
    IAUSFL(26) = 1; " after creating fluorescent photons "
]

IF(LATCH_OPTION  ~= 0)[
        "call ausgab if a SECONDARY is created in order to record the "
        "region number where the particle is generated                "
        "we're going to call ausgab a lot"
        /IAUSFL(8),IAUSFL(10),IAUSFL(12),IAUSFL(14),IAUSFL(15),IAUSFL(17),
        IAUSFL(19),IAUSFL(21)/=1;
        IF(LATCH_OPTION  >= 2)[
           IAUSFL(25)  = 1; " after a coherent interaction has occurred "
           LNOB29 = 2**(29-$LATCH_NUMBER_OF_BITS);
        ]
        "LNOB29 is a constant used to shift the region number so that this    "
        "number can be recorded by LATCH using bits (29-$LATCH_NUMBER_OF_BITS)"
        "- 28. BITS 1 - (28-$LATCH_NUMBER_OF_BITS) are used for region bit set"
        "One can recover the region number by dividing LATCH by LNOB29 later  "
        "on while working with PAW. For example, one can get the information  "
        "on all the particles created in region N using (INT(L/LNOB29) = N).  "
        "For the primaries, we should have N = 0.                             "
]

IF(IZLAST ~= 0)[ "scoring of last interaction site is requested."
   /IAUSFL(8),IAUSFL(14),IAUSFL(15),IAUSFL(17)/ =1;
   /IAUSFL(19),IAUSFL(25),IAUSFL(21)/ = 1;
   "With these flags set, AUSGAB is called as follows:"
   "8  => after brem created"
   "14 => after annihiliation in flight"
   "15 => after annihiliation at rest"
   "17 => after pair production"
   "19 => after compton scatter"
   "21 => after photoelectric event"
   "25 => after Rayleigh event"
]

" Set up AUSGAB calls for cross section enhancement "
" Added by IK July 13 2005.                         "
DO j=1,$MXAUS [ cse_return(j) = .false.; ]
IF( use_cs_enhance ) [
    " cross section enhancement requested.
    " we need calls to ausgab before and after compton/pair/photo/rayleigh
    " If the flags for these calls are not set, we set cse_return to true
    " so that we can return from AUSGAB immediately.
    IF( iausfl(16) = 0 ) cse_return(16) = .true.;
    IF( iausfl(17) = 0 ) cse_return(17) = .true.;
    IF( iausfl(18) = 0 ) cse_return(18) = .true.;
    IF( iausfl(19) = 0 ) cse_return(19) = .true.;
    IF( iausfl(20) = 0 ) cse_return(20) = .true.;
    IF( iausfl(21) = 0 ) cse_return(21) = .true.;
    IF( iausfl(24) = 0 ) cse_return(24) = .true.;
    IF( iausfl(25) = 0 ) cse_return(25) = .true.;
    IAUSFL(16) = 1; IAUSFL(17) = 1; " before/after PAIR     "
    IAUSFL(18) = 1; IAUSFL(19) = 1; " before/after COMPTON  "
    IAUSFL(20) = 1; IAUSFL(21) = 1; " before/after PHOTO    "
    IAUSFL(24) = 1; IAUSFL(25) = 1; " before/after RAYLEIGH "
]

"Ali:BCSE"

IF(IBRSPL=1)[IAUSFL(26)=1; "to split eii relaxation photons in UBS"]
                           "regardless of the use of BCSE         "
IF(USE_BCSE)[/IAUSFL(7),IAUSFL(8),IAUSFL(26)/=1;]

"*******************************************************************************
"
"                     INITIALIZATION FOR SHOWER                        ""toc:
"                     *************************
"
;
MXNP=0; "Reset the maximum stack indicator passed in SCORE

IHSTRY = NCASEO; "Reset the number of histories counter
NPASS_ph_sp=NPASS_ph_spO; "set number of particles rejected because of being"
                          "multiple passers"
NFAT_ph_sp=NFAT_ph_spO; "set no. of photons rejected because their trajectory"
                        "would take them beyond DBS radius at SSD"
NHSTRY = NHSTRYO;
IF((ISOURC=21 | ISOURC=24) & ~phsp_open)[
   IF(IPARALLEL>1 & PARNUM>0)["this is one of IPARALLEL parallel runs"
      IF(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp)<NNPHSP/IPARALLEL)[
          INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+IHSTRY+
                 (NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp);
      ]
      ELSE[
          long_tmp=NNPHSP;
          INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+
                   MOD(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp),
                       long_tmp/IPARALLEL);
      ]
   ]
   ELSE["not a parallel run"
      IF(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp).LT.NNPHSP)[
           INPHSP = IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp);
      ]
      ELSE[
          long_tmp=NNPHSP;
           INPHSP=MOD(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp),long_tmp);
      ]
   ]
   IF(i_iaea_in=1)["need to set position in IAEA phsp source"
      $IAEA_SET_PHSP_RECORD(IINSRC,INPHSP+1);"start at INPHSP+1 because"
                                             "INPHSP is incremented upon"
                                             "entering srchst"
   ]
]
"set the counter for the particle number being read from ph-sp file"

JHSTRY = 0; "Reset counter for EGS_WINDOWS for ZLAST"

IF(ISOURC < 21 | ISOURC=22) ["non-phase space input"
   IF(MONOEN =  0) ["Monoenergetic beam"
       IF(IQIN =  0)[EI=EIN;]ELSE[EI=EIN+RM;]
       EKMAX=EIN; "Maximum kinetic energy"
   ]
   ELSEIF(MONOEN =  1) ["spectrum input"
       EKMAX = ENSRCD(NENSRC);
   ]
]
ELSEIF(ISOURC >= 21 & ISOURC~=22) [
    "Read from ph-sp file or use beam characterization model"
    EKMAX=EKMAXSRC; "Maximum kinetic energy from the ph-sp particle"
    EIN=EKMAXSRC;"EIN will be used later in ISUMRY "
]

" Check that the data file had data over the energy range required"
DO I=1,NMED[
    IF((EKMAX >  UP(I)) |  (EKMAX >  UE(I)-RM))[
        OUTPUT I,EKMAX,UP(I),UE(I);
        (//1X,50('*')//
        ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MeV'/
        ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MeV'/
        '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
        1X,50('*')//);
        IRESTART=2; "Signal an early exit"
    ]
] "End of loop over media"

" Calculate one-time-only constants for source"
CALL SRCOTO(WEIGHT);

$BEAMMODEL_READ_FILE;
"beam characterization model inputs"

"open the .egsgeom file if asked for (.egsgph is opened in WATCH)"
IF(IWATCH=4 | IZLAST=2)[
   IOUTGEOM=egs_open_file(IOUTGEOM,0,1,'.egsgeom');
]
IF(IZLAST=2)[
    IOUTGPH=egs_open_file(IOUTGPH,0,1,'.egsgph');
]

"open the .egsdat file if asked for"
IF(IDAT=0) data_unit = egs_open_file(IORSTRT,0,1,'.egsdat');

"Print the summary of INPUTS"
CALL ISUMRY;

"now set ECUT(1)=PCUT(1)=0.0 to avoid warning messages from AUSGAB"
ECUT(1)=0.;
PCUT(1)=0.;
IF (IERR_INPUTS ~= 0) [ "stop if errors detected in INPUTS
   OUTPUT; (//'***ERROR in CM geometries -- simulation not run'//);
   WRITE (IOUTLIST,121);
   $CALL_EXIT(1);
]
121  FORMAT('***ERROR in CM geometries -- simulation not run'/
     T20, 'See log file or terminal output');

" Write the header for the listing file
CALL DATETIME(1);
WRITE(IOUTLIST,100) TITLE,TIMEN,DATEN;
100  FORMAT(//1A79/
     /' NRCC CALN: BEAMnrc(EGSnrc) '$BEAM_VERSION $USER_MACROS_VERSION,
     /' ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
WRITE(IOUTLIST,200);
200  FORMAT(' ',79('*')/
            ' ',T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
            ' ',79('*') );

"Print header for execution messages"
WRITE(i_log,200);

" Print execution mode
IF(IRESTART =  0)[WRITE(i_log,201);WRITE(IOUTLIST,201);]
ELSEIF(IRESTART =  1)[
    IF(ISOURC=21 | ISOURC=24)[
       WRITE(i_log,205) NCASE,NCASEO,NHSTRYO,NPASS_ph_spO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
       WRITE(IOUTLIST,205)NCASE,NCASEO,NHSTRYO,NPASS_ph_spO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
    ]
    ELSEIF(ISOURC=23)[
       WRITE(i_log,206) NCASE,NCASEO,NHSTRYO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
       WRITE(IOUTLIST,206)NCASE,NCASEO,NHSTRYO,NFAT_ph_spO,
                    (NPPHSP(IS),IS=1,NSC_PLANES);
    ]
    ELSE[
       WRITE(i_log,202) NCASE,NCASEO,(NPPHSP(IS),IS=1,NSC_PLANES);
       WRITE(IOUTLIST,202)NCASE,NCASEO,(NPPHSP(IS),IS=1,NSC_PLANES);
    ]
]
ELSEIF(IRESTART =  2)[
    WRITE(i_log,203); WRITE(IOUTLIST,203);
    ircode = 2; return;
]
ELSEIF(IRESTART =  3)[
    WRITE(i_log,204); WRITE(IOUTLIST,204);
    ircode = 1; return;
]
201  FORMAT(/'********* NEW INPUT FILE *********'/);
202  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
           ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
           ' ',10X,'USING RN SEEDS FROM PREVIOUS RUN'/
           ' ',10X,'# OF PARTICLES IN THE PH-SP FILE FROM PREVIOUS RUN ='/
           ' ',20X,4(1X,I12)/);
203  FORMAT(/' ********* INPUT FILE CREATION ONLY *********'/);
204  FORMAT(/' ********* DATA ANALYSIS ONLY *********'/);
205  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
      ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES (',I12,' PRIMARY HISTORIES)'/
      ' ',10X,'# OF MULTIPLE PASSERS REJECTED FROM PREVIOUS RUN = ',I12/
      ' ',10X,'# OF PHOTONS REJECTED BECAUSE THEY FALL OUTSIDE '/
      ' ',10X,'                            DBS SPLITTING RADIUS = ',I12/
      ' ',10X,'USING RN SEEDS FROM PREVIOUS RUN'/
      ' ',10X,'# OF PARTICLES IN THE PH-SP FILE FROM PREVIOUS RUN ='/
      ' ',20X,4(1X,I12)/);
206  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
      ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES (',I12,' PRIMARY HISTORIES)'/
      ' ',10X,'# OF FAT PHOTONS REJECTED=',I12/
      ' ',10X,'USING RN SEEDS FROM PREVIOUS RUN'/
      ' ',10X,'# OF PARTICLES IN THE PH-SP FILE FROM PREVIOUS RUN ='/
      ' ',20X,4(1X,I12)/);

" Initialize IWATCH routine"
IF(IWATCH ~= 0) CALL WATCH(-99,IWATCH);

CHOSEN_SRC18=0; "initialize in case we are using source 18"

DO I1=1,$MXSTACK[NP_INC(I1)=0;] "INITIALIZE PHOTON INTERACTION FORCING FLAG"

"initialize min. and max. particle weights"
MINWEIGHT=9999.;
MAXWEIGHT=0.;

CYCLNUM=0; "initialize no. of times a particle has been recycled"

NUM_BREM=0; "keeps track of bremsstrahlung interactions for this run only"

NHSTRY_LAST=0;

"the following was added by Tony Popescu and Julio Lobo to allow"
"communication between several moving beam modules"
"initialiaze communicating variables"
BEAM_MU_INDEX=-1.0;
BEAM_MU_INDEX_OLD=-1.0;
dosxyz2beam_index=1.0; "used for dosxyz phsp source- kept as +ve otherwise"

IF(ISTORE =  -1)[
    OUTPUT IOUTRN;(/' Will READ RANDOM NUMBER PARAMETERS FROM UNIT : ',I2);
    IOUTRN=egs_open_datfile(IOUTRN,0,1,'.egsrns');
    $RETRIEVE RNG STATE FROM UNIT IOUTRN;
    "Read initial random # parameters for the first history from a file"
]

" initialize interaction counters for dbs "
/count_nbrem,count_ncomp,count_npair,count_nphoto,count_nannih,
count_kill_brem,count_kill_comp,count_kill_photo,count_kill_annih/=0;
/time_brem,time_comp/=0;
count_esplit=0;
return;

:EOF_MAIN:;
OUTPUT;(//' *** unexpected end of file reading input for MAIN ***');
ircode = -1; return;

:ERROR_MAIN:;
OUTPUT;(//' *** format error on input for MAIN ***');
ircode = -2; return;

:EOF_RS1:;
OUTPUT;(/' *** Error on opening file: No directory/file can be found. ***');
ircode = -3;

return; end;

/**************************************************************************
 *
 *                 beam_shower
 *
 **************************************************************************/
subroutine beam_shower(icase);
/**************************************************************************/
implicit none;
$LONG_INT icase;

;COMIN/SCORE,SOURCE,EPCONT,RANDOM,CMs,USER,IO_INFO,TIMING-INFO,USEFUL,EGS-IO,
RWPHSP/;

$LONG_INT
   NHSTRY_OLD;   "T>used to store previous version of NHSTRY before call
                 "  to SRCHST"

$INTEGER RESETWATCH,IRIN,I1,I2,I3,IT,LATCHI,ITMAX;
$REAL    EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;
integer  egs_open_file;

RESETWATCH = 0;
ITMAX=3+LNEXC+LNINC;

IHSTRY=IHSTRY+1; "Increment history counter"
NHSTRY_OLD=NHSTRY; "store old value of NHSTRY"
IF(IWATCH < 0 & ABS(IWATCH) = IHSTRY)[
      IWATCH=2;
      RESETWATCH=1;
]

NFTIME(1)=0; "Reset the photon interaction forcing counter"
IDISC=0; "reset flag for starting a new particle           "
     "Photon forcing didn't work properly without this in  "
     "past but not now as we changed the condition for exit"
     "from IDISC=1 to IRNEW=1. Anyway, it does more good   "
     "than harm to reset it in the beginning of a history. "
     "It prevints further problems when we make use of     "
     "IDISC in the future.                                 "

IF(ISTORE = 1)["store state of RNG for later use"
    IOUTRN=egs_open_file(IOUTRN,0,1,'.egsrns');
    $PUT RNG STATE ON UNIT IOUTRN;
    CLOSE(IOUTRN);
]

IF(IBRSPL=2)[
  IPHATI=NBRSPL;
]
ELSE[
  IPHATI=1; "default value of iphat for source particles"
          "may be changed in SRCHST if ISOURC=3 and DSB is on"
]

IF(dosxyz2beam_index<0)[" for particles given by dosxyznrc"
                      "set the index to be positive again"
        BEAM_MU_INDEX=dosxyz2beam_index+1.1;
        "make sure the old index is different so the CMs freeze since"
        "dosxyznrc sets them"
        BEAM_MU_INDEX_OLD=BEAM_MU_INDEX-1.1;

]

$SET_DYN_COMP; "set leaf positions for dynamic or step-and-shoot"
               "simulations with DYNVMLC if needed"
$SET_DYNJAWS_COMP; "set dynamic jaw positions if needed"


"Tony Popescu and Julio Lobo: Note: with multiple"
"synchronized modules, only one sets the BEAM_MU_INDEX"
"the rest use the same one"
$SET_SYNCJAWS_COMP; "set synchronized jaws positions"
$SET_SYNCVMLC_COMP; "set synchronized vmlc positions"
$SET_SYNCMLCE_COMP; "set synchronized mlce positions"
$SET_SYNCHDMLC_COMP;"set synchronized hdmlc positions if needed"

"the following was added by Tony Popescu and Julio Lobo to allow"
"communication between several moving beam modules"
"set old mu index after all dynamic modules have been set"
BEAM_MU_INDEX_OLD = BEAM_MU_INDEX;

"Calculate the source dependant values which change for each
"history these include :
"particle energy if full phase-space input
"entry point into target,
"initial component module,
"initial direction cosines,
"statistical weight,
CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
"for ISOURC=21 EIN and IQIN are passed via comin score"
ICMNEW = ICM; "set equal to suppress full phase-space output until
              "particle crosses a scoring plane
IF( ISOURC ~= 21 & ISOURC ~=23 & ISOURC~=24) [
    IF( MONOEN = 1 ) CALL EN_SAMPLE(EIN);
    IF(IQIN =  0)[EI=EIN;]ELSE[EI=EIN+RM;]
] ELSE [ EI = EIN; ]

"set initial energy for beam models";
$BEAMMODEL_INITIAL_ENERGY;  "default is ;"

"Set initial values of non-standard particle properties in /STACK/"
IF( ISOURC~=21 & ISOURC~=24)[   " added by jwei "
    NPASSI=0;
    "Keeps track of number of times particle or its ancestors
    "have passed through scoring planes
]

NSPLITI=0;

ESPLIT_DBS=0; "default is to not split e- in DBS"

IF (IZLAST ~= 0) [
    ZLAST(1) = ZIN; XLAST(1) = XIN; YLAST(1)= YIN;
    IF (ISOURC ~= 21 & ISOURC~=24) ["not a phase space input"
       ZLAST(1) = ZIN; XLAST(1) = XIN; YLAST(1)= YIN;
    ]
    ELSE [
      "Note that for ISOURC = 21 XLAST,YLAST are not in the input"
      XLAST(1) = -100.0; YLAST(1)= -100.0;
      "Set above values to try to make sure not misused"
   ]
]

IF((IWATCH > 0)  &  (IWATCH ~= 4))[
   OUTPUT 1,(EI-abs(IQIN)*PRM),IQIN,IRIN,XIN,YIN,ZIN,UIN,
            VIN,WIN,LATCHI,WEIGHT;
   (' INITIAL SHOWER VALUES',T37,':',
   I2,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
]

IF(dosxyz2beam_index>=0)[
"Never increment when nhistry controlled by source 20 "
"in dosxyznrc."
IF( isourc = 3 & i_dsb = 1 ) [
    " history counter incremented in SRCHST "
]
ELSE [

IF((ISOURC~=21 & ISOURC~=23 & ISOURC~=24) | (DOSE_STAT=1 & NRCYCL=0) |
   (DOSE_STAT=1 & NRCYCL>0 & CYCLNUM=1) |
   ((ISOURC=21 | ISOURC=24) & DOSE_STAT=0 & IPARALLEL>1 & PARNUM>0 &
       ICASE=1 & IBATCH=1 & NHSTRY=NHSTRY_OLD)) NHSTRY=NHSTRY+1;
"increment no. of primary histories if this is not a phsp source,"
"if phsp source does not demarcate primary histories AND there is"
"no recycling or this is the first particle in the cycle, or if"
"phsp source does indicate primary histories but NHSTRY was not"
"incremented on the first history because this is one of a number"
"of parallel runs and, due to the way the phsp source was"
"partitioned, the first particle did not indicate a new primary"
"history."

]
]
ELSE [
 NHSTRY=NHSTRY_DOS;
]


IF(NHSTRY~=NHSTRY_OLD)["not necessarily true if this is a phsp"
                       "source"
   NHSTRY_LAST=NHSTRY_LAST+1;
   IF(NHSTRY_LAST=32700)["zero all SCARRAY_LAST counters and"
                         "reset NHSTRY_LAST to 1"
     SCSTP_LAST=0; SCDSTP_LAST=0;

     DO IT=1,ITMAX[
        DO ID=1,NDOSE_ZONE[
           SCDOSE_LAST(ID,IT)=0;
        ]
     ]
     [I1=1,3;
        [I2=1,$MAX_SC_PLANES;
           [I3=1,$MAX_SC_ZONES+1;
              SCFLU_LAST(I1,I2,I3,1)=0;
              SCFLU_LAST(I1,I2,I3,2)=0;
           ]
        ]
     ]
     NHSTRY_LAST=1;
   ]
]

"All initial shower variables are set, call the shower routine"

$USER-BEFORE-SHOWER;
CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
$USER-AFTER-SHOWER;

"Signal the end of a history if WATCH mode is set"
IF(IWATCH >  0) CALL WATCH(-1,IWATCH);
IF(RESETWATCH=1)[IWATCH = 0;]

return; end;

/****************************************************************************
 *
 *                          beam_shower_loop
 *
 ***************************************************************************/
subroutine beam_shower_loop;
/***************************************************************************/
implicit none;

;COMIN/SCORE,SOURCE,STACK,EGS-IO,IO_INFO,USER,EPCONT,RANDOM,USEFUL,CMs,
       CH-Steps,RWPHSP,TIMING-INFO/;

INTEGER
   I,I1,I2,I3,I4,IT, "T>DO loop indices
   TOT_BATCH,    "T>Total number of batches processed
   IRIN,         "T>
   ITMAX,        "T>Number of dose components
   RESETWATCH,   "T>used to reset IWATCH to 0 when IWATCH<0
   NPPHSPSP,     "T>INTEGER*4 version of NPPHSP for writing/reading to/from
                 "T>header of phsp file
   lnblnk1;      "T> built-in lnblnk function

$LONG_INT
   ICASE,
   NHSTRY_OLD;   "T>used to store previous version of NHSTRY before call
                 "  to SRCHST"
$DECLARE_TIMING_VARIABLES;   "timing_variables CPUT0/1/2 TZERO ETIME UTIME_"

$REAL BATCHT;

integer egs_open_file;

$INTEGER IERR;

CHARACTER AUNIT*8, phsp_fn*256,phsp_fn_base*256;

#ifdef HAVE_C_COMPILER;
$REAL   part_dose, part2_dose, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last,n_left,other_num_1,other_num_2,p_per_phsp_chunk;
$INTEGER  n_run_chunk;
$LOGICAL first_time;
#endif;

INTEGER NETADJ;  "T>keeps track of how many times elapsed time adjusted"

NETADJ=0;  "initialize number of times elapsed time adjusted"
ITMAX=3+LNEXC+LNINC;
RESETWATCH=0;
TOT_BATCH = 0;

" Set clock at the beginning of simulations"
$SET_ELAPSED_CPUTIME(tzero);
$INITIALIZE_ELAPSED_TOTAL_TIME;
"note above macros defined in timing.macros"

"New parallel processing implementation. Only used if there is a
"    working C compiler.
#ifdef HAVE_C_COMPILER;
;
n_tot = ncaseo; first_time = .true.;
/part_dose,part2_dose/=0;
"Not sure what is a good quantity to put into the job control file"
"In fact, this quantity may change depending on the run"
"just use 0 for now"

write(i_log,*) '*********** jcase = ',jcase;

:start_parallel_loop:;
IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(i_log,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        return;
    ]
    jcase = n_run/$NBATCH;
    IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
    IF( first_time ) [
        IF(ISOURC=21 | ISOURC=24)
                   p_per_phsp_chunk=NNPHSP/(n_parallel*$N_CHUNKS);
        first_time = .false.; n_last = n_run;
        write(i_log,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(i_log,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(i_log,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
    IF(ISOURC=21 | ISOURC=24)[
"    figure out where to start in the phase space file"
        n_run_chunk=(ncase-n_left)*n_parallel*$N_CHUNKS/ncase;
        other_num_1=n_run_chunk*ncase;
        other_num_2=(ncase-n_left)*n_parallel*$N_CHUNKS;
        IF(other_num_1<other_num_2)[
          n_run_chunk=n_run_chunk+1;
        ]
        INPHSP_MIN=(n_run_chunk-1)*p_per_phsp_chunk+1;
        IF(n_left=0)["this is the last run just use up the rest of the"
                     "phsp source"
           INPHSP_MAX=NNPHSP;
        ]
        ELSE["calculate the max value of INPHSP"
           INPHSP_MAX=INPHSP_MIN+p_per_phsp_chunk-1;
        ]
        INPHSP=INPHSP_MIN-1; "src routine adds 1 to INPHSP"
        "need to set position in IAEA source, if applicable"
        IF(i_iaea_in=1)[$IAEA_SET_PHSP_RECORD(IINSRC,INPHSP_MIN);]
        CYCLNUM=0; "reset NRCYCL counter"
        write(i_log,'(/a/,a,i12,a,i12/,a//)')
  '      This simulation uses a phase space source.',
  '      This run will use from particle',INPHSP_MIN,' to particle ',
         INPHSP_MAX,
  '      in the source file.';
    ]
]
#endif;


"*******************************************************************************
"*******************************************************************************
"
"                                 SHOWER CALL                          ""toc:
"                                 ***********
"
"*******************************************************************************
"
" Loop through the number of histories. Calculate constants that may change for
" each history and do the simulation.
"
"Break up into batches.  Execution stops if there is not enough time to do
"another batch.  Note: these are not statistical batches, they are only for
"output purposes.

IF(IRESTART=3)[
   OUTPUT;(/' Analyzing data from a previous run'//);
]
ELSEIF(IRESTART=4)[
   OUTPUT;(/' Combining and analyzing data from parallel runs'//);
]
ELSE[

  DO IBATCH=1,$NBATCH[

    TOT_BATCH = TOT_BATCH + 1; "Num done including the current one"
    IF(IBATCH =  1)[
        CALL DATETIME(1);
        OUTPUT TIMEN;
        (/' BATCH #',2X,'TIME-ELAPSED',2X,'TOTAL CPUTIME',2X,'RATIO',2X,
        'TIME OF DAY',2X,'RNG pointers'//
        ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',4X,$TIMEN_FORMAT,'  ',$);
        $SHOW-RNG-STATE(i_log);OUTPUT;(' ');
    ]
    ELSE[
        $SET_ELAPSED_TOTAL_TIME(TIMEB);
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU=CPUT2-tzero;
        ETIMETOT=ETIMETOT+TIMEB;
        CALL DATETIME(1);
        OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU,TIMEN;
        (4X,I2,5X,F8.1,7X,F8.1,2X,F8.2,4X,$TIMEN_FORMAT,'  ',$);
        $SHOW-RNG-STATE(i_log);OUTPUT;(' ');
        "Check there is time left for another batch"
        BATCHT=TIMCPU/FLOAT(TOT_BATCH - 1);"Time per batch so far"
        IF(TIMCPU+1.1*BATCHT >  TIMMAX*3600.)[
            "Not enough time for another batch"
            "Print message and exit simulation loop"
            WRITE(IOUTLIST,210) TIMMAX,TOT_BATCH-1,IHSTRY-NCASEO,IHSTRY;
            WRITE(i_log,210) TIMMAX,TOT_BATCH-1,IHSTRY-NCASEO,IHSTRY;
            return;
        ]

        ;$BEAMMODEL_DATA_OUTPUT;
        "analysis data for beam characterization models"
    ]

    210  FORMAT(//' ========= '/'   NOT ENOUGH TIME TO FINISH WITHIN',
       ' LIMIT OF',F8.2,' HOURS',I3,' BATCHES USED'/
       ' ',I12,' HISTORIES RUN, ',I12,' HISTORIES ANALYZED'//);

    DO ICASE=1,JCASE["within a batch now"

        call beam_shower(icase);

    ] "End of the ICASE loop"

    "Succesful completion of a batch. Delete the raw data from the last batch"
    "and record the new batch only if requested"
    call beam_write_dat;
    IF(IO_OPT = 0  | IO_OPT >= 3) [
        IF(PHSP_OUTDIR~=' ')[
             "assume the user wants definition of output directory in the"
             "input file to overwrite that in beamnrc_user_macros.mortran"
           phsp_fn_base=$cstring(PHSP_OUTDIR) // $file_sep //
                         $cstring(output_file);
        ]
        ELSE[
           phsp_fn_base=$DIRECTORY-FOR-PHSP // $file_sep //
                         $cstring(output_file);
        ]
        IF( i_parallel > 0 ) ["add an _w"
           phsp_fn_base=$cstring(phsp_fn_base)// '_w';
           call egs_itostring(phsp_fn_base,i_parallel,.false.);
        ]
        $BEAM_PHSP_BUFFER_FLUSH;
    ]
  ] "End of loop on IBATCH  - ie end of simulations "
]"end of normal run"

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]

#endif;

return; end;

subroutine beam_write_dat;

"subroutine writes the .egsdat file if requested."
"Put in a separate subroutine so that we can output the file when"
"a BEAM simulation is used as a source."
implicit none;
;COMIN/SCORE,SOURCE,RANDOM,CH-Steps,TIMING-INFO,USER,EGS-IO/;

INTEGER IT,ITMAX,I1,I2,I3,I4;

$DECLARE_TIMING_VARIABLES;

ITMAX=3+LNEXC+LNINC;

    IF(IDAT =  0)[
        "add unscored portions of all *_TMP arrays before writing"
        "the .egsdat file"
        SCSTP=SCSTP+SCSTP_TMP;
        SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
        SCSTP_TMP=0;
        SCDSTP=SCDSTP+SCDSTP_TMP;
        SCDSTP2=SCDSTP2+SCDSTP_TMP*SCDSTP_TMP;
        SCDSTP_TMP=0;
        DO ID=1,NDOSE_ZONE[
          DO IT=1,ITMAX[
             SCDOSE(ID,IT)=SCDOSE(ID,IT)+SCDOSE_TMP(ID,IT);
             SCDOSE2(ID,IT)=SCDOSE2(ID,IT)+SCDOSE_TMP(ID,IT)*SCDOSE_TMP(ID,IT);
             SCDOSE_TMP(ID,IT)=0;
          ]
        ]
        DO I1=1,3[
          DO I2=1,NSC_PLANES[
            DO I3=1,NSC_ZONES(I2)+1[
              "mean energy, first time crossers"
              SCFLU_COV(I1,I2,I3,1)=SCFLU_COV(I1,I2,I3,1)+
                                       SCFLU_TMP(I1,I2,I3,3)*
                                       SCFLU_TMP(I1,I2,I3,2);
              "mean angle, first time crossers"
              SCFLU_COV(I1,I2,I3,2)=SCFLU_COV(I1,I2,I3,2)+
                                       SCFLU_TMP(I1,I2,I3,4)*
                                       SCFLU_TMP(I1,I2,I3,1);
              "mean energy, multiple crossers"
              SCFLU_COV(I1,I2,I3,3)=SCFLU_COV(I1,I2,I3,3)+
                                       SCFLU_TMP(I1,I2,I3,7)*
                                       SCFLU_TMP(I1,I2,I3,6);
              "mean angle, multiple crossers"
              SCFLU_COV(I1,I2,I3,4)=SCFLU_COV(I1,I2,I3,4)+
                                       SCFLU_TMP(I1,I2,I3,8)*
                                       SCFLU_TMP(I1,I2,I3,5);
              DO I4=1,$MAX_SC_PARAMETERS[
                SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)+
                                    SCFLU_TMP(I1,I2,I3,I4);
                SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)+
                              SCFLU_TMP(I1,I2,I3,I4)*SCFLU_TMP(I1,I2,I3,I4);
                SCFLU_TMP(I1,I2,I3,I4)=0;
              ]
            ]
          ]
        ]
        rewind(data_unit); "i.e. overwrite data from previous batch"
        WRITE(data_unit,*) SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP+count_pII_steps;
        WRITE(data_unit,*)
             ((SCDOSE(ID,IT),SCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
        WRITE(data_unit,*)
             ((((SCFLU(I1,I2,I3,I4),SCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
        WRITE(data_unit,*)
             ((((SCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
        WRITE(data_unit,*)
             ((((SCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU=CPUT2-tzero;
        $PUT RNG STATE ON UNIT data_unit;
        WRITE(data_unit,*) IHSTRY,NHSTRY,TIMCPU,(NPPHSP(I1),I1=1,NSC_PLANES),
                         NPASS_ph_sp,NFAT_ph_sp;
        $USER-WRITE-DAT(data_unit);
        OUTPUT IHSTRY,NPPHSP(1);
           ('     # of histories run:',I10,
            '      # of particles in ph-sp file:',I10/);
        $FLUSH_UNIT(data_unit);
     ]"End of conditional data storage"

return; end;

subroutine beam_finish(ientry);
implicit none;

$INTEGER ientry,egs_open_file;

;COMIN/SCORE,SOURCE,STACK,IO_INFO,RANDOM,USER,CMs,EGS-IO,UPHIOT,TIMING-INFO,
       RWPHSP/;

$REAL
   SCORE_NORM_NUM, "T>Normalization factor for scoring numbers of particles
   SCORE_NORM_FLUENCE, "T>Normalization factor for fluence scoring
   FMASS            "T>Mass of dose zone unless vacuum in which case FMASS=1
;

REAL*8 SCORE_TEMP; "T> temp variable used during uncertainty analysis

$REAL TEMP1,WEIGHT,RATIO;

$INTEGER I,I1,I2,I3,I4,IT,ITMAX,IERR,NUMIND,COVIND;

$DECLARE_TIMING_VARIABLES;

external combine_results;

#ifdef HAVE_C_COMPILER;
integer n_job;

#endif;

is_finished = .false.;

"*******************************************************************************
"
"                             END OF SIMULATION                        ""toc:
"                             *****************

ITMAX=3+LNEXC+LNINC;

IF( ientry ~= 0 & ientry ~= 1) [ goto :END-OF-RUN:; ]

IF(ISOURC=21 | ISOURC=24)[
  IF(OUTCNT>0)["print warning" WRITE(IOUTLIST,249) OUTCNT; ]
  249 FORMAT(///' **WARNING** USED ALL PARTICLES FROM SOURCE FILE ',I5,
  ' TIMES.');
]

:TIME-PLUS-ANAL:

IF(IRESTART~=4 & ~is_finished)[
  WRITE(IOUTLIST,250);
  $SHOW-RNG-STATE(IOUTLIST);
  WRITE(i_log,250);
  $SHOW-RNG-STATE(i_log);
]
$SET_ELAPSED_TOTAL_TIME(TIMEB);
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=CPUT2-tzero;
ETIMETOT=ETIMETOT+TIMEB;
RATIO=ETIMETOT/TIMCPU;
IF(IRESTART ~= 3 & IRESTART ~=4 & ~is_finished)[
    WRITE(IOUTLIST,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
    WRITE(i_log,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
    IF(ientry=1) [
      WRITE(IOUTLIST,280)TIMCPU/dble(IHSTRY),
      3600.*dble(IHSTRY)/TIMCPU;
      WRITE(i_log,280)TIMCPU/dble(IHSTRY),
      3600.*dble(IHSTRY)/TIMCPU;
    ]
    ELSE[
      WRITE(IOUTLIST,280)TIMCPU/dble((IBATCH-1)*JCASE),
      3600.*dble((IBATCH-1)*JCASE)/TIMCPU;
      WRITE(i_log,280)TIMCPU/dble((IBATCH-1)*JCASE),
      3600.*dble((IBATCH-1)*JCASE)/TIMCPU;
    ]
]
IF(IRESTART = 1)[
    WRITE(IOUTLIST,270) TIMCPU+TMCPUO,(TIMCPU+TMCPUO)/3600.;
    WRITE(i_log,270) TIMCPU+TMCPUO,(TIMCPU+TMCPUO)/3600.;
    WRITE(IOUTLIST,280)(TIMCPU+TMCPUO)/dble(IHSTRY),
                       3600.*dble(IHSTRY)/(TIMCPU+TMCPUO);
    WRITE(i_log,280)(TIMCPU+TMCPUO)/dble(IHSTRY),
                 3600.*dble(IHSTRY)/(TIMCPU+TMCPUO);
]
ELSEIF(IRESTART = 3)[
    WRITE(IOUTLIST,275) TMCPUO,TMCPUO/3600.;
    WRITE(i_log,275) TMCPUO,TMCPUO/3600.;
    WRITE(IOUTLIST,280)TMCPUO/dble(IHSTRY),
                       3600.*dble(IHSTRY)/TMCPUO;
    WRITE(i_log,280)TMCPUO/dble(IHSTRY),
                 3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRESTART = 4 | is_finished)[
    WRITE(IOUTLIST,285) DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/FLOAT(DATCOUNT);
    WRITE(i_log,285) DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/FLOAT(DATCOUNT);
    WRITE(IOUTLIST,290)TMCPUO/dble(IHSTRY),
                       3600.*dble(IHSTRY)/TMCPUO;
    WRITE(i_log,290)TMCPUO/dble(IHSTRY),
                 3600.*dble(IHSTRY)/TMCPUO;
]

250  FORMAT(/' *** FINAL RANDOM NUMBER POINTERS: ',$);
260  FORMAT(//' FOR THIS RUN:'/
             ' ------------ '/
             ' ELAPSED& CPU TIMEs, RATIO =',2F10.1,'s (=',F7.2,'HR)',F7.2);
270  FORMAT(/' FOR THIS+PREVIOUS RUN:'/
             ' --------------------- '/
             ' TOTAL CPUTIME =',F10.1,'s (=',F8.2,' HR)');
275  FORMAT(/' FOR OLD RUN:'/
             ' ----------- '/
             ' TOTAL CPUTIME =',F10.1,'s (=',F8.2,' HR)');
280  FORMAT( ' CPUTIME per history =',F10.5,' sec. Number of histories per',
             ' hour =',F12.0/'   On '$MACHINE' ');
285  FORMAT(/' FOR PARALLEL RUNS:'/
             ' ----------------- '/
    ' On ',I5,' machines '/
    ' TOTAL CPUTIME =',F10.1,'s (=',F8.2,' HR), CPUTIME/machine =',F10.1);
290  FORMAT( ' CPUTIME per history =',F10.5,' sec. '/
             ' Number of histories per hour on one machine =',F12.0/
             '   On '$MACHINE' ');

"*******************************************************************************
"*******************************************************************************
"
"                        ANALYSIS AND OUTPUT OF RESULTS                ""toc:
"                        ******************************
"
"*******************************************************************************
"
"                      STATISTICAL AND OTHER DATA HANDLING             ""toc:
"                      ***********************************

:STATS-ANAL:;

IF(OUTCNT>0)[
   OUTPUT;(//' ***WARNING***'/
       ' The phsp source was restarted at least once.  This may lead'/
       ' to an underestimate of uncertainty, especially if restarted'/
       ' many times.  If restarted many times, try re-running with'/
       ' NRCYCL recalculated as described at top of beamnrc.mortran'//);
]
IF((ISOURC=3 & i_dsb=1)|ISOURC=23)[
   SCORE_NORM_NUM=NHSTRY;
]
ELSE[
   SCORE_NORM_NUM = NINCSRC*dble(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/
                 FLOAT(NNPHSP);
]
"this is the total number of primary (non-phsp source) histories"
"it is a useful number in the following analysis"

"   dose analysis (also analyze no. of charged particle steps)
"   =============
"

$ANALYZE(SCSTP, :SCORE_NORM_NUM);
$ANALYZE(SCDSTP, :SCORE_NORM_NUM);
DO I1=1,ITMAX[
   DO I2=1,NDOSE_ZONE[
     $ANALYZE(SCDOSE,(I2,I1):SCORE_NORM_NUM);
   ]
]

" Convert dose from MeV to Grays per incident particle"
" Recall 1 MeV = 1.602E-6 erg, 1 rad = 100 erg/g, 1 Gy = 1 J/kg = 100 rad  "
" = 10000 erg/g. The unit of mass here is gram. Thus we have 1 MeV/g =     "
" 1.602E-10 Gy. The unit of dose/per incident particle is also Gy.         "

DO IT=1,ITMAX[
    DO ID=1,NDOSE_ZONE[
            IF(SCDOSE(ID,IT) ~= 0.0)[
                FMASS=AMASS(ID);
                IF(FMASS =  0.0)FMASS=1.0; "Avoids /0 for vacuum"
                SCDOSE(ID,IT)=SCDOSE(ID,IT)*1.602E-10/
                              (FMASS*SCORE_NORM_NUM);
            ]
    ]
]

"   fluence analysis
"   ================
"
DO I1=1,3[
  DO I2=1,NSC_PLANES[
     FLUENCERR(I2)=0;
     IF(MZONE_TYPE(I2) = 0)["circular scoring"TEMP1=PI;]
     ELSEIF(MZONE_TYPE(I2) = 1)["square scoring"TEMP1=4.0;] "Ali:GRID"
     ELSEIF(MZONE_TYPE(I2) = 2)["grid scoring"TEMP1=1.0;]
     ELSE[OUTPUT;(///' SCORING NORMALIZATION NOT WELL DEFINED********');
           TEMP1 = 1.0;
     ]
     DO I3=1,NSC_ZONES(I2)+1[
       IF(MZONE_TYPE(I2)<2)["i.e.not grid" "Ali:GRID"
         IF (I3=1) [
            SCORE_NORM_FLUENCE = TEMP1*RSCORE_ZONE2(I2,I3)*SCORE_NORM_NUM;
         ]
         ELSEIF(I3=NSC_ZONES(I2)+1)[
            IF((IPLANE_to_CM(I2)=MAX_CMs) |
              (RMAX_CM_FLAG(IPLANE_to_CM(I2))=RMAX_CM_FLAG(IPLANE_to_CM(I2)+1)
              & RMAX_CM(IPLANE_to_CM(I2))>=RMAX_CM(IPLANE_to_CM(I2)+1)) |
              (RMAX_CM_FLAG(IPLANE_to_CM(I2))=1 &
              RMAX_CM(IPLANE_to_CM(I2))>=SQRT(2.)*RMAX_CM(IPLANE_to_CM(I2)+1))|
              (RMAX_CM_FLAG(IPLANE_to_CM(I2))=2 &
              RMAX_CM(IPLANE_to_CM(I2))>=RMAX_CM(IPLANE_to_CM(I2)+1)))[
                IF(RMAX_CM_FLAG(IPLANE_to_CM(I2))=1)[
                   SCORE_NORM_FLUENCE=(PI*RMAX_CM(IPLANE_to_CM(I2))**2
                                 -TEMP1*RSCORE_ZONE2(I2,NSC_ZONES(I2)))*
                                 SCORE_NORM_NUM;
                ]
                ELSEIF(RMAX_CM_FLAG(IPLANE_to_CM(I2))=2)[
                   SCORE_NORM_FLUENCE=(4*RMAX_CM(IPLANE_to_CM(I2))**2
                                 -TEMP1*RSCORE_ZONE2(I2,NSC_ZONES(I2)))*
                                 SCORE_NORM_NUM;
                ]
            ]
            "now normalizes with area and # of particles in outer zone"
            ELSE["just normalize wrt # of incident particles"
               SCORE_NORM_FLUENCE=SCORE_NORM_NUM;
               FLUENCERR(I2)=1;
            ]
         ]
         ELSE [
            SCORE_NORM_FLUENCE = TEMP1*(RSCORE_ZONE2(I2,I3) -
                                 RSCORE_ZONE2(I2,I3-1))*SCORE_NORM_NUM
         ]
       ]
       ELSE["grid"   "Ali:GRID"
         IF(I3=NSC_ZONES(I2)+1)["the outermost zone"
             SCORE_NORM_FLUENCE=(4*RMAX_CM(IPLANE_to_CM(I2))**2
                  -(RSCORE_ZONE(I2,NX_ZONE(I2)+1)-RSCORE_ZONE(I2,1))*
                   (RSCORE_ZONE2(I2,NY_ZONE(I2)+1)-RSCORE_ZONE2(I2,1)))*
                   SCORE_NORM_NUM;
         ]
         ELSE["the same for all zones"
             SCORE_NORM_FLUENCE=(RSCORE_ZONE(I2,2)-RSCORE_ZONE(I2,1))*
                                (RSCORE_ZONE2(I2,2)-RSCORE_ZONE2(I2,1))*
                                SCORE_NORM_NUM;
         ]
       ] "end of grid"

         IF(SCORE_NORM_FLUENCE~=0.)[
             DO I4=1,8[
                "first add unscored portions of SCFLU_TMP if we have not"
                "already added them prior to writing the .egsdat file"
                IF(IDAT=1)[
                  SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)+
                                   SCFLU_TMP(I1,I2,I3,I4);
                  SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)+
                                    SCFLU_TMP(I1,I2,I3,I4)**2;
                  "add to the covariance arrays"
                  IF(I4=1)["mean energy, first time crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+2)*
                                           SCFLU_TMP(I1,I2,I3,2);
                  ]
                  ELSEIF(I4=2)["mean angle, first time crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+2)*
                                           SCFLU_TMP(I1,I2,I3,1);
                  ]
                  ELSEIF(I4=3)["mean energy, multiple crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+4)*
                                           SCFLU_TMP(I1,I2,I3,6);
                  ]
                  ELSEIF(I4=4)["mean angle, multiple crossers"
                    SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                           SCFLU_TMP(I1,I2,I3,I4+4)*
                                           SCFLU_TMP(I1,I2,I3,5);
                  ]
                ]

                "now, do the analysis, total no. of incident primary"
                "histories (SCORE_NORM_NUM) as normalization no."
                SCORE_TEMP=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)/SCORE_NORM_NUM;
                SCFLU2(I1,I2,I3,I4)=(SCFLU2(I1,I2,I3,I4)-SCORE_TEMP**2)/
                                     (SCORE_NORM_NUM-1);
                IF(SCFLU2(I1,I2,I3,I4)>0) SCFLU2(I1,I2,I3,I4)=
                                          SQRT(SCFLU2(I1,I2,I3,I4));
                IF((I4<5 & SCFLU_NUM(I1,I2,I3,1)<=1) |
                   (I4>4 & I4<9 & SCFLU_NUM(I1,I2,I3,2)<=1))[
                   "we have 0 or 1 particle contributing"
                   SCFLU2(I1,I2,I3,I4)=99.9;
                ]
                ELSEIF(SCORE_TEMP~=0)[
                     SCFLU2(I1,I2,I3,I4)=
                          MIN(SCFLU2(I1,I2,I3,I4)/SCORE_TEMP*100.D00,99.9D00);
                ]

                "and normalize quantities for output"
                IF(I4=1|I4=5)["no."
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                ]
                ELSEIF(I4=2|I4=6)["fluence"
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_FLUENCE;
                ]
                ELSEIF(I4=3|I4=7)["mean energy"
                    IF(I4=3)["set indices"
                       NUMIND=1;
                       COVIND=1;
                    ]
                    ELSE[
                       NUMIND=2;
                       COVIND=3;
                    ]
                    "first, normalize by no. of primary histories"
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                    "now, get fluence normalized by no. of primary histories"
                    SCORE_TEMP=SCFLU(I1,I2,I3,I4-1)*SCORE_NORM_FLUENCE/
                               SCORE_NORM_NUM;
                    IF(SCFLU_NUM(I1,I2,I3,NUMIND)<=1)[
                        "only 0-1 particle contributing"
                        SCFLU2(I1,I2,I3,I4)=99.9;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                    ]
                    ELSE[
                      IF(SCFLU_NUM(I1,I2,I3,NUMIND)<$COVMIN)[
                        "covers case where there are too few particles to"
                        "consider covariance"
                        SCFLU_COV(I1,I2,I3,COVIND)=0.;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                      ]
                      ELSE[
                        "calculate cov(Energy fluence,fluence)"
                        SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                             SCORE_NORM_NUM -
                                        SCFLU(I1,I2,I3,I4)*SCORE_TEMP;
                        "calcuate cov(E flu.,flu.)/((E flu.)(flu.)(N-1))"
                        SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                                 (SCFLU(I1,I2,I3,I4)*
                                             SCORE_TEMP*(SCORE_NORM_NUM-1));
                      ]
                      SCFLU2(I1,I2,I3,I4)=(SCFLU2(I1,I2,I3,I4)/100.D00)**2+
                                        (SCFLU2(I1,I2,I3,I4-1)/100.D00)**2-
                                         2*SCFLU_COV(I1,I2,I3,COVIND);
                      IF(SCFLU2(I1,I2,I3,I4)>0.)[
                          SCFLU2(I1,I2,I3,I4)=SQRT(SCFLU2(I1,I2,I3,I4));
                      ]
                      SCFLU2(I1,I2,I3,I4)=MIN(SCFLU2(I1,I2,I3,I4)*100.D00,
                                            99.9D00);
                    ]
                    "now divide E flu. by flu."
                    IF(SCFLU(I1,I2,I3,I4-1)>0) SCFLU(I1,I2,I3,I4)=
                                     SCFLU(I1,I2,I3,I4)/SCORE_TEMP;
                ]
                ELSEIF(I4=4|I4=8)[ "mean angle"
                    IF(I4=4)["set indices"
                       NUMIND=1;
                       COVIND=2;
                    ]
                    ELSE[
                       NUMIND=2;
                       COVIND=4;
                    ]
                    "first, normalize in the same way as no.,flu."
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)/SCORE_NORM_NUM;
                    IF(SCFLU_NUM(I1,I2,I3,NUMIND)<=1)[
                        "only 0-1 particle contributing"
                        SCFLU2(I1,I2,I3,I4)=99.9;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                    ]
                    ELSE[
                      IF(SCFLU_NUM(I1,I2,I3,NUMIND)<$COVMIN)[
                        "covers case where there are too few particles to"
                        "consider covariance"
                        SCFLU_COV(I1,I2,I3,COVIND)=0.;
                        SCFLU_NOCOV(I1,I2,I3,NUMIND)=1;
                      ]
                      ELSEIF(SCFLU(I1,I2,I3,I4)=0.)[
                        "covers case where all particles have angle 0"
                        SCFLU_COV(I1,I2,I3,COVIND)=0.;
                      ]
                      "calculate cov(angle,no.)"
                      SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                             SCORE_NORM_NUM -
                                        SCFLU(I1,I2,I3,I4)*SCFLU(I1,I2,I3,I4-3);
                      "calcuate cov(angle,no.)/((angle)(no.)(N-1))"
                      SCFLU_COV(I1,I2,I3,COVIND)=SCFLU_COV(I1,I2,I3,COVIND)/
                                                 (SCFLU(I1,I2,I3,I4)*
                                                  SCFLU(I1,I2,I3,I4-3)*
                                                  (SCORE_NORM_NUM-1));
                      "now, estimate the uncertainty"
                      SCFLU2(I1,I2,I3,I4)=(SCFLU2(I1,I2,I3,I4)/100.D00)**2+
                                        (SCFLU2(I1,I2,I3,I4-3)/100.D00)**2-
                                         2*SCFLU_COV(I1,I2,I3,COVIND);
                      IF(SCFLU2(I1,I2,I3,I4)>0.)[
                          SCFLU2(I1,I2,I3,I4)=SQRT(SCFLU2(I1,I2,I3,I4));
                      ]
                      SCFLU2(I1,I2,I3,I4)=MIN(SCFLU2(I1,I2,I3,I4)*100.D00,
                                            99.9D00);
                    ]
                    "divide angle by no. and convert to degrees"
                    IF(SCFLU(I1,I2,I3,I4-3)>0) SCFLU(I1,I2,I3,I4)=
                                        SCFLU(I1,I2,I3,I4)/SCFLU(I1,I2,I3,I4-3);
                    SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)*57.29578;
                ]
             ]
         ]
         ELSEIF(I1=1 & I3<=NSC_ZONES(I2)) [
            WRITE (IOUTLIST,
          '(//''***WARNING IN SCORING PLANE '',I4,/
              ''Zone '',I4,'' has zero area''//)') I2, I3;
            OUTPUT I2, I3; (//'***WARNING IN SCORING PLANE ',I4,/
                   'Zone ',I4,' has zero area'//);
         ]
    ]
  ]
]

"
"*******************************************************************************
"
"                            OUTPUT SUMMARY                            ""toc:
"                            **************
"

"extra data analysis, output, etc"
"put here so user can skip OSUMRY if required"
$USER-FINISH;

IF(ientry=1) NINCPHSP=SCORE_NORM_NUM;
"so correct no. of incident particles is output to phsp summary when this is a"
"beam source"

CALL OSUMRY; "Print the output summary"

;$BEAMMODEL_OSUMRY;"beam characterization model output"

"below used for evaluating DBS, commented out for now"
"write(6,*); write(6,*);
"write(6,*) '========================================================';
"write(6,*) 'Interaction counters:';
"write(6,*) ' number of brems events: ',count_nbrem;
"write(6,*) ' number of killed brem photons: ',count_kill_brem;
"write(6,*) ' number of annihilation events: ',count_nannih;
"write(6,*) ' number of killed annihilation photons: ',count_kill_annih;
"write(6,*) ' number of compton events: ',count_ncomp;
"write(6,*) ' number of killed compton-scattered photons: ',count_kill_comp;
"write(6,*) ' number of pair events: ',count_npair;
"write(6,*) ' number of photo events: ',count_nphoto;
"write(6,*) ' number of killed fluorescent photons: ',count_kill_photo;
"write(6,*) ' number of electron splitting events: ',count_esplit;
"write(6,*);
"write(6,*) ' time spent doing brem: ',time_brem,' seconds';
"write(6,*) ' time spent doing compton: ',time_comp,' seconds';
"write(6,*) '========================================================';
"write(6,*); write(6,*);

:END-OF-RUN:;

"close any files that were opened"
IF(IDAT=0) close(data_unit);
IF(IWATCH=4 | IZLAST=2 )[
    close(IOUTGPH);
    close(IOUTGEOM);
]
IF(ISTORE = -1)[ CLOSE(IOUTRN); ]

$BEAM_CLOSE_PHSP;

CALL DATETIME(1);
OUTPUT DATEN,TIMEN;(/' END OF RUN',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//);
WRITE(IOUTLIST,400) DATEN,TIMEN;
400  FORMAT(///' END OF RUN',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//);

call egs_finish;     " Finish the simulation "

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IOUTLIST=egs_open_file(IOUTLIST,0,1,'.egslst');
    IF( n_job = 0 ) [
        is_finished = .true.;
        DO ID=1,NDOSE_ZONE[
           AMASS(ID)=0.; "zero these since they get summed again in ISUMRY"
        ]
        CALL ISUMRY;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET; NCASE=0;
        CALL SRCOTO(WEIGHT);
        goto :TIME-PLUS-ANAL:;
    ]
]
#endif;

return; end;

"REPLACE {$CHECK-WEIGHTS(#);} WITH {;
"  DO j=npold,np [
"      ;
"      IF( iphat(j) = 1 ) [
"          IF( abs(wt(j)-1) > 0.01 ) [
"              write(25,*) {P1},iphat(j),wt(j);
"              n_weight_warning = n_weight_warning + 1;
"          ]
"      ]
"      ELSE [
"          IF( abs(wt(j)*nbrspl-1) > 0.01 ) [
"              write(25,*) {P1},iphat(j),wt(j);
"              n_weight_warning = n_weight_warning + 1;
"          ]
"      ]
"  ]
"  IF( n_weight_warning > 1000 ) [
"      write(6,*) ' *** too many weight warnings! '; $CALL_EXIT(1);
"  ]
"};

REPLACE {$CHECK-WEIGHTS(#);} WITH {;}

%E     "beamnrc.mortran - start subroutine ausgab                         "
"*******************************************************************************
"
                          SUBROUTINE AUSGAB(IARG);
"                         *****************
"*******************************************************************************
"
"
"     An AUSGAB routine to be used with the radiotherapy accelerator
"     simulation code BEAMnrc.
"
"     This routine:
"        scores fluence and dose
"        writes the phase-space file
"        does latch setting
"        calls watch
"
"     LATCH Setting         There are 3 options:
"
"     LATCH_OPTION = 1:     bits are set in LATCH whenever particle is
"                           in the specified region, but LATCH is NOT inherited
"                           by secondary if created in region being watched.
"
"     LATCH_OPTION = 2:     bit 0 set if brem or annihilation occurs
"                           bits 1 to (28-$LATCH_NUMBER_OF_BITS) set as in
"                           option 1 -i.e. wherever it has beeni but inherited.
"                           rest of bits up to 28 tell which bit_region
"                           created in.
"
"     LATCH_OPTION = 3:     as option 2 but bits only set for regions
"                           where it has interacted.  Note electrons
"                           interact everywhere they are, so 2 vs 3 only
"                           differ regarding photons
"
"     Bit 30 is set if particle is contaminant defined as cross selected plane.
"
"     Fluence scoring:  Outputs the full phase-space of each particle which
"     crosses the scoring planes to units 44,45 and 46. The full phase-space is:
"
"                  (IQ,LATCH,E,X,Y,Z,U,V,W,WT,NPASS).
"
"     When OPEN a file with 'direct access, unformated, fixed record length'
"     The record length for the 7 variables stored in a compressed file is
"     28 bytes.
"     The 7 variables are (LATCH,E,X,Y,U,V,WT)
"     When OPEN a file with 'unformated'
"     The record length for the 7 variables stored in a compressed file is
"     36 bytes.
"
"     Dose scoring:  The user must specify the accelerator geometry as well
"     as the regions which comprise the zones in which the dose is to be scored
"     the geometrical checks for crossing 'geometrical' or 'dose' regions
"     are handled by the subroutine  HOWFAR.  (Adapted from DOSRZ).
;
"     FOR IT = 1      the total dose is scored
"            = 2      the dose less stopped/discarded particles is scored
"            = 3      the dose components are scored with CM CHAMBER
"
"*******************************************************************************
"
$IMPLICIT-NONE;
;COMIN/CMs,EDGE,EPCONT,GEOM,IO_INFO,SCORE,STACK,USEFUL,USER,RANDOM,BREMPR,
MEDIA,MISC,PHOTIN,BOUNDS,RWPHSP,EGS-VARIANCE-REDUCTION,SOURCE,ELECIN,
COMPTON-DATA,EGS-IO/;

$DECLARE-PARTICLE-CONTAINER;

"T>****************************
"T>TYPE DECLARATIONS FOR AUSGAB
"T>****************************
"T>
;INTEGER
   IARG,    "T>argument from EGS (see SLAC-265, section A2.6, p260)
   IPAR,    "T>index for fluence scoring parameter
   IQL,
   LGLE,IBITH30,IBITL30,"T>local variable
   IT,      "T> loop control for score dose
   ISTATUS, "T>used to control the bit filter
   I, II,   "T> loop control indices
   IERR,    "T> needed for BEAMDP1 subroutine
   split_dsb, "T> used for splitting/rotating in dsb
   IRL,     "T>local region number
   lnblnk1, "T>built-in lnblnk function
   IX,IY;   "T>indices for grid scoring"  "Ali:GRID"

$REAL
   FTMP,   "T>total dose with delta transport
   RDIST2, "T>square of distance from z-axis
   WEIGHT, "T>particle weight
   WGHTMA, "T>local variables
   WL,     "T>local direction cosine
   RNNO35,COHFAC,"T> local variables
   ANG_DBS,"T> used in e- splitting in DBS for radially-symmetric redistn"
   ang_dsb,"T> used for particle splitting/rotating for dsb"
   ener,   "T> energy variable used by DBS
   sinthe,costhe,cphi,sphi,rhophi2,yphi2,yphi,xphi2,xphi;
                "above is for annihilation at rest with IBRSPL=2"
$REAL twopi,cos_dsb,sin_dsb,RNDM_BCSE,one;
LOGICAL BTEST;
CHARACTER*8 AUNIT;
CHARACTER*256 phsp_fn; "T> temp. storage for phase space file name
$INTEGER iicm,ip;

$REAL phsp_upper_limit; "T> set to max. no. of particles in phsp file
      "^--- changed to $REAL so one can set it to very large values"
      "     without having to use the -dbl compiler directive to make"
      "     integer*8 the default integer constant -- EMH"
$REAL abrspl,wt_i;
$INTEGER iphat_i;

"this group is only for debugging DBS"
REAL*4 time_array(2),etime;
$INTEGER n_weight_warning;
parameter (one = 1);
data n_weight_warning/0/;
data phsp_upper_limit/$MAX_INT/twopi/6.28318530717958647702561791881237241/;
                      "^--- this controls the max. no. of particles"
                      "     that can be written to a phsp file.  Currently"
                      "     it is set to 2^31-1 (file size up to 64 GBytes)"
                      "     due to the fact that the variable used to write"
                      "     the no. of particles to the header is integer*4."
                      "     If we change this variable to real*4 (4-byte"
                      "     restriction is due to phsp file record length),"
                      "     then this number could be increased but there"
                      "     would be a loss of precision in the no. of"
                      "     particles output to the header."
save n_weight_warning,phsp_upper_limit,twopi;

$INITIALIZE_PHSP_VARIABLES;

"have to do it in 2 steps or else the -1 is lost"
"phsp_upper_limit=2.**32;
"phsp_upper_limit=phsp_upper_limit-1;
"^ Is 2**32-1 or 2**31-1 required ?
"  I thought this is to prevent overflow of 32 bit integers =>
"  must be 2**31-1 (this are signed integers).
"  => changed to the data statement above.  --IK"

"*******************************************************************************
"
"                             STACK OVERFLOW CHECK
"                             ********************

MXNP=MAX(MXNP,NP);"Keep track of how deep stack is -passed in comin score"
IF(NP >  $MXSTACK)[ "Stack as deep as allowed"
    OUTPUT NP,$MXSTACK;
    (' IN AUSGAB, NP=',I3,' >= MAXIMUM STACK ALLOWED=',I3,/1X,79('*')/);
    $CALL_EXIT(1);
]

" Ali:BCSE"
/* MUST be BEFORE the WATCH call so IWATCH output becomes meaningful */

/*
IF(USE_BCSE & IBRSPL < 2)[
   IF(IARG=6)[
      IF(MED(IR(NP))=MED_BCSE)[
         NBRSPL = NBRSPL_ORGNL;
         NBR_SPLIT = NBRSPL;
         ENPOLD_ORGNL = E(NP);
      ]
      ELSE[
         NBRSPL=INT(NBRSPL_ORGNL*BCSE_FACTOR);
         NBR_SPLIT = NBRSPL;
      ]
   ]
   IF(IARG=7 & MED(IR(NP))=MED_BCSE)[
         NBRSPL = INT(NBRSPL_ORGNL*BCSE_FACTOR);
         NBR_SPLIT = NBRSPL;
         $RANDOMSET RNDM_BCSE;
         IF(RNDM_BCSE > 1./BCSE_FACTOR)[E(NPOLD)=ENPOLD_ORGNL;]
         DO I=NPold+1,NP[ WT(I)=WT(I)/BCSE_FACTOR; ]
   ]
]
*/

"IK: modified BCSE"
"Contrary to Ali's approach, we consider NBRSPL to be the maximum amount "
"of splitting. When BCSE is in effect and brems is about to occur, NBRSPL"
"is decreased by bcse_factor and then reset back to its original value   "
"after the brems event => noting to be done in all other cases.          "
IF( use_bcse & ibrspl < 2 ) [
    IF( iarg = 6 & is_bcse_medium(med(ir(np))) ) [
        "Brems about to occur in an enhanced medium "
        abrspl = NBRSPL_ORGNL; abrspl = abrspl/bcse_factor;
        IF( abrspl < 1 ) [
            "$egs_fatal(*,'Brems enhancement factor ',abrspl,"
            "   ' is greater than nbrspl!');"
            $egs_fatal(*,'Brems enhancement factor ',bcse_factor,
               ' is greater than nbrspl ',NBRSPL_ORGNL);
        ]
        nbrspl = abrspl; $RANDOMSET rndm_bcse;
        IF( rndm_bcse < abrspl - nbrspl ) nbrspl = nbrspl + 1;
        nbr_split = nbrspl;
        wt(np) = (wt(np)*nbrspl)/nbrspl_orgnl; enpold_orgnl = e(np);
    ]
    IF( iarg = 7 & is_bcse_medium(med(ir(np))) ) [
        "Brems in an enhanced medium just occured "
        wt(npold) = (wt(npold)*nbrspl_orgnl)/nbrspl;
        nbrspl = nbrspl_orgnl; nbr_split = nbrspl;
        $RANDOMSET rndm_bcse;
        IF( rndm_bcse*bcse_factor > 1 ) e(npold) = enpold_orgnl;
    ]
]


" The following splits eii photons both for UBS & BCSE whether the two       "
" are used individually or in conjunction with each other. Not automatically "
" done in EGS, has to be done by the user.                                   "

IF((IBRSPL=1 | (USE_BCSE & IBRSPL<2)) & IARG=25 & WT(NP)=1.0)[
   NPOLD=NP;
   CALL UNIFORM_PHOTONS_4PI(NBRSPL,E(NP));
]

"Ali: end BCSE alone and BCSE with UBS"

IF(IWATCH >  0) CALL WATCH(IARG,IWATCH); "Signal WATCH routine if active"

"user functions in AUSGAB"
$USER-AUSGAB;

" Check if particle is leaving the transport geometry
" ***************************************************
IRL = IR(NP);  "Local region number"
IF(IRL =  1)[
   IF(IARG ~= 3 & IARG ~=5)[
       "if properly coded we should only get IRL=1 when being discarded"
       "IARG 3 means user has asked for a discard not at a scoring plane"
       "IARG 5 means we are at scoring plane"
       OUTPUT IARG;(//' ********IN AUSGAB:   IRL = 1 with IARG=',I5,/
       'This should not happen'//);
       $CALL_EXIT(1);
   ]
   IF(IARG = 3) [RETURN;] "Outside the geometry, HOWFAR will discard"
   "If IARG = 5, it will return after writinbg phase space"
]

"Ali:REJPLN"
IF(IBRSPL=2 & USE_REJPLN) ["DBS WITH A REJECTION PLANE"
   IF(FLAG_REJPLN=0)["FIRST TIME"
      WRITE(IOUTLIST,901) Z_REJPLN;
901 FORMAT(/'** A rejection plane is being used with DBS **'/
            'Z(cm) from zero reference plane =',F12.2/
      'The following is a list of discarded fat particle data (if any):'/
      'IARG , IQ(NP) , IR(NP) , WT(NP) , Z(NP) , TVSTEP'//);
      FLAG_REJPLN=1;

   ]
   IF (WT(NP)=1 & Z(NP)>=Z_REJPLN & IARG > 5)[
      WRITE(IOUTLIST,902) IARG,IQ(NP),IR(NP),WT(NP),Z(NP),TVSTEP;
902   FORMAT(I3,2X,I3,2X,I3,2X,E10.3,2X,E10.3,2X,E10.3);
      WT(NP)=0;
      FLAG_REJPLN = FLAG_REJPLN+1;
      IF(FLAG_REJPLN>1000)[
         WRITE(IOUTLIST,903);
903      FORMAT('Rejection plane eliminated more than 1000 fat photons. STOP');
         STOP;
      ]
      RETURN;
   ]
]

"*******************************************************************************
"                        cross section enhancement
"*******************************************************************************
IF( use_cs_enhance ) [
    iicm = IR_to_CM(irl);
    IF( cs_enhance(iicm) > 1 ) [
        IF( iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 ) [
                       "Pair/Compton/Photo/Rayleigh about to occur"
            np = np+1; $CHECK-STACK(np,'ausgab(cs_enhance)');
            $TRANSFER PROPERTIES TO (np) FROM (np-1);
            W(NP)=W(NP-1); U(np)=U(np-1); V(np)=V(np-1);
            E(NP)=E(NP-1);IQ(NP)=IQ(NP-1); wt(np) = wt(np)/cs_enhance(iicm);
            return;
        ]
        ELSE IF( iarg = 16 | iarg = 18 | iarg = 20 | iarg = 24 ) [
                       "Pair/Compton/Photo/Rayleigh just occured."
            $RANDOMSET rnno35;
            IF( rnno35*cs_enhance(iicm) > 1 ) [
                "keep the original photon and trow away scattered photons "
                DO ip=npold,np [
                    IF( iq(ip) = 0 ) [ wt(ip) = 0; ]
                ]
            ]
            ELSE [
                "keep the scattered photons and throw away the original photon"
                wt(npold-1) = 0;
                DO ip=npold,np [
                    IF( iq(ip) = 0 ) [ wt(ip) = wt(ip)*cs_enhance(iicm); ]
                ]
            ]
            return;
        ]
    ]
    IF( cse_return(iarg+1) ) return;
]

"*******************************************************************************
"
"                            FLUENCE SCORING                           ""toc:
"                            ***************
"
" Check if particle crossing scoring plane
" ****************************************
" IAUSFL(6)=1 set in WHERE-AM-I when found we are leaving a CM "
" also set to 1 in HOWFAR or WHERE_AM_I routine of ICM_DBS when splitting"
" electrons with directional bremsstrahlung splitting.  In this latter case,"
" the electron has just reached the user-specified splitting plane within the"
" CM."
IF (IARG =  5) ["Particle step just taken"

   IF(ESPLIT_DBS=1)["fat electron has reached splitting plane"
    IF(W(NP)>0)["electron going forward, split it"
     count_esplit=count_esplit+1;
     IF(IWATCH=1|IWATCH=2)[
       OUTPUT NP,E(NP)-PRM,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),
              U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
             (' Electron',T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
       OUTPUT NBRSPL;(' about to be split ',I10, ' times (DBS).');
       IF(IRAD_DBS=1)[
         OUTPUT;
    (' Split electrons will be symmetrically distributed about beam axis.');
       ]
     ]
     WT(NP)=WT(NP)/FLOAT(NBRSPL); "reduce weight of first electron"
     IPHAT(NP)=1;            "signify that it is now non-fat"
     IF(IRAD_DBS=1)["calculate angular increment for radially-symmetric dist"
        ANG_DBS=2.*3.1415926/FLOAT(NBRSPL);
     ]
     IF(IWATCH=1|IWATCH=2)[
        OUTPUT NP,E(NP)-PRM,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),
              U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
             (T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
     ]
     DO I=1,NBRSPL-1[
        NP=NP+1;
        $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
        W(NP)=W(NP-1);E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        IF(IRAD_DBS=1)[
        "have to do rotational transformation of X,Y,U,V"
             X(NP)=X(NP-1)*COS(ANG_DBS)+Y(NP-1)*SIN(ANG_DBS);
             Y(NP)=-X(NP-1)*SIN(ANG_DBS)+Y(NP-1)*COS(ANG_DBS);
             U(NP)=U(NP-1)*COS(ANG_DBS)+V(NP-1)*SIN(ANG_DBS);
             V(NP)=-U(NP-1)*SIN(ANG_DBS)+V(NP-1)*COS(ANG_DBS);
        ]
        ELSE[
             U(NP)=U(NP-1);V(NP)=V(NP-1);
        ]
        IF(IWATCH=1|IWATCH=2)[
           OUTPUT NP,E(NP)-PRM,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),
              U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
             (T36,':',I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
        ]
     ]
    ]
    ESPLIT_DBS=0; "turn off flag for e- splitting"
   ]"end of electron splitting for DBS"

   IF(ICM=ICMNEW)["IAUSFL(6) was set to 1 by SPLIT_E_DBS, not in"
                  "WHERE_AM_I for leaving CM"
     IAUSFL(6)=0;
     RETURN;
   ]

   IF((IDIRG=-1 & W(NP)>0) | (IDIRG=1 & W(NP)<0))[ "particle has scattered"
     "back on reaching the CM boundary--do not score it"
     IAUSFL(6)=0;
     RETURN;
   ]
   IF(IWATCH =  1 |  IWATCH =  2) [
     IF(ICMNEW ~= 0)[
       OUTPUT ICM,ICMNEW;(' PASSING FROM CM',I3,' TO CM',I3);
     ]
     ELSE [
       OUTPUT ICM;(' PASSING FROM CM',I3,' TO OUTSIDE REGION');
     ]
   ]

   "below check is really redundant with DBS stuff above"
   IF (ICM =  ICMNEW) [ "Should never happen, check anyway"
      OUTPUT ICM,IAUSFL(6),IHSTRY; (' *** WARNING *** ICM=ICMNEW=',I2,
      ' when IAUSFL(6)=',I2, ' for history',I10);
      WRITE (IOUTLIST,
         '('' *** WARNING *** ICM=ICMNEW='',I2,'' when IAUSFL(6)='',I2,
           '' for history'',I10)') ICM,IAUSFL(6),IHSTRY;
      GOTO :FLU_SCORE_END:;
   ]

   "   Find which scoring plane we are to use - ICM_to_SCORE is in COMINN  CMS"
   "                                          value is 0 if not a scoring plane"
   IF (W(NP) >  0.) [ISCORE = ICM_to_SCORE(ICM);]  "Index of scoring plane"
   ELSEIF (ICM =  1)  [ISCORE = 0; "going back out of first CM"]
   ELSE [ISCORE = ICM_to_SCORE(ICM-1);"going back - score with previous CM"]

   " No scoring if particle is NOT crossing scoring plane or if scoring plane
   " index exceeds limit.
   IF (ISCORE = 0) GOTO :FLU_SCORE_END:;

   " Particle statistics (number, energy, and angle wrt z-axis)
   " *******************
   IQL = IQ(NP)+2; "Local variable"
   WL = W(NP); "Local direction cosine, may be >1.  If so, set to 1"
   IF (ABS(WL) >  1.) WL=SIGN(one,WL);
   RDIST2 = Y(NP)**2+X(NP)**2;

   NPFLU(ISCORE)=NPFLU(ISCORE)+1;"new variable to keep track of #"
                                 "of particles crossing scoring plane; used"
                                 "to be NPPHSP, but NPPHSP is only incremented"
                                 "if writing phsp files"

   IF(MZONE_TYPE(ISCORE) = 0)["Find index of radial scoring zones"
       DO ISZ=1,NSC_ZONES(ISCORE) [
          IF (RDIST2 <= RSCORE_ZONE2(ISCORE,ISZ)) [GOTO :FOUND-ZONE-INDEX:;]
       ]
   ]
   ELSEIF(MZONE_TYPE(ISCORE) = 1)["Find index of square scoring zones"
       DO ISZ=1,NSC_ZONES(ISCORE) [
          IF( ABS(X(NP)) <= RSCORE_ZONE(ISCORE,ISZ) & ABS(Y(NP)) <=
                RSCORE_ZONE(ISCORE,ISZ)) [GOTO :FOUND-ZONE-INDEX:;]
       ]
   ]
   ELSEIF(MZONE_TYPE(ISCORE) = 2)["find index of zone in grid"  "Ali:GRID"
       DO IX=1,NX_ZONE(ISCORE)[
          IF(RSCORE_ZONE(ISCORE,IX)<=X(NP) & RSCORE_ZONE(ISCORE,IX+1) > X(NP))
                                      EXIT;
       ]
       DO IY=1,NY_ZONE(ISCORE)[
          IF(RSCORE_ZONE2(ISCORE,IY)<=Y(NP) & RSCORE_ZONE2(ISCORE,IY+1) > Y(NP))
                                      EXIT;
       ]
       IF(IX=NX_ZONE(ISCORE)+1 | IY=NY_ZONE(ISCORE)+1)[
          ISZ=NSC_ZONES(ISCORE)+1;
       ]
       ELSE[
          ISZ=IX+(IY-1)*NX_ZONE(ISCORE);
       ]
   ]
   "on exit, if no exit used, ISZ = NSC_ZONES+1, but this is only"
   "possible if particle coming backwards from a CM with a larger value"
   "of RMAX_CM -  hence set up so last value always available"

   ;:FOUND-ZONE-INDEX:;

   "Fill scoring array..."
   IF (ISZ<=NSC_ZONES(ISCORE)+1) ["Particle crosses through scoring zone"
      IF (NPASS(NP,ISCORE)=0) ["1st crossing of scoring plane" IPAR = 0;]
      ELSE ["multiple crossings of scoring plane" IPAR = 4;]
      WEIGHT = WT(NP);
      IF (WEIGHT < 0.0)[OUTPUT WEIGHT,E(NP);
         (' ***error in AUSGAB - weight=',F12.4,' is NEGATIVE for E=',
            F12.4);
      ]

      "scoring for fluence,etc.  Do not use $SCORE macro because this"
      "coding is more compact.  Also, we only have two SCFLU_LAST/zone,"
      "rather than one/quantity scored, which is what $SCORE assumes."
      IF(IPAR=0 & NHSTRY_LAST=SCFLU_LAST(IQL,ISCORE,ISZ,1) |
         IPAR=4 & NHSTRY_LAST=SCFLU_LAST(IQL,ISCORE,ISZ,2))[
         "same as the last primary history that scored with this IQ,ISCORE,"
         "and ISZ"

         "Number:"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)+
                                          WEIGHT; "Number"

         "Fluence:"
         "In case particle at steep angle, avoid huge weight using max"
         "angle of 85 degrees"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)+
                                          WEIGHT/MAX(0.08716,ABS(WL));

         "Energy fluence:"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)+
                                          WEIGHT*(E(NP)-PRM*ABS(IQ(NP)))/
                                          MAX(0.08716,ABS(WL));
         "Angle:"
         "change to degrees on output"
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)=SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)+
                                          WEIGHT*ACOS(WL);
      ]
      ELSE[ "not the same as the last primary history that scored with"
            "this IQ, ISCORE and ISZ--update the scoring arrays and"
            "quantities^2"

         "Energy: also score Energy flu.*flu. now for covariance"
         "analysis later"
         SCFLU(IQL,ISCORE,ISZ,IPAR+3)=SCFLU(IQL,ISCORE,ISZ,IPAR+3) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+3)=SCFLU2(IQL,ISCORE,ISZ,IPAR+3)+
                                       SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)**2;
         SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+1)=SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+1)+
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)*
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2);
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+3)=WEIGHT*(E(NP)-PRM*ABS(IQ(NP)))/
                                          MAX(0.08716,ABS(WL));

         "Angle: also score angle*no. (weighted) now for covariance"
         "analysis later"
         SCFLU(IQL,ISCORE,ISZ,IPAR+4)=SCFLU(IQL,ISCORE,ISZ,IPAR+4) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+4)=SCFLU2(IQL,ISCORE,ISZ,IPAR+4)+
                                       SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)**2;
         SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+2)=SCFLU_COV(IQL,ISCORE,ISZ,IPAR/2+2)+
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)*
                                          SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1);
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+4)=WEIGHT*ACOS(WL);

         "Number: do it here because we used SCFLU_TMP from this for mean"
         "angle above"
         SCFLU(IQL,ISCORE,ISZ,IPAR+1)=SCFLU(IQL,ISCORE,ISZ,IPAR+1) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+1)=SCFLU2(IQL,ISCORE,ISZ,IPAR+1) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)**2;
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+1)=WEIGHT;

         "Fluence: do it here because we use SCFLU_TMP from this for mean"
         "energy above"
         SCFLU(IQL,ISCORE,ISZ,IPAR+2)=SCFLU(IQL,ISCORE,ISZ,IPAR+2) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2);
         SCFLU2(IQL,ISCORE,ISZ,IPAR+2)=SCFLU2(IQL,ISCORE,ISZ,IPAR+2) +
                                      SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)**2;
         SCFLU_TMP(IQL,ISCORE,ISZ,IPAR+2)=WEIGHT/MAX(0.08716,ABS(WL));

         "update SCFLU_LAST"
         IF(IPAR=0)[
           SCFLU_LAST(IQL,ISCORE,ISZ,1)=NHSTRY_LAST;
         ]
         ELSE[
           SCFLU_LAST(IQL,ISCORE,ISZ,2)=NHSTRY_LAST;
         ]
      ]

      "update SCFLU_NUM, no. of particles crossing each scoring zone"
      IF(IPAR=0)[
         SCFLU_NUM(IQL,ISCORE,ISZ,1)=SCFLU_NUM(IQL,ISCORE,ISZ,1)+1;
      ]
      ELSE[
         SCFLU_NUM(IQL,ISCORE,ISZ,2)=SCFLU_NUM(IQL,ISCORE,ISZ,2)+1;
      ]

      "determine if this is > max weight or < min weight"
      IF(WEIGHT<MINWEIGHT)[
             MINWEIGHT=WEIGHT;
      ]
      ELSEIF(WEIGHT>MAXWEIGHT)[
             MAXWEIGHT=WEIGHT;
      ]


   ]

   " Full phase-space scoring
   " ************************

   IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4)[
                                 "phase-space output"
     NPPHSP(ISCORE)=NPPHSP(ISCORE)+1;"increment # of particles in file"
     IF((E(NP)-PRM*ABS(IQ(NP)))>EKMAXPHSP(ISCORE))[
            EKMAXPHSP(ISCORE)=E(NP)-PRM*ABS(IQ(NP));
     ]
     IF(IQ(NP)=-1)[
        IF((E(NP)-PRM)<EKMINPHSPE(ISCORE))[
              EKMINPHSPE(ISCORE)=E(NP)-PRM;
        ]
     ]
     ELSEIF(IQ(NP)=0)[
        NPHOTPHSP(ISCORE)=NPHOTPHSP(ISCORE)+1;
     ]
     IF(PHSP_OUTDIR~=' ')[
      "assume the user wants definition of output directory in the"
      "input file to overwrite that in beamnrc_user_macros.mortran"
       phsp_fn=$cstring(PHSP_OUTDIR) // $file_sep // $cstring(output_file);
     ]
     ELSE[
       phsp_fn=$DIRECTORY-FOR-PHSP // $file_sep // $cstring(output_file);
     ]
     $BEAM_WRITE_PHSP;"this is different when using BEAM as a source"
   ] "end of write phase space option"


    ;$BEAMMODEL_DATA_ANALYSIS;
    "data analysis for beam models - default is null, i.e. ;"

   "Increment NPASS, the number of times this particle or its ancestors have"
   "crossed scoring plane ISCORE"
   NPASS(NP,ISCORE) = NPASS(NP,ISCORE)+1;

   :FLU_SCORE_END:

   " Do the particle splitting if called for by ICM_SPLIT"
   IF(ICM_SPLIT>0)["particle splitting is to be done"
    IF(ICMNEW=ICM_SPLIT & W(NP)>0. & NSPLIT(NP)=0)[
"only split on entering CM from top and if it has not been split before"
     NSPLIT(NP)=NSPLIT(NP)+1;"descendants will not be split again"
     IF(IQ(NP)=0 & NSPLIT_PHOT>1)[
        WT(NP)=WT(NP)/FLOAT(NSPLIT_PHOT);
        IF(IWATCH=1 | IWATCH=2)[
          OUTPUT NSPLIT_PHOT;
 (' SPLITTING PHOTON INTO ',I4,' PHOTONS EACH WITH THE FOLLOWING PROPERTIES:');
          OUTPUT NP,NP+NSPLIT_PHOT-1,E(NP),IQ(NP),IR(NP),X(NP),Y(NP),
                 Z(NP),U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
          (' RESULTING PHOTONS',T29,':',I5,' -',I5,F9.3,2I4,3F8.3,3F7.3,
                                I10,1PE10.3);
        ]
        DO I=1,NSPLIT_PHOT-1[
          NP=NP+1;
          $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
          U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);
          E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        ]
     ]
     "ELSEIF(IQ(NP)=-1 & NSPLIT_ELEC>1)["
        "Why splitting only electrons???  --IK, July 2005"
     ELSEIF(IABS(IQ(NP))=1 & NSPLIT_ELEC>1)[
        WT(NP)=WT(NP)/FLOAT(NSPLIT_ELEC);
        IF(IWATCH=1 | IWATCH=2)[
          OUTPUT NSPLIT_ELEC;
(' SPLITTING ELECTRON INTO ',I4,' ELECTRONS EACH WITH THE',
 ' FOLLOWING PROPERTIES:');
          OUTPUT NP,NP+NSPLIT_ELEC-1,E(NP)-PRM,IQ(NP),IR(NP),
                 X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
          (' RESULTING ELECTRONS',T29,':',I5,' -',I5,F9.3,2I4,3F8.3,3F7.3,
                                        I10,1PE10.3);
        ]
        DO I=1,NSPLIT_ELEC-1[
          NP=NP+1;
          $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
          U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);
          E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        ]
     ]
    ]
   ]

   "directional source biasing done here"
   IF(i_dsb=1 & dsb_delta>0 & icmnew=splitcm_dsb & w(np)>0. & iphat(np)>1 &
     iphat(np)<nbrspl)[
     "split and rotate particle about this plane for dsb"
     WT(NP)=WT(NP)/FLOAT(iphat(np)); "reduce weight of first electron"
     ANG_dsb=twopi/FLOAT(iphat(np));
     cos_dsb = cos(ang_dsb); sin_dsb = sin(ang_dsb);
     split_dsb=iphat(np); "store this because we reset it to 1"
     iphat(np)=1;
     DO I=1,split_dsb-1[
        NP=NP+1;
        $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
        W(NP)=W(NP-1);E(NP)=E(NP-1);IQ(NP)=IQ(NP-1);
        "have to do rotational transformation of X,Y,U,V"
        X(NP)=X(NP-1)*cos_dsb+Y(NP-1)*sin_dsb;
        Y(NP)=-X(NP-1)*sin_dsb+Y(NP-1)*cos_dsb;
        U(NP)=U(NP-1)*cos_dsb+V(NP-1)*sin_dsb;
        V(NP)=-U(NP-1)*sin_dsb+V(NP-1)*cos_dsb;
     ]
   ]

   IF( IQ(NP)=0 & IFORCE=1 )["photon interaction forcing is used"

      IF(((ICMNEW=NFCMIN & W(NP)>0) | (ICMNEW=NFCMAX & W(NP)<0))
        & NP_INC(NP)=0 )[
      "particle is entering CM where it could be forced to interact"

         IF( NFTIME(NP)+1<=NFMAX)[
         "We now test against NFTIME(NP)+1, the projection of what NFTIME(NP)"
         "would be if there was in interaction.  Used to also contain a test"
         "for NFTIME+1>=NFMIN, but the NFMIN option was cut since it is"
         "difficult to implement and the usefulness of being able to"
         "set NFMIN~=1 is questionable.  Thus, NFMIN is now always treated"
         "as 1."

            NFTIME(NP)=NFTIME(NP)+1;
                             "increment the the number of interactions in the"
                             "forcing CMs"
            $RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;
            ;$SELECT-PHOTON-MFP-FOR-FORCING(DPMFP);
            "re-calculate the MFP of this photon"
            "a new photon will be created which carries the remaining weight"
         ]
      ]
   ]
   IAUSFL(6) = 0; "Reset to prevent call to AUSGAB for fluence scoring until"
                  "scoring plane is crossed"
   RETURN; "only for IARG=5 case"
] "End of fluence scoring branch ie IARG=5 block"

"******************************************************************************
"
"         SETTINGS FOR BREMSSTRAHLUNG SPLITTING
"         *************************************
"
"
IF(IBRSPL=1 & IRRLTT=0)["uniform bremsstrahlung splitting without Russ. Roul."
  IF(IARG=6 | IARG=12 | IARG=28)[
"sets nbr_split=1 before bremsstrahlung and annihilation events if this is a"
"secondary charged particle and nbr_split=NBRSPL if this is a primary"
"charged particle--prevents splitting of higher-order bremsstrahlung and"
"annihilation photons"
    IF($BTEST(LATCH(NP),0))[
                 "this is a secondary particle, do not split"
        nbr_split=1;
    ]
    ELSE["Note primary annihilation photons will also be split by NBRSPL"
          "In the case of an incoming e+ beam"
        nbr_split=NBRSPL;
    ]
  ]
]

ELSEIF(IBRSPL=2) ["directional bremsstrahlung splitting"

   IF( iarg > 5 & z(np) > ssd ) [ nbr_split = 1; GOTO :ZLAST_AND_LATCH:; ]


   IF(i_dsb=1 & z(np)<Z_min_CM(splitcm_dsb) & dsb_nbin>1)[do_dsb=1;]
   ELSE[do_dsb=0;]

   IF(iarg = 6 | iarg = 12 | iarg = 28 ) [

       "bremsstrahlung or annihilation about to occur"

       "check below commented out because we can now have non-fat e-"
       "with the e- splitting scheme"
       "IF( iphat(np) ~= 1 ) ["
       "    write(6,*) ' A non-fat charged particle ???'; "
       "    write(6,*) ' position: ',x(np),y(np),z(np);"
       "    write(6,*) ' direction: ',u(np),v(np),w(np);"
       "    write(6,*) ' energy and weight: ',e(np),wt(np);"
       "    $CALL_EXIT(1);"
       "]"

       IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
         "LATCHIN applies to primaries"
         LATCHIN=LATCH(np);
         "prepare LATCHOUT to apply to secondaries"
         IF($BTEST(LATCHIN,30))[IBITH30=1073741824;
                LATCHOUT=LATCHIN-IBITH30;]
         ELSE[IBITH30=0;]
         LATCHOUT = $IBSET(LATCHIN,0);
         "bit 0 is used to mark the photon"
         IF(LATCHIN >= LNOB29)["check whether the parent is a secondary."
             LATCHOUT=LATCHOUT+
                   (IREGION_TO_BIT(IRL)- INT(LATCHOUT/LNOB29))*LNOB29;
         ]
         ELSE["The parent is a primary."
             LATCHOUT =  LATCHOUT+IREGION_TO_BIT(IRL)*LNOB29;
         ]
         LATCHOUT=LATCHOUT+IBITH30;
         LATCH(np)=LATCHOUT; "allows transfering of latch value to secondaries"
                             "during interaction.  Just have to remember to"
                             "reset LATCH of electron after brems"
       ]
       IF(IZLAST=1)ZLAST(np)=Z(np); "will get transferred during interaction"

       nbr_split = NBRSPL;
       IF( iarg = 6 )  [

           IF( iphat(np) > 1 ) [
               "IK: modified BCSE"
               IF( use_bcse & is_bcse_medium(med(ir(np))) ) [
                   " reduce nbrspl by the current BCSE factor          "
                   " which was computed in ELECTR (in $CALCULATE-SIGF) "
                   " depending on the particle energy                  "
                   abrspl = nbrspl_orgnl; abrspl = abrspl/bcse_factor;
                   IF( abrspl < 1 ) [
                       $egs_fatal(*,'Brems enhancement factor ',abrspl,
                         ' is greater than NBRSPL!');
                   ]
                   $RANDOMSET rndm_bcse; nbrspl = abrspl;
                   IF( rndm_bcse < abrspl - nbrspl ) nbrspl = nbrspl + 1;
                   nbr_split = nbrspl;
                   " Remember old energy and weight "
                   enpold_orgnl = e(np); wt_i = wt(np);
                   " Adjust electron weight so that resulting brems photons "
                   " have the proper weight                                 "
                   wt(np) = (wt_i*nbrspl)/nbrspl_orgnl;
               ]
               ELSE [
                   nbrspl = iphat(np); nbr_split = nbrspl;
               ]
               " Remember old fatness and set electron fatness to 1 "
               iphat_i = iphat(np); iphat(np) = 1;
               count_nbrem = count_nbrem + nbrspl;
               IF( ibrdst = 0 ) [ call do_smart_brems; ]
               ELSE [
                   call brems;
                   call kill_the_photons(npold+1,0);
                   count_kill_brem = count_kill_brem + count_kill_tmp;
               ]
               " Set electron fatness to its old value "
               iphat(npold) = iphat_i;
               IF( use_bcse & is_bcse_medium(med(ir(np))) ) [
                   " Reset electron weight to its initial value "
                   wt(npold) = wt_i;
                   " Now decide if we should accept this interaction "
                   $RANDOMSET rndm_bcse;
                   IF( rndm_bcse*bcse_factor > 1 ) [
                       " No. Set electron energy to its initial value and "
                       " kill all fat photons                             "
                       e(npold) = enpold_orgnl;
                       wt_i = 0;
                   ]
                   DO ip=npold+1,np [
                       IF( iphat(ip) > 1 ) [
                           wt(ip) = wt_i; iphat(ip) = iphat_i;
                       ]
                   ]
                   " And finally reset nbrspl back to its maximum value "
                   nbrspl = nbrspl_orgnl; nbr_split = nbrspl;
               ]
           ]
           ELSE [
               " Thin electron -> do single brems but kill photons not going "
               " towards the field "
               count_nbrem = count_nbrem + 1;
               nbr_split=1;
               call brems;
               call kill_the_photons(npold+1,0);
               count_kill_brem = count_kill_brem + count_kill_tmp;
           ]
           $CHECK-WEIGHTS('After brems ');
           "reset LATCH of electron"
           IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(npold)=LATCHIN;
       ]

       ELSE IF( iarg = 12 ) [
           IF( iphat(np) > 1 ) [
               nbr_split = iphat(np); iphat(np) = 1;
               count_nannih = count_nannih + 2*nbr_split;
           ]
           ELSE [
               count_nannih = count_nannih + 2; nbr_split=1;
           ]
           call annih;
           call kill_the_photons(npold,0);
           count_kill_annih = count_kill_annih + count_kill_tmp;
           $CHECK-WEIGHTS('After annih ');
       ]

       ELSE [
           IF(iphat(np) > 1) [
               count_nannih = count_nannih + 2*iphat(np);
               npold = np;
               call uniform_photons(2*iphat(np),rm);
           ]
           ELSE[ "non-fat, do not use uniform_photons for this"
               count_nannih = count_nannih + 2;
               npold = np;
               "Pick random direction for first gamma
               $RANDOMSET costhe; costhe = 2*costhe-1;
               sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
               $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               e(np) = prm; iq(np) = 0;
               $TRANSFER PROPERTIES TO (np) FROM (npold);
               u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
               np = np+1;
               $CHECK-STACK(np,'ANNIH_AT_REST');
               e(np) = prm; iq(np) = 0;
               $TRANSFER PROPERTIES TO (np) FROM (npold);
               u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
               call kill_the_photons(npold,0);
               count_kill_annih = count_kill_annih + count_kill_tmp;
           ]
           $CHECK-WEIGHTS('After annih at rest ');
       ]
       IF(IZLAST=2)[
         DO I=NPold,NP[
           XLAST(I)=X(I);
           YLAST(I)=Y(I);
           ZLAST(I)=Z(I);
         ]
       ]
       " now put a zero weight particle on top of the stack thus forcing "
       " a return to shower. "
       np=np+1;
       $CHECK-STACK(np,'ausgab(after brems or annih)');
       wt(np) = 0; return;
   ]

   IF( iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 ) [

       "Pair/Compton/Photo/Rayleigh about to occur

       /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
       /*               wt(np) = 0; return;                     */
       /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

       IF( iphat(np) < NBRSPL & (ICM_DBS=0 | Z(NP)<=ZRR_DBS) &
           (rhor(ir(np))>=1.2e-2 | do_dsb=1)) [
                                  " non-fat photon which is not in gas"
                                  " and is above RR plane (if electron"
                                  " splitting is on)"
         "IF( iarg ~= 17 | ibcmp(irl) = 0 ) [ "
         IF( (iarg ~= 17 | ibcmp(irl) = 0) & iarg ~= 23 ) [
             "russian roulette it"
             $RANDOMSET rnno35;
             IF( rnno35*nbrspl > iphat(np) ) [ wt(np) = 0; return; ]
             wt(np) = wt(np)*float(nbrspl)/float(iphat(np));
             iphat(np)=nbrspl;
         ]
         "We don't kill the photon before bound compton"
         "because the interaction may get rejected => we get a fat "
         "photon going towards the field."
       ]

       "at this point, the photon is fat, or it is non-fat and about to"
       "interact in gas or is below the RR plane (if e- splitting on)"

      " IF(WT(NP)<1)[
      "   write(*,*)' iphat,wt,iarg ',IPHAT(NP),WT(NP),iarg;
      " ]

       IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
         LATCHOLD=LATCH(np);"retain in case compton rejected"
         "prepare LATCHIN to apply to primaries"
         LATCHIN=LATCH(np);
         IF(LATCH_OPTION=3)
                LATCHIN=$IBSET(LATCHIN,IREGION_TO_BIT(IRL));
         "prepare LATCHOUT to apply to secondaries"
         IF($BTEST(LATCHIN,30))[IBITH30=1073741824;
                LATCHOUT=LATCHIN-IBITH30;]
         ELSE[IBITH30=0;]
         IF(LATCHIN >= LNOB29)["check whether the parent is a secondary."
             LATCHOUT=LATCHOUT+
                   (IREGION_TO_BIT(IRL)- INT(LATCHOUT/LNOB29))*LNOB29;
         ]
         ELSE["The parent is a primary."
             LATCHOUT =  LATCHOUT+IREGION_TO_BIT(IRL)*LNOB29;
         ]
         LATCHOUT=LATCHOUT+IBITH30;
       ]
       IF(IZLAST=1)ZLASTOLD=ZLAST(np);"retain in case compt rejected"

       IF( iarg = 15 | iarg = 19 ) ["pair or photo about to occur"
         IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(np)=LATCHOUT;
             "photon disappears so we can just pass on LATCHOUT"
         IF(IZLAST=1)ZLAST(np)=Z(np); "will get transferred during interaction"
         IF(iphat(np)=nbrspl & ICM_DBS>0 & Z(NP)>ZRR_DBS)[
                                    "split interaction"
           IF(iarg=15)[ count_npair= count_npair+nbrspl; call do_pair;]
           ELSE[ count_nphoto= count_nphoto+nbrspl; call do_photo;]
           IF(IZLAST=2)[
             DO I=NPold,NP[
               ZLAST(I)=Z(I);
               XLAST(I)=X(I);
               YLAST(I)=Y(I);
             ]
           ]
         ]
         ELSE["no splitting, let electr take care of interaction"
           nbr_split = 1; return;
         ]
       ]
       ELSE IF( iarg = 17 ) ["compton about to occur, always split it"
         time_start = etime(time_array);
         IF(iphat(np)=nbrspl)["fat, should be split"
           count_ncomp = count_ncomp + nbrspl;
           IF( ibcmp(ir(np)) = 1 | (ICM_DBS>0 & Z(NP)>ZRR_DBS)) [
              "cannot do smart_compton below RR plane because it produces"
              "a fat electron"
               call do_compton;
               count_kill_comp = count_kill_comp + count_kill_tmp;
           ] ELSE [
               IF(LATCH_OPTION=3)LATCH(np)=LATCHIN;"pass on LATCHIN"
               IF(IZLAST=1)zlast(np)=z(np);
               call do_smart_compton;
               "single e- in npold"
               IF(LATCH_OPTION=2 | LATCH_OPTION=3) LATCH(npold)= LATCHOUT;
               IF(IZLAST=2)[
                 DO I=NPold,NP[
                   ZLAST(I)=Z(I);
                   XLAST(I)=X(I);
                   YLAST(I)=Y(I);
                 ]
               ]
           ]
         ]
         ELSE["non-fat, play Russian Roulette with photon"
           count_ncomp = count_ncomp + 1;
           IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(np)= LATCHOUT;
           "easier to pass on latch of secondaries by transferring"
           IF(IZLAST=1)zlast(np)=z(np);
           call compt;
           IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
             IF(np>npold)[LATCH(npold)=LATCHIN;]
             ELSE[LATCH(npold)=LATCHOLD;]"interaction rejected"
           ]
           IF(IZLAST=1 & np=npold)zlast(npold)=zlastold;"interaction rejected"
           call kill_the_photons(npold,0);
           count_kill_comp = count_kill_comp + count_kill_tmp;
           IF(IZLAST=2)[
              DO I=NPold,NP[
                ZLAST(I)=Z(I);
                XLAST(I)=X(I);
                YLAST(I)=Y(I);
              ]
           ]
         ]
         time_end = etime(time_array);
         time_comp = time_comp + time_end - time_start;
         $CHECK-WEIGHTS('After compton ');
       ]
       ELSE [
           IF(LATCH_OPTION=3) LATCH(np)=LATCHIN;
           IF(IZLAST=1)zlast(np)=z(np);
           IF(iphat(np)=1)["thin photon, just one interaction"
              call do_rayleigh(1);
           ]
           ELSE[
              call do_rayleigh(nbrspl);
           ]
           $CHECK-WEIGHTS('After rayleigh');
           IF(IZLAST=2)[
             DO I=npold,np[
               zlast(I)=z(I);
               xlast(I)=x(I);
               ylast(I)=y(I);
             ]
           ]
       ]
       IF( iarg = 16 ) [ $CHECK-WEIGHTS('After pair '); ]
       IF( iarg = 20 ) [ $CHECK-WEIGHTS('After photo '); ]

       " now put a zero weight particle on top of the stack thus forcing "
       " a return to shower. "
       np=np+1;
       $CHECK-STACK(np,'ausgab(after compton or rayleigh)');
       wt(np) = 0; return;

   ]

   IF( iarg = 25 ) [ "a fluorescent photon has just been put on the stack "
                     "split it"
       IF( iphat(np) = nbrspl ) [
           ener = e(np);
           npold=np;
           call uniform_photons(nbrspl,ener);
           $CHECK-WEIGHTS('After fluorescence ');
       ]
       ELSE["kill the thin photon if it is not aimed into the field"
           call kill_the_photons(np,0);
       ]
       return;
   ]

]
IF(IARG=6) NUM_BREM=NUM_BREM+nbr_split;

"macro below sets prob_RR, the probability that a charged particle will"
"survive Russian Roulette, when seletive bremsstrahlung is on"
:ZLAST_AND_LATCH:;
"******************************************************************************
"
"         LAST INTERACTION SITE SCORING (FOR PHOTONS AND ELECTRONS) ""toc:
"         *********************************************************
"
"The last interaction site is scored as follows: For photons, whenever there
"is an interaction ZLAST is replaced with the Z, for electrons ZLAST is
"identified as the Z of it's creation by photon and this value is passed on to
"any other electron with which the original electron discreetly interacts.

IF(IZLAST = 1)[
  IF(IARG = 7)[ "brems just occurred -- not sure if this dealt with splitting"
                "before"
    DO I=NPold,NP[
      ZLAST(I)=Z(I); "set Z of creation of photon and interaction of e-"
    ]
  ]
  ELSEIF(IARG = 18)["compton just occurred"
    IF(NP > NPold | i_survived_rr > 0)["need this in case interaction rejected"
        DO I=NPold,NP[
          ZLAST(I)=Z(I); "set Z of creation of e- and interaction of phot."
        ]
    ]
  ]
  ELSEIF(IARG = 24)[ "IARG = 24: a coherent interaction has just occurred"
    ZLAST(NP) = Z(NP); " In this case there is one and only one photon"
  ]
  ELSEIF(IARG = 13 | IARG = 14)[
     "IARG = 13: returned to ELECTR after a call to ANNIH
     "IARG = 14: a positron has annihilated at rest
     DO I=NPold,NP[
         ZLAST(I)=Z(I); "set Z of creation of photons"
     ]
  ]
  ELSEIF(IARG = 20)[
  "IARG = 20: returned to PHOTON after a call to PHOTO was made (if NP ~= 0)"
      IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
        DO I=NPold,NP[
            ZLAST(I)=Z(I); "set Z of creation of electrons and interaction of"
                           "photon"
        ]
      ]
  ]
  ELSEIF(IARG = 16)[ "IARG = 16: after a call to PAIR was made"
      DO I=NPold,NP[
           ZLAST(I)=Z(I); "mark Z of creation of e- and e+"
      ]
  ]
]" END IF FOR IZLAST=1"

ELSEIF(IZLAST = 2)["store x and y for display too"
  IF(IARG = 7)[ "brems just occurred -- not sure if this dealt with splitting"
                "before"
    DO I=NPold,NP[
      XLAST(I)=X(I);
      YLAST(I)=Y(I);
      ZLAST(I)=Z(I);
    ]
  ]
  ELSEIF(IARG = 18)["compton just occurred"
    IF(NP > NPold | i_survived_rr > 0)[
        DO I=NPold,NP[
          XLAST(I)=X(I);
          YLAST(I)=Y(I);
          ZLAST(I)=Z(I);
        ]
    ]
  ]
  ELSEIF(IARG = 24)[ "IARG = 24: a coherent interaction has just occurred"
    ZLAST(NP) = Z(NP); " In this case there is one and only one photon"
    YLAST(NP) = Y(NP); XLAST(NP) = X(NP);
  ]
  ELSEIF(IARG = 13 | IARG = 14)[
     "IARG = 13: returned to ELECTR after a call to ANNIH
     "IARG = 14: a positron has annihilated at rest
     DO I=NPold,NP[
         XLAST(I)=X(I);
         YLAST(I)=Y(I);
         ZLAST(I)=Z(I);
     ]
  ]
  ELSEIF(IARG = 20)[
  "IARG = 20: returned to PHOTON after a call to PHOTO was made (if NP ~= 0)"
      IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
        DO I=NPold,NP[
            XLAST(I)=X(I);
            YLAST(I)=Y(I);
            ZLAST(I)=Z(I);
        ]
      ]
  ]
  ELSEIF(IARG = 16)[ "IARG = 16: after a call to PAIR was made"
      DO I=NPold,NP[
           XLAST(I)=X(I);
           YLAST(I)=Y(I);
           ZLAST(I)=Z(I);
      ]
  ]
]" END IF FOR IZLAST = 2"

"*******************************************************************************

"*******************************************************************************
"
"                               LATCH SETTING                          ""toc:
"                               *************
" for detailed implementation see beamnrc documentation:
" BEAMnrc code Technical Notes.

"On each step, if asked, an appropriate bit in latch is"
"set to indicate particle has been in this region"

IF(LATCH_OPTION  < 3 | (LATCH_OPTION  = 3 & IQ(NP) ~= 0) )[
   IF((IARG = 0) & (IREGION_TO_BIT(IRL) ~= 0) ) [
      LATCH(NP) = $IBSET(LATCH(NP),IREGION_TO_BIT(IRL));
   ]
]
"$IBSET is defined in beamnrc_user_macros.mortran"

"If LATCH is not to be inherited, the following arranges this in a restricted"
" sense - if a secondary is created in one of the regions we are watching"
"         then the new latch does not carry the info about the previous value"
IF(LATCH_OPTION  = 1 & IREGION_TO_BIT(IRL) ~= 0)[
   IF(IARG = 7)[      " Brem just taken"
      DO I=NPold+1,NP[ "photons at the top of the stack"
       LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 9)[  " Moller just occurred, secondary is on top of stack"
      LATCH(NP) = $IBSET(0,IREGION_TO_BIT(IRL));
   ]
   ELSEIF(IARG = 11)[ " Bhabha just occurred - positron doesn't inherit"
      IF(IQ(NP) = 1)[ LATCH(NP-1) = $IBSET(0,IREGION_TO_BIT(IRL)); ]
      ELSE[  LATCH(NP) = $IBSET(0,IREGION_TO_BIT(IRL)); ]
   ]
   ELSEIF(IARG = 13 | IARG = 14 )[  " Annih just occurred"
      DO I=NPold,NP[
        LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 16)[ " Pair production just occurred reset both"
      DO I=NPold,NP[
        LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 18)[ " Comp just occurred reset all electrons"
      DO I=NPold+1,NP[ "original photon is NPold"
           LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
      ]
   ]
   ELSEIF(IARG = 20)[ " Photo just occurred--treat all photons as created"
      IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
        DO I=NPold,NP[
           LATCH(I) = $IBSET(0,IREGION_TO_BIT(IRL));
        ]
      ]
   ]
]"end of LATCH_OPTION = 1 block"

"*******************************************************************************
"
"                               LATCH SETTING for LATCH_OPTION 2       ""toc:
"                               *************
"The following is for LATCH_OPTION =2. In this case, both the primaries' LATCH
"values are passed on to the secondaries and the particle origins are recorded.
"we use bits 1 to (28-$LATCH_NUMBER_OF_BITS) for region bit set, bit 0
"is used to record whether a brem is involved in this particle history, and
"bits (29-$LATCH_NUMBER_OF_BITS) - 28 to record the region # where the particle
"is created. This works for 2**($LATCH_NUMBER_OF_BITS) geometrical regions.
"Bits 29-31 are reserved for rw-ph-sp. The number of bits used for particle
"origin can be increased by changing the value of $LATCH_NUMBER_OF_BITS
"in the beginning of this file. For example, if 7 bits are used
"we can have altogether 128 geometrical regions in the simulation geometry.
"Note that for a secondary we record its origin according to where it is created
"no matter its parent is a primary or a secondary.
"Recall bits 1-23 are set above for LATCH(NP) on IARG=0 steps
"Also, recall that in this piece of code LATCH(NP-1)=LATCH(NP) if they
"      are both just created by same parent
"
"Prior to SID 2.31 there was a bug which caused LATCH(0) to be accessed
"for IWATCH on or for Coherent scatter on.  Bug Pointed out by Jeff Chen and
"Joanne Moseley of London Regional Cancer Center.
"

ELSEIF(LATCH_OPTION  = 2 & IARG > 6)[
  " LNOB29 = 2**(29-$LATCH_NUMBER_OF_BITS). We use this constant to shift"
  " IREGION_TO_BIT(IRL) by (29-$LATCH_NUMBER_OF_BITS) bits in order to   "
  "record it using bits from (28-$LATCH_NUMBER_OF_BITS) to 28.           "

"Define some macros for saving bit 30 for contaminant dose calculations"
"       Note 1073741824=2**30
REPLACE {$SAVE_LATCH_BIT30NP;} WITH {
  ;IF($BTEST(LATCH(NP),30))[IBITH30=1073741824; LATCH(NP)=LATCH(NP)-IBITH30;]
  ELSE[IBITH30=0;]
}
REPLACE {$SAVE_LATCH_BIT30NP-1;} WITH {
  ;IF($BTEST(LATCH(NP-1),30))[
     IBITL30=1073741824; LATCH(NP-1)=LATCH(NP-1)-IBITL30;
  ]
  ELSE[IBITL30=0;]
}
REPLACE {$SAVE_LATCH_BIT30I;} WITH {
  ;IF($BTEST(LATCH(I),30))[IBITH30=1073741824; LATCH(I)=LATCH(I)-IBITH30;]
  ELSE[IBITH30=0;]
}
REPLACE {$RESTORE_LATCH_BIT30NP;} WITH {LATCH(NP)=LATCH(NP)+IBITH30;}
REPLACE {$RESTORE_LATCH_BIT30NP-1;} WITH {LATCH(NP-1)=LATCH(NP-1)+IBITL30;}
REPLACE {$RESTORE_LATCH_BIT30I;} WITH {LATCH(I)=LATCH(I)+IBITH30;}


  "Moller is the most probable interaction, check it first"
  ;IF(IARG = 9)[ " Moller just occurred, secondary is on top of stack"
    $SAVE_LATCH_BIT30NP;
    IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. At "
      "this stage the resultant particle has the same LATCH as the parent."
      LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-
                  INT(LATCH(NP)/LNOB29))*LNOB29;
    ]
    ELSE["the parent is a primary"
      LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
    ]
  $RESTORE_LATCH_BIT30NP;
  ]

  ELSEIF(IARG = 18)[ " Comp just occurred, record the electron"
    DO I=NPold+1,NP[
      $SAVE_LATCH_BIT30I;
      IF(LATCH(I) >= LNOB29)["check whether the parent photon is a secondary. "
         LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                       INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["photon is a primary"
         LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ]"end of Compton block"

  ELSEIF(IARG = 7)[ " Brem just occurred, record the photon origin"
    DO I=NPold,NP["photons start at NPold+1"
     IF(IQ(I)=0)[
      $SAVE_LATCH_BIT30I;
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the brem photon"
      IF(LATCH(I) >= LNOB29)["check whether the parent e- is a secondary. "
        LATCH(I) =LATCH(I)+(IREGION_TO_BIT(IRL)-
        INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
     ]
    ]
  ]"end of bremsstrahlung block"

  ELSEIF(IARG = 16)[ " Pair production just occurred, record both"
    "at this stage both particle have the same LATCH.               "
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I; IBITL30 = IBITH30;
      IF(LATCH(I) >= LNOB29)["check whether the parent photon is a secondary. "
        LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)- INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
        LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ]"end of pair block"

  ELSEIF(IARG = 11)[ " Bhabha just occurred - record the electron"
    IF(IQ(NP) = 1)[ "positron on top"
      $SAVE_LATCH_BIT30NP-1;
      IF(LATCH(NP-1) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP-1) = LATCH(NP-1)+(IREGION_TO_BIT(IRL)-
        INT(LATCH(NP-1)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP-1) = LATCH(NP-1)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
    $RESTORE_LATCH_BIT30NP-1;
    ]"end positron on top"
    ELSE[ "electron on top, record the region number using LATCH"
      $SAVE_LATCH_BIT30NP;
      IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-
                    INT(LATCH(NP)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
    $RESTORE_LATCH_BIT30NP;
    ]"end electron on top"
  ]

  ELSEIF(IARG = 13 | IARG = 14 )[  " Annih just occurred -record both."
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I;
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the photon"
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
        "At this stage both particle have the same LATCH.               "
        LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)- INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
        LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ] "End of Annih"

  ELSEIF(IARG = 20)[ " Photo just occurred"
    IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
      DO I=NPold,NP[
        $SAVE_LATCH_BIT30I;
        IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
           LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                      INT(LATCH(I)/LNOB29))*LNOB29;
        ]
        ELSE["the parent is a primary"
           LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
        ]
        $RESTORE_LATCH_BIT30I;
      ]
    ]
  ] "End of photo"

]         "End of LATCH option = 2,   "
"
"*******************************************************************************
"
"                               LATCH SETTING  LATCH_OPTION=3          ""toc:
"                               *************
"The following is for LATCH_OPTION =3. In this case, both the primaries' LATCH
"values are passed on to the secondaries and the particle origins are recorded.
"we use bits 1 to (28-$LATCH_NUMBER_OF_BITS) for region bit set, bit 0
"is used to record whether a photon is involved in this particle history, and
"bits (29-$LATCH_NUMBER_OF_BITS) - 28 to record the region # where the particle
"is created. This works for 2**($LATCH_NUMBER_OF_BITS) geometrical regions.
"Bits 29-31 are reserved for rw-phsp. The number of bits used for particle
"origin can be increased by changing the value of $LATCH_NUMBER_OF_BITS
"in the beginning of this file. For example, if 7 bits are used
"we can have altogether 128 geometrical regions in the simulation geometry.
"Note that for a secondary we record its origin according to where it is created
"no matter its parent is a primary or a secondary.
"
"The difference between LATCH_OPTION =3 and LATCH_OPTION =2 is that
"for LATCH_OPTION =3 the region number, where a photon has interacted, is
"recorded rather than where it has passed through. This option is considered
"to be more appropriate for BEAMnrc than option 2. However, there are some
"problems with this option. As primaries' LATCH values are passed on to the
"secondaries, one can find region numbers in a photon history which do not
"correspond to photon interactions but to electron paths of their parents.
"
"For LATCH_OPTION =3 we set bits in LATCH here if there is an interaction.
"    whereas for LATCH_OPTION =2 it is done near the start of AUSGAB.
"
"
"Jan 26, 1996 - a fairly significant bug was fixed. It had two parts.
"  1) For a compton photon, if IREGIO_TO_BIT(IRL) was not set, then
"     BIT 0 in LATCH was set => it was a bremsstrahlung photon.
"       HOWEVER, since we default any non-set regions to region 23,
"                this was a non-problem.
"  2) For pair events,coherent events, photo-electric events, the bits
"     were not set when the secondaries were created. If they were
"     created below ECUT or PCUT, they were discarded without the region
"     bit set - this could muck up the dose scoring by component.
"     MORE importantly, for e+, which then annihilate, there were 511
"     photons created which had no bits set, although the region of origin
"     was properly set.
"     For Compton, electron had its bit set prior to this change.
"
"     To be explicit, both electrons and photons carry the current bit
"     set, immediately after creation - either because the parent had
"     it set (for charged particle parents) or because we set it here.

"
"Feb 6, 1996 - also noted that for fluorescent x-ray, had been saving"
"     BIT30NP instead of BIT30NP-1 so contaminant dose scoring would"
"     have been missing this component if initial photon was a secondary"
"
ELSEIF(LATCH_OPTION  = 3 & IARG > 6)[

  " LNOB29 = 2**(29-$LATCH_NUMBER_OF_BITS). We use this constant to shift"
  " IREGION_TO_BIT(IRL) by (29-$LATCH_NUMBER_OF_BITS) bits in order to   "
  "record it using bits from (28-$LATCH_NUMBER_OF_BITS) to 28.           "

  "Moller is the most probable interaction, check it first"
  IF(IARG = 9)[ " Moller just occurred, secondary is on top of stack"
    $SAVE_LATCH_BIT30NP;
    IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. At "
      "this stage the resultant particle has the same LATCH as the parent."
      LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-INT(LATCH(NP)/LNOB29))*LNOB29;
    ]
    ELSE["the parent is a primary"
      LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
    ]
    $RESTORE_LATCH_BIT30NP;
  ]

  ELSEIF(IARG = 18)[ " Comp just occurred, record the electron"
    DO I=NPold+1,NP["secondary e- and relaxation products"
        LATCH(I)= $IBSET(LATCH(I),IREGION_TO_BIT(IRL)); "set where created"
                                                        "also for fluor. phot"
        $SAVE_LATCH_BIT30I;
        IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
            LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                       INT(LATCH(I)/LNOB29))*LNOB29;
        ]
        ELSE["the parent is a primary"
           LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
        ]
        $RESTORE_LATCH_BIT30I;
    ]"taken care of secondaries"
    IF(NP>NPold | i_survived_rr > 0)[ "interaction took place set region"
                                      "where primary interacted"
        LATCH(NPold)=$IBSET(LATCH(NPold),IREGION_TO_BIT(IRL));
    ]
  ]

  ELSEIF(IARG = 7)[ " Brem just occurred, record the photon origin"
    DO I=NPold,NP[ "photons start at NPold+1"
     IF(IQ(I)=0)[
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the brem photon"
      $SAVE_LATCH_BIT30I;
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(I) =LATCH(I)+(IREGION_TO_BIT(IRL)-
                   INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
     ]
    ]
  ]

  ELSEIF(IARG = 16)[ " Pair production just occurred, record both"
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I;
      LATCH(I)=$IBSET(LATCH(I),IREGION_TO_BIT(IRL)); "set where created"
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
      "at this stage both particle have the same LATCH.               "
         LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)-INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
         LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ]

  ELSEIF(IARG = 11)[ " Bhabha just occurred - record the electron"
    IF(IQ(NP) = 1)[ "positron on top"
      $SAVE_LATCH_BIT30NP-1;
      IF(LATCH(NP-1) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP-1) = LATCH(NP-1)+(IREGION_TO_BIT(IRL)-
                      INT(LATCH(NP-1)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP-1) = LATCH(NP-1)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30NP-1;
    ]
    ELSE[ "electron on top, record the region number using LATCH"
      $SAVE_LATCH_BIT30NP;
      IF(LATCH(NP) >= LNOB29)["check whether the parent is a secondary. "
        LATCH(NP) = LATCH(NP)+(IREGION_TO_BIT(IRL)-
                    INT(LATCH(NP)/LNOB29))*LNOB29;
      ]
      ELSE["the parent is a primary"
        LATCH(NP) = LATCH(NP)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30NP;
    ]
  ]
  ELSEIF(IARG = 24)[ " Coherent scattering just occurred, record the photon"
    IF(IQ(NP) = 0)[ "the particle is a photon"
       LATCH(NP)=$IBSET(LATCH(NP),IREGION_TO_BIT(IRL));
    ]
    ELSE[ "the particle is not a photon. This must be wrong."
        OUTPUT;(/// ' ***IN AUSGAB****'/
        ' Something is wrong, IQ(NP) should be = 0 for photons!!!'///);
        $CALL_EXIT(1);
    ]
  ] "end of coherent interaction"

  ELSEIF(IARG = 20)[ " Photo just occurred"
    IF(NP>NPold | i_survived_rr > 0 | IQ(NPold)=-1)[
      DO I=NPold,NP[
        $SAVE_LATCH_BIT30I;
        IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
          LATCH(I) = LATCH(I)+(IREGION_TO_BIT(IRL)-
                    INT(LATCH(I)/LNOB29))*LNOB29;
        ]
        ELSE["the parent is a primary"
          LATCH(I) = LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
        ]
        LATCH(I)=$IBSET(LATCH(I),IREGION_TO_BIT(IRL));"set bit to creation"
                                                      "of e- and any phot."
        $RESTORE_LATCH_BIT30I;
      ]
    ]
  ] "End of photo"

  ELSEIF(IARG = 13 | IARG = 14 )[  " Annih just occurred -record both."
    DO I=NPold,NP[
      $SAVE_LATCH_BIT30I;
      LATCH(I) = $IBSET(LATCH(I),0);
      "bit 0 is used to mark the photon"
      IF(LATCH(I) >= LNOB29)["check whether the parent is a secondary. "
      "At this stage both particle have the same LATCH.               "
        LATCH(I)=LATCH(I)+(IREGION_TO_BIT(IRL)-INT(LATCH(I)/LNOB29))*LNOB29;
      ]
      ELSE["The parent is a primary."
        LATCH(I) =  LATCH(I)+IREGION_TO_BIT(IRL)*LNOB29;
      ]
      $RESTORE_LATCH_BIT30I;
    ]
  ] "End of Annih"
]         "End of LATCH option = 3,   "


"*******************************************************************************

"*******************************************************************************
"
"                                DOSE SCORING                          ""toc:
"                                ************
"
" Obtain frequently used local variables
" **************************************
ID=DOSE_ZONE(IRL);    "Dose scoring zone for this region"

IF(IARG =  0)["About to transport a particle"
    IF(IQ(NP) ~= 0)[
        $SCORE(SCSTP, :1); "count total steps taken"
        IF(ID  ~=  0)[$SCORE(SCDSTP, :1);"Count total steps in dose regions"]
    ]
] "END TEST FOR IARG = 0"

" Do some basic checks to see if scoring is needed
" ************************************************
IF((IARG >= 5) |  (EDEP =  0.0))RETURN;

" Score total energy deposited
" ****************************

FTMP=WT(NP)*EDEP;

IF(ID  ~=  0)[ "In a dose scoring region"

    "Score total energy deposited"
    $SCORE(SCDOSE,(ID,1):FTMP);

    IF(IBRSPL=2 & IPHAT(NP)=1)["score non-fat total dose for DBS"
       $SCORE(SCDOSE,(ID,2):FTMP); "unused dose component otherwise"
    ]

    "Here if itdose_on=1, score dose components filtered by latch bits"
    "L_N_EXC(): score the energy deposited  less the latch  bit       "
    " setting  specified by L_N_EXC().                              "
    "L_N_INC(): score the energy deposited only by particles with bit "
    "setting  specified by L_N_INC().                               "

     IF(ITDOSE_ON=1 )["contaminant dose and latch filters considered)
        " here it=3 reserved for the photon or electron contamination"
        " in where am i routine, set the bit 30 to specify the particle"
       IF( $BTEST(LATCH(NP),30) ) [
           " IT=3 reserved for contaminant dose"
           $SCORE(SCDOSE,(ID,3):FTMP);
       ]
       IF( LNEXC+LNINC > 0 ) ["i.e. there is some bit filtering to do"
           DO IT=4, 3+LNEXC[ "  any bit set specified by L_N_EXC(IT, I)
                             "  will be excluded, i.e., not scored
               ISTATUS=1;
               DO I=1, 31 [
                   IF( L_N_EXC(IT, I)=0 )[ EXIT; ]
                   ELSEIF($BTEST(LATCH(NP),L_N_EXC(IT, I)))[ISTATUS=0;]
               ]
               IF(I=1)[ ISTATUS=0;]
               IF( ISTATUS=1 )[
                   $SCORE(SCDOSE,(ID,IT):FTMP);
               ]
           ]
           DO IT=4+LNEXC, 3+LNEXC+LNINC [
               " (any one of the bits specified by L_N_INC(IT, I)
               " is set )  &   ( all of the bits specified by
               " L_N_INC(IT, II)  are not set ), then score.
               " L_N_INC(IT, I) and L_N_INC(IT, II) are separated
               " by a 0
               ISTATUS=0;
               DO I=1, 31 [
                   IF( L_N_INC(IT, I)=0 )[ EXIT; ]
                   ELSEIF($BTEST(LATCH(NP),L_N_INC(IT, I)))[ ISTATUS=1;]
               ]
               IF(I=1)[ ISTATUS=0;]
               DO II=I+1, 31 [
                   IF( L_N_INC(IT, II)=0 )[ EXIT; ]
                   ELSEIF($BTEST(LATCH(NP),L_N_INC(IT, II)))[ ISTATUS=0;]
               ]
               IF( ISTATUS=1 )[ $SCORE(SCDOSE,(ID,IT):FTMP); ]
           ]
       ]"end of bit filtering routine"
    ]"end of ITDOSE_ON set"
    IF((IWATCH >  1)  &  (IWATCH ~= 4))[
        OUTPUT FTMP,IRL,IARG;
        (' ***TOTAL DOSE WITH DELTA TRANSPORT = ',E14.7,' MeV. IRL= ',I3,
        ' IARG= ',I3);
    ]
]

IF(IAUSFL(6)=1)[
   IF(IARG=1 | IARG=2 | IARG=3)["We reset the flag"
       IAUSFL(6)=0;
       "if this flag is not re-set, the next particle on stack may"
       "be scored even it's not crossing a scoring plane BECAUSE if "
       "USTEP<DNEAR IAUSFL(6) won't be re-set in HOWFAR for the particle "
       ESPLIT_DBS=0; "also reset this in case the reason IAUSFL(6) is set"
                     "to one is because we were going to do e- splitting"
                     "Cancels e- splitting in case transport cut off"
                     "due to E<AE or E<ECUT or range rejection"
   ]
   ELSEIF(ICM = ICMNEW & ESPLIT_DBS=0)[
       "this is not necessary anymore. Bugs related to this removed"
       IAUSFL(6) = 0;
       OUTPUT;
       (/' IN AUSGAB, IAUSFL(6) is re-set to 0. This should not happen!'/
        ' Track down why we are getting this!'/);
       OUTPUT X(NP),Y(NP),Z(NP),W(NP),IR(NP),ICM,IHSTRY;
       (' X(NP),Y(NP),Z(NP),W(NP),IR(NP),ICM,IHSTRY= ',4F12.4,3I8);
   ]
]

RETURN;
END;  "End of subroutine AUSGAB"
%E     "beamnrc.mortran - start subroutine ENSRC                          "
"************************************************************************
"
"    These routines handle sampling from an energy spectrum as
"     per standard NRC routine ensrc.mortran
"
"************************************************************************
SUBROUTINE EN_SAMPLE(ENIN);

$IMPLICIT-NONE;
;COMIN/ENERGYSRC,RANDOM,SOURCE,EGS-IO/;

INTEGER K;
$REAL ENIN; "energy as sampled from energy distribution"

"THIS  DOES THE ACTUAL SAMPLING OF THE INCIDENT ENERGY"
"THIS WILL  RETURN A HISTOGRAM OF VALUES"
:RETRY:;
$RANDOMSET RNNO1;      $RANDOMSET RNNO2;
DO K=1,NENSRC[
   RNNO1=RNNO1-SRCCDF(K);
   IF(RNNO1<=0) EXIT;
]
ENIN = CDFINV(K,1) + RNNO2*CDFINV(K,2);
IF(ENIN < ENMIN)[
   IF(ENIN < 0.9999*ENMIN)[
       OUTPUT;(//' ***WARNING IN ENERGY SAMPLING ROUTINE:'/
                 ' Sampled energy < ENMIN'//);
   ]
   GOTO :RETRY:;
]
IF(ENIN > ENSRCD(NENSRC))[
   IF(ENIN > 1.0001*ENSRCD(NENSRC))[
       OUTPUT;(//' ***WARNING IN ENERGY SAMPLING ROUTINE:'/
                 ' Sampled energy > max. energy'//);
   ]
   GOTO :RETRY:;
]
RETURN;
END;

SUBROUTINE EN_INITIALIZE;

$IMPLICIT-NONE;
;COMIN/ENERGYSRC,SCORE,SOURCE,EGS-IO/;

INTEGER KMAX, "stores index of bin with max. probability"
        I,K; "indices"
$REAL    FMAX, "stores max. normalized probability"
        TEMP, "used in re-ordering bins"
        FNORM; "used to calculate normalization"

"This initialization routine is based on a sampling routine by Iwan"
"Kawrakow.  The previous initialization routine allowed sampling of"
"energies beyond the maximum energy and also sometimes failed to sample"
"from bins with small probabilities"
"SRCCDF($INVDIM) used to store the cumulative probability distribution"
"but now simply stores the normalized PDF re-ordered so that bins with"
"the highest probability come first"

IF(ENMIN >= ENSRCD(1))[
    OUTPUT;(//' ***ERROR IN ENERGY SPECTRUM:'/
              ' Lower energy of 1st bin >= upper energy of 1st bin.'//);
    $CALL_EXIT(1);
]

"now normalize the distribution and for each energy bin determine the"
"lower energy of the bin and the width of the bin"
FNORM=0;
DO IB=1,NENSRC[ FNORM = FNORM + SRCPDF(IB);]
DO IB=1,NENSRC[
    SRCCDF(IB)=SRCPDF(IB)/FNORM;
    IF(IB>1)[
      CDFINV(IB,1)=ENSRCD(IB-1);
    ]
    ELSE[
      CDFINV(IB,1)=ENMIN;
    ]
    CDFINV(IB,2)=ENSRCD(IB)-CDFINV(IB,1);
]

"re-order the bins to put bins with max. probability first"

DO I=1,NENSRC-1[
   FMAX=SRCCDF(I);KMAX=I;
   DO K=I+1,NENSRC[
     IF(SRCCDF(K) > FMAX)[
        FMAX=SRCCDF(K); KMAX=K;
     ]
   ]
   K=KMAX;
   TEMP=SRCCDF(K); SRCCDF(K)=SRCCDF(I); SRCCDF(I)=TEMP;
   TEMP=CDFINV(K,1); CDFINV(K,1)=CDFINV(I,1); CDFINV(I,1)=TEMP;
   TEMP=CDFINV(K,2); CDFINV(K,2)=CDFINV(I,2); CDFINV(I,2)=TEMP;
]"END LOOP OVER I"

"OUTPUT IF IWATCH IS ACTIVE"
IF(IWATCH ~= 0)[
  OUTPUT SPEC_TITLE;(1x,80A1);
  OUTPUT;(/' ENSRCD,   SRCPDF:'//);
  OUTPUT (ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);(2E17.7);
  OUTPUT;(//);
]
RETURN;
END;   "end of subroutine ensrc
%E     "beamnrc.mortran - start subroutine howfar                         "
"*******************************************************************************
"
                          SUBROUTINE HOWFAR;
"                         *****************
"*******************************************************************************
"
"     HOWFAR routine for BEAMnrc.
"
"     ASSUMES arrays IR_to_CM_forward and IR_to_CM_back  and NREG have
"     been initialized.
"
"     ROUTINES CALLED:
"
"     This routine just determines which CM to call and
"     otherwise just passes everything through to the HOWFAR_CM routines
"
"
"*******************************************************************************
"
"                             LOCAL REPLACEMENT MACROS
"                             ************************
;
" MACRO's to expands the call into a series of labelled
" calls to the individual CM's HOWFARS. The last CM ends up being the statement
" immediately after the original statement> Note the order is critical.

REPLACE {;$CALL_HOWFAR;} WITH {
       {REDUCE ;CALL HOWFAR__$CM_LIST;} :CM_CALL_DONE: CONTINUE;
}
;REPLACE {;CALL HOWFAR__CMLIST(#);} WITH {;:HOWFAR_{P1}:  ;CALL HOWFAR_{P1};}
;REPLACE {;CALL HOWFAR__CMLIST(#,#);} WITH {
       ;CALL HOWFAR__CMLIST({P2});
       GOTO :CM_CALL_DONE:;
:HOWFAR_{P1}:  ;CALL HOWFAR_{P1};
}
"*******************************************************************************
"
"                       TYPE DECLARATIONS AND COMMON BLOCKS
"                       ***********************************
$IMPLICIT-NONE;
;COMIN/CMs,GEOM,SCORE,STACK,EPCONT,USER,EGS-IO/;
"T>****************************
"T>TYPE DECLARATIONS FOR HOWFAR
"T>****************************
"T>
$REAL
   A,    "T>direction sine wrt z-axis
   B,    "T>X*U+Y*V;B2=B*B
   B2,   "T>square of B
   C,    "T>square of radial position
   COUT, "T>square of radial position less square of cylinder radius (<=0)
   TCYL, "T>distance to outer cylinder along particle trajectory
   XF,   "T> X coordinate after ustep
   YF;   "T> Y coordinate after ustep

" Discard if in region 1 (vacuum region which surrounds geometry)
" **********************
IF(IR(NP) > 1 & IR(NP) <= NREG) [ ICM = IR_to_CM(IR(NP)); ]
ELSE ["region is out of geometry" IDISC = 1; RETURN; ]

" Call HOWFAR for current component module
" ****************************************
ICMNEW = ICM; "ICMNEW is changed in WHERE_AM_I when particle reaches boundary of
              "component module as established in HOWFAR_$CMNAME.
IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring after particle transport.
               "This flag is set to 1 in WHERE_AM_I to request a call to AUSGAB
               "after particle transport for the purpose of scoring fluence on
               "the scoring plane between component modules.  The flag is reset
               "here to avoid the situation where no call is made to AUSGAB
               "after the particle transport, such as with a negative USTEP in
               "subroutine ELECTR, resulting in an AUSGAB call after the next
               "particle step when the particle is not crossing a scoring plane.
ESPLIT_DBS=0;  "set to 0 to avoid splitting e- (DBS) when splitting plane is at"
               "the bottom of a CM, and e- reaches the splitting plane by"
               "travelling backwards (W<0) to it but then changes direction"
               "(W>0) as soon as it hits the splitting plane.  In this case,"
               "the e- never really entered the splitting CM, so we do not want"
               " to split"

;$GOTO_CM_LIST(HOWFAR) ICM;
;$CALL_HOWFAR;    "expands to call specific HOWFAR_CM routines for each CM

" Check for particle crossing outer boundary, radius or 1/2 square RMAX_CM(ICM)
" *****************************************************************************
"
" set IRNEW and ICMNEW if particle will pass out of the side of  geometry
" while still in this CM.
"
" calculate x and y position at end of step.
XF = ABS(X(NP) + USTEP * U(NP));
YF = ABS(Y(NP) + USTEP * V(NP));

IF(RMAX_CM_FLAG(ICM) = 1) [" cylindrical boundary about CM"
   C = X(NP)**2 + Y(NP)**2; "radial position at START of step"
   IF( C > RMAX_CM2(ICM) ) [ " particle already out
      IRNEW = 1; "set region into 1"
      ICMNEW = 0; "set CM into 0"
      IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.  This
           "flag may have been set to 1 in WHERE_AM_I, but boundary
           "of cylinder, which particle is now known to cross, is
           "not a scoring plane.
      USTEP =  0.0;
      ESPLIT_DBS = 0;
   ]
   ELSEIF( (XF**2 + YF**2) > RMAX_CM2(ICM) ) [" particle will pass the boundary
      A = U(NP)*U(NP)+V(NP)*V(NP);
      "In principle, we must be inside CM still since USTEP reduced in
      "HOWFAR_CM, but we are cautious in case of roundoff.
      "If particle is going out, we reduce USTEP etc so energy deposition
      "etc will be correct out to the boundary.
      IF(A > 0.0 & (RMAX_CM(ICM)-SQRT(C))/SQRT(A) < USTEP) [
         "boundary may be crossed
         COUT = C - RMAX_CM2(ICM);
         IF(COUT > 0.0)[ "COUT should be negative or zero
            IF(IWATCH > 0)[OUTPUT COUT;(' COUT=',E11.3);]
            COUT=0.0;
         ]
         B = X(NP)*U(NP)+Y(NP)*V(NP);
         B2 = B**2;
         IF(B > 0.0)[
            IF(COUT/B2 > -1.0E-3)[TCYL=-0.5*COUT/B;]
            ELSE[TCYL=-COUT/(SQRT(B2-A*COUT)+B);]
         ]
         ELSEIF(B < 0.0)[
            IF(COUT/B2 > -1.0E-3)[TCYL = -2.*B/A*(1.-0.25*A*COUT/B2);]
            ELSE[TCYL = (SQRT(B2-A*COUT)-B)/A;]
         ]
         ELSE[ TCYL=SQRT(-COUT/A); ]
         IF (USTEP > TCYL) [ "check if particle reaches boundary
            USTEP = TCYL; "adjust USTEP
            IRNEW = 1; "particle passing out of geometry into region 1"
            ICMNEW = 0; "particle passing out of geometry into CM 0"
            IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.
            ESPLIT_DBS=0;
         ]
      ]
   ]"end of particle will pass the boundary block"
]"end of check for cylindrical outer boundary

ELSEIF (RMAX_CM_FLAG(ICM) = 2) ["request check of square boundary about CM
   IF(ABS(X(NP)) > RMAX_CM(ICM) | ABS(Y(NP)) > RMAX_CM(ICM) )[
      " particle already outside the boundary at start of step"
      IRNEW = 1; "set region = 1"
      ICMNEW = 0; "set CM = 0"
      IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.  This
                     "flag may have been set to 1 in WHERE_AM_I, but boundary
                     "of cylinder, which particle is now known to cross, is
                     "not a scoring plane.
      USTEP =  0.0; "
      ESPLIT_DBS=0;
   ]
   ELSEIF((XF > RMAX_CM(ICM)) | (YF > RMAX_CM(ICM)) )[
      " particle will pass the boundary"
      A=1.E20;B=1.E20;
      IF (U(NP) > 0)    ["X-boundary  pos" A = (RMAX_CM(ICM)-X(NP))/U(NP);]
      ELSEIF(U(NP) < 0) ["X-boundary  neg" A = (-RMAX_CM(ICM)-X(NP))/U(NP);]

      IF (V(NP) > 0)     ["Y-boundary pos" B = (RMAX_CM(ICM)-Y(NP))/V(NP);]
      ELSEIF (V(NP) < 0) ["Y-boundary neg" B = (-RMAX_CM(ICM)-Y(NP))/V(NP);]
      C = MIN(A,B);
      IF(C < USTEP) [ "boundary to be crossed
         USTEP = C; "adjust USTEP
         IRNEW = 1; "particle passing out of geometry into region 1"
         ICMNEW = 0; "particle passing out of geometry into CM 0"
         IAUSFL(6) = 0; "No call to AUSGAB for fluence scoring flag.  This
         ESPLIT_DBS=0;
      ]
   ]"end of particle will pass the boundary block"
]"end of check for square boundary"
RETURN;
END; "End of subroutine HOWFAR
%E     "beamnrc.mortran - start subroutine inputs                         "
"*******************************************************************************
"
                          SUBROUTINE INPUTS;
"                         *****************
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;
;COMIN/BREMPR,EDGE,CMs,ELECIN,GEOM,IO_INFO,MEDIA,MISC,SCORE,
      SOURCE,USEFUL,RANDOM,USER, STACK,EPCONT,ENERGYSRC,BOUNDS,
      EGS-VARIANCE-REDUCTION,ET-Control,EGS-IO,GetInput,RWPHSP/;

"T>****************************
"T>TYPE DECLARATIONS FOR INPUTS
"T>****************************
"T>
INTEGER
   I,J,JJ, "T>DO loop indices
   INEXT, "T>dummy variable
   NUM_PHSPOUT; "T> used for getting name of phsp file output directory
DOUBLE PRECISION FCASE; "T>dummy variable.

$REAL ESTEPIN,SMAX; "Dummy variables for things now taken"
                                  "care of by egsnrc"
INTEGER IDORAY,IFLUOR; "Dummy variables for things now taken"
                                  "care of by egsnrc"
;
"*****************************************************************************
"
"                       INPUT/OUTPUT CONTROL INPUT          ""toc:
"                       **************************
"First Record
"************
OUTPUT;(/' TITLE:',$);
;MINPUT (INPUTS) TITLE;(1A80);
OUTPUT TITLE;(' ',1A80/);
OUTPUT;(' ');

"EGSnrc transport parameters
"***************************

OUTPUT;(' Reading in EGSnrc transport parameters:'/
        ' -------------------------------------- ');

"set skindepth to 0 here.  If skindepth input is omitted from"
"the input file or is input improperly, then it will remain 0, only"
"to get reset to BLCMIN if BCA=PRESTA-I or 3 if BCA=EXACT in the"
"subroutine mscati.  If, on the other hand, skindepth is input properly,"
"but the value is out of the range of allowed values [-1,1e15], then"
"it will be set to its default value of 3.  This will not be reset in"
"mscati"
skindepth_for_bca=0;

call get_transport_parameter(-1);

OUTPUT;(//' Finished reading EGSnrc transport parameters.'/);

IF((~exact_bca | transport_algorithm=$PRESTA--I) & SMAXIR(1)=1e10)[
"if we get to here with the default value of SMAX (1e10), then"
"assume that this is because the SMAX input does not exist, the user"
"did not input it properly or the value was out of range and we want to"
"set it to the PRESTA-I default of 5"
    DO I=1,$MXREG[ SMAXIR(I)=5.;]
]

"now, see if the user has input a directory in which to write"
"phase space files"
PHSP_OUTDIR=' ';
NUM_PHSPOUT=1;
VALUES_SOUGHT(NUM_PHSPOUT)='PHSP OUTPUT DIRECTORY';
TYPE(NUM_PHSPOUT)=2; "character input"
NVALUE(NUM_PHSPOUT)=1;"only looking for 1 input"

DELIMETER='USER INPUTS';
$GET_INPUT(NUM_PHSPOUT);

IF(error_flags(NUM_PHSPOUT)=0)[
  "read PHSP_OUTDIR from the input text string"
  READ (CHAR_VALUE(NUM_PHSPOUT,1),FMT='(A)') PHSP_OUTDIR;
]

REWIND(i_input); "go back to beginning of input file"
;MINPUT (INPUTS) TITLE;(1A80); "read the title again to get to the 2nd line"

"input of name of material for nominal AIR as used by pegs4dat"
" *************************************"
NMED = 1;                  "Number of media so far
AIR_INDEX = 1;             "first medium is the air, unless set to 0 for vacuum
;OUTPUT;
   (/' MEDIUM of nominal AIR (exactly as in pegs4dat) (left justify): ',$);
READ(i_input,'(24A1)') (MED_IN(J),J=1,24);
;OUTPUT (MED_IN(J),J=1,24); (' ',24A1/);
IF(MED_IN(1) =  'V' & "Check if medium is vacuum"
    MED_IN(2)='A' & MED_IN(3)='C' & MED_IN(4)='U' & MED_IN(5)='U' &
    MED_IN(6)='M') [
    OUTPUT;(/' AIR  is called VACUUM '/);
    AIR_INDEX = 0;
    NMED = 0;
]
ELSEIF (MED_IN(1) =  ' ' & MED_IN(2)=' ' & MED_IN(3)=' ' & MED_IN(4)=' ')[
    "Nothing input, assume vacuum"
    MED_IN(1)='V'; MED_IN(2)='A';MED_IN(3)='C';MED_IN(4)='U';MED_IN(5)='U';
    MED_IN(6)='M';
    OUTPUT;(' Defaults to vacuum');
    AIR_INDEX = 0;
    NMED = 0;
]
DO J=1,24[MEDIA(J,1)=MED_IN(J);]              "medium 1 is nominal AIR
;

"next record
"***********

OUTPUT;(/' IWATCH(-N-4), ISTOR(0,+-1), IRESTART(0-3), IO_OPT(0-4), ',/
         ' IDAT(0-1), LATCH_OPTION (1-3), IZLAST(0-2): ',$);
;MINPUT (INPUTS) IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION ,IZLAST;
               (7I12);
OUTPUT IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION ,IZLAST;
       (2I12,3I10,2I12);
IF(IWATCH >  4)IWATCH=0;
IF((ISTORE < -1)   |  (ISTORE >  1))  ISTORE=0;
IF((IRESTART  < 0) |  (IRESTART >  4))IRESTART=0;
IF((IO_OPT  < 0)   |  (IO_OPT >  4))  IO_OPT=0;
IF((IDAT    < 0)   |  (IDAT   >  1))  IDAT  =0;
IF((IZLAST < 0)    |  (IZLAST > 2))   IZLAST = 0;
IF(LATCH_OPTION <=0| LATCH_OPTION>3)  LATCH_OPTION = 2;
$BEAMMODEL_INPUT_OPTION;
OUTPUT IWATCH,ISTORE,IRESTART,IO_OPT,IDAT,LATCH_OPTION ,IZLAST;
    (/' Do not track(0) or track(>0) every interaction or track Nth'/
      ' history only(-N):',T60,I12/
    ' Store random # for a batch(0),a history(1) or read random #(-1):',T70,I2/
    ' First run(0),restarted(1),make(2),analyze(3):',T70,I2/
    ' Output to PH-SP(0),not(1),BEAM-MODEL(2),PH-SP&MODEL(3),'/
    '      output to PH-SP in IAEA format(4):',T70,I2/
    ' Store data(0) or not(1):',T70,I2/
    ' LATCH OPTION,do not inherit(1),inherit+record origin(2,3):',T70,I2/
    ' Do not score ZLAST(0), score ZLAST(1), output file for graphics(2):',
    T70,I2);
"IF((IRESTART =  2) |  (IDAT =  1))[INEXT=0;]ELSE[INEXT=1;]"
IF(IRESTART =  1)[INEXT=1;]ELSE[INEXT=0;]"Only leave restart=1 if already is"
OUTPUT;(' ');

"                       MONTE CARLO CONTROL INPUT            ""toc:
"                       *************************

"Next Record
"***********

OUTPUT;(' #HISTORIES, RN SEED #1, RN SEED #2, TIMMAX, ',
        ' IBRSPL(0,1,2),'/T10,'NBRSPL, IRRLTT(0,1,2), ICM_SPLIT'/' : ',$);
READ(i_input,'(F15.0,2I13,F12.0,4I10)',END=:EOF_INPUTS:,ERR=:ERR_INPUTS2:)
     FCASE, IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT;
OUTPUT  FCASE,IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT,ICM_SPLIT;
(/T1,F15.0,2I13,F12.4,4I10);

IF(IWATCH = 4 & FCASE >1000 ) [ "This is probably unintentional"
     OUTPUT;(//' *****************************************************'/
               ' *****************************************************'/
               ' IWATCH = 4 and FCASE > 1000. => a huge file'/
               ' The assumption is that this is a mistake/oversight'/
               '        Stopping the run'/
               ' *****************************************************'/
               ' *****************************************************'/);
     $CALL_EXIT(1);
]

"Make sure the IXXIN and JXXIN values will not be overridden by defaults"
" and warn user if they will in case they expect to start independent runs"
IF((IXXIN <= 0) | (IXXIN > 31328)) [
   OUTPUT; (' First RN seed outside allowed range and default value set');
   IXXIN = 1802;
]
IF((JXXIN < = 0) | (JXXIN > 30081)) [
   OUTPUT; (' Second RN seed outside allowed range and default value set');
   JXXIN = 9373; "sets Marsaglia default"
]

NCASE=FCASE;
IF(IWATCH =  0  &  NCASE  < $NCASEMIN)[NCASE=$NCASEMIN;]
IF(NCASE/$NBATCH=0)["must have a minimum of $NBATCH cases"
   NCASE=$NBATCH;
]
JCASE=NCASE/$NBATCH; NCASE=$NBATCH*JCASE;
FCASE=NCASE;

IF( i_parallel > 0 ) JXXIN = JXXIN - 1 + i_parallel;

$INITIALIZE RNG USING IXXIN AND JXXIN;

IF(TIMMAX =  0.0)TIMMAX=0.99;
IF(IRRLTT<0 | IRRLTT > 2)IRRLTT=0; "default "
IF(IBRSPL =  0 & IRRLTT>=1)[
    "Russian roulette can only be used with brem splitting"
    IRRLTT=0;NBRSPL=1;
    OUTPUT;(//' Russian roulette can only be used with brem splitting'/
              ' IRRLTT reset to 0.'//);
]
"Huh? Was: ELSEIF(IBRSPL=2 & IBRSPL>0)["
ELSEIF(IBRSPL=2 & IRRLTT>0)[
    "built-in Russ. Rou. not used with DBS"
    IRRLTT=0;
    OUTPUT;(//' Built-in Russian roulette not used with DBS'/
              ' IRRLTT reset to 0.'//);
]
ELSEIF(IBRSPL=29)[ "SBS no longer supported"
    OUTPUT;
  (//' Selective bremsstrahlung splitting no longer supported.'/
     ' Will carry on with no bremsstrahlung splitting.'//);
    IRRLTT=0;NBRSPL=1;
]
IF(IRRLTT=1)[ "no longer support this option"
    OUTPUT;(//' IRRLTT=1 is no longer supported.  Defaults to IRRLTT=2.'//);
    IRRLTT=2;
]
IF(IBRSPL =  1 | IBRSPL=2)[
    "DEFAULT BREM SPLITTING TO $MAXBRSPLIT"
    IF(NBRSPL <= 0)[
      "default bremsstrahlung splitting to NBRSPL=20, which should"
      "provide reasonable optimization up to 20 MeV"
      NBRSPL=20;
      OUTPUT NBRSPL;(//' ***WARNING***'/
                       ' NBRSPL<=0.  Reset to ',I4//);
      WRITE(IOUTLIST,100)NBRSPL;
    100 FORMAT(//' ***WARNING***'/
                 ' NBRSPL<=0.  Reset to ',I4//);
    ]
    ELSEIF(NBRSPL >  $MAXBRSPLIT)[
      "default to $MAXBRSPLIT"
      OUTPUT $MAXBRSPLIT,NBRSPL;
      (//' ***WARNING***'/
         ' NBRSPL > $MAXBRSPLIT '/
         ' NBRSPL reduced to ',I10,' from ',I10//);
      WRITE(IOUTLIST,101)$MAXBRSPLIT,NBRSPL;
   101 FORMAT(//' ***WARNING***'/
         ' NBRSPL > $MAXBRSPLIT '/
         ' NBRSPL reduced to max = ',I10,' from ',I10//);
      NBRSPL=$MAXBRSPLIT;
    ]
    IF($MXSTACK<4*NBRSPL)[
      OUTPUT $MXSTACK,4*NBRSPL;
      (//' ***WARNING***'/
         ' $MXSTACK is only ',I10,'.  This may not be large enough to'/
         ' handle the bremsstrahlung splitting.  We recommend increasing'/
         ' $MXSTACK to at least 4*NBRSPL = ',I10,' in '/
         ' beamnrc_user_macros.mortran.'//);
      WRITE(IOUTLIST,102)$MXSTACK,4*NBRSPL;
      102 FORMAT(//' ***WARNING***'/
         ' $MXSTACK is only ',I10,'.  This may not be large enough to'/
         ' handle the bremsstrahlung splitting.  We recommend increasing'/
         ' $MXSTACK to at least 4*NBRSPL = ',I10,' in '/
         ' beamnrc_user_macros.mortran.'//);
    ]
    IF(LATCH_OPTION.LT.2)[
        LATCH_OPTION=2;"DEFAULT IS 2"
        OUTPUT;
    (//' LATCH_OPTION cannot be set to 0 or 1 if brem-splitting required.'/
           ' LATCH_OPTION has been re-set to 2'//);
    ]
]

IF(IBRSPL=1 | IBRSPL=2) nbr_split=NBRSPL; "so egsnrc can take over ubs"
                                          "note that this gets reset in"
                                          "AUSGAB"
IF(IRRLTT=2)[ "so egsnrc can take over russ. roulette"
    i_play_RR=1;
    IF(IBRSPL=1 | IBRSPL=2) prob_RR=1./FLOAT(NBRSPL);
]

IF(ICM_SPLIT<0)[
    ICM_SPLIT=0; "default"
]
ELSEIF(ICM_SPLIT=1)[
    OUTPUT;(//' ***WARNING***'/
     ' You have set the arbitrary splitting plane to the top of CM 1.'/
     ' Splitting only works for CM > 1.  Code will not fail but you'/
     ' will not get splitting.'//);
    WRITE(IOUTLIST,103);
  103 FORMAT(//' ***WARNING***'/
     ' You have set the arbitrary splitting plane to the top of CM 1.'/
     ' Splitting only works for CM > 1.  Code will not fail but you'/
     ' will not get splitting.'//);
]

OUTPUT NCASE,IXXIN,JXXIN,TIMMAX,IBRSPL,NBRSPL,IRRLTT;
    (/' # of histories:',T60,I12/
    ' 1st initial random number seed(>0,<31329):',T60,I12/
    ' 2nd initial random number seed(>0,<30081):',T60,I12/
    ' maximum cpu time allowed:',T60,F10.2,' hrs'/
    ' bremsstrahlung angular sampling is always switched on'/
    ' bremsstrahlung splitting off(0),uniform(1),'/
    ' directional(2):',T60,I12 /
    ' each brem split into:',T60,I12/
    ' Russian roulette off(0),on(1),on+annihilation split(2):',T60,I12/);
IF(ICM_SPLIT>0)[
   OUTPUT ICM_SPLIT;
    (' Arbitrary splitting plane at top of CM # ',T60,I12);
]
OUTPUT;(' ');


"Next Record only if IBRSPL > 1
"***********

IF(IBRSPL=2)[
   OUTPUT;
   (' Inputs for DBS:'/
    ' ---------------'/
' Field radius at SSD (cm), SSD (cm), CM no. for electron splitting'/
' (0 for no splitting), Plane no. within CM for electron splitting,'/
' IRAD_DBS (set to 1 for radially-symmetric splitting), Z position'/
' of russian roulette plane (cm).'/
    ' : ',$);
    ;MINPUT (INPUTS) FS,SSD,ICM_DBS,ZPLANE_DBS,IRAD_DBS,ZRR_DBS;
         (2F12.0,3I12,F12.0);
    OUTPUT  FS,SSD,ICM_DBS,ZPLANE_DBS,IRAD_DBS,ZRR_DBS;
    (/T1,2F12.3,3I12,F12.3);

    IF(ICM_DBS<=0 | ZPLANE_DBS<=0)[
       ICM_DBS=0;
       OUTPUT;(/' Electrons will not be split.'/);
    ]
    ELSE[
       OUTPUT NBRSPL,ICM_DBS,ZPLANE_DBS,ZRR_DBS;
       (/' Electrons will be split ',I10,' times:'/
         '        CM no. for splitting = ',I4,/
         '        Splitting plane no.  = ',I8,/
         ' Z of russian roulette plain = ',F8.5,' cm'/);
       IF(IRAD_DBS=1)[
          OUTPUT;(/' Split electrons will be redistributed with radial'/
                   ' symmetry about the beam axis.'/);
       ]
       ELSE[
          IRAD_DBS=0;
       ]
    ]

    OUTPUT;(' ');
]

"Next Record only if ICM_SPLIT > 0
"***********

IF(ICM_SPLIT>0)[
  OUTPUT;(' NSPLIT_PHOT,NSPLIT_ELEC :',$);
  ;MINPUT (INPUTS) NSPLIT_PHOT,NSPLIT_ELEC;(2I6);
  OUTPUT  NSPLIT_PHOT,NSPLIT_ELEC;
  (/T1,2I6);
  IF(NSPLIT_PHOT<=1 & NSPLIT_ELEC<=1)[
    OUTPUT;(//' ***WARNING in arbitrary splitting:'/
              ' Both NSPLIT_PHOT and NSPLIT_ELEC are <=1'/
          ' Implying no splitting is to be done for either particle type.'/
          ' ICM_SPLIT will be set to 0, shutting off arbitrary splitting.'//);
    ICM_SPLIT=0;
  ]
  IF($MXSTACK<4*NSPLIT_PHOT)[
    OUTPUT $MXSTACK,4*NSPLIT_PHOT;
      (//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the photon splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_PHOT = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
      WRITE(IOUTLIST,104)$MXSTACK,4*NSPLIT_PHOT;
      104 FORMAT(//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the photon splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_PHOT = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
  ]
  IF($MXSTACK<4*NSPLIT_ELEC)[
    OUTPUT $MXSTACK,4*NSPLIT_ELEC;
      (//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the electron splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_ELEC = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
      WRITE(IOUTLIST,105)$MXSTACK,4*NSPLIT_ELEC;
      105 FORMAT(//' ***WARNING***'/
         ' $MXSTACK is only ',I6,'.  This may not be large enough to'/
         ' handle the photon splitting at an arbitrary plane.  We recommend'/
         ' increasing $MXSTACK to at least 4*NSPLIT_ELEC = ',I6,' in '/
         ' beamnrc_user_macros.mortran.'//);
  ]
]

"                       SOURCE CONFIGURATION INPUT       ""toc:
"                       **************************

DOSE_STAT=0; "assume that we can get nhstry from a phsp source"
             "if not, this is set to 1 in ISOURCE"

CALL ISOURCE; "Get source data including source energies"

"Next Record
"***********
OUTPUT;
    (/'(ESTEPIN,SMAX--DUMMY INPUTS),ECUTIN,PCUTIN,(IDORAY--DUMMY INPUT)'/
    'IREJCT_GLOBAL(-2...2),ESAVE_GLOBAL,(IFLUOR--DUMMY INPUT)'/'   : ',$);
;MINPUT (INPUTS)
    ESTEPIN,SMAX,ECUTIN,PCUTIN,IDORAY,IREJCT_GLOBAL,ESAVE_GLOBAL,IFLUOR;
    (4F15.0,2I12,F15.0,I5);
OUTPUT ESTEPIN,SMAX,ECUTIN,PCUTIN,IDORAY,IREJCT_GLOBAL,ESAVE_GLOBAL,IFLUOR;
    (F7.3, 1PE12.4, 0PF10.4,F10.4,2I5,F10.4, I5)

IF(ECUTIN>ECUT(2))[ "reset ecut in all regions to ecutin"
   OUTPUT ECUT(2);
    (/' ****WARNING****'/
      ' ECUTIN > ECUT input in EGSnrc parameters ( ',F10.4,' MeV).'/
      ' ECUT defaults to ECUTIN.'/);
   DO I=2,$MXREG[ ECUT(I)=ECUTIN;]
]
ELSE[
   ECUTIN=ECUT(2);
]
IF(PCUTIN>PCUT(2))[ "reset ecut in all regions to ecutin"
   OUTPUT PCUT(2);
    (/' ****WARNING****'/
      ' PCUTIN > PCUT input in EGSnrc parameters ( ',F10.4,' MeV).'/
      ' PCUT defaults to PCUTIN.'/);
   DO I=2,$MXREG[ PCUT(I)=PCUTIN;]
]
ELSE[
   PCUTIN=PCUT(2);
]

"moved to below call to ISUMRY to avoid ECUT=AE in show transport params"
"now set ECUT(1)=PCUT(1)=0.0 to avoid warning messages from AUSGAB"
"ECUT(1)=0.;
"PCUT(1)=0.;

IF(MONOEN=1)[
"check that minimum energy of first non-zero bin is above ECUT,PCUT"
   IF(SRCPDF(1)>0.0)[
        IF(IQIN=-1&ENMIN<ECUTIN)[
          OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < ECUTIN'/
' May lead to artifically high dose in region(s) on which source',
'  is incident'//);
          WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < ECUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
        ]
        ELSEIF(IQIN=0&ENMIN<PCUTIN)[
          OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < PCUTIN'/
' May lead to artifically high dose in region(s) on which source',
' is incident'//);
          WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < PCUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
        ]
    ]
    ELSE["find out the min energy of the first non-zero bin"
        DO IB=2,NENSRC[
          IF(SRCPDF(IB)>0.)[
            IF(IQIN=-1&ENSRCD(IB-1)<ECUTIN)[
               OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < ECUTIN'/
' May lead to artifically high dose in region(s) on which source',
' is incident'//);
               WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < ECUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
            ]
            ELSEIF(IQIN=0&ENSRCD(IB-1)<PCUTIN)[
               OUTPUT;(//' *******WARNING:'/
                      ' min. energy of spectrum < PCUTIN'/
' May lead to artifically high dose in region(s) on which source',
' is incident'//);
               WRITE(IOUTLIST,'(//'' *******WARNING:''/
                      '' min. energy of spectrum < PCUTIN''/
                      '' May lead to artifically high dose in region(s)'',
                      '' on which source is incident''//)');
            ]
            EXIT;
          ]
        ]
   ]
]

OUTPUT ESAVE_GLOBAL;
    (' Global esave cutoff value for range rejection:',T60,F10.4,' MeV');

IF( IREJCT_GLOBAL < 0 & IREJCT_GLOBAL > -3 ) [
"special range rejection options for DBS, -1, -2"
    i_rr_global = 1; IREJCT_GLOBAL = -IREJCT_GLOBAL;
] ELSE [ i_rr_global = 0; ]
IF(IREJCT_GLOBAL <=  0 | IREJCT_GLOBAL > 2)[ OUTPUT;(' NO RANGE REJECTION');
   IF(ESAVE_GLOBAL > ECUTIN)[
      OUTPUT;(T10,' Why is ESAVE_GLOBAL set when there is no range rejection?',
      /T15,'It is set to zero'/);
      ESAVE_GLOBAL = 0.0;
   ]
   IREJCT_GLOBAL=0;
]
ELSEIF(IREJCT_GLOBAL > 0)[
    OUTPUT;(' RANGE REJECTION below ESAVE with RANGE and DNEAR');
    IF (ESAVE_GLOBAL <= ECUTIN) [
         OUTPUT ;(///' ******  NB ESAVE_GLOBAL <= ECUT  so NO Range Rejection',
                ' ***' /'              Unless ESAVE set individually'//);
    ]
    ELSEIF (ESAVE_GLOBAL ~= 0.0 & IREJCT_GLOBAL = 1)[
         OUTPUT ;(///'       ***** NOTE ****',/
           ' Automated range rejection (IREJCT_GLOBAL=1) is being used.',/
           ' This implies doses will be inaccurate because of changes',/
           ' in ECUTRR going from one CM to the next.'///);
    ]
]
ELSE["this option not implemented "
    OUTPUT IREJCT_GLOBAL;(' RANGE REJECTION  option:',I4,'  NOT IMPLEMENTED'/
           '  No range rejection done ******'//);
    IREJCT_GLOBAL = 0;
]

"Next record
"***********

OUTPUT;(/' Photon forcing: next five numbers on one line'/
    ' Force photon interactions in the target?(0)=>no,(1)=>yes, '/
    ' min/max photon interaction #/history to do forcing for,'/
    ' min/max CM # in which to do forcing  '/' : ',$);
;MINPUT (INPUTS) IFORCE,NFMIN,NFMAX, NFCMIN, NFCMAX;(5I12);
OUTPUT IFORCE,NFMIN,NFMAX, NFCMIN, NFCMAX;(5I4);
IF((IFORCE  < 0) |  (IFORCE >  1)) IFORCE=0;
IF(IFORCE =  0)[
    OUTPUT;(/' No photon interaction forcing in effect'/);
]
ELSE[
    IF(NFMIN <= 0)NFMIN=1;
    IF(NFMAX <= 0)NFMAX=1;
    "NOTE, WE COULD ARRANGE THE SCORING SO THAT SECOND FORCING COULD BE"
    "USED, BUT IT IS NOT A TRIVIAL EXTENTION."
    OUTPUT NFMIN,NFMAX;
    (/' Forced photon interactions in effect for interactions #',
     I3,' to',I3/);
    OUTPUT NFCMIN,NFCMAX;
    (/' Forced photons to interact in modules',I3,' to',I3,/);
]
;
"                       SCORING PLANES             ""toc:
"                       **************
"INPUT records FOR SCORING PLANES

OUTPUT;(/' Information about scoring planes'/);

IF(IO_OPT=1 | IO_OPT=2) [
   OUTPUT IO_OPT;(' No phase space files since IO_OPT=',I3);
]
ELSE[ OUTPUT; (' There will be phase space files generated at each plane');
   IF(IO_OPT=4) OUTPUT;
      (' Phase space will be in IAEA format');
]

OUTPUT;(' Number of scoring planes(NSC_PLANES) & list of CMs (score at',
       ' back of each)'/' : ',$);
;MINPUT (INPUTS) NSC_PLANES,(IPLANE_to_CM(I),I=1,NSC_PLANES);(10I5);
OUTPUT NSC_PLANES,(IPLANE_to_CM(I),I=1,NSC_PLANES);(10I5);
IF (NSC_PLANES > $MAX_SC_PLANES)[ OUTPUT NSC_PLANES, $MAX_SC_PLANES;
  (///' *******asked for too many scoring planes**********'/
      '        reduced from',I4,' to', I3/
     /' ***********************');
  NSC_PLANES = $MAX_SC_PLANES;
]

IF(IO_OPT ~= 1)&(NSC_PLANES = 0) [
   OUTPUT;
   (//' AT LEAST ONE SCORING PLANE HAS TO BE GIVEN FOR PH-SP OUTPUT!!'/
             ' PLEASE RESTART AND USE NSC_PLANES > 0.'///);
   $CALL_EXIT(1);
]

IF (NSC_PLANES < 0 | NSC_PLANES > $MAX_SC_PLANES) NSC_PLANES=$MAX_SC_PLANES;

IF(NSC_PLANES = 0) [
   OUTPUT;(//' Number of scoring or output planes is zero.'/
             ' No fluence scoring will be done.'//);
]
"Note that the existence of the requested CMs is checked in the gemoetry
"checking routine in main after we know how many there are.

ELSE[OUTPUT NSC_PLANES,(IPLANE_to_CM(I),I=1,NSC_PLANES);
   (' Number of planes for fluence scoring or phase space output:', I5/
    ' Fluence will be scored at the back of component module(s): ',10(I5,','));
   IF(IPLANE_to_CM(1) = 0)[
      OUTPUT;(' Scoring plane will default to back of last CM');
   ]
]

IF(NSC_PLANES>0 & IO_OPT ~= 1 & PHSP_OUTDIR~=' ')[
   "user specified directory in which to write phase space files"
   OUTPUT PHSP_OUTDIR;
   (//' Phase space files at scoring planes will be output to directory'/
      ' : ',A);
]

"                        SCORING ZONES            ""toc:
"                        *************

"INPUT records FOR SCORING ZONES

IF(NSC_PLANES  > 0) ["only ask if there are scoring planes"
   DO ISCORE=1,NSC_PLANES ["loop through scoring planes "
      OUTPUT ISCORE;(/' Inputs for scoring plane ',I5);
      "Ali:GRID"
      OUTPUT $MAX_SC_ZONES; (/' Number of scoring zones(',I5,
             ') & zone type (0-annular;1-square;2-grid): ',$);
      ;MINPUT (INPUTS) NSC_ZONES(ISCORE),MZONE_TYPE(ISCORE);(2I5);
      IF (NSC_ZONES(ISCORE) > $MAX_SC_ZONES)[
         OUTPUT ISCORE, NSC_ZONES(ISCORE), $MAX_SC_ZONES;
         (///' *******asked for too many scoring zones for scoring plane',I2,
             ' **********'/
             '        reduced from',I4,' to', I3/
            /' ***********************'///);
         NSC_ZONES(ISCORE) = $MAX_SC_ZONES;
      ]
      OUTPUT NSC_ZONES(ISCORE),MZONE_TYPE(ISCORE);  (2I5);

      "Ali:GRID"
      IF(MZONE_TYPE(ISCORE) <0 | MZONE_TYPE(ISCORE)>2)
         MZONE_TYPE(ISCORE)=0; "default to annular zones"

      IF(MZONE_TYPE(ISCORE) = 0)[ "annular zones - default case is set later"
         IF (NSC_ZONES(ISCORE)>0)[
            OUTPUT;
            (' Radii of scoring zones, in increasing order(10/line): ',$);
            ;MINPUT (INPUTS) (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE));
                (10F15.0);
            OUTPUT (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE));
                (10F10.5);
            DO ISZ=1,NSC_ZONES(ISCORE) [
              "Square radius of scoring zones for each plane"
               RSCORE_ZONE2(ISCORE,ISZ) = RSCORE_ZONE(ISCORE,ISZ)**2;
            ]
         ] "end NSC_ZONES>0 block"
         ELSE [OUTPUT;
         (' Five equal area annular zones to be used for scoring');]
         "Note that if NSC_ZONES=0, there are 5 regions of equal area set up to
         "maximum boundary of CM. This is done in the geometry checking routines
         "since the CM outer boundary is needed first but not yet available
         OUTPUT;(' ');
      ]"end of annular zones"
      ELSEIF(MZONE_TYPE(ISCORE) = 1) ["square zones"
         IF (NSC_ZONES(ISCORE)>0)[
            OUTPUT;
            (' Half-width of scoring zones, in increasing order(10/line)'/
            ' : ',$);
            ;MINPUT (INPUTS) (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE));
                  (10F15.0);
            OUTPUT (RSCORE_ZONE(ISCORE,I),I=1,NSC_ZONES(ISCORE)); (10F10.5);
            DO ISZ=1,NSC_ZONES(ISCORE) ["Square half-width for scoring zones"
               RSCORE_ZONE2(ISCORE,ISZ) = RSCORE_ZONE(ISCORE,ISZ)**2;
            ]
         ] "end NSC_ZONES>0 block"
         ELSE [OUTPUT;
         (' Five equal area square rings to be used for scoring');]
         "Note that if NSC_ZONES=0, there are 5 regions of equal area set up to
         "maximum boundary of CM.
      OUTPUT;(' ');
      ]
      ELSEIF(MZONE_TYPE(ISCORE) = 2) ["grid"   "Ali:GRID"
         ;MINPUT (INPUTS) XMIN_ZONE(ISCORE),XMAX_ZONE(ISCORE),
                          YMIN_ZONE(ISCORE),YMAX_ZONE(ISCORE),
                          NX_ZONE(ISCORE),NY_ZONE(ISCORE);
                          (4F12.5,2I5);
         OUTPUT; (' XMIN, XMAX, YMIN and YMAX in cm');
         OUTPUT XMIN_ZONE(ISCORE),XMAX_ZONE(ISCORE),
                YMIN_ZONE(ISCORE),YMAX_ZONE(ISCORE); (4F10.3);
         OUTPUT NX_ZONE(ISCORE),NY_ZONE(ISCORE);
                (' NX =',I3,'    NY =',I3);
         IF(NX_ZONE(ISCORE)*NY_ZONE(ISCORE)>$MAX_SC_ZONES)[
            OUTPUT ISCORE, NX_ZONE(ISCORE)*NY_ZONE(ISCORE), $MAX_SC_ZONES;
         (///' *******asked for too many scoring zones for scoring plane',I2,
             ' **********'/
             '   You asked for ',I4,' but max. number is ',I4/
            /' ***********************'///);
            STOP;
         ]
         ELSE[
            NSC_ZONES(ISCORE)=NX_ZONE(ISCORE)*NY_ZONE(ISCORE);
            OUTPUT NSC_ZONES(ISCORE);
            (' Total no. of scoring zones = ',I5);
            "now, get the grid boundaries,  RSCORE_ZONE stores X boundaries"
            "RSCORE_ZONE2 stores Y boundaries"
            DO ISZ=1,NX_ZONE(ISCORE)+1[
               RSCORE_ZONE(ISCORE,ISZ)=XMIN_ZONE(ISCORE)+
               (XMAX_ZONE(ISCORE)-XMIN_ZONE(ISCORE))/NX_ZONE(ISCORE)*(ISZ-1);
            ]
            OUTPUT (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NX_ZONE(ISCORE)+1);
               (' X-grid boundaries:'/(6F10.3));
            DO ISZ=1,NY_ZONE(ISCORE)+1[
               RSCORE_ZONE2(ISCORE,ISZ)=YMIN_ZONE(ISCORE)+
               (YMAX_ZONE(ISCORE)-YMIN_ZONE(ISCORE))/NY_ZONE(ISCORE)*(ISZ-1);
            ]
            OUTPUT (RSCORE_ZONE2(ISCORE,ISZ),ISZ=1,NY_ZONE(ISCORE)+1);
               (' Y-grid boundaries:'/(6F10.3));OUTPUT;(/);
         ]
      ]
   ]"end of do loop through scoring scoring planes"
]"end of NSC_PLANES > 0 block"

"         inputs for dose components calculations       ""toc:

OUTPUT;
 (' Total dose only(0) or total dose & dose components(1):', $);
;MINPUT (INPUTS) ITDOSE_ON; (I5);
IF(ITDOSE_ON ~= 1)ITDOSE_ON=0;"default to 0"
OUTPUT ITDOSE_ON; (I5);

IF(ITDOSE_ON = 1)[
    OUTPUT;
(/' CM # at which contaminant particles are identified on entry at front,'/
  ' and type of contaminant particle (0=photons,1=charged particles)'/
  ' :',$);
   ;MINPUT (INPUTS) ICM_CONTAM, IQ_CONTAM; (2I5);
   OUTPUT ICM_CONTAM, IQ_CONTAM; (2I5);
   "do some checks"
   IF (IQ_CONTAM ~= 0)&(ABS(IQ_CONTAM) ~= 1)[
      OUTPUT;(///' Wrong input for IQ_CONTAM!!!'/
      ' Try again with IQ_CONTAM = 1(charged particles) or 0(photons)'//);
      $CALL_EXIT(1);
   ]
   IF(LATCH_OPTION = 1 & ICM_CONTAM ~= 0) ["this combination won't work"
      OUTPUT;(//' ****************WARNING: **************'/
      'Contaminant dose is meaningless with LATCH_OPTION = 1'/
      'ICM_CONTAM has been set to 0'//);
      WRITE(IOUTLIST,'(//''***WARNING:''/
      ''Contaminant dose is meaningless with LATCH_OPTION = 1''/
      ''ICM_CONTAM has been set to 0''//)');
      ICM_CONTAM=0;
   ]

   IF((ISOURC=21 | ISOURC=23 | ISOURC=24) & ICM_CONTAM<INIT_ICM)[
      OUTPUT;(//'***WARNING:'/
    'ICM_CONTAM < CM # on which phase space/BEAMnrc sim. source is incident.'/
       'Cannot score contaminant dose in this case.'/
       'ICM_CONTAM reset to 0 (no contaminant dose determined) for now.'//);
      WRITE(IOUTLIST,'(//''***WARNING:''/
  ''ICM_CONTAM <= CM # on which phase space/BEAMnrc sim. source is incident.''/
       ''Cannot score contaminant dose in this case.''/
     ''ICM_CONTAM reset to 0 (no contaminant dose determined) for now.''//)');
      ICM_CONTAM=0;
   ]
   ELSEIF(ICM_CONTAM>=1)[
      IF(IQ_CONTAM=0)[
        OUTPUT; (//' Dose from contaminant photons will be calculated');
      ]
      ELSEIF(ABS(IQ_CONTAM)=1)[
        OUTPUT;
        (//' Dose from contaminant electrons & positrons will be calculated');
      ]
      OUTPUT ICM_CONTAM; (' in CM # ',I4,//);
   ]
   ELSE[
      OUTPUT; (//'No contaminant dose will be calculated'//);
      ICM_CONTAM=0;
   ]
   OUTPUT; (/' # of dose components which exclude particles',
                                           ' from specified regions: ',$);
   ;MINPUT (INPUTS) LNEXC; (I5);
   OUTPUT LNEXC; (I5);
   IF(LNEXC<=0)[ LNEXC=0;]
   IF( LNEXC+3>$MAXIT) [
      OUTPUT $MAXIT-3,$MAXIT;
        (/' ******Input error: too many components asked for'/
      ' MAX. LNEXC =', I3,' since $MAXIT=',I3);
      $CALL_EXIT(1);
   ]   " out of max sub index "
   DO I=4, 3+LNEXC[  "this counts on the fortran not executing if LNEXC=0"
       OUTPUT I-3;(/' INPUT THE BIT #S IN LATCH FOR DOSE COMPONENT' , I4,
                  /' WILL NOT SCORE THE DOSE WHEN THESE BITS ARE SET: ');
       ;MINPUT (INPUTS) (L_N_EXC(I, J), J=1, 31 ); (31I5);
       DO J=1,31[
         IF(L_N_EXC(I,J) ~= 0)[
           OUTPUT  L_N_EXC(I, J); (I5,$);
         ]
       ]
       OUTPUT;(' ');
   ]
   OUTPUT;
   (/' # of dose components including particles from specified regions: ',$);
   ;MINPUT (INPUTS) LNINC; (I5);
   OUTPUT LNINC; (I5);
   IF(LNINC<=0)[ LNINC=0;]
   IF( LNINC+LNEXC+3>$MAXIT) [
      OUTPUT $MAXIT-3-LNINC,$MAXIT;
      (/' ******Input error: too many components asked for',
      ' MAX. LNINC =', I3,' since $MAXIT=',I3);
      $CALL_EXIT(1);
   ]   " out of max sub index "
   DO I=4+LNEXC, 3+LNEXC+LNINC [
      OUTPUT I-3;
      (/' INPUT THE BIT #S IN LATCH FOR DOSE COMPONENT', I4,
      /' INPUT BIT #S TO INCLUDE, 0, BIT #S TO EXCLUDE (IF ANY): ');
      ;MINPUT (INPUTS) (L_N_INC(I, J), J=1, 31) ; (31I5);
      DO J=1,31[
         IF(L_N_INC(I,J)=0)[
           EXIT;
         ]
         ELSE[
           IF(J=1) OUTPUT;
                  (' WILL SCORE THE DOSE IF ANY OF THESE BITS ARE SET: ');
           OUTPUT  L_N_INC(I, J); (I5,$);
         ]
      ]
      DO JJ=J+1,31[
         IF(L_N_INC(I,JJ)=0)[
           EXIT;
         ]
         ELSE[
           IF(JJ=J+1) OUTPUT;
                  (/' AND NONE OF THESE BITS ARE SET: ');
           OUTPUT  L_N_INC(I, JJ); (I5,$);
         ]
      ]
      OUTPUT;(' ');
   ]
]"end of ITDOSE_ON block"


" input the front boundary of the ist component module"
OUTPUT;
(/' Z dist from ref plane(Z=0) to CM front (include any air gap): ', $);
;MINPUT (INPUTS) Z_min_CM(1); (F15.0);
OUTPUT Z_min_CM(1); (F11.5);

"INITIALIZATION OF BIT SETTING just in case
DO I = 1, $MXREG[IREGION_TO_BIT(I) = 0;]
;
RETURN;

"BAD INPUT FILE, STOP AND PRINT MESSAGE
:EOF_INPUTS:
;OUTPUT;(//' *** unexpected end of file reading input for INPUTS ***');
$CALL_EXIT(1); "END OF INPUT FILE RETURN"

:ERROR_INPUTS:
;OUTPUT;(//' *** format error on input for INPUTS ***');
$CALL_EXIT(1); "END OF INPUT FILE RETURN"

:ERR_INPUTS2:
;OUTPUT;(//' *** format error on input for INPUTS ***'/
           ' Note that we have added a new input variable, ICM_SPLIT '/
           ' for particle splitting at an arbitrary plane.  This error '/
           ' may be due to the fact that you are using an older input'/
           ' file without ICM_SPLIT and with explanatory text on this'/
           ' input line.');
$CALL_EXIT(1);

END; "END OF SUBROUTINE INPUTS

%E     "beamnrc.mortran - start subroutane isumry                         "
"*******************************************************************************
"
                            SUBROUTINE ISUMRY;
"                           *****************
"
"     ISUMRY routine for BEAMnrc.
"
"     ASSUMES arrays IR_to_CM_forward and IR_to_CM_back have
"     been initialized.
"
"     ROUTINES CALLED:  none
"
"*******************************************************************************
"
$IMPLICIT-NONE;
;COMIN/BOUNDS,BREMPR,CMs,EDGE,ELECIN,EPCONT,GEOM,IO_INFO,MEDIA,MISC,
      SCORE,SOURCE,STACK,THRESH,USEFUL,USER,RANDOM,ENERGYSRC,EGS-IO/;
"T>****************************
"T>TYPE DECLARATIONS FOR ISUMRY
"T>****************************
"T>
;INTEGER
   I,I1,I2,I3,J,JJ,kk, "T>DO loop indices
   I3MAX, "T>limit of number of media for listing
   IOUT,  "T>output unit number
   IRL,   "T>region number"
   LELKE, "T>used to calc. max. range
   lelktmp,"T>used to calc. max. range
   lelec;  "T>used to calc. max. range

;$REAL
   AEMIN,   "T>minimum AE, lower total electron energy of PEGS data
   EIE,     "T>total energy of electron, includes rest mass
   ETAB(5), "T>tables of energies for summary of RNGEE
   RNGEE($MXMED), "T>maximum range that EGS will transport electron
   TSTTPM,  "T>PRESTA calculated minimum step sizes for maximum energy
   IEKMAX,   "T>keeps track of maximum kinetic energy of the source
   EKEI,     "T>used in calculation of max. range
   ELKEI,    "T>used in calculation of max. range
   fedep,    "T> used in calculating max. range
   elktmp,   "T> used in calculating max. range
   dedxmid,  "T> used in calculating max. range
   aux;      "T> used in calculating max. range


DATA ETAB/1.,1.5,2.,4.,6./;


"                                 OUTPUT
"                                 ******
"
" Write the header
" ****************
CALL DATETIME(1);
WRITE(IOUTLIST,100) TITLE,TIMEN,DATEN;
100  FORMAT(// ,1A79/
      /' NRCC CALN: BEAMnrc(EGSnrc) '$BEAM_VERSION $USER_MACROS_VERSION,
      /' ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
WRITE(IOUTLIST,200);
" Monte Carlo, transport, and scatter controls
" ********************************************
WRITE(IOUTLIST,211) NCASE,NCASET;
IF((NCASE+IHSTRY)  < 100)WRITE(IOUTLIST,203);
"in fact, this should never happen because minimum NCASE = 100 - CMa"
IF(IQIN < 9) & (ISOURC < 21 | ISOURC=22)[
     IF(IQIN < 9)[WRITE(IOUTLIST,204) IQIN;]
     IF(MONOEN =  0)[WRITE(IOUTLIST,201) EIN;]
     IF(MONOEN = 1)["spectrum input"
         WRITE(IOUTLIST,205) FILNAM, ENMIN, ENSRCD(NENSRC),NENSRC;
         IF(IMODE=1)[
            WRITE(IOUTLIST,'(T20,''  SPECTRUM FILE CONTAINS COUNTS/MeV'')');
         ]
         ELSEIF(IMODE=0)[
            WRITE(IOUTLIST,'(T20,''  SPECTRUM FILE CONTAINS COUNTS/BIN'')');
         ]
         IF(IOUTSP = 1)["list spectrum"
            WRITE(IOUTLIST,110) NENSRC;
            110   FORMAT(T20,'ENERGY DIST''N, # OF INCIDENT ENERGY BINS:',T60,
            I3/T20,'BIN    KINETIC ENERGY     PROBABILITY  ');
            DO IB=1,NENSRC[
               WRITE(IOUTLIST,120)IB,ENSRCD(IB),SRCPDF(IB);
               120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3);
            ]
         ]
     ]
]
ELSEIF(ISOURC >= 21 & ISOURC~=22)[
     IF((ISOURC = 21 | ISOURC=24) & ~phsp_open)[
                      WRITE(IOUTLIST,207) NNPHSP, NPHOTSRC, EKMAXSRC,
                      EKMINSRCE, NINCSRC, INIT_ICM, NRCYCL;
        IF(OLDSRC = 1)[ WRITE(IOUTLIST,208); ]
        IF(IPARALLEL>1 & PARNUM>0)[
             WRITE(IOUTLIST,209)IPARALLEL,INT((PARNUM-1)*NNPHSP/IPARALLEL)+1,
                INT(PARNUM*NNPHSP/IPARALLEL);
        ]
     ]

     "space for ISOURC=31 when it arrives
]

"Ali:BCSE"
IF((IBRSPL = 1 | IBRSPL = 2) & USE_BCSE)[NBRSPL = NBRSPL_ORGNL;]
IF(IBRSPL =  0)[WRITE(IOUTLIST,2279);]
ELSEIF(IBRSPL = 1)[WRITE(IOUTLIST,2281)NBRSPL;]
ELSEIF(IBRSPL = 2)[
    WRITE(IOUTLIST,2289)FS,SSD,NBRSPL;
    IF(ICM_DBS>0)[
      WRITE(IOUTLIST,2290)ZPLANE_DBS,ICM_DBS,ZPOSN_DBS,ZRR_DBS;
      IF(IRAD_DBS=1)[
         WRITE(IOUTLIST,2291);
      ]
      ELSE[
         WRITE(IOUTLIST,2292);
      ]
    ]
]

IF(USE_BCSE) [
   WRITE(IOUTLIST,:new2:) nmed_enhance;
   :new2: FORMAT(/T20,'Brem. cross section enhancement WILL be used'/
   T20,' The following ',I2,' media will be enhanced:');
   DO i=1,$MXMED [
       IF( is_bcse_medium(i) ) [
          WRITE(IOUTLIST,'(T20,24a1)') (media(kk,i),kk=1,24);
       ]
   ]
   IF( BCSE_POWER_N > 0 ) [
    WRITE(IOUTLIST,:new3:) BCSE_FACTOR_C,BCSE_POWER_N;
    :new3: FORMAT(T20,' Enhancement factor will be 1 + C*E**N WITH C = ',
               1PE14.6,' N = ',0PF9.2);
   ]
   ELSE [
       WRITE(IOUTLIST,:new4:) BCSE_FACTOR_C;
       :new4: FORMAT(T20,' Constant enhancement factor  =',F12.2);
   ]
]"end of using BCSE block"
ELSE [ WRITE(IOUTLIST,:new1:);
  :new1: FORMAT(T20,'Brem. cross section enhancement WILL NOT be used');
]

IF(IBRSPL=1)[
  IF(IRRLTT >=  1)[WRITE(IOUTLIST,2282);] ELSE [WRITE(IOUTLIST,2283);]
]
IF(IRRLTT = 2)[
  IF(IBRSPL = 1)[WRITE(IOUTLIST,2286)NBRSPL;]
]
IF(ICM_SPLIT>0)[
   WRITE(IOUTLIST,2287)ICM_SPLIT,NSPLIT_PHOT,NSPLIT_ELEC;
]
IF(IFORCE ~= 0)[
   IF( NFCMIN<1 | NFCMIN>NFCMAX )[ NFCMIN = 1; ]
   IF( NFCMAX<NFCMIN | NFCMAX>MAX_CMS ) [ NFCMAX = MAX_CMS; ]
   WRITE(IOUTLIST,230)NFMIN,NFMAX,NFCMIN,NFCMAX;
]
ELSE[WRITE(IOUTLIST,231);]
IF(NSC_PLANES = 0)[WRITE(IOUTLIST,233);]
ELSEIF(NSC_PLANES>0)[
   WRITE(IOUTLIST,234);
   DO I = 1,NSC_PLANES[
     WRITE(IOUTLIST,235) I,IPLANE_to_CM(I);
   ]
   IF(IO_OPT = 1|IO_OPT = 2)[WRITE(IOUTLIST,236);]
   ELSE[
     WRITE(IOUTLIST,237);
     IF(IO_OPT=4) WRITE(IOUTLIST,238);
   ]
]

200  FORMAT(' ',78('*')/ ' **',T78,'**'/
' **',T38,'BEAMnrc',T78,'**'/ ' **',T78,'**'/
' **',T10,'Code developed at National Research Council of Canada as part of',
                   T78,'**'/
' **',T15,'OMEGA collaboration with the University of Wisconsin.',T78,'**'/
' **',T78,'**'/
' **',' This is version V1 of BEAMnrc ',
'(Rev 1.78 last edited 2004-01-12 11:44:06-05)'
   ,T78,'**'/ ' **',T78,'**'/ ' ',78('*')//);
211  FORMAT(' Max # of histories: to run',I12,T50,'To analyze',T65,I12);
204  FORMAT(' ',T20,'Incident charge',T63,I2);
201  FORMAT(' ',T20,'Incident kinetic energy',T56,F9.3,' MeV');
202  FORMAT(' ',T20,'Maximum incident kinetic energy',T57,F9.3,' MeV');
203  FORMAT (' ',T4,'*** WARNING *** too few histories - statistical analysis',
              ' incorrect');
205  FORMAT(' ',T20,'Read incident kinetic energy spectrum from file:'/A,/
            ' ',T20,'  Minimum kinetic energy in spectrum',T56,F9.3,' MeV',/
            ' ',T20,'  Maximum kinetic energy in spectrum',T56,F9.3,' MeV',/
            ' ',T20,'               # of bins in spectrum',T56,I9);
207  FORMAT(' ',T20,'Reading in a phase space source with:',/,
            ' ',T20,'             total # of particles',T56,I9,/
            ' ',T20,'                     # of photons',T56,I9,/
            ' ',T20,'  Maximum particle kinetic energy',T56,F9.3,' MeV',/
            ' ',T20,'  Minimum electron kinetic energy',T56,F9.3,' MeV',/
            ' ',T20,'  # of particles incident from   ',/
            ' ',T20,'                  original source',T56,F13.1,/
            ' ',T20,'   Source entering at top of CM #',T63,I2/
            ' ',T20,'  # of times to recycle particles',T56,I9);
208  FORMAT(/' ',T20,'***WARNING****NUMBER OF PHOTONS AND MINIMUM'/
            ' ',T20,'     PHOTON AND ELECTRON ENERGIES SHOWN ABOVE'/
            ' ',T20,'     HAVE BEEN SET TO ZERO EITHER BECAUSE THE'/
            ' ',T20,'     THE SOURCE FILE WAS GENERATED BY AN OLDER'/
            ' ',T20,'     VERSION OF BEAMnrc OR BECAUSE IT HAS AN ERROR.'/
            ' ',T20,'     CHECK THE FILE!!'/);
209  FORMAT(/,' ',T20,'This is one of ',I4,' parallel runs'/
            ' ',T20,'Simulation will use from particle',T56,I12,/
            ' ',T20,'                      to particle',T56,I12);
230  FORMAT(' ',T20,'Min/max photon step forced',T60,I6,'/',I6,
       /T20,'Min/max CM modules to force interaction',T60,I6,'/',I6);
231  FORMAT(' ',T20,'Photon force interaction switch',T60,'OFF');
233  FORMAT(' ',T20,'There are no scoring planes');
234  FORMAT(' ',T20,'SCORING PLANES:     #',T52,'CM #',/
            ' ',T20,'---------------------',T52,'----');
235  FORMAT(' ',T37,I4,T53,I2);
236  FORMAT(T20,'No phase space files will be output');
237  FORMAT(T20,'Phase space files will be output at EVERY scoring plane');
238  FORMAT(T20,'Phase space files will be in IAEA format');
2279   FORMAT(/T20,'Bremsstrahlung splitting',T60,'OFF');
2281   FORMAT(/T20,'Bremsstrahlung splitting',T60,'UNIFORM'/T20,
      'Initially, each bremsstrahlung photon split into ',I10,' photons');
2282   FORMAT(T20,'Russian Roulette is',T60,'ON');
2283   FORMAT(T20,'Russian Roulette is',T60,'OFF');
2284   FORMAT(T20,'Annihilation splitting no.',T60,F5.1);
2286   FORMAT(T20,'Annihilation splitting no.',T60,I4);
2289   FORMAT(/T20,'Bremsstrahlung splitting',T60,'DIRECTIONAL'/
               T20,' splitting field radius',T60,F8.3,' cm'/
               T20,' splitting field SSD',T60,F8.3,' cm'/
               T20,' splitting no. in field',T60,I10);
2290   FORMAT(T20,' e+/e- will be split at plane',I4,' in CM',I4,':'/
              T20,'  Z of splitting plane',T60,F8.3,' cm'/
              T20,'  Z of Russian Roulette plane',T60,F8.3,' cm');
2291   FORMAT(T20,'  Radial redistribution of split e+/e-',T60,'ON');
2292   FORMAT(T20,'  Radial redistribution of split e+/e-',T60,'OFF');
2287   FORMAT(T20,'Arbitrary split plane at top of CM',T60,I5/
              T20,'           Photon splitting number',T60,I5/
              T20,'         Electron splitting number',T60,I5);


" Range rejection summary
" ***********************
IF(IREJCT_GLOBAL = 0)[
   WRITE(IOUTLIST,'(T20,''RANGE REJECTION SWITCH'',T60,''OFF'')');
]
ELSEIF(IREJCT_GLOBAL > 0)[
   "check that ESAVE is set above ECUT somewhere, otherwise there is"
   "no range rejection"
   lelec=-1;
   JJ = 0;"flag "
   DO I = 1,NREG[
      IF(ESAVE(I) > ECUT(I))[JJ = JJ + 1;]"adds up regions for range rejection"
   ]
   IF(JJ = 0)[
      WRITE(IOUTLIST,'(T10,''ESAVE NEVER ABOVE ECUT=> NO RANGE REJECTION'')');
   ]
   "List the maximum ranges for 7 media
   WRITE(IOUTLIST,'(T20,''Range rejection switch'',T60,''ON '' )');
   IF(JJ>0)[
     WRITE(IOUTLIST,:label:) JJ;
     :label: FORMAT(T20,'Range rejection in',I4,' regions');
   ]
   IF(IREJCT_GLOBAL = 1) [
      WRITE(IOUTLIST,
      '(T20,''Automatic ECUTRR used starting from'',T60,F10.3,'' MeV'')')
      ECUTIN;
   ]
   IF(IREJCT_GLOBAL = 2) [WRITE(IOUTLIST,'(T30,''Fixed ECUT used'')');]
   WRITE(IOUTLIST,
   '('' Range rejection based on medium of region particle is traversing'')');
   I3MAX = MIN0(NMED,7); "Limited to 7 media for listing
   WRITE(IOUTLIST,246) I3MAX,((MEDIA(J,I),J = 1,8),I = 1,I3MAX);
   246  FORMAT(' Maximum electron ranges for restricted stopping powers:'/
           '   kinetic',T20,'   Range for media 1 through',I2/
           '   energy',T30,'      (cm)'/'   (MeV)    ',6(8A1,2X),8A1);
   AEMIN = 1.E30;       IEKMAX = 20.;
   DO I3 = 1,I3MAX[
      IF(AEMIN >  AE(I3)) [AEMIN = AE(I3);]]
   IF((MONOEN = 0) & (ISOURC<21 | ISOURC=22)) [IEKMAX = EIN;]
   ELSEIF(ISOURC>=21 & EKMAXSRC>0. & ISOURC~=22) [IEKMAX = EKMAXSRC;]
   ELSEIF((MONOEN=1) & (ISOURC<21 | ISOURC=22)) [IEKMAX = ENSRCD(NENSRC);]
   DO I1 = 1,8[
      DO I2 = 1,5[
         EKE = ETAB(I2)*10.**(I1-4);
         EIE = EKE+RM;
         IF(EIE >= AEMIN  &  EIE <= IEKMAX) [
            ELKE = LOG(EKE);
            DO MEDIUM = 1,I3MAX[
               RNGEE(MEDIUM) = 0.;
               IF(EIE >= AE(MEDIUM)  &  EIE <= UE(MEDIUM)) [
                 $SET INTERVAL ELKE, EKE;
                 EKEI = E_array(LELKE,MEDIUM);
                 ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
                 $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RNGEE(MEDIUM));
                 RNGEE(MEDIUM)=(RNGEE(MEDIUM)+range_ep(0,LELKE,MEDIUM));
               ]
               IF(EIE >  UE(MEDIUM)) [RNGEE(MEDIUM) = 999.999;]
            ]"END OF MEDIUM LOOP"
            WRITE(IOUTLIST,247) EKE,(RNGEE(I3),I3 = 1,I3MAX);
            247  FORMAT(' ',F7.3,2X,10(F10.3));]
      ]"END OF I2 LOOP"
   ]"END OF I1 LOOP"
   EKE = IEKMAX;
   EIE = EKE+RM;
   ELKE = LOG(EKE);
         DO MEDIUM = 1,I3MAX[
            RNGEE(MEDIUM) = 0.;
            IF(EIE >= AE(MEDIUM)  &  EIE <= UE(MEDIUM)) [
              $SET INTERVAL ELKE, EKE;
              EKEI = E_array(LELKE,MEDIUM);
              ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
              $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RNGEE(MEDIUM));
              RNGEE(MEDIUM)=(RNGEE(MEDIUM)+range_ep(0,LELKE,MEDIUM));
            ]
            IF(EIE >  UE(MEDIUM)) [RNGEE(MEDIUM) = 999.999;]
         ]"END OF MEDIUM LOOP"
         WRITE(IOUTLIST,247) EKE,(RNGEE(I3),I3 = 1,I3MAX);
]"End of IREJCT_GLOBAL>0 branch"
IF((ESAVE_GLOBAL >  0.0)) WRITE(IOUTLIST,267)ESAVE_GLOBAL;
267  FORMAT(' ',T20,'Discard all electrons below energy:',T60,F7.3,
                   ' MeV'/
                T25,'if too far from closest boundary');

" Various variables output
" ************************

WRITE(IOUTLIST,260) TIMMAX,IXXIN,JXXIN;
260  FORMAT(' ',T20,'Maximum cputime allowed',T59,F10.2,' (hrs)'/
            ' ',T20,'Initial random number seeds',T50,I12,I14);

" Latch options
" ******************

IF(LATCH_OPTION  = 1)[
  WRITE(IOUTLIST,'(T13,''LATCH_OPTION = 1: Latch values for secondaries not''/
                   T13,''                  inherited from primaries.'')');
]
ELSEIF(LATCH_OPTION  = 2)[
  WRITE(IOUTLIST,'(T13,''LATCH_OPTION = 2: Latch values inherited, origin of''/
                   T13,''                  secondary particles recorded.'')');
]
ELSEIF(LATCH_OPTION  = 3)[
  WRITE(IOUTLIST,'(T13,''LATCH_OPTION = 3: Latch values inherited, origin of''/
                   T13,''                  secondary particles recorded.  For''/
                   T13,''                  photons, region no. are recorded''/
                   T13,''                  where they interact, not where ''/
                   T13,''                  they just pass through.'')');
]
"LATCH_OPTION  is part of COMIN STACK"

"summary of transport parameters"
call show_transport_parameter(IOUTLIST);

" Material summary
" ****************
WRITE(IOUTLIST,300) NMED;
DO I=1,NMED[
    WRITE(IOUTLIST,310) I,(MEDIA(J,I),J=1,18),RHO(I),AE(I),AP(I),UE(I),UP(I);
]
300  FORMAT('  ',T20,'Material summary   ',I1,' Materials used'/
             ' ',79('*')/
             '  # Material',11x,'density(g/cm**3)',3X,'AE(MeV)',3X,'AP(MeV)',
                 5X,'UE(MeV)',2X,'UP(MeV)'/
             ' -- -----------------  ----------------',3X,'-------',
             3X,'-------',5X,'-------',2X,'-------');
310  FORMAT(' ',I2,1X,18A1,3X,1PE10.3,1x,2(3X,0PF9.3,1X,F9.3));


" Source summary
" **************
CALL SRCOUT;

" Geometry summary
" ****************
"Note: Region and Range rejection summaries now in one table"

WRITE(IOUTLIST,548);
548 FORMAT(/' REGION and RANGE REJECTION SUMMARY:',/
              ' **********************************'/);
WRITE(IOUTLIST,549) NREG;
549 FORMAT(' Total number of regions, including region 1',
                 ' which surrounds the geometry:', I4);
WRITE(IOUTLIST,550) ;
"Region 1 is vacuum"
WRITE(IOUTLIST,560) 1,1,0,'exterior',0,0,0,'V','a','c','u','u','m';

DO IRL=2,NREG ["DEFAULT IREGION_TO_BIT(IRL) TO 23"
   IF(IREGION_TO_BIT(IRL)<1|IREGION_TO_BIT(IRL)>23)[IREGION_TO_BIT(IRL)=23;]
]

DO IRL=2,NREG [
     IF(IREJCT_GLOBAL > 0)["range rejection"
        IF(IREJCT(IRL)=0)[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m',' ',' ',' ',ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'NO RR';
          ]
          ELSE[
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),(MEDIA(J,MED(IRL)),J=1,9),ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'NO RR';
          ]
        ]
        ELSEIF(IREJCT(IRL)=1)[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m',' ',' ',' ',ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'DNEAR';
          ]
          ELSE[
             WRITE(IOUTLIST,560)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),(MEDIA(J,MED(IRL)),J=1,9),ECUTRR(IRL),
             RANGE_ECUTRR(IRL),ESAVE(IRL),'DNEAR';
          ]
        ]
     ]  "end IREJCT_GLOBAL > 0 block"
     ELSE["no range rejection"
        ESAVE(IRL)=0.0;
        IF(IRL=2)[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,565)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m',' ',' ',' ',
             'Global range rejection off';
          ]
          ELSE[
            WRITE(IOUTLIST,565)
            IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
            CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
            MED(IRL),(MEDIA(J,MED(IRL)),J=1,9),
            'Global range rejection off';
          ]
        ]
        ELSE[
          IF(MED(IRL)=0)["vacuum"
             WRITE(IOUTLIST,565)
             IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
             CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
             MED(IRL),'V','a','c','u','u','m';
          ]
          ELSE[
            WRITE(IOUTLIST,565)
            IRL, IRL-IR_start_CM(IR_to_CM(IRL))+1, IR_to_CM(IRL),
            CMLIST(IR_to_CM(IRL)), DOSE_ZONE(IRL), IREGION_TO_BIT(IRL),
            MED(IRL),(MEDIA(J,MED(IRL)),J=1,9);
          ]
        ]
     ]
]


550  FORMAT(/T3,'Region',T13,'CM',T25,'Dose', T32,'IR_',
         T39,'Medium',T49,'ECUTRR',T57,'res_rnge',T67,'ESAVE',
         T75,'type',
        /T2,'abs',T6,'local',T13,'# IDENTIF ',T25,'ZONE',
         T32,'TO_',
         T37,'(No.&Name)',T50,'(MeV)',T59,'(cm)',T67,'(MeV)',
         /T24,'(0=no)',T32,'BIT');
560  FORMAT(1x,i3,i4,i5,1x,A8,I4,I7,I5,1X,9A1,F7.3,F8.3,F8.3,A7);
565  FORMAT(1x,i3,i4,i5,1x,A8,I4,I7,I5,1X,9A1,A32);

IF(NSC_PLANES=0)[OUTPUT;(/' No scoring planes included in output');]
ELSE [OUTPUT NSC_PLANES;(/' There are',I3,' scoring planes -see below');]

WRITE(IOUTLIST,'(/'' Component Module summary:''/
                 '' *************************'')');

IF (MAX_CMs = 1)[WRITE(IOUTLIST,'(/''  There is 1 Component Module:''/)') ;]
ELSE [
   WRITE(IOUTLIST,'(/''  There are'',I3,'' Component Modules.''/)') MAX_CMs;
]
WRITE(IOUTLIST,540);
DO ICM = 1,MAX_CMs[
    WRITE(IOUTLIST,545) ICM,CMTYPE(ICM),CMLIST(ICM),IR_start_CM(ICM),
       RMAX_CM_FLAG(ICM),RMAX_CM(ICM),Z_min_CM(ICM),Z_gap_THICK(ICM),
       ICM_to_SCORE(ICM);
] "end of loop over CMs"

540 FORMAT(
'     COMPONENT MODULE  FIRST     BOUNDARY    DISTANCE FROM    AIR    SCORING'/
'                      REGION  (1=cyl,2=sq)  REFERENCE PLANE   GAP     PLANE'/
'  #  TYPE  IDENTIFIER         FLAG    (cm)          (cm)      (cm)   (0=none)'
/);
545  FORMAT(I3,1X,A,1X,A,I5,I6,F10.3,4X,F10.3,F10.3,I6);


;$CALL_ISUMRY;    "this expands to call all the specific ISUMRY_CM routines

WRITE(IOUTLIST,'(//)');

RETURN;

END;     "Last line of subroutine ISUMRY"
%E     "beamnrc.mortran - start subroutine osumry                         "
"*******************************************************************************
"
                             SUBROUTINE OSUMRY;
"                            *****************
"
"     Routine  to ouput results for BEAMnrc.
"
"     ROUTINES CALLED: none
"
"*******************************************************************************
$IMPLICIT-NONE;
;COMIN/BOUNDS,BREMPR,CMs,EDGE,ELECIN,GEOM,IO_INFO,MEDIA,MISC,
    SCORE,SOURCE,THRESH,USEFUL,USER,RANDOM,CH-Steps,EGS-IO/;
"T>****************************
"T>TYPE DECLARATIONS FOR OSUMRY
"T>****************************
"T>
;INTEGER
   I,J,   "T>indices for general use
   IPAR,  "T>parameter index in fluence scoring arrays FLUENCE[UN][IS], SCFLU
   IQL,   "T>charge of particle
   IT,    "T>parameter index in dose scoring arrays DOSE[UN][IS], SCDOSE
   IT1,   "T>looping index used to keep dose output < 80 columns wide
   MAXIT1,"T>the max. value of IT1
   IT2,   "T>another looping index; index for dose curves
   MAXIT2,"T>the max. value of IT2
   TYPE,  "T>graph type = 1 for histogram and = 0 for normal point
   NNZ,   "T>keeps track of non-zero fluence zones
   HADZERO, "T>keeps track of zero bits in inclusive bit filters
   NOCOV; "T>set to 1 if one of the average energy or angle uncertainty
          "  estimates does not include covariance
;REAL
   TOTNUM, "T>keeps track of total # of particles in each scoring zone
   NUMTOT, "T> total # of particles in all scoring planes
   TOTERR, "T>keeps track of error on total # of particles
   TOTflu_uncer; "T>tracks total uncertainty on fluence when grid scoring

  $REAL XPLOT($MAX_DOSE_ZONE),YPLOT($MAX_DOSE_ZONE),ERRY($MAX_DOSE_ZONE);
  CHARACTER*100 SUBTITLE;
  CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
  CHARACTER*3  COMPNUM; "dose component no. in character format"
  integer      egs_open_file;
"*******************************************************************************
"
"                      INITIALIZATION AND OUTPUT
"                      *************************
"
"PRINT OUT FINAL BREM SPLITTING NUMBER"
IF(IBRSPL =  1)[WRITE(IOUTLIST,90)NBRSPL;]

"Print # charged particle steps/# times MS switched off/ratio"
WRITE(IOUTLIST,200) SCSTP,SCSTP2,
SCSTP/(NINCSRC*dble(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/FLOAT(NNPHSP)),
SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
90   FORMAT(/' FINAL BREMSSTRAHLUNG EVENTS CREATE ',I10,' PHOTONS'/);
100  FORMAT(' ',80A1/' ',75X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//
           T28,'SUMMARY OF FLUENCE AND DOSE RESULTS'/
           ' ',T28,'***********************************');
200  FORMAT(/' ',T20,'TOTAL # CHARGED PARTICLE STEPS',T57,
           1PE10.3,' +/-',0PF4.1,'%'/
           ' ',T10,'# CHARGED PARTICLE STEPS/INITIAL HISTORY',T57,
           1PE10.3,' +/-',0PF4.1,'%'/
           ' ','# PRESTA-II STEPS/TOTAL # CHARGED PARTICLE STEPS',T60,
           F7.3,' +/-',0PF4.1,'%');
IF(IRESTART~=4 & ~is_finished)[ "do not keep track of this when combining"
                                "parallel runs"
WRITE(IOUTLIST,
          '(/''        NO. OF BREMSSTRAHLUNG EVENTS IN THIS RUN:'',T60,I12)')
             NUM_BREM;
" MXNP in COMIN SCORE is depth of stack"
WRITE(IOUTLIST,'(/T20,'' Maximum depth of stack='',I8)') MXNP;
]
"
" Summarize incident phase space data"
" ***********************************"

IF(ISOURC = 21 | ISOURC=23 | ISOURC=24)["full phase space data input"
   IF(N_ph_sp_e ~= 0)[E_ph_sp_e = E_ph_sp_e/N_ph_sp_e; "average"]
   IF(N_ph_sp_g ~= 0)[E_ph_sp_g = E_ph_sp_g/N_ph_sp_g; "average"]
   IF(N_ph_sp_p ~= 0)[E_ph_sp_p = E_ph_sp_p/N_ph_sp_p; "average"]
   IF(ISOURC = 21 | ISOURC=24)[
   WRITE(IOUTLIST,'(/T5,''PHASE SPACE SOURCE: Summary of particles '',
''used (not including recycling)''/
'' Used total of'',I10,'' particles, ignored'',I6,
'' multiple passers''/
'' and rejected'',I6,'' photons falling outside the DBS radius at SSD'')')
     N_ph_sp_e+N_ph_sp_g+N_ph_sp_p,NPASS_ph_sp,NFAT_ph_sp;
   ]
   ELSEIF(ISOURC=23)[
   WRITE(IOUTLIST,'(/T5,''BEAM SIMULATION SOURCE: Summary of particles used''/
'' Used total of'',I10,'' particles, and rejected'',I6,'' fat photons'')')
     N_ph_sp_e+N_ph_sp_g+N_ph_sp_p,NFAT_ph_sp;
   ]
   WRITE(IOUTLIST,
    '(/'' Equivalent to'',I10,'' primary histories'')') NHSTRY;
   WRITE(IOUTLIST,'(/'' There were'',I10,'' electrons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_e,E_ph_sp_e;
   WRITE(IOUTLIST,'(/'' There were'',I10,'' photons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_g,E_ph_sp_g;
   WRITE(IOUTLIST,'(/'' There were'',I10,'' positrons with average energy'',
     T55, F9.4,'' MeV'')') N_ph_sp_p,E_ph_sp_p;
   WRITE(IOUTLIST,'(/'' Maximum particle energy was'',F12.3,'' MeV'')')
     E_MAX_ph_sp;
]


" Scoring-plane results (fluence + phase space)
" ********************************************
"
IF (NSC_PLANES >  0) [
   IF (IO_OPT = 0 | IO_OPT >= 3) [
      WRITE(IOUTLIST,
      '(/T20,'' PHASE SPACE FILE OUTPUT''/T20,
             '' ***********************''/)');
      WRITE(IOUTLIST, '('' FILE  SCORE    TOTAL     TOTAL'',
                    ''    MAX. KE OF       MIN. KE OF     # INCIDENT''/
                        ''  #    PLANE  PARTICLES* PHOTONS*'',
                    ''   PARTICLES        ELECTRONS   PARTICLES FROM''/
                        ''                                '',
                    ''      (MeV)            (MeV)    ORIGINAL SOURCE''/)');
      DO ICM=1,MAX_CMs [
         ISCORE=ICM_to_SCORE(ICM);
         IF (ISCORE ~= 0) [
            IF(IRESTART=3|IRESTART=4|is_finished)[
               WRITE(IOUTLIST,'(I4,I7,I11,I9,''**'',F11.4,''**'',F15.4,''**'',
                                F14.3,''**''/)')
               ISCORE,ISCORE,NPPHSP(ISCORE),
               NPHOTPHSP(ISCORE),EKMAXPHSP(ISCORE),EKMINPHSPE(ISCORE),
               NINCPHSP;
            ]
            ELSE[
               WRITE(IOUTLIST,'(I4,I7,I11,I9,F13.4,F17.4,F16.3/)')
               ISCORE,ISCORE,NPPHSP(ISCORE),
               NPHOTPHSP(ISCORE),EKMAXPHSP(ISCORE),EKMINPHSPE(ISCORE),
               NINCPHSP;
            ]
         ]
      ]
   ]
    "End of phase space summary"

   IF(DOSE_STAT=1)[
      WRITE(IOUTLIST,'(//'' ***WARNING***''/
'' Could not read no. of primary (non-phsp) histories from ph-sp source.''/
'' Dose and fluence analyzed assuming each particle read from the ph-sp''/
'' file is an independent history.  May result in an underestimate''/
'' of uncertainties.''//)');
   ]
   IF(OUTCNT>0)[
      WRITE(IOUTLIST,'(//'' ***WARNING***''/
'' The phsp source was restarted at least once.  This may lead''/
'' to an underestimate of uncertainty, especially if restarted''/
'' many times.  If restarted many times, try re-running with''/
'' NRCYCL recalculated as described at top of beamnrc.mortran''//)');
   ]

   WRITE(IOUTLIST,'(//T20,'' FLUENCE RESULTS''/T20, '' ***************''/)');
   IF(OLDSRC=1|OLDSRC=2) [
               WRITE(IOUTLIST,
     '('' ***WARNING: FLUENCE IS NORMALIZED per PARTICLE INCIDENT FROM''/
       ''             PHASE SPACE SOURCE, NOT ORIGINAL SOURCE''//)');
   ]
   DO ICM=1,MAX_CMs ["Radii or half-widths of scoring zones"
      ISCORE=ICM_to_SCORE(ICM);
      IF (ISCORE ~= 0) [
         IF (MZONE_TYPE(ISCORE) = 0)["annular zones"
                  WRITE(IOUTLIST, '(''  CM SCORE POSITION   TOTAL'',
                  T48,  ''ZONE RADII'',/,
           ''     PLANE  (cm)    PARTICLES*'',T47,''   (cm)'')');
           WRITE(IOUTLIST,'(I4,I5,F8.2,I12,5F10.4,/(29X,5F10.4))')
           ICM,ISCORE,Z_min_CM(IPLANE_to_CM(ISCORE)+1),NPFLU(ISCORE),
           (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
         ]
         ELSEIF(MZONE_TYPE(ISCORE) = 1)["square zones"
                  WRITE(IOUTLIST, '(''  CM SCORE POSITION   TOTAL'',
                  T48,  ''ZONE HALF-WIDTHS'',/,
           ''     PLANE  (cm)    PARTICLES*'',T47,''      (cm)'')');
           WRITE(IOUTLIST,'(I4,I5,F8.2,I12,5F10.4,/(29X,5F10.4))')
           ICM,ISCORE,Z_min_CM(IPLANE_to_CM(ISCORE)+1),NPFLU(ISCORE),
           (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NSC_ZONES(ISCORE));
         ]
         ELSEIF(MZONE_TYPE(ISCORE) = 2)[ "Ali:GRID"
            WRITE(IOUTLIST,'(//'' For grid scoring in plane'',I2)') ISCORE;
            WRITE(IOUTLIST,'(/'' XMIN, XMAX, YMIN and YMAX in cm'')');
            WRITE(IOUTLIST,'(4F10.3)') XMIN_ZONE(ISCORE),XMAX_ZONE(ISCORE),
                  YMIN_ZONE(ISCORE),YMAX_ZONE(ISCORE);
            WRITE(IOUTLIST,'('' NX ='',I3,''    NY ='',I3)')
                  NX_ZONE(ISCORE),NY_ZONE(ISCORE);
            WRITE(IOUTLIST,'('' Total no. of scoring zones ='',I5)')
                  NSC_ZONES(ISCORE);
            WRITE(IOUTLIST,'('' X-grid boundaries:'')');
            WRITE(IOUTLIST, '(6F10.3)') "6 here to list them 6 in one line"
                 (RSCORE_ZONE(ISCORE,ISZ),ISZ=1,NX_ZONE(ISCORE)+1);
            WRITE(IOUTLIST,'('' Y-grid boundaries:'')');
            WRITE(IOUTLIST, '(6F10.3)') "6 here to list them 6 in one line"
                 (RSCORE_ZONE2(ISCORE,ISZ),ISZ=1,NY_ZONE(ISCORE)+1);
         ]
      ]
   ]
   WRITE(IOUTLIST, '(/'' *Includes all particles of all weights'')');
   IF(IRESTART=3 | IRESTART=4 | is_finished)[
     WRITE(IOUTLIST,
   '(/'' **Information not available from runs in which previous data''/
      ''   is simply analyzed (IRESTART=3) or combined from parallel''/
      ''   runs (automatically or with IRESTART=4).  The missing phase''/
      ''   space file info is available in the header of the (combined)''/
      ''   phase space file.'')');
   ]
   WRITE(IOUTLIST, '(/''  Lines with zero results are not printed'')');
   NUMTOT=0.;
   DO IPAR=1,8,4 [
         IF (IPAR=1) [
            WRITE(IOUTLIST,
             '(/'' SPECTRAL-AVERAGED QUANTITIES FOR FIRST TIME CROSSINGS OF'',
             '' THE SCORING PLANE''/
             T20,''NORMALIZED per INCIDENT PARTICLE'')');
         ]
         ELSE [
            WRITE(IOUTLIST,
             '(/'' SPECTRAL-AVERAGED QUANTITIES FOR MULTIPLE CROSSINGS OF'',
             '' THE SCORING PLANE''/
             T20,''NORMALIZED per INCIDENT PARTICLE'')');
         ]
      WRITE(IOUTLIST,401);
401   FORMAT(
      ' ZONE        NUMBER            FLUENCE    ',
      '      ENERGY       ANGLE WRT Z-AXIS'/
      '                            (/cm**2)    ',
      '      (MeV)           (degrees)'/
      ' ---- ------------------ ------------------',
      ' ---------------- ----------------');
      NOCOV=0;
      DO ICM=1,MAX_CMs [
         IF (ICM_to_SCORE(ICM) ~= 0) [
            ISCORE=ICM_to_SCORE(ICM);
            WRITE(IOUTLIST,
               '(T25,'' SCORING PLANE'',I2,'', CM'',I3,'':'')') ISCORE,ICM;
            DO IQL=-1,1 [
               IF (IQL=-1) [
                  WRITE(IOUTLIST,'('' ELECTRONS'')') ;
               ]
               ELSEIF (IQL=0) [
                  WRITE(IOUTLIST,'('' PHOTONS'')') ;
               ]
               ELSE [
                  WRITE(IOUTLIST,'('' POSITRONS'')') ;
               ]
               TOTNUM=0.;
               TOTERR=0.;
               TOTflu_uncer=0.;
               NNZ=0;  "counts non-zero fluences"
               DO ISZ=1,NSC_ZONES(ISCORE)+1 ["loop over all scoring zones"
                  IF (SCFLU(IQL+2,ISCORE,ISZ,IPAR) ~= 0.0)["non-zero fluence"
                     IF(SCFLU_NOCOV(IQL+2,ISCORE,ISZ,IPAR/5+1)=1)[
                       WRITE(IOUTLIST,404) ISZ,(SCFLU(IQL+2,ISCORE,ISZ,I),
                       SCFLU2(IQL+2,ISCORE,ISZ,I),
                       I=IPAR,IPAR+$MAX_SC_PARAMETERS/2-1);
                       NOCOV=1;
                     ]
                     ELSE[
                       WRITE(IOUTLIST,402) ISZ,(SCFLU(IQL+2,ISCORE,ISZ,I),
                       SCFLU2(IQL+2,ISCORE,ISZ,I),
                       I=IPAR,IPAR+$MAX_SC_PARAMETERS/2-1);
                     ]
                     NNZ=NNZ+1;
                     NUMTOT=NUMTOT+SCFLU(IQL+2,ISCORE,ISZ,IPAR);
                     IF(ISZ ~= NSC_ZONES(ISCORE)+1 & MZONE_TYPE(ISCORE) = 2)[
                      "not in outer region and scoring a grid"
                      TOTflu_uncer=TOTflu_uncer+SCFLU2(IQL+2,ISCORE,ISZ,IPAR+1);
                      "IPAR +1 is the fluence and its uncertainty"
                     ]
                  ]"end of if that suppresses zero fluence regions"
                  ELSEIF(ISZ=NSC_ZONES(ISCORE)+1)[
                     FLUENCERR(ISCORE)=0;
                  ]"don't print anything about errors in zone 6"
                  IF (NSC_ZONES(ISCORE)>1)[
                     TOTNUM=TOTNUM+SCFLU(IQL+2,ISCORE,ISZ,IPAR);
                     TOTERR=TOTERR+(SCFLU2(IQL+2,ISCORE,ISZ,IPAR)/100.D00
                            *SCFLU(IQL+2,ISCORE,ISZ,IPAR))**2;
                     IF(ISZ=NSC_ZONES(ISCORE)+1 & TOTNUM>0. & NNZ>1)[
                        WRITE(IOUTLIST,403)'Tot',TOTNUM,SQRT(TOTERR)/
                                           TOTNUM*100.;
                        IF ( MZONE_TYPE(ISCORE) = 2) ["a grid scoring area"
                           WRITE(IOUTLIST,405) TOTflu_uncer/(NNZ-1);
                        ]
                     ]
                  ]
                 402 FORMAT(' ',I4,1PE11.3,'+-',0PF5.2,'%',1PE11.3,'+-',
                     0PF5.2,'%',0PF10.3,'+-',0PF4.1,'%',0PF10.3,'+-',
                     0PF4.1,'%');
                 403 FORMAT('   --------------------',/,
                            ' ',A4,1PE11.3,'+-',0PF4.1,'%');
                 404 FORMAT(' ',I4,1PE11.3,'+-',0PF5.2,'%',1PE11.3,'+-',
                     0PF5.2,'%',0PF10.3,'+-',0PF4.1,'%*',0PF10.3,'+-',
                     0PF4.1,'%*');
                 405 FORMAT(' ',19x,'Average fluence uncertainty in grid  ',
                            0PF5.2,'%');
               ]"end of loop in ISZ"
            ]"end of loop on different charges"
            IF(FLUENCERR(ISCORE)=1)[
               WRITE(IOUTLIST,
'(/''***WARNING: RMAX_CM('',I4,'') goes beyond RMAX_CM('',I4,'').  Thus,''/
   ''fluence in outer scoring zone may have contributions from particles''/
   ''exiting from the top of CM '',I4,''.  Since it is difficult to ''/
   ''determine the area of outer zone under these conditions, fluence in''/
   ''outer zone has been normalized by # of incident particles only.''/)')
                  IPLANE_to_CM(ISCORE)+1, IPLANE_to_CM(ISCORE),
                  IPLANE_to_CM(ISCORE)+1;
            ]
         ]
      ]
      IF(NOCOV=1)[
         WRITE(IOUTLIST,
'(/'' *Covariance not included in uncertainty because no. of particles''/
   ''  crossing scoring zone < '',I5)') $COVMIN;
      ]
   ]
    "End of fluence summary"
   "output min and max overall particle weights"
  IF(IRESTART < 2 & ~is_finished)[
   IF(NUMTOT=0.) MINWEIGHT=0.; "reset from 999 if no particles scored"
   IF(MINWEIGHT > 0.0000030 )[
      WRITE(IOUTLIST,
            '(//'' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = '',F12.7/
                '' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = '',F12.7,/)')
                MINWEIGHT,MAXWEIGHT;
      OUTPUT MINWEIGHT,MAXWEIGHT;
            (//' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = ',F12.7/
               ' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = ',F12.7/);
   ]
   ELSE[
      WRITE(IOUTLIST,
            '(//'' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = '',1PE12.5/
                '' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = '',0PF12.7,/)')
                MINWEIGHT,MAXWEIGHT;
      OUTPUT MINWEIGHT,MAXWEIGHT;
            (//' MIN PARTICLE WEIGHT FOR ALL SCORING ZONES = ',1PE12.5/
               ' MAX PARTICLE WEIGHT FOR ALL SCORING ZONES = ',0PF12.7/);
   ]
  ]
]

" Dose zone results
" *****************
IF (NDOSE_ZONE ~= 0) [
   WRITE(IOUTLIST,'(/T30,'' DOSE RESULTS''/
                 T30,'' ************''/)');
   IF(OLDSRC=1|OLDSRC=2) [
               WRITE(IOUTLIST,
       '('' ***WARNING: DOSES ARE NORMALIZED per PARTICLE INCIDENT FROM''/
         ''             PHASE SPACE SOURCE, NOT ORIGINAL SOURCE''//)');
   ]
   IF(IREJCT_GLOBAL = 1 & ESAVE_GLOBAL ~= 0. & ESAVE_GLOBAL > ECUTIN) [
     WRITE(IOUTLIST,'(T10,'' ***NOTE***''/
            T10,''Automated range rejection is being used.''/
            T10,''This implies doses will be inaccurate because''/
            T10,''of changes in ECUTRR going from on CM to the next.''/)');
   ]
   "print # charged particle steps in dose region"
   WRITE(IOUTLIST,210) SCDSTP,SCDSTP2,
         SCDSTP/(NINCSRC*dble(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/
         FLOAT(NNPHSP)),SCDSTP2;

   "Print a summary of the dose zone results"
   WRITE(IOUTLIST,300);
   WRITE(IOUTLIST,302)
      (ID,AMASS(ID),SCDOSE(ID,1),SCDOSE2(ID,1),(AMASS(ID)/1000.)*SCDOSE(ID,1),
      SCDOSE2(ID,1),ID=1,NDOSE_ZONE);
   IF(IBRSPL=2)["print total non-fat dose for DBS"
     WRITE(IOUTLIST, *);
     WRITE(IOUTLIST,305);
     WRITE(IOUTLIST,302)
      (ID,AMASS(ID),SCDOSE(ID,2),SCDOSE2(ID,2),(AMASS(ID)/1000.)*SCDOSE(ID,2),
      SCDOSE2(ID,2),ID=1,NDOSE_ZONE);
   ]
   IF( ITDOSE_ON=1) [

      IF( ICM_CONTAM >= 1) [
         WRITE(IOUTLIST, *);
         WRITE(IOUTLIST,304)ICM_CONTAM;
         WRITE(IOUTLIST,302)(ID,AMASS(ID),SCDOSE(ID,3),SCDOSE2(ID,3),
             (AMASS(ID)/1000.)*SCDOSE(ID,3),SCDOSE2(ID,3),ID=1,NDOSE_ZONE);
      ]
      WRITE(IOUTLIST, *);
      IF(LNEXC+LNINC>0)[
        WRITE(IOUTLIST,
            '(/T22,'' DOSE RESULTS WITH BIT FILTERS''/
            T30,'' ************''/)');
        WRITE(IOUTLIST,
            '(T5,''BIT FILTER SUMMARY''/
              T5,''******************''/)');
        WRITE(IOUTLIST,
        '(T2,''COMPONENT  FILTER                      BIT''/,
        T2,''   #        TYPE                        #s''/)');
        IF(LNEXC > 0)[
          DO I=4,3+LNEXC[
            WRITE(IOUTLIST,:FILTFORM1:)I-3,'EXCLUDE';
            DO J=1,31[
              IF(L_N_EXC(I,J) ~= 0)[
                 WRITE(IOUTLIST,:FILTFORM2:)L_N_EXC(I,J);
              ]
              ELSE[
                 EXIT;
              ]
            ]
          WRITE(IOUTLIST,'('' '')');
          ]
        ]
        IF(LNINC > 0)[
          DO I=4+LNEXC,3+LNEXC+LNINC[
            WRITE(IOUTLIST,:FILTFORM1:)I-3,'INCLUDE';
            HADZERO=0;
            DO J=1,31[
              IF(L_N_INC(I,J) ~= 0)[
                 WRITE(IOUTLIST,:FILTFORM2:)L_N_INC(I,J);
              ]
              ELSEIF(HADZERO=0 & L_N_INC(I,J)=0 & L_N_INC(I,J+1)~=0)[
                 HADZERO=1;
                 WRITE(IOUTLIST,:FILTFORM3:)'-';
              ]
              ELSE[
                 EXIT;
              ]
            ]
          WRITE(IOUTLIST,'('' '')');
          ]
        ]
        IF(MOD((LNEXC+LNINC),3)~=0|LNEXC+LNINC=0)[
          MAXIT1=AINT((LNEXC+LNINC)/3.)+1;
        ]
        ELSE[
          MAXIT1=AINT((LNEXC+LNINC)/3.);
        ]
        IT=3;
        DO IT1=1,MAXIT1[
          WRITE(IOUTLIST, '(/'' DOSE '', $)' );
          WRITE(IOUTLIST, '(2X, ''   DOSE   '', $ )');
          IF(IT1=MAXIT1)[
            MAXIT2=LNEXC+LNINC-(IT1-1)*3;
          ]
          ELSE[
            MAXIT2=3;
          ]
          DO IT2=1,MAXIT2[
            WRITE(IOUTLIST, '(7X, ''    DOSE     '', $ )');
          ]
          WRITE(IOUTLIST, *);
          WRITE(IOUTLIST, '('' ZONE '', $)' );
           WRITE(IOUTLIST, '(2X,''   TOTAL   '' , $ )');
          DO IT2=1,MAXIT2[
               WRITE(IOUTLIST, '(7X, ''COMPONENT:'',I2,''  '', $ )')
                    IT2+(IT1-1)*3;
          ]
          WRITE(IOUTLIST, *);
          DO ID=1,NDOSE_ZONE [
            WRITE(IOUTLIST, '(/I4,$ )' ) ID;
            WRITE(IOUTLIST, '(1X,1PE10.3, "+/-",0PF4.1,"%", $ )')
            SCDOSE(ID,1), SCDOSE2(ID,1);
            DO IT2=1,MAXIT2[
               WRITE(IOUTLIST, '(1X,1PE10.3, "+/-",0PF4.1,"%", $ )')
               SCDOSE(ID,IT+IT2), SCDOSE2(ID,IT+IT2)
            ]
          ]   " end of the do id loop "
          WRITE(IOUTLIST,*);
          WRITE(IOUTLIST,*);
          IT=IT+MAXIT2;
        ] "end of the do it1 loop
      ]"end of if LNEXC+LNINC>0
   ]"end of if itdose_on"

   "Plot of dose zone results to file [-.egsplot]"
   IOUTPLOT = egs_open_file(IOUTPLOT,0,0,'.egsplot');
   IF( IOUTPLOT > 0 ) [
       TYPE=1;"histogram as default, but it can be changed to normal
              "point plot by setting to 0"

       IF(IPLOTFLAG.EQ.0)[
          DO ID=1,NDOSE_ZONE[XPLOT(ID)=FLOAT(ID);]
          XTITLE='DOSE ZONE NUMBER';
       ]
       ELSE[
          XTITLE='Z (cm)';
          IF(TYPE.EQ.0)[
             DO ID=1,NDOSE_ZONE[XPLOT(ID)=(ZPLOTCHM(ID)+ZPLOTCHM(ID+1))/2.;]
          ]
          ELSE[
             DO ID=1,NDOSE_ZONE[XPLOT(ID)=ZPLOTCHM(ID+1);]
          ]
       ]
       DO ID=1,NDOSE_ZONE[
          YPLOT(ID)=SCDOSE(ID,1);
          ERRY(ID)=SCDOSE2(ID,1)*SCDOSE(ID,1)/100.;
       ]
       YTITLE='ABSORBED DOSE PER INCIDENT PARTICLE (Gy)';
       GRAPHTITLE='Dose Simulation Using BEAMnrc';
       SERIESTITLE='total';
       IT2=0;
       "plot histogram"
       CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2,SERIESTITLE,
         XTITLE, YTITLE, GRAPHTITLE, TITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);

       IF(IBRSPL=2)["plot total-fat dose"
         DO ID=1,NDOSE_ZONE[
          YPLOT(ID)=SCDOSE(ID,2);
          ERRY(ID)=SCDOSE2(ID,2)*SCDOSE(ID,2)/100.;
         ]
         SERIESTITLE='total-fat';
         IT2=IT2+1;
         CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2,SERIESTITLE,
         XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);
       ]

       IF(ITDOSE_ON=1)[
         IF(ICM_CONTAM>=1)[
            DO ID=1,NDOSE_ZONE[
              YPLOT(ID)=SCDOSE(ID,3);
              ERRY(ID)=SCDOSE2(ID,3)*SCDOSE(ID,3)/100.;
            ]
            SERIESTITLE='contaminant';
            IT2=IT2+1;
            CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2, SERIESTITLE,
              XTITLE, YTITLE, GRAPHTITLE, TITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);
         ]
         DO IT=4,3+LNEXC+LNINC [
            DO ID=1,NDOSE_ZONE[
              YPLOT(ID)=SCDOSE(ID,IT);
              ERRY(ID)=SCDOSE2(ID,IT)*SCDOSE(ID,IT)/100.;
            ]
            IT2=IT2+1;
            IF(IT-3<10)[
               COMPNUM=CHAR((IT-3)+48);
            ]
            ELSEIF(IT-3<100)[
               COMPNUM=CHAR((IT-3)/10+48)//CHAR(MOD((IT-3),10)+48);
            ]
            ELSEIF(IT-3<1000)[
               COMPNUM=CHAR((IT-3)/100+48)//CHAR(MOD((IT-3),100)/10+48)//
                       CHAR(MOD(MOD((IT-3),100),10)+48);
            ]
            ELSE[ "do not label components past 999"
               COMPNUM=' ';
            ]
            SERIESTITLE='component '//COMPNUM;
            CALL XVGRPLOT(XPLOT, YPLOT, ERRY, NDOSE_ZONE, IT2, SERIESTITLE,
               XTITLE, YTITLE, GRAPHTITLE, TITLE,IOUTPLOT, TYPE, ZPLOTCHM(1),0);
         ]
       ]
       CLOSE(IOUTPLOT);
   ]
   ELSE [
       write(i_log,*);
       write(i_log,*)
     ' ************ failed to open .egsplot file for writing ********** ';
       write(i_log,*);
   ]
]
210  FORMAT(' ',T12,'TOTAL # CHARGED PARTICLE STEPS in DOSE REG.',T57,
             1PE10.3,' +/-',0PF4.1,'%'/
             ' ','# CHARGED PARTICLE STEPS in DOSE REG./INITIAL HISTORY',T57,
             1PE10.3,' +/-',0PF4.1,'%'/);
300 FORMAT(' ',T15,'TOTAL DOSE PER INCIDENT PARTICLE'/
             /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
             /T5,'ZONE      (g)           (Gy)                 (J)',
             /T5,'---- -----------  ------------------  ------------------');
302  FORMAT(' ',I6,3X,1PE10.3,2X,1PE10.3,'+/-',0PF4.1,'%',
            2X,1PE10.3,'+/-',0PF4.1,'%');
"303 FORMAT(' ',T10,'T-S  DOSE PER INCIDENT PARTICLE FOR ION CHAMBER'/
            " /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
            " /T5,'ZONE      (g)           (Gy)                 (J)',
            " /T5,'---- -----------  ------------------  ------------------');
304 FORMAT(' ',T10,'CONTAMINANT DOSE/INCIDENT PARTICLE FOR CM',I3/
             /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
             /T5,'ZONE      (g)           (Gy)                 (J)',
             /T5,'---- -----------  ------------------  ------------------');
305 FORMAT(' ',
'TOTAL DOSE EXCLUDING FAT PARTICLES PER INCIDENT PARTICLE (DBS ONLY)'/
             /T5,'DOSE     MASS           DOSE          ENERGY DEPOSITED '
             /T5,'ZONE      (g)           (Gy)                 (J)',
             /T5,'---- -----------  ------------------  ------------------');
:FILTFORM1: FORMAT(T2,I4,A14,T25,$);
:FILTFORM2: FORMAT(I5,$);
:FILTFORM3: FORMAT(A5,$);

RETURN;

END; "End of subroutine OSUMRY"
%L    TURN LISTING BACK ON IN CASE OFF IN MACRO FILE
%E     "beamnrc.mortran - start subroutine isource                        "
"*******************************************************************************
"
                            SUBROUTINE ISOURCE;
"                           ******************
"*******************************************************************************
"
"   Source input routine for BEAMnrc, particle position, direction, and energy.
"
"     This subroutine handles the inputs assoiciated with various source
"     options. For ISOURC<21, info re source energies are read here too.
"     Associated routines are:
"         SRCOUT   describes source for listing file
"         SRCOTO   does one time only source initialization
"         SRCHST   initializes variable for each history
"
"     Other options can be added - must get ISOURC and MONOEN (COMIN
"      USER-VARIANCE-REDIUCTION and IQIN from COMIN SCORE
"
"*******************************************************************************
"
"
$IMPLICIT-NONE;
;COMIN/CMs,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,
       ENERGYSRC,RWPHSP,EGS-IO/;

"T>*****************************
"T>TYPE DECLARATIONS FOR ISOURCE
"T>*****************************
"T>
INTEGER I, "T>a loop index"
"        SWAPYES, T>set to 1 if you have to swap bytes in the phsp source"
"        IOS, T>an io status indicator"
        TEMPINT, "T>a dummy integer"
        LATCHM,NHSTRYM,IQINM,NPASSM, "T> temp. variables for source 21"
        egs_get_unit,i_spect,i_spcnam,len,ilen,lnblnk1,IZLAST1;
$REAL
   FNORM, "T>normalization for direction cosines
   TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8, "T>for general use
   EINM,XINM,YINM,UINM,VINM,WTM,ZINM,WINM,Z_SCORE;
                                "T> temp. variables for source 21"

CHARACTER*256 TEXT;

COMIN/BMODEL/;

$LONG_INT tmp_long;

"*******************************************************************************
"
"                      INITIALIZATION AND INPUT
"                      ************************
"
INIT_ICM=0; "initialization "
MONOEN = 0; "Monoenergetic source"

OUTPUT;(' CHARGE OF THE INCIDENT BEAM(-1,0,1),'/' SOURCE CONFIGURATION');
OUTPUT;('      (0) Parallel beam incident from the front:(0),radius(cm),'/
        '                    incident direction cosines (U,V,W)'/);
OUTPUT;('  or  (1) Point source on axis incident from the front,'/
        '           DISTZ,distance of source to VERY front of first CM.'/
        '           RBEAM,beam radius (cm) or flag indicating rectangular(<0),'/
        '           GAMMA,1/2 angle(degrees) of source if RBEAM=0.0,'/
        '           XINL,XINU,YINL,YINU, dimensions of rectangular beam if'/
        '           RBEAM<0.'/);
OUTPUT;('  or  (3) Uniform isotropically radiating source incident within CMs:'/
        '          inner radius of vertical ring (if next input >=0) or Z'/
        '          of centre of horizontal cylinder (if next input < 0) in cm,'/
        '          outer radius of vertical ring (if >=0) or -radius of '/
        '          horizontal cylinder (if <0) in cm, Z of top of vertical'/
        '          ring or min. X of horizontal cylinder in cm, Z of bottom'/
        '          of vertical ring or max. X of horizontal cylinder in cm,'/
        '          i_dsb (set to 1 to use directional source biasing),'/
        '          splitcm_dsb (CM no. at which, upon entering, photons '/
        '          are split and radially redistributed--set to 0 for no'/
        '          splitting/redistribution), dsb_delta (min. linear distance'/
        '          between split/redistributed photons projected to SSD'/
        '          in cm)'/);
OUTPUT;('  or  (5) NRC swept beam, cone 1/2 angle (in degrees)'/
        '                    radius of beam spot (in cm)'/);
OUTPUT;('  or  (6) Parallel rectangular beam incident along Z-axis:(6),'/
        '                    centred at (Xo,Yo), half-widths: Xh, Yh (cm)'/
        '                    (0, 6, Xo, Yo, Xh, Yh)'/);
OUTPUT;('  or  (7) Scanning beam, scanning field size to 100 cm '/
        '                    ratio of the frequencies in Y/X directions'/
        '                    spot size at the initial point. '/);
OUTPUT;('  or  (8) Scanning point source for MM50--uniform field coverage:'/
        '                    (8), SSD (defaults to 100 cm), radius of'/
        '                    field at SSD (defaults to RMAX_CM(1)), radius'/
        '                    of beam spot at Z=0 (defaults to 0).'/
        '                    Note that this option assumes the point'/
        '                    source is at Z=0'/);
OUTPUT;('  or  (9) Scanning point source for MM50--discrete field coverage:'/
        '                    (9), SSD (defaults to 100 cm), # of '/
        '                    discrete points at SSD.'/
        '                    Note that this option assumes the point'/
        '                    source is at Z=0'/);
OUTPUT;('  or (10) Parallel circular beam incident on an x-ray target:'/
        '                    (10), radius(cm), direction cosines (U,V)'/
        '                    default to (-1,0), (W is set to 0)'/);
OUTPUT;('  or (13) Parallel rectangular beam incident on an x-ray target:'/
  '                    (13), half-width(cm), half-height (cm)'/
  '                    direction cosines (U,V,W), default to (-1,0,0)'/);
OUTPUT;
('  or (15) NRC swept beam with radial divergence and intensity distribution:'/
'                    (15),cone 1/2 angle (in degrees), Z of apex of cone (cm),'/
'                    radius at which beam divergence angle is defined (cm),'/
'                    beam divergence angle (degrees)'/);
OUTPUT;('  or (19) Parallel elliptical beam with gaussian in X and Y:'/
        '                (19),sigma of gaussian distribution in X (if > 0) or'/
        '                -FWHM of gaussian distribution in X (if < 0) in cm,'/
        '                incident direction cosines (U,V,W),'/
        '                mean angular spread (degrees, none if <=0,'/
        '                if set >0 then overrides U,V,W inputs),'/
        '                sigma (if > 0) or -FWHM (if < 0) of gaussian'/
        '                distribution in Y in cm (if = 0 then defaults to'/
        '                value in X-direction)'/);
OUTPUT;('  or (21) Full phase-space of each particle read from unit 42'/
        '                    component module # '/
        '                      (particles incident on the front of this CM),'/
        '                    no. of times to recycle each particle'/
        '                      (calculated automatically if set to 0),'/
        '                    no. of parallel jobs (if using pprocess script),'/
        '                    job no. (if using pprocess),'/
        '                    ISRC_DBS (1 if source generated using DBS),'/
        '                    RSRC_DBS,SSDSRC_DBS (splitting radius, SSD used'/
        '                       to generate this source--only if ISRC_DBS=1),'/
        '                    ZSRC_DBS (Z where the source was generated--'/
        '                       only if ISRC_DBS=1)'/
        '                    (0, 21, INIT_ICM, 0,0,0,0,0,0,0)'/);
OUTPUT;
   ('  or (23) Full BEAM simulation source incident from user-defined angle'/
        '                    component module # '/
        '                      (particles incident on the front of this CM),'/
        '                    ISRC_DBS (1 if source using DBS),'/
        '                    angle of rotation about X axis (ALPHA24),'/
        '                    angle of rotation about Y axis (BETA24),'/
'                    distance of point of rotation above INIT_ICM (DIST24)'/
     '                    (0, 23, INIT_ICM, ISRC_DBS,ALPHA24,BETA24,DIST24)'/);
OUTPUT;('  or (24) Full phase-space incident from user-defined angle'/
        '          Input line 1:'/
        '                    component module # '/
        '                      (particles incident on the front of this CM),'/
        '                    no. of times to recycle each particle'/
        '                      (calculated automatically if set to 0),'/
        '                    no. of parallel jobs (if using pprocess script),'/
        '                    job no. (if using pprocess),'/
        '                    ISRC_DBS (1 if source generated using DBS),'/
        '                    RSRC_DBS,SSDSRC_DBS (splitting radius, SSD used'/
        '                       to generate this source--only if ISRC_DBS=1),'/
        '                    ZSRC_DBS (Z where the source was generated--'/
        '                       only if ISRC_DBS=1)'/
        '                    (0, 24, INIT_ICM, 0,0,0,0,0,0,0)'/
        '          Input line 2:'/
        '                    angle of rotation about X axis (ALPHA24),'/
        '                    angle of rotation about Y axis (BETA24),'/
'                    distance of point of rotation above INIT_ICM (DIST24)'/);
OUTPUT;('  or (31) Beam characterization model, component module #',/
        '                    (particles incident on the front of this CM)'/
        '                    (0, 31, CMSOU,0.,0.,0.)'/);
OUTPUT;(' IQIN,ISOURC, up to 8 reals: ',$);
;MINPUT (ISOURCE) IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8;
(2I12,8F15.0);
IF( ISOURC < 0 ) [
    ISOURC = -ISOURC; INIT_ICM = -1;
]
IF( ISOURC > 1000 ) [
    INSIDE_FLAG = ISOURC/1000; ISOURC = ISOURC - INSIDE_FLAG*1000;
]
ELSE [ INSIDE_FLAG = 0; ]
IF( INIT_ICM < 0 ) [
    ;MINPUT (ISOURCE) Z_SOURCE; (F15.0);
]

OUTPUT IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8;
(I4,I4,8F10.4);
IF((IQIN  < -1) |  (IQIN >  1)) IQIN=0;
IF(ISOURC < 21)OUTPUT IQIN;(T20,' SOURCE CHARGE is ',I3);
OUTPUT ISOURC; (T20,' ISOURC =',I3);
IF( INSIDE_FLAG > 0 ) [ OUTPUT INSIDE_FLAG; (T20,' IFLAG  =',I3); ]

" ISOURC = 0   Frontal parallel beam"
" **********
IF(ISOURC = 0)[
    RBEAM=TEMP1;
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=0.0;VINC=0.0;WINC=1.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    OUTPUT RBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT FROM THE FRONT(+VE Z-AXIS)'/
        ' RADIUS OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    TEMP5=1.E30;  "Radius limited to RMAX_CM(1) in SRCOTO"
    IF ((RBEAM  < 0.0) |  (RBEAM >  TEMP5)) RBEAM=TEMP5;
    100 FORMAT(' ',2(I2,' '),4(G14.6),', IQIN,ISOURCE etc');
    200 FORMAT(' ',I1);
    300 FORMAT(' ',I3);
    400 FORMAT(' ',2(G14.7,' '));
    500 FORMAT(' ',79('*')//T30,'SOURCE PARAMETERS'//' ',79('*')/);
]

" ISOURC = 1 FRONTAL POINT SOURCE"
" **********
ELSEIF(ISOURC = 1)[
    DISTZ=TEMP1;RBEAM=TEMP2;GAMMA= TEMP3;
    IF(RBEAM<0.)["rectangular beam"
       XINL=TEMP4;XINU=TEMP5;YINL=TEMP6;YINU=TEMP7;
    ]
    IF (DISTZ <= 0.0) DISTZ=100.;
    IF (RBEAM > 0.0 & GAMMA ~=0.0)[
      OUTPUT RBEAM,GAMMA; (//' ****Beam radius (=',F10.3,') and half-angle(=',
      F10.3,') are both non-zero****'/' We ignore the half-angle'//);
      GAMMA = 0.0;
    ]
    IF (RBEAM > 0.0)[
       OUTPUT DISTZ,RBEAM;
          (' Point source on axis incident from the front'/
           ' Distance OF  source to VERY front of first CM:',T60,F10.4,' cm'/
           ' Radius of the beam at front of first CM:', T60,F10.4,' cm'/);
    ]
    ELSEIF (RBEAM < 0.0)[
       OUTPUT DISTZ,XINL,XINU,YINL,YINU;
          (' Point source on axis incident from the front'/
           ' Distance of  source to VERY front of first CM:',T60,F10.4,' cm'/
           ' Beam is rectangular on front of first CM with:'/
           '             X boundaries:',F10.4,' - ',F10.4,' cm'/
           '             Y boundaries:',F10.4,' - ',F10.4,' cm'/);
    ]
    ELSE [
       OUTPUT DISTZ,GAMMA;
          (' Point source on axis incident from the front'/
           ' Distance of  source to VERY front of first CM:',T60,F10.4,' cm'/
           ' Half-angle of circular source =',T60,F10.4,' deg'/);
    ]

    IF(RBEAM=0. & GAMMA < 0.0) [OUTPUT GAMMA;(/'  ****Asked for negative angle'
       ,'=',F12.3/'      Its absolute value is used');
       GAMMA = ABS(GAMMA);
    ]
    IF (RBEAM=0. & GAMMA >= 90.)[
      OUTPUT;(//' ***Half-angle must be less than 90 degrees to hit target'/
      '     Angle reduced to 89 degrees'//);
      GAMMA = 89.;
    ]
]

ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING DISK"
    RBEAM=TEMP2;
    RBEAM2 = RBEAM**2;
    RMINBM = TEMP1;
    IF(RBEAM >= 0)[
       IF(RMINBM < 0)[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/ ' RMINBM < 0'//);
          IF(RBEAM=0)[
             OUTPUT;(//' NB: IF YOU WANT A HORIZONTAL CYLINDER OF 0 RADIUS,'/
                       '     SET RBEAM TO A VERY SMALL -VE NUMBER'//);
          ]
          $CALL_EXIT(1);
       ]
       IF(RMINBM > RBEAM)[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/ ' RMINBM > RBEAM'//);
          IF(RBEAM=0)[
             OUTPUT;(//' NB: IF YOU WANT A HORIZONTAL CYLINDER OF 0 RADIUS,'/
                       '     SET RBEAM TO A VERY SMALL -VE NUMBER'//);
          ]
          $CALL_EXIT(1);
       ]
       RMINSQ = RMINBM**2;
    ]
    ZSMIN=TEMP3;ZSMAX=TEMP4;
    IF(ZSMIN > ZSMAX)[
       OUTPUT;(//' ***ERROR IN SOURCE 3:'/ ' ZSMIN > ZSMAX'//);
       $CALL_EXIT(1);
    ]
    IF(RBEAM >= 0)[
       OUTPUT RMINBM,RBEAM,ZSMIN,ZSMAX;
       (' UNIFORM ISOTROPICALLY RADIATING RING CENTRED ON Z-AXIS:'/
        ' INNER RADIUS:',T60,F10.4,' cm' /
        ' OUTER RADIUS:',T60,F10.4,' cm' /
        ' Z OF TOP OF RING:',T60,F10.4,' cm' /
        ' Z OF BOTTOM OF RING:',T60,F10.4,' cm' /);
    ]
    ELSE[
       OUTPUT ABS(RBEAM),RMINBM,ZSMIN,ZSMAX;
       (' UNIFORM ISOTROPICALLY RADIATING CYLINDER CENTRED || TO X-AXIS:'/
        ' RADIUS:',T60,F10.4,' cm' /
        ' Z POSITION OF CENTRE OF CYLINDER:',T60,F10.4,' cm'/
        ' MIN. X OF CYLINDER:',T60,F10.4,' cm' /
        ' MAX. X OF CYLINDER:',T60,F10.4,' cm' /);
    ]
    i_dsb=temp5; dsb_aeff = 1;
    IF(i_dsb=1)[
      IF(IBRSPL=2)[
          splitcm_dsb=temp6; dsb_delta=temp7;
          OUTPUT; (' Directional source biasing (DSB) used in conjunction with'/
              ' directional bremsstrahlung splitting (DBS).'/);
          IF(splitcm_dsb <= 0 ) [
             OUTPUT; (' NOT USING ROTATIONAL SYMMETRY'/);
              write(*,*) '===> split_cm = ', splitcm_dsb;
          ]
          ELSE [
            IF( dsb_delta > 0 ) [
              call dsb_init_sampling(dsb_delta,fs,dsb_aeff,$DSB_MAX_BIN,
                             dsb_nbin,dsb_rbin,dsb_prob,dsb_ibin);
            ]
            IF( dsb_delta > 0 ) [
              OUTPUT splitcm_dsb,dsb_delta*fs,dsb_nbin,dsb_aeff;
              (' Particles will be split on entering CM no. ',I10/
              ' and rotated to positions at least ',F12.5,' cm apart.'/
              ' This requires ',i4,' sampling bins and has Aeff = ',f8.5/);
            ]
            ELSE [
              OUTPUT; (' NOT USING ROTATIONAL SYMMETRY'/);
              write(*,*) '===> dsb_delta = ', dsb_delta;
            ]
          ]
      ]
      ELSE[
       OUTPUT;
          (' Directional source biasing (DSB) selected, but directional'/
           ' bremsstrahlung splitting (DBS) is not.  DSB requires DBS.'/
           ' DSB turned off for now.'/);
          i_dsb=0;
      ]
    ]
    ELSE[
       i_dsb=0;
    ]
]

" ISOURC = 5   NRC swept beam"
" **********
ELSEIF(ISOURC = 5)[
    GAMMA=TEMP1;RBEAM=TEMP2;
    IF(GAMMA < 0.0) [OUTPUT GAMMA;(/'  ****Asked for negative angle'
       ,'=',F12.3,'deg'/'      Its absolute value is used');
       GAMMA = ABS(GAMMA);
    ]
    IF(RBEAM < 0.0) [OUTPUT RBEAM;(/'  ****Asked for negative BEAM RADIUS'
       ,'=',F12.3/'      It is set to zero');
       RBEAM = 0.0;
    ]
    "RBEAM > area of CM handled below"
    IF(GAMMA > 89.0) [OUTPUT;(/' ***REDUCED GAMMA to 89 degrees');
      GAMMA = 89.;
    ]
    "It is hard to do more checks since large angles may be valid here"
    OUTPUT GAMMA,RBEAM;
       (' NRC SWEPT BEAM '/
        ' Half angle of cone',T60,F10.4,' deg'/
        ' RADIUS OF THE BEAM SPOT AT FRONT of FIRST CM:',
        T60,F10.4,' cm'/);
]

" ISOURC = 6  Frontal parallel beam with rectangular field"
" **********
ELSEIF(ISOURC = 6)[
    XBEAM0=TEMP1;YBEAM0=TEMP2;XBEAM=TEMP3;YBEAM=TEMP4;
    UINC=0.0;VINC=0.0;WINC=1.0;"beam along z-axis"
    OUTPUT XBEAM0,YBEAM0,XBEAM,YBEAM;
       (' PARALLEL RECTANGULAR BEAM INCIDENT ALONG Z-AXIS'/
        ' CENTRED AT (Xo,Yo) = (',T60,2F10.4,')'/
        ' HALF-WIDTH IN X DIRECTION:',T60,F10.4/
        ' HALF-WIDTH IN Y DIRECTION:',T60,F10.4/
        ' (Note: beam edge limited to simulation geometry later!)'/);
    "note: Beam edge will be limited to RMAX_CM(1) in SRCOTO"
]

ELSEIF(ISOURC = 22)[
    XBEAM0=TEMP1;YBEAM0=TEMP2;XBEAM=TEMP3;YBEAM=TEMP4;
    UINC=0.0;VINC=0.0;WINC=1.0;"beam along z-axis"
    OUTPUT XBEAM0,YBEAM0,XBEAM,YBEAM;
    (' PARALLEL RECTANGULAR RING INCIDENT ALONG Z-AXIS'/
     ' CENTRED AT (Xo,Yo) = (',T60,2F10.4,')'/
     ' HALF-WIDTH IN X DIRECTION:',T60,F10.4/
     ' HALF-WIDTH IN Y DIRECTION:',T60,F10.4/
     ' (Note: beam edge limited to simulation geometry later!)'/);
      "note: Beam edge will be limited to RMAX_CM(1) in SRCOTO"
]

" ISOURC = 7   the scanning beam  "
"*********
ELSEIF(ISOURC = 7) [
      FD_AT100=TEMP1;
      IF( FD_AT100<=0.0 )
      [OUTPUT; (' SCANNING FIELD SIZE ERROR!!!'); $CALL_EXIT(1); ]
      IRATIO_YXF=TEMP2*2;
      IF(IRATIO_YXF<=0) [ IRATIO_YXF=13; ]  " default to manufacture set"
      IF( MOD(IRATIO_YXF, 2)=0 )[ IRATIO_YXF=IRATIO_YXF+1; ]
                " set to odd number, see the scanning system ref. "
      XSCAN_UNIT=FD_AT100*2.0/IRATIO_YXF; " the scanning step for half cycle
      RBEAM=TEMP3;
      IF( RBEAM<=0.0 ) [ RBEAM=0.01; ]  " default size "
      OUTPUT  FD_AT100, IRATIO_YXF, RBEAM;
              (' SCANNING BEAM WITH: ',
              /'          SCANNING FIELD SIZE AT SSD=100 : ', F15.7,
              /'          THE FREQUENCY RATIO BETWEEN Y/X: ', I5,
              /'          THE SPOT SIZE AT THE INITIAL POINT:', F15.7);
]

" ISOURC = 8   scanned point source uniform on xy plane for MM50  "
"*********

ELSEIF(ISOURC = 8)[
    DISTZ=TEMP1;RBEAM=TEMP2;RBEAM0=TEMP3;
    IF (DISTZ <= 0.0) DISTZ=100.;
    IF (RBEAM0 < 0.0) RBEAM0=0.;
    IF (RBEAM > 0.0)[
        OUTPUT DISTZ,RBEAM,RBEAM0;
        (' MM50 scanned point on axis at Z=0, uniform circular field at SSD'/
         ' SSD                      :',T60,F10.4,' cm'/
         ' radius of the beam at SSD :', T60,F10.4,' cm'/
         ' radius of beam spot at Z=0 :',T60,F10.4,' cm'/);
    ]
    IF(RBEAM <= 0.0) [OUTPUT RBEAM;(/'  ****Asked for negative BEAM RADIUS'
       ,'=',F12.3/'      It will be reset to RINMAX.');
       "RINMAX is related to RMAX_CM(1) which is not available yet"
    ]
]

" ISOURC = 9   discrete point source on xy plane for MM50  "
"*********

ELSEIF(ISOURC = 9)[
    DISTZ=TEMP1;NPTS_SRC9=TEMP2;
    IF (DISTZ <= 0.0) DISTZ=100.;
    IF(NPTS_SRC9>$MAXPTS_SRC9)[
       NPTS_SRC9=$MAXPTS_SRC9;
       OUTPUT $MAXPTS_SRC9; (//'***WARNING IN SOURCE 9'/
              ' Number of discrete points chosen > max. allowed'/
              ' Number of points reduced to',I4//);
       WRITE(IOUTLIST,
          '(//''***WARNING IN SOURCE 9''/
          '' Number of discrete points chosen > max. allowed''/
          '' Number of points reduced to'',I4//)') $MAXPTS_SRC9;
    ]
    ELSEIF(NPTS_SRC9<=0)[
       NPTS_SRC9=1;
       OUTPUT; (//'***WARNING IN SOURCE 9'/
              ' Number of discrete points chosen <= 0'/
              ' Number of points reset to 1'//);
       WRITE(IOUTLIST,
          '(//''***WARNING IN SOURCE 9''/
          '' Number of discrete points chosen <= 0''/
          '' Number of points reset to 1''//)');
    ]
    OUTPUT DISTZ,NPTS_SRC9;
     (/' MM50 SCANNED POINT SOURCE ON AXIS AT Z=0, DISCRETE COVERAGE AT SSD'/
       '                              SSD:',T60,F10.4,' cm'/
       ' NUMBER OF DISCRETE POINTS AT SSD:', T60,I10,/);
    OUTPUT NPTS_SRC9; (' INPUT (X,Y,PROBABILITY) FOR THE',I4,
                  ' DISCRETE POINTS AT THE SSD:');
    FNORM = 0.0;
    DO I=1,NPTS_SRC9[
       OUTPUT I;(' For point ',I4,' X,Y,prob : ',$);
       ;MINPUT (ISOURCE) X_SRC9(I),Y_SRC9(I),PROB_SRC9(I);(3F15.0);
       OUTPUT X_SRC9(I),Y_SRC9(I),PROB_SRC9(I); (3F10.4);
       FNORM=FNORM+PROB_SRC9(I);
    ]
    "normalize and convert to cumulative prob distn"
    DO I=1,NPTS_SRC9[
       PROB_SRC9(I)=PROB_SRC9(I)/FNORM;
       IF(I>1)[ PROB_SRC9(I)=PROB_SRC9(I)+PROB_SRC9(I-1); ]
    ]
]

" ISOURC = 10  parallel circular beam incident on an x-ray target"
" **********
ELSEIF(ISOURC = 10)[
    RBEAM=TEMP1;
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=-1.;VINC=0.0;WINC=0.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    IF(UINC >= 0.0)[
        UINC=-UINC;
        OUTPUT UINC;
        (/' BEAM MUST FACE Z-AXIS, UINC HAS BEEN RE-SET TO ',F8.3/);
    ]
    IF (RBEAM  < 0.0) RBEAM=0.2;  "default to 0.2 cm"
    OUTPUT RBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT ON X-RAY TARGET (FACING X-AXIS)'/
        ' RADIUS OF CROSSECTION AREA OF THE BEAM :',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
]

" ISOURC = 13   parallel rectangular beam incident on an x-ray target"
" **********
ELSEIF(ISOURC = 13)[
    YBEAM=TEMP1;ZBEAM=TEMP2;
    FNORM=TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=-1.;VINC=0.0;WINC=0.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP3/FNORM;VINC=TEMP4/FNORM;WINC=0.;
    ]
    IF(UINC >= 0.0)[
        UINC=-UINC;
        OUTPUT UINC;
        (/' BEAM MUST FACE Z-AXIS, UINC HAS BEEN RE-SET TO ',F8.3/);
    ]
    IF (YBEAM  < 0.0) YBEAM=0.2;
    IF (ZBEAM  < 0.0) ZBEAM=0.2;"default to 0.2 mm"
    OUTPUT YBEAM,ZBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT ON X-RAY TARGET (FACING X-AXIS)'/
        ' HALF-WIDTH OF CROSSECTION AREA OF THE BEAM :',T60,F10.4,' cm'/
        ' HALF-HEIGHT OF CROSSECTION AREA OF THE BEAM :',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
]

ELSEIF(ISOURC = 15)["Radial intensity distribution"
    GAMMA=TEMP1; ZFOCUS=TEMP2; THETAIN=TEMP4; RTHETAIN=TEMP3;

    IF(GAMMA < 0.0) [OUTPUT GAMMA;(/'  ****Asked for negative angle'
       ,'=',F12.3,'deg'/'      Its absolute value is used');
       GAMMA = ABS(GAMMA);
    ]

    OUTPUT GAMMA,ZFOCUS,THETAIN,RTHETAIN;
       (' NRC SWEPT BEAM with RADIAL INTENSITY DISTRIBUTION and DIVERGENCE'/
        ' Half angle of swept cone =',T60,F10.4,' degrees'/
        ' Z of apex of cone = ',T60,F10.4,' cm'/
        ' Divergence angle of beam = ',T60,F10.4,' degrees'/
        ' Radius at which divergence angle defined = ',T60,F10.4,' cm'/);

"    OUTPUT;(' LOCAL INPUT(TEMP3=0) OR EXTERNAL FILE(TEMP3=1): ',$);
"    MODEIN = 1;  needed temp3 for RTHETAIN"
    "IF(MODEIN.NE.1) MODEIN=0;  DEFAULT"
"    OUTPUT;(/' RADIAL DISTRIBUTION:');
"    IF(MODEIN.EQ.0)[
        "INPUT FROM KEYBOARD OR .INP FILE"
"        OUTPUT;(' NUMBER OF RADIAL BINS: ',$);
"        MINPUT (ISOURCE) NRDIST;(I15);
"        IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
"            OUTPUT;
"            (/' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
"            ' RESET TO 100 ***');
"            NRDIST=100;
"            ]
"        OUTPUT NRDIST;(' INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT');
"        OUTPUT;('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE');
"        DO IB20=1,NRDIST[
"            MINPUT (ISOURCE) RDISTF(IB20),RPDF(IB20);(2F20.0);
"            ]
"        ]
"    ELSE[
        "EXTERNAL FILE INPUT"
        OUTPUT;
(' INPUT NAME OF FILE WITH RADIAL INTENSITY DISTRIBUTION (up to 80 CHAR '/
 ' WITH .EXT): '/);
        READ(i_input,'(A256)',END=:EOF_ISOURCE:) SPCNAM;
      OUTPUT SPCNAM;(/' READ INPUT RADIAL INTENSITY DISTRIBUTION FROM: '/A256);
        call replace_env(SPCNAM);
        i_spcnam=9;
        i_spcnam=egs_get_unit(i_spcnam);
        IF(i_spcnam<0)[
           $egs_fatal(*,'failed to get a free Fortran I/O unit for file.');
        ]
        OPEN(UNIT=i_spcnam,STATUS='OLD',FILE=SPCNAM);
        READ(i_spcnam,*)NRDIST;
        IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
            OUTPUT;
            (' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
            ' RESET TO 100 ***');
            NRDIST=100;
            ]
        READ(i_spcnam,*)(RDISTF(IB20),RPDF(IB20),IB20=1,NRDIST);
        CLOSE(UNIT=i_spcnam);
        OUTPUT NRDIST;('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE');

    "DO A CHECK ON THE RADIAL DISTRIBUTION"
    ICOUNT=0;
    "RLAST=0;  daryoush changed below"
    RLAST=-1000.;
    IERROR=0;
    :R-DIST-INPUT:LOOP[
        ICOUNT=ICOUNT+1;
        IF(ICOUNT.GT.NRDIST)[EXIT:R-DIST-INPUT:;]
         IF(RDISTF(ICOUNT).LE.RLAST)[
            " IERROR=1;   daryoush, to allow symmetric input"
            OUTPUT;
            (' *** RDISTF>=LAST ONE. MAYBE NOT ALLOWED,',
            ' CHECK THIS OUT.');
            ]
        ELSEIF(RPDF(ICOUNT).LT.0.0)[
            IERROR=1;
            OUTPUT;(' PDF < 0 NOT ALLOWED,',
            ' TERMINATING RADIAL INTENSITY DISTRIBUTION INPUT');
            ]
        IF(IERROR.EQ.1)[
            ICOUNT=ICOUNT-1;
            IF(ICOUNT.EQ.0)[
                OUTPUT;(' *** NO RADIAL INTENSITY DISTRIBUTION DEFINED,',
                ' STOPPING EXECUTION ***');
                $CALL_EXIT(1);
                ]
            OUTPUT ICOUNT;
            (' RADIAL INTENSITY DITRIBUTION INPUT APPEARS TO BE INCOMPLETE,',
            ' NRDIST RESET TO ',I12);
            NRDIST=ICOUNT;
            EXIT:R-DIST-INPUT:;
            ]
        RLAST=RDISTF(ICOUNT);
        ]

    OUTPUT RDISTF(1),RDISTF(NRDIST);
    ('    UPPER BIN RADII RANGE FROM ',F12.3,' TO',F12.3,' cm');

    OUTPUT;(/' AND NOW THE RADIAL INTENSITY DISTRIBUTION...');

    "now multiply the PDF by area and find the normalization factor"
    "note that RCDF used to store the cumulative distribution function"
    "but now it just stores RPDF*area"
    FNORM20=0;
    DO IB20=1,NRDIST[
       IF(IB20>1)[
         RCDF(IB20)=RPDF(IB20)*(RDISTF(IB20)**2-RDISTF(IB20-1)**2);
       ]
       ELSE[
         RCDF(IB20)=RPDF(1)*RDISTF(1)**2;
       ]
       FNORM20=FNORM20+RCDF(IB20);
    ]
    "now do the normalization and find the min rad**2 and the area of"
    "each radial bin"
    DO IB20=1,NRDIST[
        RCDF(IB20)=RCDF(IB20)/FNORM20;
        IF(IB20>1)[
           RCDFIN(IB20,1)=RDISTF(IB20-1)**2;
        ]
        ELSE[
           RCDFIN(IB20,1)=0.0;
        ]
        RCDFIN(IB20,2)=RDISTF(IB20)**2-RCDFIN(IB20,1);
    ]
    "now put the bins with maximum probability first"
    DO IB20=1,NRDIST-1[
       DUMMY15 = RCDF(IB20); "stores maximum value"
       AK= IB20;  "stores index of max. value"
       DO K20=IB20+1,NRDIST[
          IF(RCDF(K20) > DUMMY15)[
               DUMMY15=RCDF(K20);
               AK=K20;
          ]
       ]
       K20 = AK;
       TEMP5 = RCDF(K20); RCDF(K20) = RCDF(IB20); RCDF(IB20) = TEMP5;
       TEMP5 = RCDFIN(K20,1); RCDFIN(K20,1)=RCDFIN(IB20,1);
               RCDFIN(IB20,1)=TEMP5;
       TEMP5 = RCDFIN(K20,2); RCDFIN(K20,2)=RCDFIN(IB20,2);
               RCDFIN(IB20,2)=TEMP5;
    ]

    OUTPUT;(/'                               ');
    OUTPUT;( '    UPPER RADIUS OF BIN(cm)         PROB. '/);
    OUTPUT (RDISTF(IB20),RPDF(IB20),IB20=1,NRDIST);(E20.7,6X,E20.7);
    OUTPUT;(//);
]
" ISOURC = 18 parallel beam with gaussian radial distribution"
" **********
"inputs are the same as for source 19"
ELSEIF(ISOURC = 18)[
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=0.0;VINC=0.0;WINC=1.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    IF(TEMP1>=0) ["user entered sigma of beam"
        RBEAM=TEMP1;
        OUTPUT RBEAM,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT FROM FRONT WITH GAUSSIAN RADIAL DISTRIBUTION'/
        ' SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    ]
    ELSE["user entered FWHM of beam"
        RBEAM=-0.42466*TEMP1;
        OUTPUT -TEMP1,UINC,VINC,WINC;
       (' PARALLEL BEAM INCIDENT FROM FRONT WITH GAUSSIAN RADIAL DISTRIBUTION'/
        ' FWHM OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
        ' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    ]
    TEMP5=1.E30;  "Radius limited to RMAX_CM(1) in SRCOTO"
    IF ((RBEAM  < 0.0) |  (RBEAM >  TEMP5)) RBEAM=TEMP5;
]
" ISOURC = 19 parallel beam with 2-D gaussian X-Y distribution plus"
" plus angular spread"
" **********
ELSEIF(ISOURC = 19)[
    FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
    IF(FNORM =  0.0)[
        UINC=0.0;VINC=0.0;WINC=1.0;
    ]
    ELSE[
        FNORM=SQRT(FNORM);
        UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
    ]
    IF( TEMP1 >= 0 ) [ RBEAM=TEMP1; ] ELSE [ RBEAM=-0.42466*TEMP1; ]
    IF( TEMP6 > 0 ) [ RBEAMY=TEMP6; ]
    ELSEIF (TEMP6 < 0 ) [ RBEAMY=-0.42466*TEMP6; ]
    ELSE [ RBEAMY=RBEAM; ]
    xo_src19 = temp7; yo_src19 = temp8;
    OUTPUT RBEAM,RBEAMY,xo_src19,yo_src19;
    (' PARALLEL ELLIPTICAL BEAM INCIDENT FROM FRONT WITH GAUSSIAN DISTRIBUTION'/
     ' IN X AND Y:'/
     ' X-SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
     ' Y-SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
     ' X-POSITION OF MIDPOINT OF ELLIPTICAL SPOT:',T60,F10.4,' cm'/
     ' Y-POSITION OF MIDPOINT OF ELLIPTICAL SPOT:',T60,F10.4,' cm');
    "IF(TEMP1>=0) [""user entered sigma of beam"
    "    RBEAM=TEMP1;"
    "    OUTPUT RBEAM;"
    "(' PARALLEL BEAM INCIDENT FROM FRONT WITH 2-D GAUSSIAN X-Y DISTRIBUTION'/"
    "    ' SIGMA OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm');"
    "]"
    "ELSE[""user entered FWHM of beam"
    "    RBEAM=-0.42466*TEMP1;"
    "    OUTPUT -TEMP1;"
    "(' PARALLEL BEAM INCIDENT FROM FRONT WITH 2-D GAUSSIAN X-Y DISTRIBUTION'/"
    "    ' FWHM OF BEAM AT THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm');"
    "]   "
    IF( temp5 > 0 ) [ sigma_src19 = (temp5*3.1415926/180)**2;
        OUTPUT TEMP5;
       (' MEAN ANGULAR SPREAD ABOUT Z AXIS:',T60,F10.4,' degrees'/);
    ]
    ELSE [ sigma_src19 = -1;
        OUTPUT UINC,VINC,WINC;
       (' X-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
        ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
    ]
]

" ISOURC = 21 or 24  Full phase space for each particle"
"************
ELSEIF(ISOURC = 21 | ISOURC=24)[
    "External file input"
    OUTPUT;
    (' FULL PHASE-SPACE TO BE READ FROM UNIT 42...'/
    ' INPUT NAME OF FILE WITH PHASE SPACE DATA(1 TO 256 CHARS,',
    'WITH .EXT)'/' : ',$);
    READ(i_input,'(A256)',END=:EOF_ISOURCE:)SPCNAM;
    OUTPUT SPCNAM;(/' READ PHASE SPACE INFORMATION FROM: '/A256);

    call replace_env(SPCNAM);

    i_iaea_in=0; "assume not in IAEA format"

    inquire(file=SPCNAM,opened=phsp_open);
  IF(phsp_open)[
      OUTPUT;(/' Phase space source already open.  Will assume that '/
                ' DOSXYZnrc Source 20 is using this BEAM code as '/
                ' an initial geometry.  Will not attempt to '/
                ' open phase space source.'/);
      MONOEN = 2; "flag for polyenergetic beam from phase-space information
      IQIN = 9;
      INIT_ICM=TEMP1;
      EKMAXSRC=TEMP2; "have to do this for a conditional statement"
                      "just before calling SRCOTO"
  ]
  ELSE[
    ilen=lnblnk1(SPCNAM);
    IF(SPCNAM(ilen-8:ilen)='.IAEAphsp')[
         i_iaea_in=1;
         SPCNAM=SPCNAM(:ilen-9);
    ]

    IF(i_iaea_in=1)[
        $IAEA_OPEN_PHSP_FOR_READ(IINSRC,SPCNAM);
        $IAEA_READ_PHSP_HEADER(IINSRC,NNPHSP,NPHOTSRC,EKMAXSRC,NINCSRC,
                               Z_SOURCE,IZLAST1,I_MUPHSP_IN,IZSCORE);
        OUTPUT NNPHSP,NPHOTSRC,EKMAXSRC,NINCSRC;
           (T10,' IAEA format Phase space source with:'/
            T5,'                    Total number of particles =',I13/
            T5,'                            Number of photons =',I13/
            T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
            T5,' # of particles incident from original source =',F13.1/);
        IF(IZSCORE=0)[
         OUTPUT Z_SOURCE;
            (T5,'                        Z where source scored =',F13.3,' cm'/);
        ]
        IF(I_MUPHSP_IN~=0)[
           OUTPUT;
        (/' Fractional MU index will be read from the phase space data.');
        ]
    ]
    ELSE[
        $OPEN_PHSP_FOR_READ(IZLAST,IINSRC,SPCNAM,MODE_RW,NNPHSP,NPHOTSRC,
          EKMAXSRC,EKMINSRCE,NINCSRC);
         "NNPHSP: the total # of particles in file"
         "NPHOTSRC: # of photons in the file"
         "EKMAXSRC: max k.e. of particles"
         "EKMINSRCE: min k.e. of e- "
         "NINCSRC: # of incident partices from"
         "         original source"

    OLDSRC=0;
    IF(EKMAXSRC = 0.0 | NPHOTSRC>NNPHSP | EKMINSRCE>EKMAXSRC)[
           OUTPUT;(//' *****WARNING*****'/
                  ' PHASE SPACE SOURCE MAY HAVE AN ERROR OR MAY HAVE BEEN'/
                  ' GENERATED BY AN OLDER VERSION OF BEAMnrc.'/
                 ' WILL USE USER-INPUT VALUE OF MAXIMUM KINETIC ENERGY.'/
                  ' NUMBER OF PHOTONS AND MINIMUM ELECTRON ENERGY'/
                  ' WILL BE SET TO 0.  THIS WILL HAVE NO EFFECT ON RESULTS.'/
                  ' # OF PARTICLES INCIDENT FROM ORIGINAL SOURCE WILL BE SET'/
                ' EQUAL TO THE TOTAL NUMBER OF PARTICLES IN THE SOURCE FILE,'/
                  ' WHICH WILL CAUSE DOSE AND FLUENCE TO BE NORMALIZED'/
                  ' WITH RESPECT TO THE # OF HISTORIES RUN FROM THE PHASE'/
                  ' SPACE FILE, NOT THE # OF PARTICLES FROM THE ORIGINAL'/
                  ' SOURCE.'/
                  ' CHECK PHSP SOURCE FOR POSSIBLE ERRORS!'//);
           EKMAXSRC=TEMP2;
           NPHOTSRC=0;
           EKMINSRCE=0.;
           NINCSRC=NNPHSP;
           OLDSRC=1;
    ]
    ELSEIF(NINCSRC < 2)["source was generated before NINC replaced EKMINSRCG"
           OUTPUT;(//' ******WARNING*****'/
                     ' PHASE SPACE SOURCE WAS GENERATED USING AN OLDER'/
                   ' VERSION OF BEAMnrc IN WHICH # OF PARTICLES INCIDENT FROM'/
                     ' ORIGINAL SOURCE WAS NOT STORED.  THIS NUMBER WILL'/
                     ' BE SET EQUAL TO THE NUMBER OF PARTICLES IN THE SOURCE'/
                     ' FILE, AND DOSE AND FLUENCE WILL BE NORMALIZED'/
                     ' WITH RESPECT TO THE # OF HISTORIES RUN FROM THIS'/
                     ' FILE...NOT THE # OF PARTICLES OF PARTICLES FROM'/
                     ' THE ORIGINAL SOURCE'//);
           NINCSRC=NNPHSP;
           OLDSRC=2;
    ]
    OUTPUT NNPHSP,NPHOTSRC,EKMAXSRC,EKMINSRCE,NINCSRC;
           (T10,' Phase space source with:',/
            T5,'                    Total number of particles =',I13,/
            T5,'                            Number of photons =',I13,/
            T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
            T5,'              Minimum electron kinetic energy =',F13.3,' MeV'/
            T5,' # of particles incident from original source =',F13.1,/);
    ]"end of BEAMnrc format phsp source"
    MONOEN = 2; "flag for polyenergetic beam from phase-space information
    IQIN = 9;
    INIT_ICM=TEMP1;
    OUTPUT INIT_ICM;
    (/' Particles will start at the front boundary of CM',I3/);
    ISRC_DBS=TEMP5;RSRC_DBS=TEMP6;SSDSRC_DBS=TEMP7;ZSRC_DBS=TEMP8;
    IF(ISRC_DBS=1)[
       OUTPUT RSRC_DBS,SSDSRC_DBS,ZSRC_DBS;
      (/ T5,' Directional Bremsstrahlung Splitting (DBS) used'/
        T5,' in BEAM simulation to generate phase space source with:'/
        T10,'    DBS splitting radius =',F10.4,' cm'/
        T10,'SSD where radius defined =',F10.4,' cm'/
        T10,'   Z where source scored =',F10.4, 'cm'/
        T5,' Photons whose trajectory takes them outside the DBS splitting'/
        T5,' radius at the SSD will be rejected.'/);
       IF(SSDSRC_DBS<ZSRC_DBS)[
         OUTPUT;(//' ***WARNING:'/
                   ' SSD where DBS splitting radius is defined < the Z'/
                   ' value of scoring plane for this source.'/
                   ' Particle rejection will be turned off.'//);
         ISRC_DBS=0;
       ]
    ]
    ELSE[
      ISRC_DBS=0;
    ]
    IPARALLEL=TEMP3;
    PARNUM=TEMP4;

#ifdef HAVE_C_COMPILER;

"control parallel jobs differently if n_parallel>0"
    IF(IPARALLEL>1 & n_parallel>0)[
       OUTPUT IPARALLEL, n_parallel;
       (/' You have set IPARALLEL in the input file to ',I4,/
         ' But you are also running a C compiled code with n_parallel=',I4,/
         ' IPARALLEL will be reset to 1, and control of the parallel run '/
         ' will be within BEAM.'/);
       IPARALLEL=1;
    ]

#endif;

    IF(IPARALLEL<=0) IPARALLEL=1;
    IF(PARNUM<0) PARNUM=0;
    IF(IPARALLEL>1)[
       IF(PARNUM>=1 & PARNUM<=IPARALLEL)[
         OUTPUT IPARALLEL,INT((PARNUM-1)*NNPHSP/IPARALLEL)+1,
                INT(PARNUM*NNPHSP/IPARALLEL);
                  (/' This is one of ',I4,' parallel jobs.'/
                    ' It will use from particle ',I12,' to particle ',I12,/
                    ' from the phase space source in the simulation.'/);
       ]
       ELSE[
         OUTPUT IPARALLEL;
     (/' IPARALLEL input indicates that this is one of ',I4,' parallel jobs.'/
       ' But PARNUM is out of range (<1 or >IPARALLEL).  Therefore, phsp '/
       ' source will not be partitioned.'/);
         PARNUM=0;
         IPARALLEL=1;
       ]
    ]
    IF(TEMP2<=0)["automatically calculate NRCYCL"
      tmp_long=NNPHSP;
      IF(NINT(dble(IPARALLEL*NCASE)/float(NNPHSP))<=1)[
         "true if NCASE is only slightly > NNPHSP or < NNPHSP"
         NRCYCL=0;
      ]
      ELSEIF(MOD(IPARALLEL*NCASE,tmp_long)=0)[
         "NCASE is an exact multiple of NNPSHP"
         NRCYCL=(IPARALLEL*NCASE)/NNPHSP-1;
      ]
      ELSE[
         NRCYCL=(IPARALLEL*NCASE)/NNPHSP;
      ]
    ]
    ELSE[
      "use user-input value of NRCYCL"
      NRCYCL=TEMP2;
    ]
    OUTPUT NRCYCL;
  (/' Particles will be recycled ',I4,' times before moving on to next one.'/);

    "now read 2nd record, if NHSTRYM gets incremented, then we have a"
    "phsp file that stores NHSTRY"
    NHSTRYM=0;
    IF(i_iaea_in=1)[
       "just check that file size=checksum and that byte orders match"
       $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IINSRC);
    ]
    ELSE[
       $READ_PHSP_RECORD(IZLAST,IINSRC,2:
           NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
    IF(NHSTRYM=0)[
       DOSE_STAT=1;
       OUTPUT;(//' ***WARNING***'/
       ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
       ' Dose and fluence will be analyzed assuming each particle read from'/
       ' the ph-sp file is an independent history.  May result in an'/
       ' underestimate of uncertainties.'//);
    ]
    ]
  ]"end of else ~phsp_open"

    IF(ISOURC=24)["read input angles, distance"
       OUTPUT INIT_ICM;
              (' Angle of source plane wrt the X-axis (degrees), Angle wrt '/
               ' the Y-axis (degrees), distance from point of rotation to '/
               ' front of CM ',I4,' (cm):',$);
       ;MINPUT (ISOURCE) ALPHA24,BETA24,DIST24;(3F15.0);
       OUTPUT ALPHA24,BETA24,DIST24;(3F12.5);
       IF(ABS(ALPHA24)>=90. | ABS(BETA24)>=90.)[
          OUTPUT;(//' ****ERROR in input for source 24:'/
                   ' At least one of the source angles is >= 90.'/
                   ' Incident particles will not hit the surface of the CM.'/
                   ' Reset angle(s) and try again.'//);
          STOP;
       ]
       ELSEIF(INIT_ICM=1 & (ALPHA24~=0 | BETA24~=0))[
          OUTPUT;(//' ****ERROR in input for source 24:'/
                    ' Incident CM must be > 1 to allow for rotation of source '/
                    ' to positions above its incident plane.  Try again.'//);
           STOP;
       ]
       ELSEIF((ALPHA24~=0 | BETA24~=0) & ((CMTYPE(INIT_ICM)~='SLABS' &
        CMTYPE(INIT_ICM)~='FLATFILT' & CMTYPE(INIT_ICM)~='SIDETUBE') |
        (CMTYPE(INIT_ICM-1)~='SLABS' &
        CMTYPE(INIT_ICM-1)~='FLATFILT' & CMTYPE(INIT_ICM-1)~='SIDETUBE')))[
          OUTPUT;(//' ****ERROR in input for source 24:'/
         ' INIT_ICM and INIT_ICM-1 must be SLABS, FLATFILT or SIDETUBE.'//);
          STOP;
       ]
       SALPHA24=SIN(ALPHA24*3.1415926/180.);
       CALPHA24=COS(ALPHA24*3.1415926/180.);
       SBETA24=SIN(BETA24*3.1415926/180.);
       CBETA24=COS(BETA24*3.1415926/180.);
    ]

    "initialize counters"
    "the following variables will keep track of source 21 parameters as"
    "the source is used"
    /N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NPASS_ph_sp,NFAT_ph_sp/=0;
    /E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
]

" ISOURC = 23   Full BEAM simulation source"
"************
ELSEIF(ISOURC = 23)[
OUTPUT;
   (' Input name of source beam code (BEAM_accelname), input file (no ext.), '/
    ' pegs data (no ext.) (A256)'/'  : ',$);
    READ(i_input,'(A)',END=:EOF_ISOURCE:) TEXT;
    OUTPUT $cstring(TEXT);(A);
    "now parse TEXT for the inputs"

    the_beam_code=TEXT(:INDEX(TEXT,',')-1);
    TEXT=TEXT(INDEX(TEXT,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_beam_code,' ')=1) [
      IF(len(the_beam_code)>=2)[
        the_beam_code=the_beam_code(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_beam_code=the_beam_code(:lnblnk1(the_beam_code));

    the_input_file=TEXT(:INDEX(TEXT,',')-1);
    TEXT=TEXT(INDEX(TEXT,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_input_file,' ')=1) [
      IF(len(the_input_file)>=2) [
        the_input_file=the_input_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_input_file=the_input_file(:lnblnk1(the_input_file));
    the_pegs_file=TEXT(:lnblnk1(TEXT));
    "strip leading blanks"
    WHILE(INDEX(the_pegs_file,' ')=1) [
      IF(len(the_pegs_file)>=2) [
        the_pegs_file=the_pegs_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    MONOEN = 2; "flag for polyenergetic beam from phase-space information
    IQIN = 9;
    INIT_ICM=TEMP1;
    ISRC_DBS=TEMP2;
    ALPHA24=TEMP3;
    BETA24=TEMP4;
    DIST24=TEMP5;

    OUTPUT $cstring(the_beam_code),$cstring(the_input_file),
             $cstring(the_pegs_file);
    (/' BEAM simulation name: ',A/
      '           input file: ',A/
      '   pegs data for BEAM: ',A/);
    OUTPUT INIT_ICM;
    (/' Particles will start at the front boundary of CM',I3/);
    IF(ISRC_DBS=1)OUTPUT;(' Fat photons from DBS will be rejected.'/);
    OUTPUT ALPHA24,BETA24,INIT_ICM,DIST24;
    (' Angle of rotation of source plane wrt the X-axis = ',F8.3,' degrees'/
     ' Angle of rotation of source plane wrt the Y-axis = ',F8.3,' degrees'/
     ' Distance of point of rotation above CM ',I4,' = ',F8.3,' cm'/);
    IF(ABS(ALPHA24)>=90. | ABS(BETA24)>=90.)[
          OUTPUT;(//' ****ERROR in input for source 23:'/
                   ' At least one of the source angles is >= 90.'/
                   ' Incident particles will not hit the surface of the CM.'/
                   ' Reset angle(s) and try again.'//);
          STOP;
    ]
    ELSEIF(INIT_ICM=1 & (ALPHA24~=0 | BETA24~=0))[
          OUTPUT;(//' ****ERROR in input for source 23:'/
                    ' Incident CM must be > 1 to allow for rotation of source '/
                    ' to positions above its incident plane.  Try again.'//);
           STOP;
    ]
    ELSEIF((ALPHA24~=0 | BETA24~=0) & ((CMTYPE(INIT_ICM)~='SLABS' &
        CMTYPE(INIT_ICM)~='FLATFILT' & CMTYPE(INIT_ICM)~='SIDETUBE') |
        (CMTYPE(INIT_ICM-1)~='SLABS' &
        CMTYPE(INIT_ICM-1)~='FLATFILT' & CMTYPE(INIT_ICM-1)~='SIDETUBE')))[
          OUTPUT;(//' ****ERROR in input for source 23:'/
          ' INIT_ICM and INIT_ICM-1 must be SLABS, FLATFILT or SIDETUBE'//);
        STOP;
    ]
    SALPHA24=SIN(ALPHA24*3.1415926/180.);
    CALPHA24=COS(ALPHA24*3.1415926/180.);
    SBETA24=SIN(BETA24*3.1415926/180.);
    CBETA24=COS(BETA24*3.1415926/180.);

    "initialize counters"
    "the following variables will keep track of source 21 parameters as"
    "the source is used"
    /N_ph_sp_e,N_ph_sp_g,N_ph_sp_p,NFAT_ph_sp/=0;
    /E_ph_sp_e,E_ph_sp_g,E_ph_sp_p,E_MAX_ph_sp/=0.0;
]

" ISOURC = 31   use beam characterization models"
"************
ELSEIF(ISOURC = 31)[ ;$BEAMMODEL_SOURCE_INPUT; ]

ELSE[
    OUTPUT ISOURC;(///' *********ISOURC=',I5,' DOES NOT EXIST IN BEAMnrc****'/
    //' START AGAIN'///);
    $CALL_EXIT(1);
]

IF (ISOURC < 21 | ISOURC=22) [

"            Source energy input                                      ""toc:
"            *******************
   OUTPUT;(/' Source energy --Monoenergetic(0) or spectrum (1): ',$);
   ;MINPUT (ISOURCE) MONOEN;(I4);
   OUTPUT MONOEN;(I8);

   IF (MONOEN = 0)  ["Monoenergetic"
      OUTPUT;(' Monoenergetic source');
      IF (IQIN = 0) [OUTPUT;(' Energy of incident beam (MeV): ',$);]
      ELSE [OUTPUT;(' Kinetic energy of incident beam (MeV): ',$);]
      ;MINPUT (ISOURCE) EIN;(F10.0);
      IF( EIN = 0.0) [EIN = 1.25;"default value"]
      OUTPUT EIN;( F15.4);
   ]

   ELSEIF(MONOEN = 1)[
      OUTPUT;(' Energy distribution source');
      OUTPUT;(' INPUT NAME OF FILE WITH SPECTRUM DATA(<=256 CHARS)'/' : ',$);
      READ(i_input,'(A256)',END=:EOF_ISOURCE:) FILNAM;
      OUTPUT FILNAM;(/'   Will now read input energy spectrum from: ',/A256);
      call replace_env(FILNAM);
      i_spect=99;
      i_spect=egs_get_unit(i_spect);
      IF(i_spect<0)[
        $egs_fatal(*,'failed to get a free Fortran I/O unit for file');
      ]
      OPEN(UNIT=i_spect,STATUS='OLD',FILE=FILNAM,ERR=:EOF_RS3:);
      READ(i_spect,'(A80)') SPEC_TITLE;
      READ(i_spect,'(I10,F15.0,I5)')NENSRC,ENMIN,IMODE;
      IF(NENSRC > $NENSRC) [
         OUTPUT NENSRC,$NENSRC;
          (//' ********** Asked for too many energy bins******'/
          ' NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//);
         NENSRC = $NENSRC;
      ]
      READ(i_spect,'(2F20.0)')(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
      CLOSE(UNIT=i_spect);
      OUTPUT NENSRC; (' Have read',I5,' energy bins from file');
      IF(IMODE=0)[ OUTPUT;('      File contained counts/bin '); ]
      ELSEIF(IMODE = 1)[ OUTPUT;('      File contained counts/MeV ');
         SRCPDF(1) = SRCPDF(1)*(ENSRCD(1)-ENMIN);
         DO IB=2,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
      ] "end mode = 1 block"
      ELSE [
         OUTPUT IMODE;(///'*****MODE not 0 or 1 in spectrum file? **'
         /80('*') //);
      ]
      EIN = ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
      OUTPUT ENMIN,EIN;
      ('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV');
      OUTPUT;
      (' Print spectrum data in output summary, yes(1) or no(0): ',$);
      READ(i_input,'(I5)') IOUTSP;
      IF(IOUTSP ~= 1)[IOUTSP=0;]
      OUTPUT IOUTSP;(I12);
      CALL EN_INITIALIZE;
   ]

   ELSEIF(MONOEN > 2)[ OUTPUT MONOEN;(' MONOEN = ',I4, ' ??? ');
                       $CALL_EXIT(1); ]
]"end of energy spectrum input for ISOURC<21"

" Normal return
" *************
RETURN;

" Errors
" ******
:EOF_ISOURCE: "unexpected end of input file, stop and print message
;OUTPUT;(//' *** unexpected end of file reading input for ISOURCE ***');
$CALL_EXIT(1); "End of input file return"

:ERROR_ISOURCE: "error on input, stop and print message
;OUTPUT;(//' *** format error on input for ISOURCE ***');
$CALL_EXIT(1); "Error in input file return"

:EOF_RS3: "error on file opening"
;OUTPUT;(//' *** SORRY, WE CANNOT FIND THE REQUIRED FILE/DIRECTORY. ***');
$CALL_EXIT(1);
END; "End of subroutine ISOURCE"
%E     "beamnrc.mortran - start subroutine srcoto                         "
"*******************************************************************************
"
                             SUBROUTINE SRCOTO(WEIGHT);
"                            *****************
"*******************************************************************************
"
" Calculation of one time only constants that may vary with source type.
"
"*******************************************************************************
"
$IMPLICIT-NONE;
;COMIN/CMs,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,EGS-IO/;

"T>****************************
"T>TYPE DECLARATIONS FOR SRCOTO
"T>****************************
"T>
INTEGER I,  "T>a looping index
    IMAX,   "T>index of CM dictating RINMAX--used with source 3"
    IMIN;   "T>index of CM dictating RINMIN--used with source 3"
$REAL
    WEIGHT, "T>weight of source particles
    RINMIN; "T>minimum radius of beam--used with source 3

"*******************************************************************************
"
"
IFPB=1;               "Default flag to not being frontal parallel beam"
IF(INIT_ICM = 0)[
   Z_SOURCE=Z_min_CM(1);
   "Default: Source incident on front of 1st component module. "
]
ELSE IF( INIT_ICM > 0 ) [
   Z_SOURCE=Z_min_CM(INIT_ICM);
   "Default: Source incident on front of CM #: INIT_ICM. "
]

WEIGHT=1.0;           " Default weight

"Determine what default or maximum angle/radius should be"
"This depends on whether first CM has circular or square outer boundary"

IF(RMAX_CM_FLAG(1) = 1)    ["circular" RINMAX = RMAX_CM(1)*$ONE-EPS;]
ELSEIF(RMAX_CM_FLAG(1) = 2)["square" RINMAX=RMAX_CM(1)*SQRT(2.)*$ONE-EPS;]
ELSE["given by some other parameter, so just make safe" RINMAX=1000.;]
IF(ISOURC = 8 | ISOURC = 9) ["in these cases, RBEAM is limited at DISTZ"
   IF(Z_SOURCE ~= 0.0)[RINMAX = RINMAX* DISTZ/ABS(Z_SOURCE);
                      "largest beam from a source in CM 1"
   ]
   ELSE               [RINMAX = 10000.;"beam size not limited by this concern"]
]

" ISOURC = 0
"***********
IF(ISOURC = 0) ["Frontal parallel beam source"
    IF (RBEAM >= RINMAX) [
       RBEAM=RINMAX; "Limit beam radius to
         "geometry radius, scaled down to insure a strike on the target"
       OUTPUT RBEAM;
         (//' BEAM GOES BEYOND BOUNDARY OF CM !'
          /' BEAM RADIUS REDUCED TO ',F8.3,' cm.');
    ]
    IFPB=0;"Set flag- passed in common SOURCE
    IF((ISOURC = 0)  &  (WINC ~= 1.)) IFPB=1; "Not for angled incidence
    RBEAM2=RBEAM**2;
]
" ISOURC = 1
"***********
ELSEIF(ISOURC = 1) ["frontal point source"
    IF (RBEAM < 0.0) ["rectangular field, calculate constants and do checks"
       IF(XINU>RMAX_CM(1))[
          OUTPUT RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' XINU>RMAX of CM 1. XINU reset to ',F8.5,' cm for now.'//);
          XINU=RMAX_CM(1);
       ]
       IF(XINL<-RMAX_CM(1))[
          OUTPUT -RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' XINL<-RMAX of CM 1. XINL reset to ',F8.5,' cm for now.'//);
          XINL=-RMAX_CM(1);
       ]
       IF(YINU>RMAX_CM(1))[
          OUTPUT RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' YINU>RMAX of CM 1. YINU reset to ',F8.5,' cm for now.'//);
          YINU=RMAX_CM(1);
       ]
       IF(YINL<-RMAX_CM(1))[
          OUTPUT -RMAX_CM(1);
          (//' ***WARNING IN SOURCE 1:'/
             ' YINL<-RMAX of CM 1. YINL reset to ',F8.5,' cm for now.'//);
          YINL=-RMAX_CM(1);
       ]
       IF(XINL>XINU)[
          OUTPUT;
          (//' ***ERROR IN SOURCE 1:'/
             ' XINL>XINU.  Please reset and try again.'//);
          $CALL_EXIT(1);
       ]
       IF(YINL>YINU)[
          OUTPUT;
          (//' ***ERROR IN SOURCE 1:'/
             ' YINL>YINU.  Please reset and try again.'//);
          $CALL_EXIT(1);
       ]
       XINDEL=XINU-XINL;
       YINDEL=YINU-YINL;
    ]
    ELSE["RBEAM>=0"
       IF (RBEAM = 0.0 & GAMMA = 0.0)[ RBEAM=RINMAX;"default" ]
       IF (RBEAM >= RINMAX) RBEAM=RINMAX;
       RBEAM2 = RBEAM**2;
       IF (GAMMA = 0.0) ["RBEAM input"
          COSGAMMA = DISTZ/SQRT(RBEAM2 + DISTZ**2);
          ONEMCOSGAM = 1D0 - COSGAMMA;   "used in sampling"
          "above will be inaccurate for small fields - use an expansion"
          "COSGAMMA = 1 - 0.5*x**2 + .377*x**4 with x=RBEAM/DISTZ"

          " Note that double precision is used to prevent problems near"
          "origin when sampling later, even in large fields"
       ]
       ELSE ["GAMMA input"
          COSGAMMA = COS(GAMMA/57.29658);
          IF (TAN(GAMMA/57.29658)*DISTZ > RINMAX)[
            "half-angle so big, some particles miss front face"
            "This may not be appropriate some day, so could remove it"
            COSGAMMA =DISTZ/SQRT(RINMAX**2 +DISTZ**2);
            GAMMA = 57.29578*ACOS(COSGAMMA); "degrees"
            OUTPUT GAMMA;
          ('  Half-angle reduced to',F10.5,' degrees so just hits front face');
          ]
          ONEMCOSGAM = 1D0 - COSGAMMA;   "used in sampling"
       ]"end of block with gamma input"
    ]
"OUTPUT GAMMA,RBEAM,COSGAMMA;(/' ***TEMPORARY  GAMMA,RBEAM,COSGAMMA'/3F15.8);
]

ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING RING"
    IF(RBEAM >= 0)[
       IF(ZSMIN < Z_min_CM(1))[
          IF(ZSMAX < Z_min_CM(1))[
             OUTPUT;(//' ***ERROR IN SOURCE 3:'/
                        ' ZSMIN & ZSMAX < Z_min_CM(1)'//);
             $CALL_EXIT(1);
          ]
          ELSE[
             ZSMIN= Z_min_CM(1);
             OUTPUT ZSMIN;(//' ***WARNING IN SOURCE 3:'/
                        ' ZSMIN < Z_min_CM(1)'/
                        ' ZSMIN reset to',F10.4,' cm'//);
             WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
                        '' ZSMIN < Z_min_CM(1)''/
                        '' ZSMIN reset to'',F10.4,'' cm''//)')ZSMIN;
          ]
       ]
       IF(ZSMAX > Z_min_CM(MAX_CMs+1))[
          IF(ZSMIN > Z_min_CM(MAX_CMs+1))[
             OUTPUT;(//' ***ERROR IN SOURCE 3:'/
                        ' ZSMIN & ZSMAX > bottom of geometry'//);
             $CALL_EXIT(1);
          ]
          ELSE[
             ZSMAX=Z_min_CM(MAX_CMs+1);
             OUTPUT ZSMAX;(//' ***WARNING IN SOURCE 3:'/
                        ' ZSMAX > bottom of geometry'/
                        ' ZSMAX reset to',F10.4,' cm'//);
             WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
                        '' ZSMAX > bottom of geometry''/
                        '' ZSMAX reset to'',F10.4,'' cm''//)')ZSMAX;
          ]
       ]
       DO I=MAX_CMs,1,-1[
          IF(ZSMIN>=Z_min_CM(I))[
             MIN_CM_SRC3=I;
             EXIT;
          ]
       ]
       DO I=1,MAX_CMs[
          IF(ZSMAX<=Z_min_CM(I+1))[
             MAX_CM_SRC3=I;
             EXIT;
          ]
       ]
    ]
    ELSE[
       IF(RMINBM < Z_min_CM(1))[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/
                    ' Centre of source cylinder < Z_min_CM(1)'/
                    ' Source will not work with this geometry'//);
          $CALL_EXIT(1);
       ]
       ELSEIF(RMINBM > Z_min_CM(MAX_CMs+1))[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/
               ' Centre of source cylinder > bottom of simulation geometry'/
               ' Source will not work with this geometry'//);
          $CALL_EXIT(1);
       ]
       IF(RMINBM - ABS(RBEAM) < Z_min_CM(1))[
          RBEAM=-ABS(RMINBM - Z_min_CM(1));
          OUTPUT ABS(RBEAM);(//' ***WARNING IN SOURCE 3:'/
          ' Source extends above Z_min_CM(1)'/
          ' RBEAM reset to',F10.4,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Source extends above Z_min_CM(1)''/
          '' RBEAM reset to'',F10.4,'' cm''//)')ABS(RBEAM);
       ]
       IF(RMINBM + ABS(RBEAM) > Z_min_CM(MAX_CMs+1))[
          RBEAM=-ABS(Z_min_CM(MAX_CMs+1)-RMINBM);
          OUTPUT ABS(RBEAM);(//' ***WARNING IN SOURCE 3:'/
          ' Source extends below simulation geometry'/
          ' RBEAM reset to',F10.4,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Source extends below simulation geometry''/
          '' RBEAM reset to'',F10.4,'' cm''//)')ABS(RBEAM);
       ]
       DO I=MAX_CMs,1,-1[
          IF(RMINBM-ABS(RBEAM)>=Z_min_CM(I))[
             MIN_CM_SRC3=I;
             EXIT;
          ]
       ]
       DO I=1,MAX_CMs[
          IF(RMINBM+ABS(RBEAM)<=Z_min_CM(I+1))[
             MAX_CM_SRC3=I;
             EXIT;
          ]
       ]
    ]
    IMAX=MIN_CM_SRC3;
    IMIN=MIN_CM_SRC3;
    RINMAX=RMAX_CM(IMAX);
    RINMIN=RMAX_CM(IMAX);
    DO I=MIN_CM_SRC3,MAX_CM_SRC3[
       IF(CMTYPE(I)~='CONESTAK' & CMTYPE(I)~='SIDETUBE'
          & CMTYPE(I)~='FLATFILT')[
          OUTPUT I;(//' ***ERROR IN SOURCE 3:'/
  ' CM ',I4,' is not a CONESTAK, SIDETUBE or FLATFILT, yet it has some of the'/
  ' source in it.  Source must be contained within CONESTAKs, SIDETUBEs, or'/
  ' FLATFILTs for now.  Try again.'//);
          $CALL_EXIT(1);
       ]
       IF(RMAX_CM(I)>RMAX_CM(IMAX))[
         IMAX=I;
         RINMAX=RMAX_CM(I);
       ]
       ELSEIF(RMAX_CM(I)<RMAX_CM(IMIN))[
         IMIN=I;
         RINMIN=RMAX_CM(I);
       ]
    ]
    IF(RBEAM >= 0)[
       IF(RMAX_CM_FLAG(IMAX)=2)[RINMAX = SQRT(2.)*RINMAX;]
       IF(RMAX_CM_FLAG(IMIN)=2)[RINMIN = SQRT(2.)*RINMIN;]
       IF(RBEAM>RINMAX)[
          IF(RMINBM>RINMAX)[
             OUTPUT;(//' ***ERROR IN SOURCE 3:'/
            ' RBEAM & RMINBM > RMAX_CM of largest CM containing source'//);
             $CALL_EXIT(1);
          ]
          ELSE[
             RBEAM=RINMAX;
             OUTPUT RBEAM;(//' ***WARNING IN SOURCE 3:'/
            ' RBEAM > RMAX_CM of largest CM containing source'/
            ' RBEAM reset to ',F8.3,' cm'//);
             WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
            '' RBEAM > RMAX_CM of largest CM containing source''/
            '' RBEAM reset to '',F8.3,'' cm''//)') RBEAM;
          ]
       ]
       IF(RBEAM>RINMIN)[
          OUTPUT;(//' ***WARNING IN SOURCE 3:'/
        ' Source goes beyond RMAX_CM of smallest CM containing source'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
        '' Source goes beyond RMAX_CM of smallest CM containing source''//)');
       ]
    ]
    ELSE[
       IF((ZSMIN < -RINMAX & ZSMAX < -RINMAX) |
           (ZSMIN > RINMAX & ZSMAX > RINMAX))[
          OUTPUT;(//' ***ERROR IN SOURCE 3:'/
' Entire source is beyond RMAX_CM of largest CM supposed to contain source'//);
          $CALL_EXIT(1);
       ]
       IF(ZSMIN < -RINMAX)[
          ZSMIN=-RINMAX;
          OUTPUT ZSMIN;(//' ***WARNING IN SOURCE 3:'/
          ' Min. X of source < RMAX_CM of largest CM containing source'/
          ' Min. X reset to ',F8.3,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Min. X of source < RMAX_CM of largest CM containing source''/
          '' Min. X reset to '',F8.3,'' cm''//)') ZSMIN;
       ]
       IF(ZSMAX > RINMAX)[
          ZSMAX=RINMAX;
          OUTPUT ZSMAX;(//' ***WARNING IN SOURCE 3:'/
          ' Max. X of source > RMAX_CM of largest CM containing source'/
          ' Max. X reset to ',F8.3,' cm'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
          '' Max. X of source < RMAX_CM of largest CM containing source''/
          '' Max. X reset to '',F8.3,'' cm''//)') ZSMAX;
       ]
       IF(ABS(ZSMAX) > RINMIN | ABS(ZSMIN) > RINMIN)[
          OUTPUT;(//' ***WARNING IN SOURCE 3:'/
      ' Source goes beyond RMAX_CM of smallest CM containing source'//);
          WRITE(IOUTLIST,'(//'' ***WARNING IN SOURCE 3:''/
      '' Source goes beyond RMAX_CM of smallest CM containing source''//)');
       ]
    ]
"   Following are used to sample Z easily
    ZSOFST=0.5*(ZSMAX - ZSMIN)+ ZSMIN;
    ZBEAM=0.5*(ZSMAX - ZSMIN);
]

" ISOURC = 5
"***********
ELSEIF(ISOURC = 5) ["NRC swept beam"
    IF (RBEAM >= RINMAX) RBEAM=RINMAX; "Limit beam radius to
         "geometry radius, scaled down to insure a strike on the target
    RBEAM2 = RBEAM**2;
    COSGAMMA = COS(GAMMA/57.29658);
    SINGAMMA = SQRT(1.0 - COSGAMMA**2);
]
" ISOURC = 6
"***********
ELSEIF(ISOURC = 6) ["Frontal parallel rectangular beam along z-axis"
    RBEAM=SQRT(XBEAM**2+YBEAM**2);
"THERE IS A BUG HERE - This assumes first CM is circular outer boundary"
"IT may be square - usually will be in fact, and these checks would be faster"
    IF (RMAX_CM_FLAG(1) = 1)["case of cylindrical CM"
       IF (SQRT(XBEAM0**2+YBEAM0**2) > RMAX_CM(1))[
          "beam centre is outside the geometry radius"
           XBEAM0=0.;YBEAM0=0.;
           OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
       ]
    ]
    ELSEIF(RMAX_CM_FLAG(1) = 2)["square CM"
       IF (ABS(XBEAM0) > RMAX_CM(1)) |
          (ABS(YBEAM0) > RMAX_CM(1)) [
          "beam centre is outside boundaries"
          XBEAM0=0.;YBEAM0=0.;
          OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
       ]
    ]
"following brings limits of beam back to RMAX_CM(1) if the"
"beam goes beyond this boundary"
    IF (ABS(XBEAM0+XBEAM) > RMAX_CM(1)) |
       (ABS(XBEAM0-XBEAM) > RMAX_CM(1)) [
       XBEAM=RMAX_CM(1) - ABS(XBEAM0);
       OUTPUT XBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
          ' XBEAM REDUCED TO ',F8.3,'cm.');
    ]
    IF (ABS(YBEAM0+YBEAM) > RMAX_CM(1)) |
       (ABS(YBEAM0-YBEAM) > RMAX_CM(1)) [
       YBEAM=RMAX_CM(1) - ABS(YBEAM0);
       OUTPUT YBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
          ' YBEAM REDUCED TO ',F8.3,'cm.');
    ]
    IFPB=0;"Set flag- FRONTAL PARALLEL BEAM"
]

ELSEIF(ISOURC=21) ["phsp source"
     IF(i_iaea_in=1 & IZSCORE=1 & CMTYPE(INIT_ICM)~='SLABS' &
           CMTYPE(INIT_ICM)~='FLATFILT' & CMTYPE(INIT_ICM)~='SIDETUBE')[
           OUTPUT;(/' Warning in source 21: Z for each particle will be read'/
                    ' from the IAEA phase space data, but INIT_ICM is not set'/
                    ' to a CM that can handle particles incident within it'/
                    ' (SLABS, FLATFILT or SIDETUBE).  Depending on the Z'/
                    ' of incident particles, this may result in the'/
                    ' simulation stopping mid-run.'/);
        ]
]

ELSEIF(ISOURC = 22) ["Frontal parallel rectangular beam along z-axis"
    RBEAM=SQRT(XBEAM**2+YBEAM**2);
    "THERE IS A BUG HERE - This assumes first CM is circular outer boundary"
"IT may be square - usually will be in fact, and these checks would be faster"
    IF (RMAX_CM_FLAG(1) = 1)["case of cylindrical CM"
          IF (SQRT(XBEAM0**2+YBEAM0**2) > RMAX_CM(1))[
              "beam centre is outside the geometry radius"
              XBEAM0=0.;YBEAM0=0.;
              OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
              ]
     ]
     ELSEIF(RMAX_CM_FLAG(1) = 2)["square CM"
         IF (ABS(XBEAM0) > RMAX_CM(1)) |
         (ABS(YBEAM0) > RMAX_CM(1)) [
             "beam centre is outside boundaries"
              XBEAM0=0.;YBEAM0=0.;
             OUTPUT;(//' BEAM CENTRE IS OUTSIDE THE GEOMETRY RADIUS!!!'/
              ' BEAM CENTRE DEFAULTS TO (0.,0.). '///);
         ]
     ]
    "following brings limits of beam back to RMAX_CM(1) if the"
    "beam goes beyond this boundary"
     IF (ABS(XBEAM0+XBEAM) > RMAX_CM(1)) |
         (ABS(XBEAM0-XBEAM) > RMAX_CM(1)) [
          XBEAM=RMAX_CM(1) - ABS(XBEAM0);
          OUTPUT XBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
            ' XBEAM REDUCED TO ',F8.3,'cm.');
     ]
     IF (ABS(YBEAM0+YBEAM) > RMAX_CM(1)) |
         (ABS(YBEAM0-YBEAM) > RMAX_CM(1)) [
              YBEAM=RMAX_CM(1) - ABS(YBEAM0);
              OUTPUT YBEAM;(//' BEAM GOES BEYOND BOUNDARY OF CM!!'/
              ' YBEAM REDUCED TO ',F8.3,'cm.');
     ]
]

" ISOURC = 7
"*********
ELSEIF(ISOURC = 7) [  " the scanning beam  "
    IF (RBEAM > RINMAX)[ RBEAM=RINMAX;]"Limit beam radius to
    "geometry radius, scaled down to insure a strike on the target
    RBEAM2=RBEAM**2;
]

" ISOURC = 8
"*********
ELSEIF(ISOURC = 8) [  " the scanning uniform MM50 beam  "
    IF (RBEAM > RINMAX | RBEAM<= 0)[
       IF (RBEAM > RINMAX)[
          OUTPUT RINMAX; (//' BEAM GOES BEYOND BOUNDARY.'/
                     ' BEAM RADIUS REDUCED TO ',F8.3,'cm.'//);
       ]
       RBEAM=RINMAX;"Limit beam radius to
       "geometry radius, scaled down to insure a strike on the model"
    ]
    RBEAM2=RBEAM**2;
    IF (RBEAM+RBEAM0 > RINMAX)[
          OUTPUT RBEAM0,RINMAX-RBEAM;
          (//' ****WARNING IN SOURCE 8'/
             ' RBEAM+RBEAM0 goes beyond boundary of CM 1 '/
             ' RBEAM0 reduced from ',F8.3,' cm to ',F8.3,' cm.'//);
          WRITE(IOUTLIST,100)RBEAM0,RINMAX-RBEAM;
     100 FORMAT(//' ****WARNING IN SOURCE 8'/
             ' RBEAM+RBEAM0 goes beyond boundary of CM 1 '/
             ' RBEAM0 reduced from ',F8.3,' cm to ',F8.3,' cm.'//);
         RBEAM0=RINMAX-RBEAM;
    ]
]

" ISOURC = 9
"*********
ELSEIF(ISOURC = 9) [  " the scanning beam with discrete points"
   IF (RMAX_CM_FLAG(1) = 1)["case of cylindrical CM"
      DO I=1,NPTS_SRC9[
         IF(SQRT(X_SRC9(I)**2+Y_SRC9(I)**2) > RINMAX)[
            OUTPUT I; (//'***WARNING IN SOURCE 9:'/
                'Point ',I4,' goes beyond RINMAX.'//);
            WRITE(IOUTLIST,'(//''***WARNING IN SOURCE 9:''/
                ''Point '',I4,'' goes beyond RINMAX.''//)') I;
         ]
      ]
   ]
   ELSEIF (RMAX_CM_FLAG(1) = 2)["square CM"
      DO I=1,NPTS_SRC9[
         IF(ABS(X_SRC9(I))>RINMAX | ABS(Y_SRC9(I))>RINMAX )[
            OUTPUT I; (//'***WARNING IN SOURCE 9:'/
                'Point ',I4,' goes beyond RINMAX.'//);
            WRITE(IOUTLIST,'(//''***WARNING IN SOURCE 9:''/
                ''Point '',I4,'' goes beyond RINMAX.''//)') I;
         ]
      ]
   ]
]

" ISOURC = 10
"***********
ELSEIF(ISOURC = 10) ["parallel circular beam source from side"
    IF (RBEAM >= (Z_min_CM(2)-Z_min_CM(1))/2.)[
        RBEAM=(Z_min_CM(2)-Z_min_CM(1))/2.;
        "too large default to half of the thickness of the target"
    ]
    RBEAM2=RBEAM**2;
]
" ISOURC = 13
"***********
ELSEIF(ISOURC = 13) ["parallel rectangular beam source from side"
    IF (YBEAM >= (Z_min_CM(2)-Z_min_CM(1))/2.)[
        YBEAM=(Z_min_CM(2)-Z_min_CM(1))/2.;
        "too large default to half of the thickness of the target"
    ]
    IF (ZBEAM >= (Z_min_CM(2)-Z_min_CM(1))/2.)[
        ZBEAM=(Z_min_CM(2)-Z_min_CM(1))/2.;
        "too large default to half of the thickness of the target"
    ]
]

ELSEIF(ISOURC = 15)[
    COSGAMMA=COS(GAMMA/57.29578);
    SINGAMMA = SIN(GAMMA/57.29578);
    WEIGHT=1.0; "INCIDENT WEIGHT"
]
" ISOURC = 18
"***********
ELSEIF(ISOURC = 18) ["Gaussian parallel beam source"
    IF (RBEAM >= RINMAX) [
       "Limit beam radius to
       "geometry radius, scaled down to insure a strike on the target"
       OUTPUT RBEAM,RINMAX;
         (//' ***WARNING IN SOURCE 18:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       WRITE(IOUTLIST,102)RBEAM,RINMAX;
    102 FORMAT(//' ***WARNING IN SOURCE 18:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       RBEAM=RINMAX;
    ]
    IFPB=0;"Set flag- passed in common SOURCE
    IF((ISOURC = 18)  &  (WINC ~= 1.)) IFPB=1; "Not for angled incidence
    RBEAM2=RBEAM**2;
]
" ISOURC = 19
"***********
ELSEIF(ISOURC = 19) ["Gaussian parallel beam source"
    IF (RBEAM >= RINMAX) [
       "Limit beam radius to
       "geometry radius, scaled down to insure a strike on the target"
       OUTPUT RBEAM,RINMAX;
         (//' ***WARNING IN SOURCE 19:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       WRITE(IOUTLIST,103)RBEAM,RINMAX;
    103 FORMAT(//' ***WARNING IN SOURCE 19:'/
            ' SIGMA OF INCIDENT BEAM IS BEYOND BOUNDARY OF CM !'
           /' SIGMA REDUCED FROM ',F8.3,' cm TO ',F8.3,' cm.'//);
       RBEAM=RINMAX;
    ]
    IFPB=0;"Set flag- passed in common SOURCE
    IF((ISOURC = 19)  &  (WINC ~= 1.)) IFPB=1; "Not for angled incidence
    RBEAM2=RBEAM**2;
]
" ISOURC=23
"***********
ELSEIF(ISOURC = 23)[ "beam simulation source"
   OUTPUT 'About to call init_beamsource';(//a);
   call init_beamsource(i_parallel,i_log,$CONFIGURATION_NAME,
                        hen_house,egs_home,the_beam_code,
                        the_pegs_file,the_input_file);
   call maxenergy_beamsource(EKMAXSRC);
]
RETURN;
END;    "End of subroutine SRCOTO
%E     "beamnrc.mortran - start subroutine srcout                         "
"*******************************************************************************
"
                            SUBROUTINE SRCOUT;
"                           *****************
"*******************************************************************************
"
"  Describe source.
"
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;

"T>****************************
"T>TYPE DECLARATIONS FOR SRCOUT
"T>****************************
"T>

INTEGER I,lnblnk1; "T>a looping index"

;COMIN/CMs,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,ENERGYSRC/;

;COMIN/BMODEL/;;

"*******************************************************************************
"
"                     EXECUTABLE PART OF CODE
"                     ***********************
"
WRITE(IOUTLIST,500);
500 FORMAT(' ',79('*')/T30,'SOURCE PARAMETERS'/);
IF(ISOURC < 21 | ISOURC=22)[
   IF(IQIN = 0)[WRITE(IOUTLIST,505);]   "IQIN is in COMIN SCORE"
   ELSEIF(IQIN = -1)[WRITE(IOUTLIST,506);]
   ELSEIF(IQIN = +1)[WRITE(IOUTLIST,507);]  "IQIN = 9 for full phase space"
]
502 FORMAT(T20,'INITIAL PARTICLES are electrons and positrons');
503 FORMAT(T20,'INITIAL PARTICLES are photons and positrons');
504 FORMAT(T20,'INITIAL PARTICLES are electrons, photons and positrons');
505 FORMAT(T20,'INITIAL PARTICLES are Photons');
506 FORMAT(T20,'INITIAL PARTICLES are Electrons');
507 FORMAT(T20,'INITIAL PARTICLES are Positrons');

;$BEAMMODEL_SRCOUT;"Beam model output"

IF(ISOURC = 0)[ WRITE(IOUTLIST,510) Z_SOURCE,RBEAM,UINC,VINC,WINC;
   510 FORMAT(T20,'PARALLEL BEAM ON FRONT FACE at Z=',F9.4,' cm'/
           T20,'Beam radius=',F9.4,' cm'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.5),')');
]
ELSEIF(ISOURC = 1)[ WRITE(IOUTLIST,520) DISTZ, Z_SOURCE;
   520 FORMAT(T5,'Point source on beam (Z) axis',F8.2, ' cm from FIRST CM, '/
           T5,'Front surface of CM at Z=',F9.4,' cm');
   IF(RBEAM<0.)["rectangular beam"
      WRITE(IOUTLIST,523)XINL,XINU,YINL,YINU;
      523  FORMAT(T5,'Collimated to rectangle with:'/
                  T5,'   X dimensions: ',F8.3,' - ',F8.3,' cm'/
                  T5,'   Y dimensions: ',F8.3,' - ',F8.3,' cm');
   ]
   ELSE[
      IF(GAMMA ~= 0.0)[WRITE(IOUTLIST,521) GAMMA;
        521  FORMAT(T5,' Half-angle of source=',F10.5,' degrees');
      ]
      ELSE [
           WRITE(IOUTLIST,522) RBEAM;
        522  FORMAT(T5,'Beam collimated to radius =',F8.3,' cm');
      ]
   ]
]
ELSEIF(ISOURC = 3)[
   IF(RBEAM>=0)[
       WRITE(IOUTLIST,525) ZSMIN,ZSMAX,RMINBM,RBEAM,MIN_CM_SRC3,MAX_CM_SRC3;
   ]
   ELSE[
       WRITE(IOUTLIST,526) ZSMIN,ZSMAX,RMINBM,ABS(RBEAM),
                          MIN_CM_SRC3,MAX_CM_SRC3;
   ]
   525 FORMAT(T5,'UNIFORM ISOTROPICALLY RADIATING RING CENTRED ON Z-AXIS'/
           T5,'SOURCE SPANS FROM Z=',F10.4,' cm to Z=',F10.4,' cm'/
           T5,'INNER RADIUS=',F10.4,' cm'/
           T5,'OUTER RADIUS=',F10.4,' cm'/
           T5,'SOURCE IS WITHIN CM(s)',I4,' -',I4);
526 FORMAT (T5,'UNIFORM ISOTROPICALLY RADIATING CYLINDER CENTRED || TO X-AXIS'/
           T5,'SOURCE SPANS FROM X=',F10.4,' cm to X=',F10.4,' cm'/
           T5,'Z OF THE SOURCE CENTRE=',F10.4,' cm'/
           T5,'RADIUS=',F10.4,' cm'/
           T5,'SOURCE IS WITHIN CM(s)',I4,' -',I4);
]
ELSEIF(ISOURC = 5)[ WRITE(IOUTLIST,530) GAMMA,RBEAM,Z_SOURCE;
   530 FORMAT(T5,'NRC swept beam  with half angle of ',F8.2, ' degrees '/
           T5,'BEAM SPOT RADIUS =',F8.3,' cm at Z=',F9.4,' cm');
]
ELSEIF(ISOURC = 6)[ WRITE(IOUTLIST,516) Z_SOURCE,XBEAM0,YBEAM0,XBEAM,YBEAM;
   516 FORMAT(T5,'PARALLEL RECTANGULAR BEAM ON FRONT FACE at Z=',
           F9.4,' cm'/
           T5,'CENTRED AT (Xh,Yh) = (',2F9.4,')'/
           T5,' HALF-WIDTH IN X DIRECTION:',F10.4,' cm'/
           T5,' HALF-WIDTH IN Y DIRECTION:',F10.4,' cm'/);
]
ELSEIF(ISOURC = 7)[ WRITE(IOUTLIST,537) FD_AT100, IRATIO_YXF, RBEAM;
   537 FORMAT(T5, ' SCANNING BEAM WITH FIELD SIZE AT SSD=100 : ', F15.7,
           T5, /'          THE FREQUENCY 2*RATION BETWEEN Y/X: ', I5,
           T5, /'          THE SPOT SIZE AT THE INITIAL POINT:', F15.7);
]
ELSEIF(ISOURC = 8)[ WRITE(IOUTLIST,538) DISTZ, Z_SOURCE;
   538 FORMAT(T5,'MM50 point scanned uniform circular source SSD',F8.2,
   ' cm from first CM, '/
           T5,'Front surface of CM(1) at Z=',F9.4,' cm');
   IF(GAMMA ~= 0.0)[WRITE(IOUTLIST,521) GAMMA;
   ]
   ELSE [ WRITE(IOUTLIST,522) RBEAM;
   ]
   WRITE(IOUTLIST,536) RBEAM0;
   536 FORMAT(T5,'Beam spot radius at Z=0 is ',F8.5,' cm');
]
ELSEIF(ISOURC = 9)[ WRITE(IOUTLIST,539) NPTS_SRC9, DISTZ, Z_SOURCE;
   539 FORMAT(T5,'MM50 scanned point source with',I4,' discrete points at SSD'/
              T5,'SSD=',F8.2,' cm, '/
           T5,'Front surface of CM(1) at Z=',F9.4,' cm'/
           T5,'(X,Y,PROBABILITY) of each point at SSD:');
   DO I=1,NPTS_SRC9[
      IF(I>1)[ WRITE(IOUTLIST,'(T10,3F10.4)')
           X_SRC9(I),Y_SRC9(I),PROB_SRC9(I)-PROB_SRC9(I-1);
      ]
      ELSE[ WRITE(IOUTLIST,'(T10,3F10.4)') X_SRC9(I),Y_SRC9(I),PROB_SRC9(I); ]
   ]
]
ELSEIF(ISOURC = 10)[ WRITE(IOUTLIST,511) RBEAM,UINC,VINC,WINC;
   511 FORMAT(T20,'PARALLEL CIRCULAR BEAM FROM SIDE, RADIUS=',F8.3,' cm'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.4),')');
]
ELSEIF(ISOURC = 13)[ WRITE(IOUTLIST,512) YBEAM,ZBEAM,UINC,VINC,WINC;
   512 FORMAT(T20,'PARALLEL RECTANGULAR BEAM FROM SIDE'/
           T20,'HALF-WIDTH(Y)=',F8.3,'cm, HALF-HEIGHT(Z)=',F8.3,' cm'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.4),')');
]
ELSEIF(ISOURC = 15)[ WRITE(IOUTLIST,540) GAMMA,ZFOCUS,THETAIN,RTHETAIN,SPCNAM;
540 FORMAT(T5,
   'NRC SWEPT BEAM WITH DIVERGENCE AND RADIAL INTENSITY DISTRIBUTION'/
  T5,'                     HALF ANGLE OF SWEPT CONE = ',F10.4,' degrees'/
  T5,'                            Z OF APEX OF CONE = ',F10.4,' cm'/
  T5,'                        BEAM DIVERGENCE ANGLE = ',F10.4,' degrees'/
  T5,'RADIUS AT WHICH BEAM DIVERGENCE ANGLE DEFINED = ',F10.4,' cm'//
             T5,'FILE CONTAINING RADIAL INTENSITY DISTRIBUTION:'/A//
             T5,'RADIAL INTENSITY DISTRIBTION...'//
             T5,'     bin     upper radius            '/
             T5,'      #          (cm)         prob.  '/);
             DO IB20=1,NRDIST[
                 WRITE(IOUTLIST,541)IB20,RDISTF(IB20),RPDF(IB20);
                 541 FORMAT(T5,I7,F17.8,E14.5);
             ]
]
ELSEIF(ISOURC = 18)[ WRITE(IOUTLIST,513) Z_SOURCE,RBEAM,RBEAM/0.42466,
                                         UINC,VINC,WINC;
513 FORMAT(T20,'PARALLEL BEAM WITH GAUSSIAN RADIAL DISTRIBUTION'/
           T20,'ON FRONT FACE at Z=',F9.4,' cm'/
           T20,'BEAM SIGMA=',F9.4,' cm (FWHM=',F9.4,' cm)'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.5),')');
]
ELSEIF(ISOURC = 19)[ WRITE(IOUTLIST,514) Z_SOURCE,RBEAM,RBEAM/0.42466,
                                         UINC,VINC,WINC;
514 FORMAT(T20,'PARALLEL BEAM WITH 2-D GAUSSIAN X-Y DISTRIBUTION'/
           T20,'ON FRONT FACE at Z=',F9.4,' cm'/
           T20,'BEAM SIGMA=',F9.4,' cm (FWHM=',F9.4,' cm)'/
           T17,' X,Y,Z DIRECTION COSINES = (',3(F10.5),')');
]

ELSEIF(ISOURC = 21 | ISOURC=24)[
              WRITE(IOUTLIST,640) SPCNAM,Z_SOURCE,INIT_ICM,NNPHSP,
                                         NPHOTSRC,EKMAXSRC,
                                         EKMINSRCE,NINCSRC,NRCYCL;
   640 FORMAT(T20,'FULL PHASE SPACE INPUT FOR EACH INCIDENT PARTICLE. '/
   T5,' SOURCE DATA FILE: ',A/
   T5,'             SOURCE INCIDENT ON FRONT FACE, Z =',F13.2,' cm'/
   T5,'                SOURCE INCIDENT ON MODULE ICM =',I13, /
   T5,'             Total # of particles in the file =',I13,/
   T5,'                     # of photons in the file =',I13,/
   T5,'                  Maximum energy of particles =',F13.3,' MeV'/
   T5,'                  Minimum energy of electrons =',F13.3,' MeV'/
   T5,' # of particles incident from original source =',F13.1/
   T5,'    # of times each particle will be recycled =',I13,/);
     IF(ISOURC=24)[
          WRITE(IOUTLIST,647)ALPHA24,BETA24,DIST24;
647 FORMAT(T5,
      ' Phase space plane incident from user-specified direction (Source 24):'/
   T5,'                angle of rotation wrt the X-axis =',F8.3,' degrees'/
   T5,'                angle of rotation wrt the Y-axis =',F8.3,' degrees'/
   T5,' distance of point of rotation above incident CM =',F8.3,' cm'/);
     ]
     IF(ISRC_DBS=1)[
          WRITE(IOUTLIST,644)RSRC_DBS,SSDSRC_DBS,ZSRC_DBS;
   644 FORMAT(T5,' Directional Bremsstrahlung Splitting (DBS) used'/
        T5,' in BEAM simulation to generate phase space source with:'/
        T10,'    DBS splitting radius =',F10.4,' cm'/
        T10,'SSD where radius defined =',F10.4,' cm'/
        T10,'   Z where source scored =',F10.4, 'cm'/
        T5,' Photons whose trajectory takes them outside the DBS splitting'/
        T5,' radius at the SSD will be rejected.'/);
     ]
     IF(IPARALLEL>1 & PARNUM>0)[
          WRITE(IOUTLIST,643) IPARALLEL,INT((PARNUM-1)*NNPHSP/IPARALLEL)+1,
                INT(PARNUM*NNPHSP/IPARALLEL);
   643 FORMAT(
   T5,' This is one of ',I4, ' parallel runs and will use from'/
   T5,' particle ',I12,' to particle ',I12,' in phase space source'/);
     ]
]
ELSEIF(ISOURC = 23)[ WRITE(IOUTLIST,646) Z_SOURCE,INIT_ICM,
                     $cstring(the_beam_code),
                    $cstring(the_input_file), $cstring(the_pegs_file),
                    EKMAXSRC,ALPHA24,BETA24,DIST24;
  646 FORMAT(T20,'BEAM SIMULATION SOURCE. '/
   T5,'             SOURCE INCIDENT ON FRONT FACE, Z =',F13.2,' cm'/
   T5,'                SOURCE INCIDENT ON MODULE ICM =',I13, /
   T32,'BEAMnrc simulation:  ',A/
   T40,'input file:  ',A/
   T36,'pegs data file:  ',A/
   T23,'Maximum energy of particles =',F13.3,' MeV'/
   T5,' angle of rotation of  source plane wrt the X-axis =',F8.3,' degrees'/
T5,' angle of rotation of source plane wrt the Y-axis =',F8.3,' degrees'/
T5,'  distance of point of rotation above incident CM =',F8.3,' cm'/);
   IF(ISRC_DBS=1)[
          WRITE(IOUTLIST,645);
          645 FORMAT(T5,' Fat photons from DBS will be rejected.'/);
   ]
]
IF(MONOEN=0&ISOURC~=31)[
   WRITE(IOUTLIST,641) EIN;
   641 FORMAT(/T20,'KINETIC ENERGY OF SOURCE =',F10.3,' MeV');
]
ELSEIF(MONOEN=1)[
   WRITE(IOUTLIST,642) FILNAM, ENMIN, ENSRCD(NENSRC),
                                     NENSRC;
   IF(IMODE=0)[
      WRITE(IOUTLIST,'(T20,''FILE CONTAINS COUNTS/BIN'')');
   ]
   ELSEIF(IMODE=1)[
      WRITE(IOUTLIST,'(T20,''FILE CONTAINS COUNTS/MeV'')');
   ]
   642 FORMAT(/T20,'INCIDENT ENERGY SPECTRUM READ FROM:'/A/
               T20,'MINIMUM KINETIC ENERGY OF SPECTRUM = ',F10.3,' MeV'/
               T20,'MAXIMUM KINETIC ENERGY OF SPECTRUM = ',F10.3,' MeV'/
               T20,'        NUMBER OF BINS IN SPECTRUM = ',I10);
]

;$BEAMMODEL_SOURCE_OUTPUT; "beam characterization model output"

RETURN;
END;    "End of subroutine SRCOUT
%E     "beamnrc.mortran - start subroutine srchst                         "
"*******************************************************************************
"
                      SUBROUTINE SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
"                     *****************
"*******************************************************************************
"
" Determine history-dependent parameters of source.
"
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;
;COMIN/
CMs,EPCONT,GEOM,IO_INFO,MEDIA,MISC,SCORE,SOURCE,STACK,UPHIOT,USER,
    RANDOM,RWPHSP,USEFUL,EGS-IO/;


"T>****************************
"T>TYPE DECLARATIONS FOR SRCHST
"T>****************************
"T>
;INTEGER
   IDIR,       "T>direction of source particle, 1=+Z direction
               "T>                             -1=-Z direction
   IRIN,       "T>region number of source
   IND_SCAN,   "T>index used in scanning beam source for the cycle index.
   I;          "T>a looping index
$REAL
   DIST_RAY,   "T>distance along ray from point source to first CM
   R2,         "T>square of randomly chosen X/Y source coordinates
   WEIGHT,     "T>weight of source particle
   UIN,VIN,WIN,"T>direction cosines of source
   XIN,YIN,ZIN,"T>coordinates of source
   XINPP,YINPP,XINP,YINP, "T>entrance coordinates of particles for source 15
   "XINS,YINS," "T>coordinates of sub-source not currently used
   ZZZ,RNG,  "T>coordinates of sub-source
   DELX,DELY, "T>deltas to add to XIN, YIN for source 8
   PHI,"T>variable for ISOURC=1
   DISTSRC_DBS, "T>stores distance along trajectory to DBS SSD (isourc=21)"
   RXYZ,FW,     "T>used for sampling ISOURC=1 as a rectangular beam"
   rand_dsb,    "T>for use in DSB"
   TEMP;        "T>used for source 24

REPLACE {$DSB_MAX_PARTICLE} WITH {1000}
$REAL  x_dsb, y_dsb, z_dsb, u_dsb($DSB_MAX_PARTICLE),
       v_dsb($DSB_MAX_PARTICLE),w_dsb($DSB_MAX_PARTICLE),
       wt_dsb($DSB_MAX_PARTICLE),wthin,xj,yj,disti,tcheck;
$INTEGER phat_dsb($DSB_MAX_PARTICLE),np_dsb,nthin,phatj,j;
$LOGICAL take_it;

$ENERGY PRECISION COS_THETA,SIN_THETA;"T>variable for ISOURC=1

;$LOCAL-VARIABLES-SOURCE31;

$ENERGY PRECISION EREAD;

/* Many of the sources below don't set the weight!
   So, set it to 1 first and the sources that have a different or variable
   weight will overwrite it below.
   IK, Aug 2004.
*/

data np_dsb/0/;
save x_dsb, y_dsb, z_dsb, u_dsb, v_dsb, w_dsb, wt_dsb, phat_dsb, np_dsb;

weight = 1;

"*******************************************************************************
"
"                         EXECUTABLE PART OF CODE
"                         ***********************
"
" ISOURC = 0
" **********
" Julio Lobo, Tony Popescu: Handle particles given by dosxyznrc
IF(dosxyz2beam_index<0)[GOTO :PARTICLE_FROM_DOSXYZ:;]

IF (ISOURC = 0) ["Frontal parallel beam source"
   IF (RBEAM =  0.0) ["pencil beam" /XIN,YIN/=0.0; ]
   ELSE["Choose a point randomly in a circle"
   ; LOOP[ $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=XIN**2+YIN**2; ] UNTIL R2 <= RBEAM2;
     ]
   IF(IFPB =  0)[WIN=1.0;UIN=0.0;VIN=0.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]
" ISOURC = 1
" **********
ELSEIF(ISOURC = 1) ["Frontal point source on axis"
   IF (RBEAM >= 0.0) [ " produce a circular beam "
      "pick angles randomly"
      $RANDOMSET RNG;
      COS_THETA = 1D0 - RNG* ONEMCOSGAM; "ONEMCOSGAM is 1-cos(1/2 angle=GAMMA)"
      "double precision since single precision causes COS_THETA to be "
      "1 when GAMMA is very small. The bug showed as a big peak around "
      "x=0,y=0 and a valley just outside it - rings actually near origin."
      SIN_THETA = DSQRT(1D0 - COS_THETA**2);
      $RANDOMSET PHI; PHI = 6.283185308*PHI;
      UIN = SIN_THETA*COS(PHI);
      VIN = SIN_THETA*SIN(PHI);
      WIN = COS_THETA;
      IF(WIN ~= 0.0)[
         ZZZ = DISTZ/WIN;
         XIN = ZZZ * UIN;
         YIN = ZZZ * VIN;
      ]
      ELSE [OUTPUT;(///' ****Initial particle will not hit target***'//);
        "this should be impossible since GAMMA is reduced to force a hit"
        $CALL_EXIT(1);
      ]
   ]
   ELSE [" produce rectangular beam"
      LOOP[" taken from DOSXYZ source 3"
          $RANDOMSET RNG;
          XIN=RNG*XINDEL+XINL;
          $RANDOMSET RNG;
          YIN=RNG*YINDEL+YINL;
          $RANDOMSET RNG;
          RXYZ=SQRT(DISTZ*DISTZ+XIN*XIN+YIN*YIN);
          WIN=DISTZ/RXYZ;
          IF(XINDEL=0. & YINDEL=0.)GOTO :FOUND_A_POINT:;
          FW=WIN**3.;
          IF(RNG<FW)GOTO :FOUND_A_POINT:;
      ]
      ;:FOUND_A_POINT:;
      UIN=XIN/RXYZ;
      VIN=YIN/RXYZ;
   ]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING DISK"
    "CHOOSE Z-COORDINATE FOR THE GENERATION OF A PARTICLE WITHIN REGION NSRCRG"
    ;:dsb_resample:;
    IF(RBEAM>=0)[
       $RANDOMSET ZIN;
       ZIN=ZSOFST+(2.0*ZIN-1.0)*ZBEAM;
       IF(RBEAM < 1.E-4)[
          XIN=0;
          YIN=0;
       ]
       ELSEIF(ABS(RBEAM-RMINBM) < 1.E-4)[
          $RANDOMSET XIN;
          XIN=TWOPI*XIN;
          YIN=RBEAM*SIN(XIN);
          XIN=RBEAM*COS(XIN);
       ]
       ELSE[
          LOOP[
              $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
              $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
              R2=XIN**2+YIN**2;
          ] UNTIL (R2 <= RBEAM2 & R2 >= RMINSQ);
       ]
    ]
    ELSE[
       $RANDOMSET XIN;
       XIN=ZSOFST+(2.0*XIN-1.0)*ZBEAM;
       IF(ABS(RBEAM)<1.E-4)[
          YIN=0;
          ZIN=RMINBM;
       ]
       ELSE[
          LOOP[
              $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*ABS(RBEAM);
              $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*ABS(RBEAM);
              R2=ZIN**2+YIN**2;
          ] UNTIL (R2 <= RBEAM2);
          ZIN=RMINBM+ZIN;
       ]
    ]
    "NOW DETERMINE INITIAL DIRECTION COSINES"

    IF( i_dsb = 1 ) [

        IF( np_dsb < 1 ) [

            " No particles left from previous calls => pick new "
            " position and directions                           "
            x_dsb = xin; y_dsb = yin; z_dsb = zin;

            " Number of thin source particles going towards circle "
            wthin = fs*fs*dsb_aeff*nbrspl/(2*(ssd-zin))**2;

            /*
            write(6,*) 'Picking particles: x = ',xin,yin,zin,' wthin = ',wthin,
              nhstry;
            */

            nthin = wthin; wthin = wthin - nthin;
            $RANDOMSET rand_dsb; IF( rand_dsb < wthin ) nthin = nthin + 1;
            /* write(6,*) 'nthin = ',nthin; */

            LOOP [

                " Increment history counters "
                nhstry = nhstry + 1;

                " Pick a direction for a phat particle "
                $RANDOMSET costhe; costhe = 2*costhe-1;
                sinthe = 1 - costhe**2;
                IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
                $RANDOMSET phi; phi = twopi*phi;
                uin = sinthe*cos(phi); vin = sinthe*sin(phi); win = costhe;
                /* write(6,*) 'phat: direction = ',uin,vin,win; */
                take_it = .true.;
                IF( win > 0 ) [
                    tcheck = (ssd-zin)/win;
                    IF( (xin+uin*tcheck)**2+(yin+vin*tcheck)**2 < fs*fs ) [
                        take_it = .false.;
                          " goes toward field, which is already taken "
                          " taken into account with thin particles"
                    ]
                ]

                np_dsb = 0;
                IF( take_it ) [
                    /* write(6,*) 'phat accepted'; */
                    u_dsb(1) = uin; v_dsb(1) = vin; w_dsb(1) = win;
                    wt_dsb(1) = 1; phat_dsb(1) = nbrspl;
                    np_dsb = 1;
                ]

                " Now pick nthin directions for the thin particles "
                DO j = 1,nthin [
                    IF( dsb_nbin > 1 ) [
                        call dsb_get_point(fs,dsb_nbin,dsb_rbin,dsb_prob,
                                dsb_ibin,xj,yj,phatj);
                    ]
                    ELSE [
                        LOOP [
                            $RANDOMSET xj; xj = 2*xj-1;
                            $RANDOMSET yj; yj = 2*yj-1;
                        ] UNTIL ( xj*xj + yj*yj < 1 );
                        phatj = 1; xj = xj*fs; yj = yj*fs;
                    ]
                    /* write(6,*) 'thin: ',j,xj,yj,phatj; */
                    uin = xj-xin; vin = yj-yin; win = ssd-zin;
                    disti = 1/sqrt(uin**2+vin**2+win**2);
                    $RANDOMSET rand_dsb; win = win*disti;
                    IF( rand_dsb < win**3 ) [
                        /* write(6,*) 'thin accepted'; */
                        uin = uin*disti; vin = vin*disti;
                        np_dsb = np_dsb + 1;
                        IF( np_dsb > $DSB_MAX_PARTICLE ) [
                          $egs_fatal(*,'In SRCHST number of stored particle ',
                                'directions exceeds ',$DSB_MAX_PARTICLE,
                                ' Increase $DSB_MAX_PARTICLE and retry');
                        ]
                        u_dsb(np_dsb) = uin; v_dsb(np_dsb) = vin;
                        w_dsb(np_dsb) = win; phat_dsb(np_dsb) = phatj;
                        wt_dsb(np_dsb) = dble(phatj)/nbrspl;
                    ]
                ]
            ] UNTIL (np_dsb > 0);
        ]

        xin = x_dsb; yin = y_dsb; zin = z_dsb;
        uin = u_dsb(np_dsb); vin = v_dsb(np_dsb); win = w_dsb(np_dsb);
        weight = wt_dsb(np_dsb); iphati = phat_dsb(np_dsb);
        /*
        write(6,*) 'Using stored particle ',np_dsb,':';
        write(6,*) xin,yin,zin,uin,vin,win,weight,iphati;
        */
        np_dsb = np_dsb - 1;

    ]
    ELSE [
        $RANDOMSET COSTHE;   COSTHE=2.*COSTHE-1;
        SINTHE=SQRT(1.0-COSTHE**2);
        $RANDOMSET PHI;PHI=TWOPI*PHI;
        UIN=SINTHE*COS(PHI);VIN=SINTHE*SIN(PHI);WIN=COSTHE;
        WEIGHT=1.0
    ]
    DO I=1,MAX_CMs[
       IF(ZIN < Z_min_CM(I+1))[
          ICM=I;
          EXIT;
       ]
    ]
    IDIR=2;
    IAUSFL(6)=0; "in case of no initial call to HOWFAR"
]

" ISOURC = 5
" **********
ELSEIF(ISOURC = 5) ["NRC swept beam "
   "Choose a point randomly in a circle"
   ; LOOP[ $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=XIN**2+YIN**2; ] UNTIL R2 <= RBEAM2;

   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
   WIN = COSGAMMA;
   $RANDOMSET RNG; RNG = TWOPI*RNG;"select angle 0 to 2 pie"
   UIN = COS(RNG)*SINGAMMA;
   VIN = SIN(RNG)*SINGAMMA;
]


" ISOURC = 6
" **********

ELSEIF (ISOURC = 6) ["Frontal parallel rectangular beam along z-axis"
   IF (RBEAM =  0.0) ["pencil beam" XIN=XBEAM0;YIN=YBEAM0; ]
   ELSE["Choose a point randomly in the field"
    ; $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*XBEAM+XBEAM0;
      $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*YBEAM+YBEAM0;
   ]
   UIN=UINC;VIN=VINC;WIN=WINC;
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

ELSEIF (ISOURC = 22) ["Frontal parallel rectangular beam along z-axis"
   IF (RBEAM =  0.0) ["pencil beam" XIN=XBEAM0;YIN=YBEAM0; ]
   ELSE["Choose a point randomly in the square ring"
       ; $RANDOMSET RNG;RNG=(2*RNG-1)*2*(XBEAM+YBEAM);
       IF(RNG<=-2*XBEAM)[
           YIN=RNG+2*XBEAM+YBEAM+YBEAM0;
           XIN=-XBEAM+YBEAM0;
       ]
       ELSEIF(RNG<=0.)[
           XIN=RNG+XBEAM+XBEAM0;
           YIN=-YBEAM+YBEAM0;
       ]
       ELSEIF(RNG<=2*YBEAM)[
           YIN=RNG-YBEAM+YBEAM0;
           XIN=XBEAM+XBEAM0;
       ]
       ELSE[
           XIN=RNG-2*YBEAM-XBEAM+XBEAM0;
           YIN=YBEAM+YBEAM0;
       ]
   ]
   UIN=UINC;VIN=VINC;WIN=WINC;
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

" ISOURC=7
"*********
ELSEIF(ISOURC=7) [  " the scanning beam  "
                    " origin at left bottom corner "
                    " scanning field at 100 cm
     $RANDOMSET RNG; IND_SCAN=RNG*IRATIO_YXF;
     IF( IND_SCAN >=IRATIO_YXF ) [ IND_SCAN=IRATIO_YXF-1; ] " should not happen
     $RANDOMSET XIN;   "  range [0,1)
     XIN=XSCAN_UNIT*XIN;  " rescale to [0, xscan_unit)
     IF( MOD(IND_SCAN, 2) = 0 ) [  YIN=XIN*IRATIO_YXF/2.0;] " go up scanning
     ELSEIF( MOD(IND_SCAN, 2) = 1 ) [  YIN=-XIN*IRATIO_YXF/2.0+FD_AT100;]
                                               " go down scanning "
                                               " y range [0, FD_AT100)
     XIN=XIN+IND_SCAN*XSCAN_UNIT;   " shift the x coord to each cycle
     IF(XIN>FD_AT100) [ XIN=-XIN+2.0*FD_AT100; ]    " the return scanning
                    " shift the origin to (0.0, 0.0) "
     XIN=XIN-FD_AT100/2.0;
     YIN=YIN-FD_AT100/2.0;
                    "  calc. the u, v, win  "
     DIST_RAY=SQRT( XIN*XIN+YIN*YIN+(100.0)**2); "modified to eliminate"
                                            "dependence of WIN on"
                                            "Z_min_CM(1)"
     WIN=(100.0)/DIST_RAY;
     UIN=XIN/DIST_RAY;
     VIN=YIN/DIST_RAY;

                   " now consider the beam spot size, i.e., not point source

   ; LOOP[ $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=XIN**2+YIN**2;
     ] UNTIL R2 <= RBEAM2;
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]


" ISOURC=8
"*********
ELSEIF(ISOURC = 8) ["scaned point source uniform on xy plane"
                    "cf ISOURC = 1 which is uniform in solid angle"

 "Choose a point randomly in a circle"
 ;LOOP[$RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
       $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
       R2=XIN**2+YIN**2;] UNTIL R2 <= RBEAM2;
   ZZZ = SQRT(XIN**2 + YIN**2 + DISTZ**2);
   IF(ZZZ > 0)[
      UIN=XIN/ZZZ;
      VIN=YIN/ZZZ;
      WIN=DISTZ/ZZZ;
   ]
   ELSE [OUTPUT;(///' ****some thing is wrong in source = 8***'//);
     $CALL_EXIT(1);
   ]
   IF(RBEAM0<=0.)[
     DELX=0.;DELY=0.;
   ]
   ELSE[
     LOOP[$RANDOMSET DELX;DELX=(2.0*DELX-1.0)*RBEAM0;
          $RANDOMSET DELY;DELY=(2.0*DELY-1.0)*RBEAM0;
          R2=DELX**2+DELY**2;] UNTIL R2 <= RBEAM0**2;
   ]
   ZIN=Z_SOURCE; "Incident Z position = Z_min_CM(1)"
   XIN=XIN*Z_SOURCE/DISTZ+DELX;"at origin if Z_SOURCE = 0.0"
   YIN=YIN*Z_SOURCE/DISTZ+DELY;
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

" ISOURC=9
"*********
ELSEIF(ISOURC = 9) ["scanned point source with discrete points on xy plane"
   $RANDOMSET XIN;  "randomly select which point to aim at"
   DO I=1,NPTS_SRC9[
     IF(XIN<PROB_SRC9(I))[
        XIN=X_SRC9(I);
        YIN=Y_SRC9(I);
        EXIT;  "exit DO loop since found and set this one"
     ]
   ]
   ZZZ = SQRT(XIN**2 + YIN**2 + DISTZ**2);
   IF(ZZZ > 0)[
      UIN=XIN/ZZZ;
      VIN=YIN/ZZZ;
      WIN=DISTZ/ZZZ;
   ]
   ELSE [OUTPUT;(///' ****some thing is wrong on the source = 9***'//);
     $CALL_EXIT(1);
   ]
   ZIN=Z_SOURCE; "Incident Z position"
   XIN=XIN*Z_SOURCE/DISTZ;
   YIN=YIN*Z_SOURCE/DISTZ;
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]

" ISOURC = 10
" ***********

ELSEIF (ISOURC = 10) ["parallel circular beam from side on x-ray target"
   IF (XTUBE_EXISTS ~= 1) [
       OUTPUT;(////'   SORRY, MY FRIEND, THIS SOURCE CAN ONLY BE USED'/
                   '   TOGETHER WITH THE COMPONENT MODULE XTUBE FOR THE'/
                   '   SIMULATION OF THE TARGET OF AN X-RAY TUBE !!!!!!');
       GOTO :ERROR_SOURCE:;
   ]
   IF (RBEAM =  0.0) ["pencil beam"YIN=0.0; XIN=0.0;ZIN=0.0;]
   ELSE["Choose a point randomly in a circle"
       LOOP[ $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*RBEAM;
           $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
           R2=ZIN**2+YIN**2; ] UNTIL R2 <= RBEAM2;
   ]
   XIN=-ZIN*TAN(ANGLE);"start from target surface"
   ZIN=Z_min_CM(1)+(Z_min_CM(2)-Z_min_CM(1))/2.+ZIN;
   UIN=UINC;VIN=VINC;WIN=WINC;
   ICM = 1; "Entering first component module"
   IDIR = 0; "Entering from side"
]

" ISOURC = 13
" ***********

ELSEIF (ISOURC = 13)["parallel rectangular beam from side on x-ray target"
   IF (XTUBE_EXISTS ~= 1) [
       OUTPUT;(////'   SORRY, MY FRIEND, THIS SOURCE CAN ONLY BE USED'/
                   '   TOGETHER WITH THE COMPONENT MODULE XTUBE FOR THE'/
                   '   SIMULATION OF THE TARGET OF AN X-RAY TUBE !!!!!!');
       GOTO :ERROR_SOURCE:;
   ]
   IF ((YBEAM =  0.0)&(ZBEAM =  0.0))
       ["pencil beam"
       YIN=0.0; XIN=0.0;
       ZIN=Z_min_CM(1)+(Z_min_CM(2)-Z_min_CM(1))/2.;
   ]
   ELSE["Choose a point randomly in a circle"
       $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*ZBEAM;
       $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*YBEAM;
       XIN=-ZIN*TAN(ANGLE);"start from target surface"
       ZIN=Z_min_CM(1)+(Z_min_CM(2)-Z_min_CM(1))/2.+ZIN;
       UIN=UINC;VIN=VINC;WIN=WINC;
       ICM = 1; "Entering first component module"
       IDIR = 0; "Entering from side"
   ]
]

" ISOURC = 15
" ***********

ELSEIF (ISOURC = 15)["swept beam with radial intensity distribution"
                     "and angular variation"

    "THIS ENTRY DOES THE ACTUAL SAMPLING OF THE INCIDENT RADIAL INTENSITY"
    "DISTRIBUTION"
    "THIS WILL RETURN A HISTOGRAM OF VALUES"
    :RETRY_SOURCE15:;
    $RANDOMSET RNNO1;$RANDOMSET RNNO2;
    DO IB20=1,NRDIST[
       RNNO1=RNNO1 - RCDF(IB20);
       IF(RNNO1 <= 0) EXIT;
    ]
    RIN=SQRT(RCDFIN(IB20,1)+RNNO2*RCDFIN(IB20,2));
    IF(RIN < 0)[
      IF(RIN < -0.0001)[
        OUTPUT;(//' ****WARNING IN SOURCE 15:'/
                  ' Sampled radius < 0.0'//);
      ]
      GOTO :RETRY_SOURCE15:;
    ]
    IF(RIN > RDISTF(NRDIST))[
      IF(RIN > 1.0001*RDISTF(NRDIST))[
         OUTPUT;(//' ****WARNING IN SOURCE 15:'/
                  ' Sampled radius > max. radius'//);
      ]
      GOTO :RETRY_SOURCE15:;
    ]

    ZIN=Z_min_CM(1);
    ICM = 1; "Entering first component module"

   "IF(THETAIN ~= 0.)["
       "$RANDOMSET RNG; "
       "COSTHETA = 1D0 -  RNG * (1.0 - DCOS(THETAIN));"
       "SINTHETA = DSQRT( 1D0 -  COSTHETA**2 );"
    " see qa_isourc15_theory.tex for proof"
    " the above sampling by itself will produce uniform fluence"
    "]"
    "ELSE[ COSTHETA = 1D0;"
    " SINTHETA = 0D0;"
    "]"


    " the above proved to make profiles much worse, see nrc20s_r[5-7]_xyz_e3"
    " note that in nrc20s_r and s series convergence was assumed not divergence"

    "THETAI = DACOS(COSTHETA);"
    " THETAI  is in radians "

    " now I'll try this:  assume that the divergence increases radially: "

    THETAI = DATAN( RIN/RTHETAIN * DTAN(THETAIN/57.29578));
    COSTHETA = DCOS(THETAI);
    " for the results of this see nrc20s_u series "

    SINTHETA = DSIN(THETAI);


    WINP = COSTHETA;
    $RANDOMSET RNG; RNG = TWOPI*RNG;
    XINPP = RIN * COS(RNG);
    YINPP = RIN * SIN(RNG);
    UINP = COS(RNG) * SINTHETA;
    VINP = SIN(RNG) * SINTHETA;


    $RANDOMSET RNG; RNG = TWOPI*RNG;
    COSRNG = COS(RNG);
    SINRNG = SIN(RNG);

    " Rotate (UINP,VINP,WINP) first by GAMMA (azimuth) then by RNG (phi)"
    UIN =       UINP * COSRNG
              + VINP * SINRNG * COSGAMMA
              + WINP * SINRNG * SINGAMMA ;
    VIN = -1.0 * UINP * SINRNG
              + VINP * COSRNG * COSGAMMA
              + WINP * COSRNG * SINGAMMA;
    WIN = -1.0 * VINP * SINGAMMA
              + WINP * COSGAMMA;

" do a 2-D rotation through phi to find XINP, YINP--Note that this"
" assumes that the source radial intensity distribution is defined in a plane"
" parallel to the ZFOCUS plane (ie not tilted with gamma)"

    XINP = XINPP*COSRNG + YINPP*SINRNG;
    YINP = -1.0 * XINPP*SINRNG + YINPP*COSRNG;

    " now project back to ZIN "

    XIN = XINP - (ZFOCUS - ZIN)/WIN*UIN;
    YIN = YINP - (ZFOCUS - ZIN)/WIN*VIN;

]
" ISOURC = 18
" **********
ELSEIF (ISOURC = 18) ["Parallel beam source with Gaussian radial distn"
   IF (RBEAM =  0.0) ["pencil beam" /XIN,YIN/=0.0; ]
   ELSE["Choose a random Gaussian point in a 1-D Gaussian distribution"
     IF(CHOSEN_SRC18=0)["need to choose 2 new gaussian distributed radii"
        LOOP[ $RANDOMSET ZIN;
            ZIN=RBEAM*SQRT(-2*LOG(1-ZIN));
        ] UNTIL ZIN<=RINMAX;
        $RANDOMSET XIN;
        XIN=2.*3.1415926*XIN;
        RIN1_SRC18=ZIN*COS(XIN);
        RIN2_SRC18=ZIN*SIN(XIN);
        ZIN=RIN1_SRC18;
        CHOSEN_SRC18=1;
     ]
     ELSE[
        ZIN=RIN2_SRC18;
        CHOSEN_SRC18=0;
     ]
     "generate a random angle"
     $RANDOMSET YIN; YIN = 2.*3.1415926*YIN;
     XIN = ZIN*COS(YIN);
     YIN = ZIN*SIN(YIN);
   ]
   IF(IFPB =  0)[WIN=1.0;UIN=0.0;VIN=0.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]
" ISOURC = 19
" **********
ELSEIF (ISOURC = 19) ["Parallel beam source with gaussian X-Y"
   IF (RBEAM =  0.0) ["pencil beam" /XIN,YIN/=0.0; ]
   ELSE["Choose a random Gaussian point in a 2-D Gaussian distribution"
     ;
     /*
     ;  XIN = RINMAX; "use XIN as limit on radius"
     ;  LOOP[ $RANDOMSET ZIN;
            ZIN=SQRT(-2.*RBEAM2*LOG(1.-ZIN)); "ZIN really radius"
            ] UNTIL ZIN <= XIN;
        "generate a random angle"
        $RANDOMSET YIN; YIN = 2.*3.1415926*YIN;
        XIN = ZIN*COS(YIN);
        YIN = ZIN*SIN(YIN);
      */
      LOOP [
          $RANDOMSET ZIN;
          ZIN=SQRT(-2*LOG(1.-ZIN)); "ZIN really radius"
          $RANDOMSET YIN; YIN = 2.*3.1415926*YIN;
          XIN = xo_src19 + RBEAM*ZIN*COS(YIN);
          YIN = yo_src19 + RBEAMY*ZIN*SIN(YIN);
      ] UNTIL (ABS(XIN)<RINMAX&ABS(YIN)<RINMAX&XIN*XIN+YIN*YIN<RINMAX*RINMAX);
   ]
   IF( sigma_src19 > 0 ) [
     "find uin,vin,win if there is angular spread"
       LOOP [
           $RANDOMSET win; win = 1 + sigma_src19*log(1-win);
       ] UNTIL (win > 0);
       uin = sqrt((1-win)*(1+win));
       $RANDOMSET PHI; PHI = 6.283185308*PHI;
       vin = uin*sin(phi); uin = uin*cos(phi);
   ] ELSE [
       IF(IFPB =  0)[WIN=1.0;UIN=0.0;VIN=0.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
   ]
   ZIN=Z_SOURCE; "Incident Z position"
   ICM = 1; "Entering first component module"
   IDIR = 1; "Entering from front"
]
" ISOURC = 21 or 24
" ***********
ELSEIF(ISOURC = 21 | ISOURC=24)["Full phase space for each particle"
  IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)["recycle this particle"
     CYCLNUM=CYCLNUM+1;
     XIN=XINOLD;
     YIN=YINOLD;
     UIN=UINOLD;
     VIN=VINOLD;
     WIN=WINOLD;
     WEIGHT=WEIGHTOLD;
     ICM=INIT_ICMOLD;
     ZIN=ZINOLD;
     IF(I_MUPHSP_IN~=0)[
       "make sure any synchronized CMs do not change BEAM_MU_INDEX by setting"
       "BEAM_MU_INDEX_OLD to something different than BEAM_MU_INDEX"
       BEAM_MU_INDEX_OLD=BEAM_MU_INDEX - 1.1;
     ]
     "all other parameters are global and unchanged"
  ]
  ELSE["get a new particle from the phsp file"

     INPHSP=INPHSP+1; "increment counter for particle no."

     :SOURCE_READ:;
    "Note that for ISOURC=21, not only do we need to get the parameters"
    "for SRCHST (i.e. XIN,YIN,ZIN,UIN,VIN,WIN,IRIN and WEIGHT) but also"
    "IQIN and EIN passed in COMIN/SCORE. Note that EKIN is usually"
    "KE for other sources - but in main we treat it as total energy"
    "since that is what it is in the phase space file"

#ifdef HAVE_C_COMPILER;
     "output a warning if we are restarting the chunk of the phase"
     "space source"
     IF(n_parallel>0 & INPHSP>INPHSP_MAX)[
        "rewind phsp source and output a warning"
        INPHSP=INPHSP_MIN;
        OUTCNT=OUTCNT+1;
       OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
       /1x,79('*')// );
      IF(i_iaea_in=1)[ NHSTRY=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
                    "above ensures that NHSTRY is accurate"
                    "note the equivalent does not work for BEAMnrc"
                    "format phsp sources"
          $IAEA_SET_PHSP_RECORD(IINSRC,INPHSP);]
     ]
#endif;

     IF(IPARALLEL>1 & PARNUM>0 & INPHSP > INT(PARNUM*NNPHSP/IPARALLEL))[
       INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+1;
       OUTCNT=OUTCNT+1;
       OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM PARTITION IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS PARTITION.'//
       /1x,79('*')// );
       IF(i_iaea_in=1)[ NHSTRY=OUTCNT*NINCSRC/IPARALLEL;
                  $IAEA_SET_PHSP_RECORD(IINSRC,INPHSP); ]
     ]
     ELSEIF(INPHSP.GT.NNPHSP)[
       "used up all the particles stored in the ph-sp file"
       INPHSP=1;"set the pointer back to the beginning of the ph-sp file"
       OUTCNT=OUTCNT+1;
       OUTPUT ;(///' ***WARNING*** USED ALL PARTICLES FROM SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN FILE.'//
       /1x,79('*')// );
       IF(i_iaea_in=1)[ NHSTRY=OUTCNT*NINCSRC;
                 $IAEA_SET_PHSP_RECORD(IINSRC,1); ]
     ]
   IF(i_iaea_in=1)[
       $IAEA_READ_PHSP_RECORD(IINSRC,NPASSI,NHSTRY,LATCHI,IQIN,EREAD,
        WEIGHT,XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST(1),BEAM_MU_INDEX);
       IF(I_MUPHSP_IN=0)BEAM_MU_INDEX=BEAM_MU_INDEX_OLD;
       "ensure BEAM_MU_INDEX gets reset if BEAM_MU_INDEX gets set"
       "to a nonsense value."
   ]
   ELSE[
   $READ_PHSP(IZLAST,IINSRC,INPHSP+1:NHSTRY,NPASSI,IQIN,WIN,ZLAST(1),LATCHI,
               EREAD,WEIGHT,XIN,YIN,UIN,VIN);
   ]
   IF((i_iaea_in=0 & IERR_PHSP>0) | (i_iaea_in=1 & iaea_n_stat=-2))[
         "end of file encountered -restart same file"
       IF(IPARALLEL>1 & PARNUM>0)[
         INPHSP=INT((PARNUM-1)*NNPHSP/IPARALLEL)+1;
         OUTCNT=OUTCNT+1;
         OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM PARTITION IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS PARTITION.'//
       /1x,79('*')// );
       ]
       ELSE[
         INPHSP=1;"set the pointer back to the beginning of the ph-sp file"
         OUTCNT=OUTCNT+1;
         OUTPUT ;(///' ***WARNING*** USED ALL PARTICLES FROM SOURCE FILE!'/
         '               RESTARTING FROM FIRST PARTICLE IN FILE.'//
       /1x,79('*')// );
       ]
       GOTO :SOURCE_READ:;
    ]
    IF (NPASSI ~= 0) [
       NPASS_ph_sp = NPASS_ph_sp + 1;INPHSP=1+INPHSP;
       GOTO :SOURCE_READ:; "Discard particles if they or their"
                           "ancestors have crossed scoring plane"
    ]
    ELSEIF(ISRC_DBS=1 & IQIN=0)["possibly reject fat photon"
       DISTSRC_DBS=(SSDSRC_DBS-ZSRC_DBS)/WIN;
       IF((XIN+UIN*DISTSRC_DBS)**2+(YIN+VIN*DISTSRC_DBS)**2>RSRC_DBS**2)[
           NFAT_ph_sp=NFAT_ph_sp+1;
           INPHSP=1+INPHSP;
           GOTO :SOURCE_READ:;
       ]
    ]
    EIN = EREAD;  "double prec EREAD stuffed into s.p. variable"
    IF(IQIN = -1)[N_ph_sp_e = N_ph_sp_e + 1; E_ph_sp_e = E_ph_sp_e+EIN;]
    IF(IQIN = 0)[N_ph_sp_g = N_ph_sp_g + 1; E_ph_sp_g = E_ph_sp_g+EIN;]
    IF(IQIN = +1)[N_ph_sp_p = N_ph_sp_p + 1; E_ph_sp_p = E_ph_sp_p+EIN;]
    E_MAX_ph_sp = MAX(E_MAX_ph_sp,EIN);   "ignores rest mass issue"

    IF(ISOURC=24 & (ALPHA24~=0 | BETA24 ~=0))[
          "rotate particle about specified point"
       ZIN = Z_SOURCE-DIST24 - XIN*CALPHA24*SBETA24 - YIN*SALPHA24 +
             DIST24*CALPHA24*CBETA24;
       YIN = -XIN*SALPHA24*SBETA24 + YIN*CALPHA24 + DIST24*SALPHA24*CBETA24;
       XIN =  XIN*CBETA24 + DIST24*SBETA24;
       TEMP = WIN;
       WIN = -UIN*CALPHA24*SBETA24 - VIN*SALPHA24 + WIN*CALPHA24*CBETA24;
       VIN = -UIN*SALPHA24*SBETA24 + VIN*CALPHA24 + TEMP*SALPHA24*CBETA24;
       UIN =  UIN*CBETA24 + TEMP*SBETA24;
       DO I=1,MAX_CMs[
        IF(ZIN < Z_min_CM(I+1))[
           ICM=I;
           EXIT;
        ]
       ]
       IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 24: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
       ]
       IDIR=2; "entering from within CM"
       IAUSFL(6)=0; "in case of no initial call to HOWFAR"
    ]
    ELSEIF(IZSCORE=1)["use Z read from IAEA phsp file"
      DO I=1,MAX_CMs[
        IF(ZIN < Z_min_CM(I+1))[
           ICM=I;
           EXIT;
        ]
      ]
      IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 21: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
      ]
      IDIR=2; "entering from within CM"
      IAUSFL(6)=0;
    ]
    ELSE[
      ZIN=Z_SOURCE; "Incident Z position"
      ICM = INIT_ICM; "Entering first component module"
                  "changed to any module by JWEI "
      IDIR=1;
    ]

    IF(NRCYCL>0)["store parameters that are not global for recycling"
      CYCLNUM=1;
      XINOLD=XIN;
      YINOLD=YIN;
      ZINOLD=ZIN;
      INIT_ICMOLD=ICM;
      UINOLD=UIN;
      VINOLD=VIN;
      WINOLD=WIN;
      WEIGHTOLD=WEIGHT;
    ]
  ]"end of getting a new particle"
]

ELSEIF(ISOURC=23) ["full beam simulation source"
  :retry_sample_beamsource:;
  call sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,
                         iqin,latchi,nhstry,iphati);
  IF(ISRC_DBS=1 & iqin=0 & iphati>1)[
      NFAT_ph_sp=NFAT_ph_sp+1;
      GOTO :retry_sample_beamsource:;
  ]
  IF(IQIN = -1)[N_ph_sp_e = N_ph_sp_e + 1; E_ph_sp_e = E_ph_sp_e+EIN;]
  IF(IQIN = 0)[N_ph_sp_g = N_ph_sp_g + 1; E_ph_sp_g = E_ph_sp_g+EIN;]
  IF(IQIN = +1)[N_ph_sp_p = N_ph_sp_p + 1; E_ph_sp_p = E_ph_sp_p+EIN;]
  E_MAX_ph_sp = MAX(E_MAX_ph_sp,EIN);   "ignores rest mass issue"

  IF(ALPHA24 ~= 0 | BETA24 ~= 0)["rotate particle about specified point"
       ZIN = Z_SOURCE-DIST24 - XIN*CALPHA24*SBETA24 - YIN*SALPHA24 +
             DIST24*CALPHA24*CBETA24;
       YIN = -XIN*SALPHA24*SBETA24 + YIN*CALPHA24 + DIST24*SALPHA24*CBETA24;
       XIN =  XIN*CBETA24 + DIST24*SBETA24;
       TEMP = WIN;
       WIN = -UIN*CALPHA24*SBETA24 - VIN*SALPHA24 + WIN*CALPHA24*CBETA24;
       VIN = -UIN*SALPHA24*SBETA24 + VIN*CALPHA24 + TEMP*SALPHA24*CBETA24;
       UIN =  UIN*CBETA24 + TEMP*SBETA24;
       DO I=1,MAX_CMs[
        IF(ZIN < Z_min_CM(I+1))[
           ICM=I;
           EXIT;
        ]
       ]
       IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 23: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
       ]
       IDIR=2;"entering from inside CM"
       IAUSFL(6)=0;
  ]
  ELSE[
       ZIN=Z_SOURCE; "Incident Z position"
       ICM = INIT_ICM; "Entering first component module"
                  "changed to any module by JWEI "
       IDIR=1; "entering from front"
  ]
]

" ISOURC = 31
" **********
ELSEIF(ISOURC = 31) ["beam characterization model"
$BEAMMODEL_SOURCE_SAMPLING;
$BEAMMODEL_PASSING_VARIABLES;
]"end of ISOURC = 31"

" Determine initial region
" ************************
" Following expands into set of calls to WHERE_AM_I_$CMNAME to determine region
" number particle is entering in component module ICM.  Require X(NP) and Y(NP)
" in WHERE_AM_I_$CMNAME.
NP = 1;
X(NP) = XIN;
Y(NP) = YIN;
Z(NP) = ZIN;  " added by jwei, NOV. 12, 1992
IQ(NP)= IQIN;
U(NP)=UIN;
V(NP)=VIN;
W(NP)=WIN;
USTEP=0.0;    " this is useful only for isourc=21, the particle enters the
"             INIT_ICM module at the beginning of the correlated simulation,
"             which will overcome a problem with where_am_i_$CMNAME, where when
"             the CM is not the first one, it always uses ustep to determine
"             the ir in the CM.     --added by JWEI.
IF(ISOURC~=21 & ISOURC~=23 & ISOURC~=24)[LATCHI=0;]
LATCH(NP)=LATCHI;

;:PARTICLE_FROM_DOSXYZ:;

IF(dosxyz2beam_index<0)["the stack values were already set in beam_lib.mortran"
			" just need to set the initial values"
    NP=1;
    EIN=E(NP);
    IQIN=IQ(NP);
    XIN=X(NP);
    YIN=Y(NP);
    IF(dosxyz2beam_izscore=1)["use Z from iaea phsp"
        ZIN=Z(NP);
        DO I=1,MAX_CMs[
          IF(ZIN < Z_min_CM(I+1))[
             ICM=I;
             EXIT;
          ]
        ]
        IF(CMTYPE(ICM)~='SLABS' & CMTYPE(ICM)~='FLATFILT' &
          CMTYPE(ICM)~='SIDETUBE')[
         OUTPUT;(/' Error in source 24: Particle not incident within a'/
                  ' CM capable of handling internal sources (SLABS, FLATFILT'/
                  ' or SIDETUBE)'//);
         STOP;
        ]
        IDIR=2;
        IAUSFL(6)=0;
    ] ELSE [
        ZIN=Z_SOURCE;
        Z(NP)=Z_SOURCE;
        IF(ISOURC=21 | ISOURC=23 | ISOURC=24)[
            ICM = INIT_ICM;
        ]
        ELSE["assume it is incident on CM 1"
            ICM=1;
        ]
        IDIR=1;
    ]
    UIN=U(NP);
    VIN=V(NP);
    WIN=W(NP);
    WEIGHT=WT(NP);
    USTEP=0.0;    " this is useful only for isourc=21, the particle enters the
"             INIT_ICM module at the beginning of the correlated simulation,
"             which will overcome a problem with where_am_i_$CMNAME, where when
"             the CM is not the first one, it always uses ustep to determine
"             the ir in the CM.     --added by JWEI.
    LATCHI=LATCH(NP);

]

IF( INSIDE_FLAG > 0 ) [ IRNEW = INSIDE_FLAG; ]
ELSE [
    IF(ISOURC=3 | ISOURC=10 | ISOURC=13 |
       (ISOURC=24 & (ALPHA24 ~= 0 | BETA24 ~= 0)) |
       (ISOURC=23 & (ALPHA24 ~= 0 | BETA24 ~= 0)) |
       (ISOURC=21 & IZSCORE=1) | dosxyz2beam_izscore=1)[
          ;$GOTO_CM_LIST(WHAMI) ICM;
          ;$WHERE_AM_I;
    ]
    ELSE [CALL WHERE_AM_I(ICM-1,1); ]
         "so we can set contaminant bit if needed"
]
IF($BTEST(LATCH(NP),30))["it enters as a contaminant particle"
                          "store this in LATCHI"
       LATCHI=$IBSET(LATCHI,30);
]
IRIN=IRNEW;
RETURN;
:ERROR_SOURCE:
;OUTPUT;
(////' *** SIMULATION STOPS DUE TO THE USE OF WRONG SOURCE/CM ***'//);
$CALL_EXIT(1);

END;   "End of subroutine SRCHST"
%E     "beamnrc.mortran - start subroutine where_am_i                     "
"*******************************************************************************
"
                          SUBROUTINE WHERE_AM_I(IICM,IDIR);
"                         *********************
"*******************************************************************************
"
"     WHERE_AM_I routine for BEAMnrc.
"
" This routine is called from HOWFAR_$CMNAME when a particle reaches the front
" (IDIR=1) or back (IDIR=-1) of a component module.  The index of the new
" component module, ICMNEW, is determined and the correct WHERE_AM_I_$CMNAME
" subroutine is called to determine the new region number, IRNEW.  IAUSFL(6) is
" also set to 1 to initiate an AUSGAB call following particle transport to check
" if the component module boundary is also a scoring plane.
"
"*******************************************************************************
"
"                    TYPE DECLARATIONS AND COMMON BLOCKS
"                    ***********************************
"
$IMPLICIT-NONE;
;COMIN/CMs,EPCONT,STACK,USER/;

"T>********************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I
"T>********************************
"T>
INTEGER
   IICM, "T>component module where current particle resides
   IDIR; "T>particle direction, +1=downstream, -1=upstream

"*******************************************************************************
"
"                 CALL WHERE_AM_I SUBROUTINE OF NEXT COMPONENT MODULE
"                 ***************************************************
"
ICMNEW = IICM+IDIR; "Index of new component module particle is about to enter"
IAUSFL(6) = 1;      "Flag to call AUSGAB after particle transport"
IDIRG=IDIR;         "set the global value of IDIR for later test in AUSGAB"

"
"   Check vacuum region 1 surrounding geometry
"   ******************************************
"
" Check if leaving front or back of geometry

IF (ICMNEW > MAX_CMs | ICMNEW <= 0 ) [ ICMNEW=0; IRNEW=1; RETURN; ]

" Check if leaving geometry through cylindrical boundary
IF (RMAX_CM_FLAG(ICMNEW)=1 &
      (X(NP)+USTEP*U(NP))**2+(Y(NP)+USTEP*V(NP))**2>RMAX_CM2(ICMNEW)) [
   ICMNEW=0; IRNEW=1; RETURN;
]

"Check if leaving geometry through square boundary
ELSEIF (RMAX_CM_FLAG(ICMNEW)=2 &
        (ABS(X(NP)+USTEP*U(NP))>RMAX_CM(ICMNEW) |
         ABS(Y(NP)+USTEP*V(NP))>RMAX_CM(ICMNEW))) [
   ICMNEW=0; IRNEW=1; RETURN;
]
"
"   Check regions within next CM
"   ****************************
" When the particle with charge IQ_CONTAM first enters the front of module
" ICM_CONTAM, the following will automatically
" set the bit 30 of LATCH to record the photon or electron contamination
" and use it in AUSGAB to score the dose separately.
"Note that the IDIR=1 condition was added Sept 2002 to make this"
"correspond only to contamination entering from the front"
"Prior to that, contamination was defined from the back as well"
"Mary Chin pointed this out"
IF(ITDOSE_ON = 1)["dose components are to be calculated  "
   IF(ICMNEW=ICM_CONTAM & ABS(IQ(NP))=ABS(IQ_CONTAM) & (IDIR = 1)) [
      LATCH(NP)=$IBSET(LATCH(NP), 30);
   ]
]

"  The following expands into a computed go to which finds regions in
"  next CM using WHERE_AM_I_$CMNAME?
"
;$GOTO_CM_LIST(WHAMI) ICMNEW;
;$WHERE_AM_I;

RETURN;

END;     "Last line of subroutine WHERE_AM_I"

%E     "beamnrc.mortran - start subroutine datetime                       "
"The following subroutine expands into the macros CALL DATE and CALL TIME"
"Originally, the macros were expanded in the body of the program"
"wherever DATEN and TIMEN had to be set, but this leads to the presence"
"of machine-dependent code throughout BEAMnrc.  With this new format,"
"machine-dependent date and time routines will only exist within this"
"subroutine, making it easier to modify BEAMnrc to run on different"
"machines"

"**********************************************************************"
              SUBROUTINE DATETIME(DUMMY);
"
"**********************************************************************"
$IMPLICIT-NONE;
;COMIN/IO_INFO/;      "contains the variables DATEN,TIMEN,DNTIME"
INTEGER DUMMY;"just a dummy variable"
"June 19, 97  back to CALL DATE    CALL TIME since"
"g77 V0.5.20 works   not sure what g77 does."
"CALL DATE(DATEN); CALL TIME(TIMEN);
"above needed possibly to match up with machine.mortran"
"but following avoids the machine.mortran macro translation"
"and for some unknown reason, works with Linux/g77 whereas"
"the translation, which should be identical, doesnt"
";CALL FDATE(DNTIME);   "
"DATEN(1:7)=DNTIME(5:12);   "
"DATEN(8:11)=DNTIME(21:24);   "
"TIMEN=DNTIME(12:19);   "

" IK: use the EGSnrc egs_fdate function instead. "
call egs_get_fdate(DNTIME);
daten(1:7)=dntime(5:11);
daten(8:11)=dntime(21:24);
timen(1:8)=dntime(12:19);


RETURN;

END; "end of the subroutine DATETIME"


%E    "beamnrc.mortran---start of subroutine SELECT_PHOTON_MFP"

SUBROUTINE SELECT_PHOTON_MFP(DDPMFP);

"This subroutine takes the place of the old $SELECT-PHOTON-MFP macro.
"We enter this subroutine for every photon step"
"variables related to photon forcing (declared in USER-PHOTON-FORCING):"
"NFCMIN=the CM number at which to begin forcing"
"NFCMAX=the CM number after which forcing is stopped"
"NFMIN=the number of interactions occurring within NFCMIN<=CM<=NFCMAX"
"      at which to begin forcing--option has been cut out and is now always"
"      treated as 1"
"NFMAX=the number of interactions occurring within NFCMIN<=CM<=NFCMAX"
"      after which to stop forcing"
"NFTIME(NP)=the number of times that a photon has interacted in"
"           NFCIMIN<=CM<=NFCMAX if photon forcing is on.  By making this"
"           a stack variable, we now force all child photons NFMAX-NFTIME(NP)"
"           times, where NFTIME(NP) is the number of photon interactions"
"           of the parent particle."
"NP_INC(NP)=1 for the photon which is forced to interact "
"          =0 if it is a new photon which may or may not require"
"             forcing"

$IMPLICIT-NONE;
;COMIN/USER,RANDOM,STACK,SCORE,EPCONT,BOUNDS,CMs,USEFUL,PHOTIN,MISC,IO_INFO,
       EGS-IO/;

$REAL RNNO35, "used to store random numbers"
     DDPMFP, "local variable used for number of MFP's to next interaction"
     COHFAC; "Rayleigh scattering correction"

$INTEGER LGLE;   "index for GMFP interpolation"

$RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;

IF(IFORCE =  0)["no photon forcing" DDPMFP=-LOG(RNNO35); ]

ELSEIF(NP_INC(NP) =  0)["this is a new photon. Check if it should"
                        "be forced to interact.                  "
    NFTIME(NP)=NFTIME(NP)+1;
                    "increment NFTIME(NP) here.  That way, the number of"
                    "interactions is incremented once and only once"
                    "for either a forced or unforced interaction"

    IF((NFTIME(NP) >  NFMAX) | (IR_TO_CM(IR(NP))<NFCMIN)
        | (IR_TO_CM(IR(NP))>NFCMAX) | (NP=$MXSTACK))[
            "forcing not needed in these cases"
            "Above used to also contain a test if NFTIME < NFMIN, however"
            "the NFMIN option has been deleted since it is difficult to"
            "implement and its value is questionable.  Thus, NFMIN is now"
            "always treated as 1."

        IF((IR_TO_CM(IR(NP))<NFCMIN) | (IR_TO_CM(IR(NP))>NFCMAX) )[
            NFTIME(NP)=NFTIME(NP)-1;
            "Since we have already incremented NFTIME(NP) above, we have to"
            "decrement it back to its original value if"
            "the interaction is not occurring within NFCMIN<=CM<=NFCMAX"
            "don't count as it's not in the required CMs"
        ]
        ELSEIF(NP=$MXSTACK)[ "cannot force it to interact here "

            OUTPUT; (' WARNING: MAXIMUM STACK NUMBER REACHED ',
            /' PHOTON INTERACTION FORCING IGNORED THIS TIME!!' );
            NFTIME(NP)=NFTIME(NP)-1;
            "don't count as it cannot be done in this case"
        ]
        DDPMFP=-LOG(RNNO35);
    ]"end of block where forcing not needed although it is on"

    ELSE["force this photon to interact in the specified CMs"
        $SELECT-PHOTON-MFP-FOR-FORCING(DDPMFP);
    ]
] "end of NP_INC(NP) = 0 case "

ELSE[ "NP_INC(NP)=1, now transport the photon that is forced to       "
      "interact in the specified CMs.                                 "
    NP_INC(NP)=0; "re-set the flag"

    IAUSFL(6)=0;"re-set the flag in case it has been set in HOWFAR"

    EPSLON=RNNO35*GWAIT(NP);
    IF(EPSLON <= 1.0E-3)[ DDPMFP=EPSLON*(1.+0.5*EPSLON); ]
    ELSE[
         ARG=1./(1.-EPSLON);
         DDPMFP=LOG(ARG);
    ]
] "end of NP_INC(NP) = 1 case "

RETURN;
END;  "end of subroutine SELECT_PHOTON_MFP"

"==============================================================================
subroutine kill_the_photons(nstart,kill_electrons);
implicit none;
$INTEGER nstart,kill_electrons,rrprobi;
;COMIN/STACK,RANDOM,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;

$USER-KILL-PHOTONS;

IDBS=nstart; count_kill_tmp = 0;
IF( nstart > np ) [ return; ]
LOOP[;
   IF(IQ(IDBS)=0) [
       PLAYRR_DBS=0;
       IF(W(IDBS)<=0)[ PLAYRR_DBS=1; rrprobi = nbrspl;]
       ELSE["see if photon is aimed into the field"
           DIST_DBS=(SSD-Z(IDBS))/W(IDBS);"distance to SSD"
           R2_DBS=(X(IDBS)+DIST_DBS*U(IDBS))**2 +
            (Y(IDBS)+DIST_DBS*V(IDBS))**2;"R^2 at SSD"
           IF(R2_DBS >= FS**2) [ PLAYRR_DBS=1; rrprobi = nbrspl; ]
           ELSE IF( do_dsb = 1 ) [
               r2_dbs = r2_dbs/fs**2;
               DO k_dsb=1,dsb_nbin [
                   IF( r2_dbs < dsb_rbin(k_dsb+1) ) EXIT;
               ]
               rrprobi = k_dsb; PLAYRR_DBS=1;
           ]
       ]
       IF(PLAYRR_DBS=1)[
           $RANDOMSET RNNO_DBS;
           IF(RNNO_DBS*rrprobi > 1) ["kill particle"
               count_kill_tmp =count_kill_tmp + 1;
               IF(IDBS<NP)[
                 IF(IWATCH=1 | IWATCH=2)[
                   OUTPUT 1./NBRSPL,IDBS,E(IDBS),IQ(IDBS),IR(IDBS),X(IDBS),
                   Y(IDBS),Z(IDBS),U(IDBS),V(IDBS),W(IDBS),LATCH(IDBS),WT(IDBS);
                   (T10,'Eliminating photon with probability ',F8.5,' :'/
                   T36,I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                 ]
                 E(IDBS)=E(NP);IQ(IDBS)=IQ(NP);WT(IDBS)=WT(NP);
                 U(IDBS)=U(NP); V(IDBS)=V(NP); W(IDBS)=W(NP);
                 iphat(idbs) = iphat(np);
               ]
               ELSE[
                 IF(IWATCH=1 | IWATCH=2)[
                   OUTPUT 1./NBRSPL,NP,E(NP),IQ(NP),IR(NP),X(NP),Y(NP),
                   Z(NP),U(NP),V(NP),W(NP),LATCH(NP),WT(NP);
                   (T10,'Eliminating photon with probability ',F8.5,' :'/
                   T36,I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                 ]
               ]
               NP=NP-1;
           ]
           ELSE["keep particle and increase weight"
               WT(IDBS)=WT(IDBS)*rrprobi;
               IPHAT(IDBS)=rrprobi;"mark it as a fat photon"
               IF(IWATCH=1 | IWATCH=2)[
                 OUTPUT IDBS,E(IDBS),IQ(IDBS),IR(IDBS),X(IDBS),
                 Y(IDBS),Z(IDBS),U(IDBS),V(IDBS),W(IDBS),LATCH(IDBS),WT(IDBS);
                 (T10,'Photon survives Russian Roulette :'/
                 T36,I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
               ]
               IDBS=IDBS+1;
          ]
      ]
      ELSE["keep the photon"
          idbs=idbs+1;
      ]
  ]
  ELSE["this is a charged particle, keep it"
     IF( kill_electrons = 0 ) [ IDBS=IDBS+1; ]
     ELSE [
         $RANDOMSET RNNO_DBS;
         IF(RNNO_DBS*NBRSPL > 1) ["kill particle"
             IF(IDBS<NP)[
                 E(IDBS)=E(NP);IQ(IDBS)=IQ(NP);WT(IDBS)=WT(NP);
                 U(IDBS)=U(NP); V(IDBS)=V(NP); W(IDBS)=W(NP);
             ]
             np=np-1;
         ]
         ELSE [ "keep particle and increase weight"
             WT(IDBS)=WT(IDBS)*NBRSPL;
             IPHAT(IDBS)=NBRSPL;
             IDBS=IDBS+1;
         ]
     ]
  ]
] UNTIL (IDBS>NP);
return; end;

"====================================================================="
          subroutine uniform_photons(nsample,energy);
"====================================================================="
" Samples nsample photons with random directions.                     "
" If a photon hits a circle with radius fs at z position ssd, it is   "
" put on the stack with a weight wt(npold)/nbrspl. If it does not,    "
" it is kept on the stack with probability 1/nbrspl and given a       "
" weight of wt(npold). To reduce the number of uniformly sampled      "
" directions, the minimum and maximum polar angles for which a photon "
" may hit the circle is calculated and on average                     "
"   nsample*(ct_max-ct_min)/2                                         "
" are forced to have polar angles between ct_min and ct_max.          "
" To be used for annihilation at rest and fluorescent photons         "
" nsample will be 2*nbrspl for annihilation events and nbrspl for     "
" fluorescent photons                                                 "
" IK, September 2002.                                                 "
"====================================================================="
implicit none;
$INTEGER nsample;
$REAL    energy;
;COMIN/STACK,RANDOM,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,
       USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;
$REAL    ro,d,aux,ct_min,ct_max,an_split,rnno,weight,cost,sint,xx,yy,cphi,sphi;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
$INTEGER n_split,i,ns;

" Calculate the minimum and maximum polar angles that may result "
" in a direction towards the circle with radius fs at ssd        "
ro = sqrt(x(np)*x(np)+y(np)*y(np)); d = ssd - z(np); aux = (ro + fs)/d;
ct_min = 1./sqrt(1+aux*aux);
IF( ro <= fs ) [ ct_max = 1; ]
ELSE [ aux = (fs-ro)/d; ct_max = 1./sqrt(1+aux*aux); ]

" Out of the nsample uniform photons, an_split will be having polar angles "
" between ct_min and ct_max                                               "
an_split = 0.5*(ct_max - ct_min)*nsample;
n_split = an_split; an_split = an_split - n_split;
$RANDOMSET rnno; IF( rnno < an_split ) [ n_split = n_split + 1; ]
count_kill_tmp = nsample - n_split;

" Now create the nsplit photons. Note: not all directions with polar angles "
" between ct_min and ct_max will hit the circle. We will therefore play "
" Russian Roulette with photons not going towards the circle            "
weight = wt(npold)/nbrspl;
np = np-1;
DO i=1,n_split [
    $RANDOMSET rnno; cost = ct_min + rnno*(ct_max - ct_min);
    sint = 1-cost*cost;
    IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    aux = d/cost*sint;
    xx = x(npold) + aux*cphi; yy = y(npold) + aux*sphi;
    ns = 0; rsq_dsb = xx*xx + yy*yy;
    IF( rsq_dsb < fs*fs ) [
        ns = 1;
        IF( do_dsb = 1 ) [
            rsq_dsb = rsq_dsb/fs**2;
            DO k_dsb = 1,dsb_nbin [
                IF( rsq_dsb < dsb_rbin(k_dsb+1) ) EXIT;
            ]
            ns = k_dsb;
        ]
    ]
    ELSE [ ns = nbrspl; ]
    IF( ns > 1 ) [
        $RANDOMSET rnno;
        IF( rnno*ns > 1 ) [ ns = 0; ]
    ]
    IF( ns > 0 ) [
        np = np+1;
        $CHECK-STACK(np,'uniform_photons');
        $TRANSFER PROPERTIES TO (np) FROM (NPold);
        e(np) = energy; iq(np) = 0; wt(np) = weight*ns;
        u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        iphat(np) = ns;
    ] ELSE [ count_kill_tmp = count_kill_tmp + 1; ]
]

" There will be on average (1-(ct_max-ct_min)/2)*nsample photons with   "
" polar angles outside of the desired range. Such photons are guaranteed"
" to not hit the circle => they must be Russian Rouletted => on average "
" (1-(ct_max-ct_min)/2)*nsample/nbrspl will survive. We model this by   "
" sampling nsample/nbrspl photons using all polar angles and rejecting  "
" those with polar angles between ct_min and ct_max (taken into account "
" above).                                                               "
n_split = nsample/nbrspl;
DO i=1,n_split [
    $RANDOMSET rnno; cost = 2*rnno-1;
    IF( cost < ct_min | cost > ct_max ) [
        sint = 1-cost*cost;
        IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
        $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
        np = np+1;
        $CHECK-STACK(np,'uniform_photons');
        $TRANSFER PROPERTIES TO (np) FROM (NPold);
        e(np) = energy; iq(np) = 0; wt(np) = weight*nbrspl;
        u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
        iphat(np) = nbrspl;
    ] ELSE [ count_kill_tmp = count_kill_tmp + 1; ]
]
return; end;

REPLACE {$STORE-PARTICLE-PROPERTIES-DBS;} WITH {
  x_dbs=x(np); y_dbs=y(np); z_dbs=z(np); ir_dbs=ir(np); wt_dbs=wt(np);
  dnear_dbs=dnear(np); latch_dbs=latch(np); zlast_dbs=zlast(np);
  nftime_dbs=nftime(np); nsplit_dbs=nsplit(np);
  DO j=1,$MAX_SC_PLANES[ npass_dbs(j) = npass(np,j); ]
  u_dbs=u(np); v_dbs=v(np); w_dbs=w(np); e_dbs=e(np);
};

REPLACE {$RESTORE-PARTICLE-PROPERTIES-DBS;} WITH {
        x(np)=x_dbs; y(np)=y_dbs; z(np)=z_dbs;
        wt(np)=wt_dbs; iq(np)=0; ir(np)=ir_dbs;
        dnear(np)=dnear_dbs; latch(np)=latch_dbs; zlast(np)=zlast_dbs;
        nftime(np)=nftime_dbs; nsplit(np)=nsplit_dbs;
        DO j=1,$MAX_SC_PLANES[ npass(np,j)=npass_dbs(j); ]
        u(np)=u_dbs; v(np)=v_dbs; w(np)=w_dbs; e(np)=e_dbs;
        iphat(np)=1;
};

"==========================================================================="
         subroutine do_compton;
"==========================================================================="
" Performs nbrspl compton events. All electrons are killed with probability "
" 1/nbrspl. Scattered photons are kept on the stack if they go towards the  "
" circle wirh radius fs at ssd, otherwise they also are killed with         "
" probability 1/nbrspl.                                                     "
"                                                                           "
" IK, September 2002                                                        "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;
$INTEGER np_save,i,j,kill_electrons,nps;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nbrspl;
IF(ICM_DBS>0 & Z(NP)>ZRR_DBS)[ kill_electrons=0; ] ELSE [ kill_electrons=1; ]
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nbrspl [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_compton');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    nps = np;
    IF(LATCH_OPTION=2 | LATCH_OPTION=3)LATCH(np)= LATCHOUT;
    "easier to pass on latch of secondaries by transferring"
    IF(IZLAST=1)zlast(np)=z(np);
    call compt;
    IF(LATCH_OPTION=2 | LATCH_OPTION=3)[
       IF(np>npold)[LATCH(npold)=LATCHIN;]
       ELSE[LATCH(npold)=LATCHOLD;]"interaction rejected"
    ]
    IF(IZLAST=1 & np=npold)zlast(npold)=zlastold;"interaction rejected"
    call kill_the_photons(nps,kill_electrons);
    IF(IZLAST=2)[
       DO j=NPold,NP[
           ZLAST(j)=Z(j);
           XLAST(j)=X(j);
           YLAST(j)=Y(j);
       ]
    ]
]
npold = np_save;
/*
IF(ICM_DBS>0 & Z(NP)>ZRR_DBS)["do not Rus Rou. electrons"
   call kill_the_photons(np_save,0);
]
ELSE["Rus. Rou. electrons"
   call kill_the_photons(np_save,1);
]
*/
return; end;

"==========================================================================="
         subroutine do_pair;
"==========================================================================="
" Performs nbrspl pair events. This is only used if IBRSPL=2 (DBS) with     "
" electron splitting and Z(NP)>ZRR_DBS.  Resulting charged particles are all"
" kept.                                                                     "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;
$INTEGER np_save,i,j;

np_save = np; iphat(np)=1; wt(np) = wt(np)/nbrspl;
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nbrspl [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_pair');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    call pair;
]
npold = np_save;
return; end;

"==========================================================================="
         subroutine do_photo;
"==========================================================================="
" Performs nbrspl photoelectric events. This is only used if IBRSPL=2 (DBS) "
" with electron splitting and Z(NP)>ZRR_DBS.  Resulting electrons are all   "
" kept.                                                                     "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;
$INTEGER np_save,i,j;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nbrspl;
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nbrspl [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_photo');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    call photo;
]
npold = np_save;
return; end;

"==========================================================================="
         subroutine do_old_rayleigh(nsample);
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,EGS-IO,
       USER-STACK,USER-PHOTON-FORCING,RANDOM,THRESH,UPHIOT,PHOTIN,USEFUL/;
$INTEGER np_save,i,j,lxxx,nsample,nps;
$REAL    xxx,x2,q2,csqthe,rejf,rnnorj;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nsample;
$STORE-PARTICLE-PROPERTIES-DBS;
DO i=1,nsample [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_old_rayleigh');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    ;
    :retry-loop: LOOP [
        $RANDOMSET xxx;
        $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
        Q2=X2*RMSQ/(20.60744*20.60744);
        COSTHE=1.-Q2/(2.*E(NP)*E(NP));
        IF (ABS(COSTHE).GT.1.0) GO TO :retry-loop:;
        CSQTHE=COSTHE*COSTHE;
        REJF=(1.0+CSQTHE)/2.0;
        $RANDOMSET RNNORJ;
    ] UNTIL (RNNORJ <= REJF);
    SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
    nps = np;
    call kill_the_photons(nps,0);
]
npold = np_save;
"call kill_the_photons(np_save,0);"
return; end;

"==========================================================================="
subroutine do_rayleigh(nsample);
"==========================================================================="
implicit none;
$declare_max_medium;
$INTEGER np_save,i,j,lxxx,nsample,nps,lgle;
$REAL    loge;
;COMIN/PHOTIN,USEFUL,EPCONT,STACK,RANDOM,UPHIOT,THRESH,
       USER-DIRECTIONAL-BREM-SPLITTING,USER-STACK,EGS-IO,
       USER-PHOTON-FORCING,USER-SPLITTING/;

np_save = np; iphat(np) = 1; wt(np) = wt(np)/nsample;
$STORE-PARTICLE-PROPERTIES-DBS;
"loge = log(E(NP)); LGLE=GE1(MEDIUM)*loge+GE0(MEDIUM);
loge = gle; LGLE=GE1(MEDIUM)*loge+GE0(MEDIUM);
DO i=1,nsample [
    IF( i > 1 ) [
        np=np+1;
        $CHECK-STACK(np,'do_rayleigh');
        $RESTORE-PARTICLE-PROPERTIES-DBS;
    ]
    call egs_rayleigh_sampling(medium,e(np),gle,lgle,costhe,sinthe);
    call uphi(2,1);
    nps = np; call kill_the_photons(nps,0);
]
npold = np_save;
return; end;

"==========================================================================="
       subroutine do_smart_compton;
"==========================================================================="
" If Compton scattering is modeled using Klein-Nishina, and if one keeps    "
" just one electron per Compton event, one
" can substantially improve the DBS efficiency by calculating in advance    "
" the probability for scattered photons going into the circle of interest.  "
" This subroutine implements the technique.                                 "
"                                                                           "
" I. Kawrakow, Septemner 2002                                               "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,RANDOM,THRESH,UPHIOT,PHOTIN,USEFUL,
       USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;
$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
$REAL    ctmin,ctmax,ko,ko2,eps1,eps2,w1,w2,wc,broi,alpha1_t,alpha2_t,
         alpha_t,alpha1,alpha2,alpha,eps1_t,eps2_t,eps1_0,eps2_0,
         rnno,rnno1,rnno2,rnno3,rej1,rej2,rejmax,rejf,asample,
         weight,br,cost,sint,temp,cphi,sphi,us,vs,un,vn,wn,x1,y1,
         eps12_t,eps12,sindel,cosdel,sinpsi,aux,ro;
real*8   peig,pese,pesg;
$INTEGER nsample,i,ns;
$LOGICAL need_rotation;
$INTEGER ntest;
"$REAL    nc1,nc2,nc3;

"ntest = 1000000; nc1=0; nc2=0; nc3=0;

call get_ctminmax(x(np),y(np),z(np),u(np),v(np),w(np),ro,fs,ssd,ctmin,ctmax);
"write(25,*) '*******do_smart_compton: e = ',e(np),' ctmin/max = ',ctmin,ctmax,
"' weight = ',wt(np);
"write(25,*) ' pos: ',x(np),y(np),z(np),' dir: ',u(np),v(np),w(np);
npold = np;
peig = e(np); ko = peig/rm; broi = 1 + 2*ko;  ko2 = ko*ko;
alpha1_t = Log(broi);
eps1_t = 1./broi; eps2_t = 1;
w2 = alpha1_t*(Ko2-2*Ko-2)+(eps2_t-eps1_t)*(1./eps1_t/eps2_t + broi
    + Ko2*(eps1_t+eps2_t)/2);
eps12_t = eps1_t*eps1_t; alpha2_t = (eps2_t*eps2_t-eps12_t);
alpha_t = alpha1_t/(alpha1_t+alpha2_t/2);
eps1 = 1./(1+Ko*(1-ctmin)); eps2 = 1./(1+Ko*(1-ctmax));
eps1_0 = eps1; eps2_0 = eps2;
alpha1 = log(eps2/eps1);
w1 = alpha1*(Ko2-2*Ko-2)+(eps2-eps1)*(1./eps1/eps2 + broi
    + Ko2*(eps1+eps2)/2);
eps12 = eps1*eps1; alpha2 = (eps2*eps2-eps12);
alpha = alpha1/(alpha1+alpha2/2);
rej1 = 1-(1-eps1)*(broi*eps1-1)/(Ko*Ko*eps1*(1+eps1*eps1));
rej2 = 1-(1-eps2)*(broi*eps2-1)/(Ko*Ko*eps2*(1+eps2*eps2));
rejmax = MAX(rej1,rej2);

wc = w1/w2;
asample = wc*nbrspl; nsample = asample; asample = asample - nsample;
$RANDOMSET rnno; IF( rnno < asample ) [ nsample = nsample + 1; ]
nsample = nsample + 1;
"write(25,*) ' wc = ',wc,' nsample = ',nsample;

sinpsi = u(npold)*u(npold)+v(npold)*v(npold);
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = v(npold)/sinpsi; cosdel = u(npold)/sinpsi;
    need_rotation = .true.;
] ELSE [ need_rotation = .false.; ]
weight = wt(npold)/nbrspl;

DO i=1,nsample [
    IF( i = nsample ) [
        eps1 = eps1_t; eps2 = 1; eps12 = eps12_t;
        alpha1 = alpha1_t; alpha2 = alpha2_t; alpha = alpha_t;
        rejmax = 1;
    ]
    LOOP [
        $RANDOMSET rnno1; $RANDOMSET rnno2; $RANDOMSET rnno3;
        IF( rnno1 < alpha ) [ br = eps1*exp(alpha1*rnno2); ]
        ELSE                [ br = sqrt(eps12 + rnno2*alpha2); ]
        Temp = (1-Br)/Ko/Br; Sint = Temp*(2-Temp);
        rejf = 1 - Br*Sint/(1+Br*Br);
    ] WHILE ( rnno3*rejmax > rejf );
    pesg = br*peig; pese = prm + peig - pesg;
    IF( Temp < 2 ) [ cost = 1 - Temp; sint = sqrt(Sint); ]
    ELSE [ cost = -1; sint = 0; ]
    $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
    IF( i = nsample ) [
        IF( br > eps1_0 & br < eps2_0 ) goto :do_the_electron:;
        ns = nbrspl;
    ]
    IF( need_rotation ) [
        us = sint*cphi; vs = sint*sphi;
        un = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
        vn = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
        wn = w(npold)*cost - sinpsi*us;
    ]
    ELSE [ un = sint*cphi; vn = sint*sphi; wn = w(npold)*cost; ]
    IF( i < nsample ) [
        ns = nbrspl;
        IF( wn > 0 ) [
            aux = (ssd-z(npold))/wn;
            x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
            rsq_dsb = x1*x1+y1*y1;
            IF( rsq_dsb < fs*fs ) [
                ns = 1;
                IF( do_dsb = 1 ) [
                    rsq_dsb = rsq_dsb/fs**2;
                    DO k_dsb=1,dsb_nbin [
                        IF( rsq_dsb < dsb_rbin(k_dsb+1) ) EXIT;
                    ]
                    ns = k_dsb;
                ]
            ]
        ]
        IF( ns > 1 ) [
            $RANDOMSET rnno;
            IF( rnno*ns > 1 ) [ ns = 0; ]
        ]
    ]
    "IF( wn > 0 ) [
    "    aux = (ssd-z(npold))/wn;
    "    x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
    "    write(25,*) '+',i,ns,cost,sqrt(x1*x1+y1*y1);
    "] ELSE [ write(25,*) '-',i,ns,cost,wn; ]
    IF( ns > 0 ) [
        np = np+1;
        $CHECK-STACK(np,'do_smart_compton');
        $TRANSFER PROPERTIES TO (np) FROM (npold);
        u(np) = un; v(np) = vn; w(np) = wn; iq(np) = 0; wt(np) = weight*ns;
        e(np)=pesg; iphat(np) = ns;
    ]
]

:do_the_electron:
aux = 1 + Br*Br - 2*Br*cost;
IF( aux > 1e-8 ) [
    cost = (1-Br*cost)/sqrt(aux);
    sint = 1 - cost*cost;
    IF( sint > 0 ) [ sint = -sqrt(sint); ]
    ELSE [ sint = 0; ] "write(6,*) 'Precision problem in smart compton'; ]"
    us = sint*cphi; vs = sint*sphi;
    u(npold) = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
    v(npold) = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
    w(npold) = w(npold)*cost - sinpsi*us;
]
e(npold) = pese; iq(npold) = -1; iphat(npold) = nbrspl;

return; end;

"==========================================================================="
       subroutine do_smart_brems;
"==========================================================================="
" If the brems angular distribution is simple (leading term, ibrdst=0), one "
" can substantially improve the DBS efficiency by calculating in advance    "
" the probability for brems emission into the circle of interest.           "
" This subroutine implements the technique.                                 "
"                                                                           "
" I. Kawrakow, Septemner 2002                                               "
"==========================================================================="
implicit none;
;COMIN/STACK,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,RANDOM,THRESH,UPHIOT,PHOTIN,USEFUL,
       BREMPR,EGS-VARIANCE-REDUCTION,EPCONT,NIST-BREMS,
       USER-DIRECTIONAL-SOURCE-BIASING,EGS-IO/;

$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
$REAL    ener, tau, beta2, beta, ct_min, ct_max, wprob, asample, aux1,
         aux2, sinpsi, sindel, cosdel, rnno, cost, sint, cphi, sphi, r1,
         us, vs, un, vn, wn, weight, eie, ekin, ese, esg, brmin, waux,
         ajj,br,alias_sample1,rnno06,rnno07,delta,phi1,phi2,rejf,x1,y1,aux;
$REAL    r,ro,d,dmin,wprob1,dist,disti,rnno_o;
$INTEGER nsample,i,ibr,ns,jj,l,l1,ip,j;
$LOGICAL need_rotation,method1;
real*8   peie,pese,pesg;

npold = np;
ener = e(np) - rm; tau = ener/rm;
beta2 = tau*(tau+2)/(tau+1)**2; beta = sqrt(beta2);
call get_ctminmax(x(np),y(np),z(np),u(np),v(np),w(np),ro,fs,ssd,ct_min,ct_max);
wprob = (ct_max - ct_min)/((1-beta*ct_max)*(1-beta*ct_min)*2*
                             (tau+1)*(tau+1));

d = ssd - z(np);
IF( ro <= fs ) [ dmin = d; ] ELSE [ dmin = sqrt(d*d + (ro-fs)*(ro-fs)); ]
wprob1 = fs*fs*d/(2*dmin*dmin*dmin);
aux = (tau+1)*(1-beta*ct_max);
wprob1 = wprob1/(2*aux*aux);

IF( wprob1 < wprob ) [ method1 = .true.; wprob = wprob1; ]
ELSE                 [ method1 = .false.; ]

IF( wprob < 1 ) [
    asample = wprob*nbrspl; nsample = asample; asample = asample - nsample;
    $RANDOMSET rnno; IF( rnno < asample ) [ nsample = nsample + 1; ]
] ELSE [ ct_max = 1; ct_min = -1; nsample = nbrspl; method1 = .false.; ]

" Now we know approximately how many photons will go into the circle of "
" interest. Sample them. "
aux1 = ct_max - ct_min; aux2 = 1 - beta*ct_max; weight = wt(np)/nbrspl;
sinpsi = u(npold)*u(npold)+v(npold)*v(npold);
IF( sinpsi > 1e-20 ) [
    sinpsi = sqrt(sinpsi); sindel = v(npold)/sinpsi; cosdel = u(npold)/sinpsi;
    need_rotation = .true.;
] ELSE [ need_rotation = .false.; ]
"$RANDOMSET rnno_o;
DO i=1,nsample [
    IF( method1 ) [
        $RANDOMSET r; $RANDOMSET rnno;
        IF( rnno > r ) r = rnno;
        "r = sqrt((i-rnno_o)/nsample);
        $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
        x1 = fs*r*cphi; y1 = fs*r*sphi;
        un = x1 - x(npold); vn = y1 - y(npold); wn = d;
        dist = sqrt(un*un + vn*vn + wn*wn); disti = 1/dist;
        cost = (u(npold)*un + v(npold)*vn + w(npold)*wn)*disti;
        rejf = (1-beta*ct_max)*dmin*disti/(1-beta*cost);
        rejf = rejf*rejf*dmin*disti;
        $RANDOMSET rnno;
        IF( rnno < rejf ) [
            ns = 1; un = un*disti; vn = vn*disti; wn = wn*disti;
        ]
        ELSE [ ns = 0; ]
    ]
    ELSE [
        $RANDOMSET rnno; rnno = rnno*aux1;
        "rnno = (i-rnno_o)/nsample; rnno = rnno*aux1;
        cost = (ct_min*aux2+rnno)/(aux2+beta*rnno);
        sint = 1-cost*cost;
        IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
        $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
        IF( need_rotation ) [
            us = sint*cphi; vs = sint*sphi;
            un = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
            vn = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
            wn = w(npold)*cost - sinpsi*us;
        ]
        ELSE [ un = sint*cphi; vn = sint*sphi; wn = w(npold)*cost; ]
        ns = 0;
        IF( wn > 0 ) [
            aux = (ssd-z(npold))/wn;
            x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
            rsq_dsb = x1*x1+y1*y1;
            IF( rsq_dsb <= fs*fs ) [
                ns = 1;
                IF( do_dsb = 1 ) [
                    rsq_dsb = rsq_dsb/fs**2;
                    DO k_dsb=1,dsb_nbin [
                        IF( rsq_dsb < dsb_rbin(k_dsb+1) ) EXIT;
                    ]
                    ns = k_dsb;
                ]
            ]
        ]
        IF( ns > 1 ) [
            $RANDOMSET rnno;
            IF( rnno*ns > 1 ) [ ns = 0; ]
        ]
    ]
    IF( ns > 0 ) [
        np = np+1;
        $CHECK-STACK(np,'do_smart_brems');
        $TRANSFER PROPERTIES TO (np) FROM (npold);
        u(np) = un; v(np) = vn; w(np) = wn; iq(np) = 0; wt(np) = weight*ns;
        iphat(np) = ns;
    ]
]

" Now pick one more direction and if it is not between ct_min and ct_max "
" (already taken into account above), add a fat photon                   "
aux1 = 2; aux2 = 1 - beta;
$RANDOMSET rnno; rnno = rnno*aux1;
cost = (rnno-aux2)/(aux2+beta*rnno);
sint = 1-cost*cost; IF( sint > 0 ) [ sint = sqrt(sint); ] ELSE [ sint = 0; ]
$SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
IF( need_rotation ) [
    us = sint*cphi; vs = sint*sphi;
    un = w(npold)*cosdel*us - sindel*vs + u(npold)*cost;
    vn = w(npold)*sindel*us + cosdel*vs + v(npold)*cost;
    wn = w(npold)*cost - sinpsi*us;
]
ELSE [ un = sint*cphi; vn = sint*sphi; wn = w(npold)*cost; ]
ns = nbrspl;
IF( wn > 0 ) [
    aux = (ssd-z(npold))/wn;
    x1 = x(npold) + un*aux; y1 = y(npold) + vn*aux;
    rsq_dsb = x1*x1+y1*y1;
    IF( rsq_dsb <= fs*fs ) ns = 0;
]
IF( ns > 0 ) [
    np = np+1; $CHECK-STACK(np,'do_smart_brems');
    $TRANSFER PROPERTIES TO (np) FROM (npold);
    u(np) = un; v(np) = vn; w(np) = wn;
    iq(np) = 0; wt(np) = weight*ns; iphat(np) = ns;
]

" The following samples the energies of the surviving photons "
" It is just cut/paste from subroutine BREMS.                 "
nsample = np - npold;
IF( nsample < 1 ) nsample = 1;
PEIE=E(NPold);
EIE=PEIE;
IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
L1 = L+1;
ekin = peie-prm; brmin = ap(medium)/ekin;
waux = elke - log_ap(medium);
IF( ibr_nist = 1 ) [
    ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
    jj = ajj; ajj = ajj - jj;
    IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
]
ip = npold;
DO ibr = 1,nsample [
    ip = ip+1;
    IF( ibr_nist = 1 ) [ "use the NIST bremsstrahlung cross section"
                         "data base"
        IF( ekin > nb_emin(medium) ) [
            $RANDOMSET r1;
            IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
            br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
                               nb_fdata(0,j,medium),
                               nb_wdata(1,j,medium),nb_idata(1,j,medium));
        ]
        ELSE [ $RANDOMSET br; ]
        esg = ap(medium)*exp(br*waux); pesg = esg;
        pese = peie - pesg; ese = pese;
    ]
    ELSE [

        LOOP [ "User wants to use Bethe-Heitler"

            $RANDOMSET rnno06; $RANDOMSET rnno07;
            br = brmin*exp(rnno06*waux);
            esg = ekin*br; pesg = esg;
            pese = peie - pesg; ese = pese;
            delta = esg/eie/ese*delcm(medium); aux = ese/eie;
            IF( delta < 1 ) [
                phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
                phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
                        delta*dl3(l1,medium));
            ]
            ELSE [
                phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
                phi2 = phi1;
            ]
            rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;

        ] UNTIL (rnno07 < rejf);
    ]
    IF( ip <= np ) [ e(ip) = pesg; ]
]
e(npold) = pese;
return; end;


subroutine get_ctminmax(xo,yo,zo,uo,vo,wo,ro,fs,ssd,ct_min,ct_max);
implicit none;
$REAL xo,yo,zo,uo,vo,wo,ro,fs,ssd,ct_min,ct_max;
$REAL d,d2,st,dmin,dmax,aux;

d = ssd - zo; d2 = d*d;
ro = sqrt(xo*xo+yo*yo);
st = 1-wo*wo; IF( st > 0 ) [ st = sqrt(st); ] ELSE [ st = 0; ]
IF( ro <= fs ) [ dmin = d; ] ELSE [ dmin = sqrt(d2+(fs-ro)*(fs-ro)); ]
dmax = sqrt(d2+(fs+ro)*(fs+ro));
aux = wo*d-xo*uo-yo*vo;
ct_max = aux+fs*st;
IF( ct_max > 0 ) [ ct_max = ct_max/dmin; ] ELSE [ ct_max = ct_max/dmax; ]
IF( ct_max > 1 ) ct_max = 1;
ct_min = aux-fs*st;
IF( ct_min > 0 ) [ ct_min = ct_min/dmax; ] ELSE [ ct_min = ct_min/dmin; ]
IF( ct_min < -1 ) ct_min = -1;
return; end;

subroutine old_get_ctminmax(x,y,z,u,v,w,fs,ssd,ct_min,ct_max);
implicit none;
$REAL x,y,z,u,v,w,fs,ssd,ct_min,ct_max;
$REAL ro,aw,d,d2,taux,x1,y1,r,tmp;

"Was :
"ro = sqrt(x*x+y*y); aw = abs(w); d = ssd - z; d2 = d*d;
"IF( aw > 1e-6 ) [
"    taux = d/aw;
ro = sqrt(x*x+y*y); d = ssd - z; d2 = d*d;
IF( abs(w) > 1e-6 ) [
    taux = d/w;
    x1 = x+taux*u; y1 = y+taux*v; r = sqrt(x1*x1+y1*y1);
    IF( r < fs ) [ ct_max = 1; ]
    ELSE [
        ct_max = (d2+(fs-ro)*(r-ro))/
                 sqrt((d2+(r-ro)*(r-ro))*(d2+(fs-ro)*(fs-ro)));
    ]
    ct_min = (d2-(r-ro)*(fs+ro))/
               sqrt((d2+(r-ro)*(r-ro))*(d2+(fs+ro)*(fs+ro)));
    IF( w < 0 ) [
        tmp = ct_min; ct_min = -ct_max; ct_max = -tmp;
    ]
]
ELSE [
    ct_min = -(fs+ro)/sqrt(d2+(fs+ro)*(fs+ro));
    ct_max = (fs-ro)/sqrt(d2+(fs-ro)*(fs-ro));
]
return; end;

"==========================================================================="
       subroutine combine_results(file_name);
"==========================================================================="
" Subroutine called at the end of all parallel runs to recombine the results"
" This used to have to be done separately by the user.                      "
"                                                                           "
"==========================================================================="
implicit none;
COMIN/IO_INFO,SCORE,SOURCE,RANDOM,CH-Steps,USER,EGS-IO/;
character*(*) file_name;
$INTEGER egs_get_unit,lnblnk1;
$INTEGER IS,I1,I2,I3,I4,TEMPNPASS_ph_sp,TEMPNFAT_ph_sp,IT,ITMAX;
$LONG_INT TEMPSCFLU_NUM(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,2),
   TEMPNCASE, TEMPNHSTRY, TEMPNPPHSP($MAX_SC_PLANES);
$REAL TEMPTMCPU;
REAL*8 TEMPSCSTP,TEMPSCSTP2,
  TEMPSCDSTP,TEMPSCDSTP2,TEMPPIISTP,
  TEMPSCDOSE($MAX_DOSE_ZONE,$MAXIT),
  TEMPSCDOSE2($MAX_DOSE_ZONE,$MAXIT),
  TEMPSCFLU(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
  TEMPSCFLU2(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,$MAX_SC_PARAMETERS),
  TEMPSCFLU_COV(3,$MAX_SC_PLANES,$MAX_SC_ZONES+1,4);
$LOGICAL first_time;
data first_time/.true./;
save first_time;

ITMAX=3+LNEXC+LNINC;

IF(first_time)[
    first_time = .false.;
    $USER-RESET-DATA;
    DATCOUNT = 0;
    "now, zero arrays"
    DO IS=1,NSC_PLANES[
         NPPHSP(IS)=0;
         NPFLU(IS)=0;
         EKMAXPHSP(IS)=0.;
         EKMINPHSPE(IS)=0.;
         NPHOTPHSP(IS)=0;
    ]
    NINCPHSP=0;
    "for steps:
    SCSTP=0; SCSTP2=0; SCDSTP=0; SCDSTP2=0; PIISTP=0;
    SCSTP_LAST=0; SCDSTP_LAST=0; count_pII_steps=0;
    "for dose:
    DO IT=1,ITMAX[
        DO ID=1,NDOSE_ZONE[
              SCDOSE_LAST(ID,IT)=0;
              SCDOSE(ID,IT)=0.0;
              SCDOSE2(ID,IT)=0.0;
              SCDOSE_TMP(ID,IT)=0.0;
        ]
    ]
    "for fluence:
    [I1=1,3;
         [I2=1,$MAX_SC_PLANES;
             [I3=1,$MAX_SC_ZONES+1;
                   SCFLU_LAST(I1,I2,I3,1)=0;
                   SCFLU_LAST(I1,I2,I3,2)=0;
                   SCFLU_NUM(I1,I2,I3,1)=0;
                   SCFLU_NUM(I1,I2,I3,2)=0;
                   SCFLU_NOCOV(I1,I2,I3,1)=0;
                   SCFLU_NOCOV(I1,I2,I3,2)=0;
                   DO I4=1,4[
                     SCFLU_COV(I1,I2,I3,I4)=0.;
                   ]
                   [I4=1,$MAX_SC_PARAMETERS;
                      SCFLU(I1,I2,I3,I4)=0.;
                      SCFLU2(I1,I2,I3,I4)=0.;
                      SCFLU_TMP(I1,I2,I3,I4)=0.;
                   ]
    ]]] "End of loop over I1"
    NCASEO=0;TMCPUO=0;NHSTRYO=0;NPASS_ph_spO=0;NFAT_ph_spO=0;
    OUTPUT ;(/1X,'Summing the following .egsdat files');
    OUTPUT ; (1X,'------------------------------------'/);
    WRITE(IOUTLIST,'(/1X,''Summing the following .egsdat files'')');
    WRITE(IOUTLIST,'(1X,''------------------------------------''/)');
]

IORSTRT=egs_get_unit(IORSTRT);
WRITE(IOUTLIST,'(A)') $cstring(file_name);
WRITE(i_log,'(A)') $cstring(file_name);
open(IORSTRT,file=file_name,status='old',err=:EOF_RS1:);

DATCOUNT=DATCOUNT+1;

READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:) TEMPSCSTP,TEMPSCSTP2,
                                    TEMPSCDSTP,TEMPSCDSTP2,TEMPPIISTP;
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
     ((TEMPSCDOSE(ID,IT),TEMPSCDOSE2(ID,IT),IT=1,ITMAX),ID=1,NDOSE_ZONE);
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
      ((((TEMPSCFLU(I1,I2,I3,I4),TEMPSCFLU2(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,$MAX_SC_PARAMETERS);
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
             ((((TEMPSCFLU_COV(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,4);
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)
             ((((TEMPSCFLU_NUM(I1,I2,I3,I4),I1=1,3),
                I3=1,NSC_ZONES(I2)+1),I2=1,NSC_PLANES),
                I4=1,2);
$RETRIEVE RNG STATE FROM UNIT IORSTRT;
READ(IORSTRT,*,err=:EOF_RS3:,end=:EOF_RS3:)TEMPNCASE,TEMPNHSTRY,TEMPTMCPU,
         (TEMPNPPHSP(IS),IS=1,NSC_PLANES),TEMPNPASS_ph_sp,TEMPNFAT_ph_sp;
$USER-ADD-DATA(IORSTRT);
write(i_log,*) '   ncase = ',TEMPNCASE,' cpu time = ',TEMPTMCPU;
write(IOUTLIST,*) '   ncase = ',TEMPNCASE,' cpu time = ',TEMPTMCPU;
      "now sum the scored data"
SCSTP=SCSTP+TEMPSCSTP; SCSTP2=SCSTP2+TEMPSCSTP2;
SCDSTP=SCDSTP+TEMPSCDSTP; SCDSTP2=SCDSTP2+TEMPSCDSTP2;
PIISTP=PIISTP+TEMPPIISTP;
DO ID=1,NDOSE_ZONE[
          DO IT=1,ITMAX[
            SCDOSE(ID,IT)=SCDOSE(ID,IT)+TEMPSCDOSE(ID,IT);
            SCDOSE2(ID,IT)=SCDOSE2(ID,IT)+TEMPSCDOSE2(ID,IT);
          ]
]
DO I1=1,3[
          DO I2=1,NSC_PLANES[
            DO I3=1,NSC_ZONES(I2)+1[
              SCFLU_NUM(I1,I2,I3,1)=SCFLU_NUM(I1,I2,I3,1)+
                                    TEMPSCFLU_NUM(I1,I2,I3,1);
              SCFLU_NUM(I1,I2,I3,2)=SCFLU_NUM(I1,I2,I3,2)+
                                    TEMPSCFLU_NUM(I1,I2,I3,2);
              NPFLU(I2)=NPFLU(I2)+TEMPSCFLU_NUM(I1,I2,I3,1)+
                        TEMPSCFLU_NUM(I1,I2,I3,2);
              DO I4=1,4[
                SCFLU_COV(I1,I2,I3,I4)=SCFLU_COV(I1,I2,I3,I4)+
                                TEMPSCFLU_COV(I1,I2,I3,I4);
              ]
              DO I4=1,$MAX_SC_PARAMETERS[
                SCFLU(I1,I2,I3,I4)=SCFLU(I1,I2,I3,I4)+
                                          TEMPSCFLU(I1,I2,I3,I4);
                SCFLU2(I1,I2,I3,I4)=SCFLU2(I1,I2,I3,I4)+
                                          TEMPSCFLU2(I1,I2,I3,I4);
              ]
            ]
          ]
]
NCASEO=NCASEO+TEMPNCASE;
NHSTRYO=NHSTRYO+TEMPNHSTRY;
TMCPUO=TMCPUO+TEMPTMCPU;
DO IS=1,NSC_PLANES[
         NPPHSP(IS)=NPPHSP(IS)+TEMPNPPHSP(IS);
]
NPASS_ph_spO=NPASS_ph_spO+TEMPNPASS_ph_sp;
NFAT_ph_spO=NFAT_ph_spO+TEMPNFAT_ph_sp;

$USER-COMBINE-RESULTS;

CLOSE(UNIT=IORSTRT);
return;
:EOF_RS1:;
WRITE(i_log,*) 'Error opening file ';
return;
:EOF_RS3:;
write(i_log,*) 'Error reading file ';
close(UNIT=IORSTRT); return; end;

"******************************************************************************
" Get cross section enhancement factors, if any
" Added by IK July 13 2005.
"******************************************************************************
subroutine get_cse_factors;
implicit none;
;COMIN/USER-CS-ENHANCEMENT,GetInput,MEDIA,ELECIN,EGS-IO/;
$INTEGER i,ival,n,imed;

DO i=1,$MAX_CMs [ cs_enhance(i) = 0; ]
use_cs_enhance = .false.;

ival = 1;

values_sought(ival) = 'SCALE XCC MEDIUM';
nvalue(ival) = 0; type(ival) = 0;
value_min(ival) = 0; value_max(ival) = nmed;
default(ival) = 0;

ival = ival + 1;
values_sought(ival) = 'SCALE XCC FACTOR';
nvalue(ival) = 0; type(ival) = 1;
value_min(ival) = 0; value_max(ival) = 1e10;
default(ival) = 1;

ival = ival + 1;
values_sought(ival) = 'CSE IN CMS';
nvalue(ival) = 0; type(ival) = 0;
value_min(ival) = 1; value_max(ival) = $MAX_CMs;
default(ival) = $MAX_CMs;

ival = ival + 1;
values_sought(ival) = 'CSE FACTORS';
nvalue(ival) = 0; type(ival) = 1;
value_min(ival) = 1; value_max(ival) = 1e10;
default(ival) = 1;

Nmin = ival-3; Nmax = ival;  delimeter = 'USER INPUTS';
call get_input;
error_flag = 0;

IF( error_flags(ival-3) = 0 & error_flags(ival-2) = 0 ) [
    n = min(nvalue(ival-3),nvalue(ival-2));
    DO i=1,n [
        imed = value(ival-3,i);
        IF( imed > 0 & imed <= nmed ) [
            write(i_log,*) '*** Scaling xcc of medium ',imed,' with ',
                value(ival-2,i);
            xcc(imed) = xcc(imed)*value(ival-2,i);
        ]
    ]
]

IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
    n = min(nvalue(ival-1),nvalue(ival));
    IF( n > 0 ) [
        DO i=1,n [ cs_enhance(int(value(ival-1,i))) = value(ival,i); ]
        DO i=1,$MAX_CMs [
            IF( cs_enhance(i) > 1 ) [ use_cs_enhance = .true.; EXIT; ]
        ]
        IF( use_cs_enhance ) [
          OUTPUT; (//'********** Photon cross section enhancement will be used',
                    ' in the following CMs: ******');
            DO i=1,$MAX_CMs [
                IF( cs_enhance(i) > 1 ) [
                    OUTPUT i,cs_enhance(i); ('   ',i3,5x,f12.4);
                ]
            ]
            OUTPUT; (//'*************************************************',
                    '*****************************'//);
            return;
        ]
    ]
]
OUTPUT; (//'************* Photon cross section enhancement will not be used'//);

return; end;

"=====================================================================
subroutine beamlib_max_energy(E);

"  used to return max. k.e. of incident particles
"  useful for codes that are using a BEAM simulation as a source
"=====================================================================
implicit none;
$REAL E;
;COMIN/SOURCE/;
E = EKMAX;
return; end;

/***************************************************************************
 *
 *   Stuff related to directional source biasing (DSB)
 *
 ***************************************************************************/

subroutine dsb_init_sampling(dsb_delta,fs,dsb_aeff,nbin_max,dsb_nbin,dsb_rbin,
              dsb_prob,dsb_ibin);
implicit none;
COMIN/EGS-IO/;
$REAL    dsb_delta,fs,dsb_aeff,dsb_rbin(*),dsb_prob(*);
$INTEGER nbin_max,dsb_nbin,dsb_ibin(*);

$INTEGER j,jh,jl;
real*8   sum,aux,pi2,dphi;
parameter (pi2=6.283185307179586477025617918812372408865);

IF( dsb_delta >= fs ) [
    dsb_delta = 0; dsb_nbin = 1; return;
]
dsb_nbin = pi2/acos(1-(dsb_delta/fs)**2/2)-1;
IF( dsb_nbin < 1 ) [
    dsb_nbin = 1; dsb_delta = 0; return;
]
IF( dsb_nbin > nbin_max ) [
    OUTPUT dsb_delta,fs,dsb_nbin,nbin_max;
    (/'In subroutine dsb_init_sampling: '/
      '  for delta = ',f10.4,' and FS = ',f10.4,' one needs ',i4,/,
      '  sampling bins. This is more than the maximum ',i4,/,
      '  => adjusting number of sampling bins to maximum'/);
    dsb_nbin = nbin_max;
]
dsb_delta = sqrt(2*(1-cos(pi2/(dsb_nbin+1))));
dsb_rbin(1) = 0; sum = 0;
DO j=2,dsb_nbin [
    dphi = pi2/j;
    dsb_rbin(j) = (dsb_delta/sqrt(2*(1-cos(dphi))))**2;
    dsb_prob(j-1) = (dsb_rbin(j)-dsb_rbin(j-1))/(j-1);
    sum = sum + dsb_prob(j-1);
    dsb_ibin(j-1) = -1;
]
dsb_rbin(dsb_nbin+1) = 1;
dsb_prob(dsb_nbin) = (1 - dsb_rbin(dsb_nbin))/dsb_nbin;
sum = sum + dsb_prob(dsb_nbin);
dsb_aeff = sum; sum = sum/dsb_nbin;
DO j=1,dsb_nbin-1 [
    DO jh=1,dsb_nbin-1 [
        IF( dsb_ibin(jh) < 0 & dsb_prob(jh) > sum ) EXIT;
    ]
    DO jl=1,dsb_nbin-1 [
        IF( dsb_ibin(jl) < 0 & dsb_prob(jl) < sum ) EXIT;
    ]
    aux = sum - dsb_prob(jl);
    dsb_prob(jh) = dsb_prob(jh) - aux;
    dsb_prob(jl) = dsb_prob(jl)/sum;
    dsb_ibin(jl) = jh;
]
DO j=1,dsb_nbin [
    IF( dsb_ibin(j) < 0 ) [
        dsb_prob(j) = dsb_prob(j)/sum; dsb_ibin(j) = j;
    ]
]
return; end;

subroutine dsb_get_point(fs,nbin,rbin,prob,ibin,x,y,phat);
implicit none;
$REAL    fs,rbin(*),prob(*),x,y;
$INTEGER nbin,ibin(*),phat;
;COMIN/RANDOM/;
$REAL rnno1,rnno2,rnno3,rnno4,r,phi,pi2;
$INTEGER j;
parameter (pi2=6.283185307179586477025617918812372408865);

$RANDOMSET rnno1; $RANDOMSET rnno2; $RANDOMSET rnno3; $RANDOMSET rnno4;
j = 1 + rnno1*nbin;
IF( rnno2 > prob(j) ) j = ibin(j);
r = fs*sqrt(rbin(j)*rnno3 + rbin(j+1)*(1-rnno3));
phi = pi2*rnno4;
x = r*cos(phi); y = r*sin(phi); phat = j;
return; end;

"Ali:BCSE"

SUBROUTINE GET_BCSE_PARAMETERS;

IMPLICIT NONE;

;COMIN/MEDIA,ELECIN,GetInput,IO_INFO,
       USER-BCSE,USER-SPLITTING,EGS-VARIANCE-REDUCTION,EGS-IO/;

$REAL    EIL,
         SIGT_OLD,SIGT_NEW_I,SIGT_NEW_II,
         BR1_OLD,BR2_OLD,BR1_NEW_I,BR1_NEW_II,BR2_NEW_I,BR2_NEW_II,
         SIG_BREM_NEW,SIG_BHABHA,
         SIGE_I,SIGE_II,SIGP_I,SIGP_II,EDEDX,PDEDX;
$LOGICAL is_ok;

$INTEGER I,k,MEDIUM,egs_add_medium,nmed_i,lnblnk1,nlen;

DO I=1,$MXMED [ is_bcse_medium(i) = .false.; ]

NMIN = 1; NMAX = 5;
DELIMETER = 'BCSE';

I = 1;
VALUES_SOUGHT(I) = 'Use BCSE';
NVALUE(I) = 1;
TYPE(I) = 3;
ALLOWED_INPUTS(I,0) = 'Off';
ALLOWED_INPUTS(I,1) = 'On';

I = I+1;
VALUES_SOUGHT(I) = 'Media to enhance';
NVALUE(I) = 0;
TYPE(I) = 2;

I = I+1;
VALUES_SOUGHT(I) = 'Enhancement constant';
NVALUE(I) = 1;
TYPE(I) = 1;
VALUE_MIN(I) = 1e-30;
VALUE_MAX(I) = 1e+30;
DEFAULT(I) = 1;

I = I+1;
VALUES_SOUGHT(I) = 'Enhancement power';
NVALUE(I) = 1;
TYPE(I) = 1;
VALUE_MIN(I) = -10;
VALUE_MAX(I) = 10;
DEFAULT(I) = 0;

I = I+1;
VALUES_SOUGHT(I) = 'Russian Roulette';
NVALUE(I) = 1;
TYPE(I) = 3;
ALLOWED_INPUTS(I,0) = 'Off';
ALLOWED_INPUTS(I,1) = 'On';

CALL GET_INPUT;

IF(ERROR_FLAGS(1) ~= 0 | ERROR_FLAGS(2) ~= 0
 | ERROR_FLAGS(3) ~= 0 | ERROR_FLAGS(4) ~= 0 | VALUE(1,1) ~= 1)[
   OUTPUT; (//'*** Brem. cross section enhancement WILL NOT be used ***'//);
   USE_BCSE = .FALSE.; RETURN;
]

nmed_i = nmed; nmed_enhance = 0;
DO i=1,nvalue(2) [
    nlen = lnblnk1(char_value(2,i));
    IF( nlen < $STRING80 ) char_value(2,i)(nlen+1:nlen+1) = char(0);
    medium = egs_add_medium(char_value(2,i));
    IF( medium > 0 & medium <= nmed_i ) [
        IF( ~is_bcse_medium(medium) ) nmed_enhance = nmed_enhance + 1;
        is_bcse_medium(medium) = .true.;
    ]
    ELSE [
        $egs_warning(*,'BCSE inputs: no medium ',char_value(2,i),' defined');
        nmed = nmed_i;
    ]
]
IF( nmed_enhance < 1 ) [
    OUTPUT; (//'*** No valid BCSE media defined -->');
    OUTPUT; ('*** Brem. cross section enhancement WILL NOT be used ***'//);
    USE_BCSE = .FALSE.; RETURN;
]

USE_BCSE = .TRUE.;
BCSE_FACTOR_C = VALUE(3,1);
BCSE_POWER_N = VALUE(4,1);
/* Introduced IF below since NBRSPL is 0 for BCSE alone! EMH Nov 2012*/
IF (IBRSPL > 0)[NBRSPL_ORGNL = NBRSPL;]
ELSE           [NBRSPL_ORGNL = BCSE_FACTOR_C;]

/* Russian Roulette setting */
IF(VALUE(5,1) = 1)["meaning RR ON"
    IF(IBRSPL=0)[ I_PLAY_RR=1;PROB_RR=1./BCSE_FACTOR_C;]"BCSE alone"
    ELSEIF(IBRSPL=1)[ IRRLTT=2; I_PLAY_RR=1;PROB_RR=1/FLOAT(NBRSPL);]"BCSE+UBS"
    "PROB_RR=1/FLOAT(NBRSPL); Doesn't make sense for BCSE alone! EMH Nov 2012"
]
IF(IBRSPL=2) [I_PLAY_RR=0;] "RR must be off for DBS; it has its own"

OUTPUT; (//' *** Brem. cross section enhancement WILL be used ***');
OUTPUT nmed_enhance; (' *** The following ',I2,' media will be enhanced:');
DO i=1,$MXMED [
    IF( is_bcse_medium(i) ) write(i_log,'(9x,24a1)') (media(k,i),k=1,24);
]
IF( BCSE_POWER_N > 0 ) [
    OUTPUT BCSE_FACTOR_C,BCSE_POWER_N;
    ('     Enhancement factor will be 1 + C*E**N WITH C = ',E14.6,' N = ',
       F9.2);
]
ELSE [
    OUTPUT BCSE_FACTOR_C; ('     Constant enhancement factor  =',F12.2);
]
OUTPUT I_PLAY_RR, PROB_RR; ('     Play Russian Roulette  =',I2,
                            ' with probability ',E10.2);


/*****************************************************************************
 *
 *      Adjust cross sections and branching ratios
 *
 *****************************************************************************/

RETURN; END; "END OF SUBROUTINE GET_BCSE_PARAMETERS"


 "Ali:BCSE"
/*******************************************************************
 UNIFORM_PHOTONS_4PI IS A MODIFIED VERSION OF UNIFORM_PHOTONS.
 IT PRODUCES PHOTONS UNIFORMLY IN THE 4PI. IT IS USED ONLY IN BCSE
********************************************************************/
SUBROUTINE UNIFORM_PHOTONS_4PI(NSAMPLE,ENERGY);
IMPLICIT NONE;
$INTEGER NSAMPLE,I;
double precision energy;
$REAL    WEIGHT,RNNO,PHI,SINT;
;COMIN/STACK,RANDOM,USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,SCORE,
       USER-STACK,USER-PHOTON-FORCING,EGS-IO/;

WEIGHT = WT(NPOLD)/NSAMPLE;
NP=NP-1;

DO I=1,NSAMPLE[
    NP = NP+1;
    $CHECK-STACK(NP,'UNIFORM_PHOTONS_4PI');
    $TRANSFER PROPERTIES TO (NP) FROM (NPOLD);
    E(NP) = ENERGY; IQ(NP) = 0; WT(NP) = WEIGHT;

    $RANDOMSET RNNO;
    PHI=3.1415927*(2.0*RNNO-1.0);
    $RANDOMSET RNNO;
    W(NP) = 2.0*RNNO-1.0;
    SINT = 1.0-W(NP)*W(NP);
    IF( SINT > 0 )[SINT = SQRT(SINT);] ELSE [SINT = 0;]
    U(NP)=SINT*COS(PHI);
    V(NP)=SINT*SIN(PHI);
]
RETURN; END;

"Ali:REJPLN"
SUBROUTINE GET_REJPLN;

IMPLICIT NONE;
;COMIN/USER-SPLITTING,USER-DIRECTIONAL-BREM-SPLITTING,GetInput,EGS-IO/;

IF(IBRSPL=2)[
   NMIN = 1; NMAX = 1;
   DELIMETER = 'DBS REJECTION PLANE';

   VALUES_SOUGHT(1) = 'Use a rejection plane';
   NVALUE(1) = 1;
   TYPE(1) = 3;
   ALLOWED_INPUTS(1,0) = 'Off';
   ALLOWED_INPUTS(1,1) = 'On';

   CALL GET_INPUT;

   IF(ERROR_FLAGS(1) ~= 0 | VALUE(1,1) ~= 1)[
      OUTPUT; (//'*** No rejection plane will be used with DBS ***'/
                 '*** Correlated-particle warning ***'//);
      USE_REJPLN = .FALSE.;
   ]
   ELSE[
      VALUES_SOUGHT(1) = 'Z(cm) from zero reference plane';
      NVALUE(1) = 1;
      TYPE(1) = 1;
      VALUE_MIN(1) = 0;
      VALUE_MAX(1) = SSD;
      DEFAULT(1) = SSD;

      CALL GET_INPUT;

      USE_REJPLN = .TRUE.;
      Z_REJPLN = VALUE(1,1);
      FLAG_REJPLN=0;

      OUTPUT Z_REJPLN;
      (//'** A rejection plane will be used with DBS **'/
       'Z(cm) from zero reference plane =',F12.2//);
   ]
]
RETURN; END; "END OF SUBROUTINE GET_REJPLN"

$HAVE_LOAD_DSO(#);

#ifndef HAVE_LOAD_DSO;

subroutine init_beamsource(i_parallel,i_log,conf_name,
                         hen_house,egs_home,the_beam_code,
                         the_pegs_file,the_input_file);
$INTEGER i_parallel;
character*(*) conf_name;
character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_input_file;
write(6,*) 'You need a working C compiler to use source 9!';
$CALL_EXIT(1);
end;

subroutine sample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
                               iqin,latchi,nhist,iphatsrc);

return; end;

subroutine finish_beamsource;
return; end;

#endif;
