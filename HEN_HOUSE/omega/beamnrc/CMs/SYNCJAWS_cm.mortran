%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: synchronized dynamic jaws                 "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Tony Popescu, 2010                                        "
"                   Julio Lobo, 2010                                          "
"                                                                             "
"  Contributors:    Frederic Tessier                                          "
"                   Blake Walters                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally derived from the existing BEAMnrc JAWS component  "
"  module and contributed back to NRC by the authors in 2010. It was rebased  "
"  on the DYNJAWS component module by Blake Walters in 2013.                  "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
"  radiotherapy treatments units. BEAM was originally developed at the        "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin, and was originally      "
"  described in:                                                              "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************      ""toc:
"                             *            *      ""toc:
"                             *    SYNCJAWS    *  ""toc:
"                             *            *      ""toc:
"                             **************      ""toc:
"
"   Programmer:  George Ding.
"
"   Development  Version, begun September 5, 1992. Completed in October,1992
"
"   For complete history see sccs record.
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.
"   Set of paired bars.(collimator jaws or applicator)
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 1 or more
"   paired bars. The bas are of arbitrary thickness and material,and X or Y.
"   orintation.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
%E   "SYNCJAWS_cm.mortran - start of geometry description
"I>
"I> Geometry of SYNCJAWS:                             ""toc:
"I> ******************
"I>                                  ||
"I>                                \ || /   beam
"I>                                 \||/
"I>                                  \/
"I>
"I>             ---------------------------------------------------
"I>
"I>             -------------     IR=1      ----------------
"I>                         /              |
"I>  ISCM=1       IR=3     /               |   IR=2
"I>            ------------  - - - - - - -  -----------------
"I>
"I>           ---------------    IR=4     ---------------------
"I>                         /            \
"I>  ISCM=2       IR=6     /              \  IR=5
"I>       ----------------- - - - - - - -  -----------------------
"I>
"I>
"I>   IR is the region number within the CM.  There are N_SYNCJAWS local
"I>   regions. The first region is between bars or jaws.  An air gap is
"I>   always present at the front.
"I>
"I>
"I>            --------------------------------------------------------
"I>            |          Region               | Description          |
"I>            |-------------------------------|----------------------|
"I>            |  absolute       | local       |                      |
"I>            |-----------------|-------------|                      |
"I>            | IRSTART_SYNCJAWS    |  IR_SYNCJAWS    |   see graph          |
"I>            |   +IR_SYNCJAWS-1    |             |                      |
"I>            --------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_$SYNCJAWS
"                      ISUMRY_$SYNCJAWS
"                      HOWFAR_$SYNCJAWS
"                      WHERE_AM_I_$SYNCJAWS
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS
"                             ************************
"
" 1. Very small jaw angles lead to approximations because of boundary
"    tolerance.  Particles may step right through the tips of jaws,
"    without recognizing that they have entered and exited a distinct
"    region, where jaw thickness is ~$BDY_TOL cm.
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                   Description of Users Input from Unit 5   ""toc:
"                   **************************************
"
"I>
"I>  CARDS CM_$SYNCJAWS
"I>  **************
"I>
"I>  -1  dummy line read in main used to separate input for CMs
"I>
"I>   0  RMAX_CM(ICM_SYNCJAWS) (F10.0):
"I>                         Perpendicular distance from Z-axis to boundary
"I>                         surrounding component module.  This component
"I>                         module has a square boundary.
"I>
"I>   1  TITLE_$SYNCJAWS (60A1):  Title of CM.
"I>
"I>   2  ISCM_MAX_$SYNCJAWS, MODE_$SYNCJAWS (2I5)
"I>
"I>           ISCM_MAX_$SYNCJAWS = Number of paired bars or jaws in CM.
"I>               MODE_$SYNCJAWS = 0 for static settings of jaw openings
"I>                            1 for dynamic settings with simulated
"I>                              jaw movement while beam is on
"I>                            2 for step-and-shoot jaw movement--beam
"I>                              off while jaw settings are changed
"I>
"I>   Repeat 3 (if MODE_$SYNCJAWS=1,2) or 3 and 4 (if MODE_$SYNCJAWS=0)
"I>               for I=1,ISCM_MAX_$SYNCJAWS
"I>
"I>   3  XY_CHOICE (A1):  indicate orientation of the paired bars/jaws
"I>                        X means bars/jaws perpendicular to x axis
"I>                       i.e. separation and movement is along x-axis
"I>
"I>   Next input is only required if MODE_$SYNCJAWS=0 (static)
"I>
"I>   4  ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I),XFP_$SYNCJAWS(I),XBP_$SYNCJAWS(I),
"I>      XFN_$SYNCJAWS(I), XBN_$SYNCJAWS(I) (6F15.0)
"I>
"I>        ZMIN_$SYNCJAWS(I): Distance front of bars/jaws to reference plane.
"I>        ZMAX_$SYNCJAWS(I): Distance back of bars/jaws to reference plane.
"I>        XFP_$SYNCJAWS(I):  positive bar/jaw x or y coodinate at front.
"I>        XBP_$SYNCJAWS(I):  positive bar/jaw x or y coodinate at back.
"I>        XFN_$SYNCJAWS(I):  negative bar/jaw x or y coodinate at front.
"I>        XBN_$SYNCJAWS(I):  negative bar/jaw x or y coodinate at back.
"I>
"I>   Next input is only required if MODE_$SYNCJAWS=1 or 2
"I>
"I>   4a jaws_file (A256)
"I>
"I>        jaws_file: The full name of a file containing jaw opening data
"I>                   in the following format:
"I>
"I>      NFIELDS_$SYNCJAWS (I10)
"I>      FOR J=1,NFIELDS_$SYNCJAWS[
"I>       INDEX_$SYNCJAWS(J) (F15.0)
"I>      (ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I),XFP_$SYNCJAWS(I),XBP_$SYNCJAWS(I),
"I>        XFN_$SYNCJAWS(I),XBN_$SYNCJAWS(I), I=1,ISCM_MAX_$SYNCJAWS)
"I>      ]
"I>
"I>      where:
"I>
"I>      NFIELDS_$SYNCJAWS:  Total number of jaw settings.
"I>      INDEX_$SYNCJAWS(J):  Index of setting J. 0 <= INDEX_$SYNCJAWS(J) <= 1
"I>                         and INDEX_$SYNCJAWS(J) > INDEX_$SYNCJAWS(J-1).
"I>			    This
"I>                         number is compared to a random number on [0,1] at
"I>                         the start of each history; if the random number is
"I>                         <= INDEX_$SYNCJAWS(J), then, if MODE_$SYNCJAWS=2,
"I>                         settings J are used.  If MODE_$SYNCJAWS=1, then
"I>                         the settings used are a linear interpolation
"I>                         between fields J-1 and J based on the random
"I>                         number selected.  See manual for more details.
"I>      ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I),XFP_$SYNCJAWS(I),XBP_$SYNCJAWS(I),
"I>      XFN_$SYNCJAWS(I),XBN_$SYNCJAWS(I):
"I>                         See description of input 4.  These are defined
"I>                         for each field, J.
"I>
"I>   5   ECUT, PCUT, DOSE_ZONE, IREGION_to_BIT (2F15.0,2I5): for interior
"I>                                                     (assumed to be AIR)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:      Dose scoring zone of air surrounding bars.
"I>          IREGION_TO_BIT: This region associated with this bit in LATCH
"I>
"I>   Repeat 6 and 7 for I=1,ISCM_MAX_$SYNCJAWS
"I>
"I>   6   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT (2F15.0,2I5)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons in
"I>                          jaw I.
"I>          DOSE_ZONE:      Dose scoring zone for jaw I.
"I>          IREGION_TO_BIT: Both bars of jaw I associated with this bit.
"I>
"I>   7   MED_IN (24A1):  Medium of jaw I, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following input defines a single tungsten jaw oriented in the Y
"I>  direction operating in step-and-shoot (MODE_$SYNCJAWS=2) mode.
"I>  The jaw settings (Z position, opening coordinates) are defined
"I>  in the file $OMEGA_HOME/beamnrc/CMs/dynjaw.opening.file
"I>  (included with the distribution).
"I>
"I>  40.0, RMAX
"I>  CM #7: jaws set for a 10x10cm field at SSD=100 cm
"I>  1,2, # PAIRED BARS OR JAWS, MODE
"I>  Y
"I>  $OMEGA_HOME/beamnrc/CMs/dynjaw.opening.file
"I>  0.7, 0.01, 0, 21,
"I>  0.7, 0.01, 0, 13,
"I>  W700ICRU
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules not allowed
"
"   2)  Overlapping bars not allowed
"
"   3)  Air gap at front of CM required
"
"   4)  Inner boundary of all bars must be within CM boundary, RMAX_CM
"
"*******************************************************************************

%E   "Start of subroutine HOWFAR_$SYNCJAWS "
"*******************************************************************************
"************************** Component Module SYNCJAWS **************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_SYNCJAWS
"                          ***********************
"
" HOWFAR routine for set of paired bars.
"
" Determine if current region number is within component module SYNCJAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are 4xISCM local regions see above graph:
"
"      local                    absolute                   description
"   ------------  ------------------------------------   ---------------
"       IRL       IR_start_CM(ICM_SYNCJAWS)+IRL-1               IRL
"
"   Geometrical co-ordinates, as set in INPUT_SYNCJAWS are:
"
"   ZFRONT_SYNCJAWS     front of CM (upstream surface, air region)
"   ZBACK_SYNCJAWS      back of CM (downstream surface, air region)
"   ZMIN_SYNCJAWS(IRL)  front of bars ISCM,
"   ZMAX_SYNCJAWS(IRL)  back of bars ISCM
"
"*******************************************************************************
;SUBROUTINE HOWFAR_$SYNCJAWS;


;IMPLICIT NONE;
;COMIN/CMs,CM_$SYNCJAWS,EPCONT,STACK,USER,EGS-IO/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_SYNCJAWS
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   IB_$SYNCJAWS,    "T>index to deal with round off errors
   I_tpo,I_tne, "T>error indices
   IRNEW_$SYNCJAWS; "T>tentative new region number within CM (absolute)

$REAL
   DIST,       "T>distance to region boundary along current particle trajectory
   DIST1,      "T>holds value of DIST while further checks are done
   XPLN_$SYNCJAWS,  "T>X or Y at a plane surface along particle trajectory
   ZPLN_$SYNCJAWS;  "T>Z along particle trajectory

DATA I_tpo,I_tne/0,0/;

IRL = IR(NP); "local region number (absolute)
"
" This replacement macros sets DNEAR as well as defining IR_$SYNCJAWS,
 ;$SYNCJAWS_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module SYNCJAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
";$SYNCJAWS_SET_XY_UV(ISCM_$SYNCJAWS);"" needed if no dnear caln in howfar"
IF(IR_$SYNCJAWS = 3*ISCM_$SYNCJAWS-2) ["particle not in positive or negative bar
   IB_$SYNCJAWS=1;
   IF(W(NP) > 0.0 )[
      IF(Z(NP) < ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL) [
         DIST = (ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
         ZPLN_$SYNCJAWS = Z(NP)+DIST*W(NP);
         IF(XPLN_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
            BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
            "must check against plane of jaws at actual Z posn of particle"
            IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
         ]
         ELSEIF(XPLN_$SYNCJAWS < ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
                BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
            IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
         ]
         ELSE[
            DIST = (ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP) + $BDY_TOL)/W(NP);
            IF(DIST < 0) [DIST = 0.0;]
            IF(DIST=0. & ISCM_$SYNCJAWS=ISCM_MAX_$SYNCJAWS)[DIST=1.E-16;]
            XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
            ZPLN_$SYNCJAWS = Z(NP)+DIST*W(NP);
            IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*ISCM_$SYNCJAWS;
            IF(ISCM_$SYNCJAWS = ISCM_MAX_$SYNCJAWS)[IRNEW_$SYNCJAWS =1;]
            DIST1=DIST;
            IF(XPLN_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
               BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
               ;$SYNCJAWS_TPOSITIVE;
               IF(DIST<DIST1)[
                 IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
            ELSEIF(XPLN_$SYNCJAWS <
                    ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
                BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
               ;$SYNCJAWS_TNEGATIVE;
               IF(DIST<DIST1)[
                 IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS)
         IF( XY_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP) +
             BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS) &
             Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_$SYNCJAWS < ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP) +
             BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS) &
             Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*ISCM_$SYNCJAWS;
         IF(ISCM_$SYNCJAWS = ISCM_MAX_$SYNCJAWS)[IRNEW_$SYNCJAWS =1;]
         XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
         ZPLN_$SYNCJAWS = Z(NP)+DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
               BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
            ;$SYNCJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_$SYNCJAWS < ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
                BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
            ;$SYNCJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_$SYNCJAWS=1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_$SYNCJAWS,1);
         ]
         ELSE ["still in CM, entering between bars
            IRNEW = IRNEW_$SYNCJAWS; "new region number"
         ]
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      IF(Z(NP) < ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL) [
         IF(ISCM_$SYNCJAWS = 1)[
            DIST = (ZFRONT_$SYNCJAWS - Z(NP))/W(NP);
            IF(DIST <= 0)[ DIST = 1.E-16;]
            IRNEW_$SYNCJAWS = 1;
         ]
         ELSE[ "  ISCM_$SYNCJAWS > 1
            ;$SYNCJAWS_SET_XY_UV(ISCM_$SYNCJAWS-1);
            DIST = (ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
            XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
            ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
            IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-2);
            IF(XPLN_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS-1)*ZPLN_$SYNCJAWS +
               BPOT_$SYNCJAWS(ISCM_$SYNCJAWS-1,IB_$SYNCJAWS))[
               IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-2) + 1;
            ]
            ELSEIF(XPLN_$SYNCJAWS <
                    ANE_$SYNCJAWS(ISCM_$SYNCJAWS-1)*ZPLN_$SYNCJAWS +
                BNET_$SYNCJAWS(ISCM_$SYNCJAWS-1,IB_$SYNCJAWS))[
               IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-2) + 2;
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS)
         IF( XY_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP) +
             BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS) &
             Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_$SYNCJAWS < ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP) +
             BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS) &
             Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP) - $BDY_TOL)/W(NP);
         IF(DIST < 0)[ DIST = 0.0;]
         XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
         ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_$SYNCJAWS > APO_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
               BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
            ;$SYNCJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_$SYNCJAWS < ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
                BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
            ;$SYNCJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSE[
            IF(ISCM_$SYNCJAWS = 1)[
               DIST = (ZFRONT_$SYNCJAWS - Z(NP))/W(NP);
               IF(DIST <= 0)[ DIST = 1.E-16;]
               IRNEW_$SYNCJAWS = 1;
            ]
            ELSE[ "  ISCM_$SYNCJAWS > 1
               ;$SYNCJAWS_SET_XY_UV(ISCM_$SYNCJAWS-1);
               DIST = (ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS-1) - Z(NP)
                    - $BDY_TOL)/W(NP);
               IF(DIST < 0)[ DIST = 0.0;]
               XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
               ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
               IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-2);
               IF(XPLN_$SYNCJAWS >
                  APO_$SYNCJAWS(ISCM_$SYNCJAWS-1)*ZPLN_$SYNCJAWS +
                  BPOT_$SYNCJAWS(ISCM_$SYNCJAWS-1,IB_$SYNCJAWS))[
                  IRNEW_$SYNCJAWS =
                    IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-2) + 1;
               ]
               ELSEIF(XPLN_$SYNCJAWS <
                      ANE_$SYNCJAWS(ISCM_$SYNCJAWS-1)*ZPLN_$SYNCJAWS +
                      BNET_$SYNCJAWS(ISCM_$SYNCJAWS-1,IB_$SYNCJAWS))[
                  IRNEW_$SYNCJAWS =
                    IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-2) + 2;
               ]
            ]
         ]
      ]
      IF(DIST <= USTEP ) [
         USTEP = DIST;
         IF(IRNEW_$SYNCJAWS = 1)["particle moving out from front CM
            CALL WHERE_AM_I(ICM_$SYNCJAWS,-1);
         ]
         ELSE[  "still in CM
            USTEP = DIST;
            IRNEW = IRNEW_$SYNCJAWS; "new region number"
         ]
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) ) [
         IF(UV_$SYNCJAWS > 0.0)[
            IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 1;
            ;$SYNCJAWS_TPOSITIVE;
         ]
         ELSE[
            IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1) + 2;
            ;$SYNCJAWS_TNEGATIVE;
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_$SYNCJAWS; "new region number"
      ]
   ]"end of w = 0.0
] "end of region 1
ELSEIF(IR_$SYNCJAWS = 3*ISCM_$SYNCJAWS-1) [ "particle in positive bars
   IB_$SYNCJAWS=2;
   IF( XY_$SYNCJAWS < APO_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP) +
       BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS) &
      Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) - $BDY_TOL  &
      Z(NP) < ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_$SYNCJAWS = ISCM_MAX_$SYNCJAWS)[DIST=1.E-16;]
      IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*ISCM_$SYNCJAWS;
      IF(ISCM_$SYNCJAWS = ISCM_MAX_$SYNCJAWS)[IRNEW_$SYNCJAWS =1;]
      XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
      ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$SYNCJAWS < APO_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
       BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
         IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
         ;$SYNCJAWS_TPOSITIVE;
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      DIST = (ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
      XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
      ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$SYNCJAWS < APO_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
       BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
         ;$SYNCJAWS_TPOSITIVE;
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_$SYNCJAWS < 0.0)[
         IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
         ;$SYNCJAWS_TPOSITIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_$SYNCJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_$SYNCJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_$SYNCJAWS; "new region number"
      ]
   ]
]  "end of region 2
ELSEIF(IR_$SYNCJAWS = 3*ISCM_$SYNCJAWS) [ "particle in negative bars
   IB_$SYNCJAWS=2;
   IF( XY_$SYNCJAWS > ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP) +
       BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS) &
      Z(NP) > ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) - $BDY_TOL &
      Z(NP) < ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_$SYNCJAWS = ISCM_MAX_$SYNCJAWS)[DIST=1.E-16;]
      IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*ISCM_$SYNCJAWS;
      IF(ISCM_$SYNCJAWS = ISCM_MAX_$SYNCJAWS)[IRNEW_$SYNCJAWS =1;]
      XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
      ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$SYNCJAWS > ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
       BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
         IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
         ;$SYNCJAWS_TNEGATIVE;
      ]
   ] "end of w > 0.0
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
      XPLN_$SYNCJAWS = XY_$SYNCJAWS + UV_$SYNCJAWS * DIST;
      ZPLN_$SYNCJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$SYNCJAWS > ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*ZPLN_$SYNCJAWS +
       BNET_$SYNCJAWS(ISCM_$SYNCJAWS,IB_$SYNCJAWS))[
         ;$SYNCJAWS_TNEGATIVE;
      ]
   ]"end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_$SYNCJAWS > 0.0)[
         IRNEW_$SYNCJAWS = IRSTART_$SYNCJAWS + 3*(ISCM_$SYNCJAWS-1);
         ;$SYNCJAWS_TNEGATIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_$SYNCJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_$SYNCJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_$SYNCJAWS; "new region number"
      ]
   ]
] "end of region 3
"end of CM regions"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_$SYNCJAWS+1, IR(NP), ICM_$SYNCJAWS,
          IR_start_CM(ICM_$SYNCJAWS);
      (//' ************'//' HOWFAR_SYNCJAWS error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
RETURN;
END; "End of subroutine HOWFAR_$SYNCJAWS"
%E   "Start of subroutine WHERE_AM_I_$SYNCJAWS "
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_SYNCJAWS
"                          ***************************
"
" WHERE_AM_I routine for set of SYNCJAWS.
"
" WHERE_AM_I_$SYNCJAWS determines the new region number when a particle
" traverses a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_$SYNCJAWS subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_$SYNCJAWS from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************
;SUBROUTINE WHERE_AM_I_$SYNCJAWS(IDIR);


;IMPLICIT NONE;
;COMIN/CM_$SYNCJAWS,EPCONT,STACK,CMs,USER/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_SYNCJAWS
"T>**************************************
"T>
INTEGER IDIR;       "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_$SYNCJAWS;
XBDY_$SYNCJAWS = X(NP) + U(NP)*USTEP;
IF(IXY_CHOICE_$SYNCJAWS(ISCM_MAX_$SYNCJAWS) = 1)[
   XBDY_$SYNCJAWS = Y(NP) + V(NP)*USTEP;
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)
   "$CHECK_FRONT_$SYNCJAWS;"
   IRNEW = IRSTART_$SYNCJAWS;
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_$SYNCJAWS + 3*ISCM_MAX_$SYNCJAWS - 3;
   "$CHECK_BACK_$SYNCJAWS;"
   IF(XBDY_$SYNCJAWS > XBP_$SYNCJAWS(ISCM_MAX_$SYNCJAWS))[
      IRNEW = IRSTART_$SYNCJAWS + 3*ISCM_MAX_$SYNCJAWS-2;
   ]
   ELSEIF(XBDY_$SYNCJAWS < XBN_$SYNCJAWS(ISCM_MAX_$SYNCJAWS))[
      IRNEW = IRSTART_$SYNCJAWS + 3*ISCM_MAX_$SYNCJAWS - 1;
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_$SYNCJAWS"
%E   "Start of subroutine INPUT_$SYNCJAWS "
"*******************************************************************************
"
"                           Subroutine INPUT_SYNCJAWS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more paired bars.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_$SYNCJAWS;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_$SYNCJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_SYNCJAWS
"T>*********************************
"T>
INTEGER I,J,K,         "T>DO loop indeces
        IRA,         "T>Absolute region number
        MED_FLAG,    "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,   "T>medium index, set after medium sort by $MED_INPUT
        jaws_unit,   "T>unit no. for file of dynamic jaws settings
        egs_get_unit; "T>EGS function to assign unit to jaws_file

$REAL AIRGAPMIN_$SYNCJAWS,  "T>minimum air gap in front and back of CM
      BDYTOL,          "T>stores $BDY_TOL
      TZMAX;           "T>stores max value of ZMAX (for MODE=1,2)
CHARACTER*1 XY_CHOICE(1);
character*256 jaws_file;
CHARACTER*80 JAWS_TITLE; "T> title line in file
"
"  initialize parameters
"  =====================
"
ICM_$SYNCJAWS = ICM;      "CM index for this component module
IRSTART_$SYNCJAWS = IR_start_CM(ICM_$SYNCJAWS); "Index of first region in this
                                    "CM set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_$SYNCJAWS) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_$SYNCJAWS = 0.01; "Minimum 0.01 cm air gap at front and back of CM

TZMAX=-999.;

OUTPUT RMAX_CM(ICM); (' This component is sets of paired bars or jaws'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
OUTPUT;(' TITLE: ',$);
;MINPUT ($SYNCJAWS) TITLE_$SYNCJAWS;(60A1);
                          ";MINPUT is a replacement macro with EOF and
                          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_$SYNCJAWS;(' ',60A1);
IF(ICM_$SYNCJAWS = 1)[
   OUTPUT;(' This is the first component and starts at the reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_$SYNCJAWS);(' Previous CM ends at:',F12.5,' cm');]

"
"   get geometry information
"   =============================
"
"get the number of paired bars/jaws"
ISCM_MAX_$SYNCJAWS = $MAX_N_$SYNCJAWS; "Max number of paired bars/jaws permitted
OUTPUT ISCM_MAX_$SYNCJAWS;
       (' NUMBER OF paired bars/jaws (minimum 1, maximum',I3,'),'/
        ' MODE of JAWS (0--static, 1--dynamic, 2--step-and-shoot)'/
        ' : ',$);
;MINPUT ($SYNCJAWS) ISCM_MAX_$SYNCJAWS,MODE_$SYNCJAWS; (2I5);
OUTPUT ISCM_MAX_$SYNCJAWS,MODE_$SYNCJAWS; (2I5);
IF(ISCM_MAX_$SYNCJAWS > $MAX_N_$SYNCJAWS)[
   OUTPUT ICM_$SYNCJAWS, $MAX_N_$SYNCJAWS;
   (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
      '# of paired bars > max. allowed.'/
      '# of pared bars reduced to ',I4,' for now.'//);
   ISCM_MAX_$SYNCJAWS=$MAX_N_$SYNCJAWS;
   IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
]
ELSEIF(ISCM_MAX_$SYNCJAWS<1)[
   ISCM_MAX_$SYNCJAWS=1;
   OUTPUT ICM_$SYNCJAWS;
   (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
      '# of paired bars < 1'/
      '# of pared bars reset to 1 for now.'//);
   IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
]
N_$SYNCJAWS = 3*ISCM_MAX_$SYNCJAWS;
IF(MODE_$SYNCJAWS<0 | MODE_$SYNCJAWS>2)[
   MODE_$SYNCJAWS=0;
   OUTPUT;(/' Mode of jaws defaults to 0 (static).'/);
]

"loop over bars
DO I = 1,ISCM_MAX_$SYNCJAWS ["loop to get each bar location"
 OUTPUT I;(/' Paired bar/jaw set no:',I3,/
    ' Are bars/jaws perpendicular to x or y axis'/
    ' i.e. is separation measured on x or y axis'/
    ' (Input "y" or "Y" for Y jaws, any other character for X jaws): ',$);
 ;MINPUT ($SYNCJAWS) XY_CHOICE;(1A1);
 OUTPUT XY_CHOICE;(' ',1A1);
 IXY_CHOICE_$SYNCJAWS(I) = 0;
 IF(XY_CHOICE(1) ='Y' | XY_CHOICE(1) ='y')[ IXY_CHOICE_$SYNCJAWS(I) = 1;]
 IF(MODE_$SYNCJAWS=0)[
   IF(IXY_CHOICE_$SYNCJAWS(I) = 0)["this is x bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: XFP, XBP,',
         ' XFN, XBN(cm) all on one line');
   ]
   ELSE ["this is y bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: YFP, YBP,',
         ' YFN, YBN(cm) all on one line');
   ]
   IF(I=1)[
         OUTPUT AIRGAPMIN_$SYNCJAWS;
          (' (leave at least min. airgap = ',F8.5,' before 1st jaws)',
          /' : ',$);
   ]
   ELSE[
         OUTPUT AIRGAPMIN_$SYNCJAWS;
          (' (leave at least min. airgap = ',F8.5,' between jaws)',
           /' : ',$);
   ]
   ;MINPUT ($SYNCJAWS) ZMIN_$SYNCJAWS(I), ZMAX_$SYNCJAWS(I), XFP_$SYNCJAWS(I),
      XBP_$SYNCJAWS(I), XFN_$SYNCJAWS(I), XBN_$SYNCJAWS(I);(6F15.0);
      ;OUTPUT ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I), XFP_$SYNCJAWS(I),
      XBP_$SYNCJAWS(I), XFN_$SYNCJAWS(I),XBN_$SYNCJAWS(I); (6F11.5);
   IF(I=1)[
       IF(ICM_$SYNCJAWS=1 &
         Z_min_CM(ICM_$SYNCJAWS)>ZMIN_$SYNCJAWS(1)-AIRGAPMIN_$SYNCJAWS)[
         OUTPUT ICM_$SYNCJAWS, AIRGAPMIN_$SYNCJAWS,
         ZMIN_$SYNCJAWS(1)-AIRGAPMIN_$SYNCJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,100)ICM_$SYNCJAWS, AIRGAPMIN_$SYNCJAWS,
              ZMIN_$SYNCJAWS(1)-AIRGAPMIN_$SYNCJAWS,Z_min_CM(1);
          100 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_$SYNCJAWS(1)-AIRGAPMIN_$SYNCJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCJAWS)>ZMIN_$SYNCJAWS(1))[
         OUTPUT ICM_$SYNCJAWS;
           (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
              'Overlaps with previous CM'//);
           IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCJAWS)>ZMIN_$SYNCJAWS(1)-AIRGAPMIN_$SYNCJAWS)[
         OUTPUT ICM_$SYNCJAWS, AIRGAPMIN_$SYNCJAWS,
         Z_min_CM(ICM_$SYNCJAWS)+AIRGAPMIN_$SYNCJAWS,
                ZMIN_$SYNCJAWS(1);
           (//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,101)ICM_$SYNCJAWS, AIRGAPMIN_$SYNCJAWS,
                Z_min_CM(ICM_$SYNCJAWS)+AIRGAPMIN_$SYNCJAWS,ZMIN_$SYNCJAWS(1);
         101 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         ZMIN_$SYNCJAWS(1)=Z_min_CM(ICM_$SYNCJAWS)+AIRGAPMIN_$SYNCJAWS;
       ]
   ]
   ELSE[
     IF (ZMAX_$SYNCJAWS(I-1)>ZMIN_$SYNCJAWS(I))[
        OUTPUT ICM_$SYNCJAWS, I-1, I;
         (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
            'Paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
     ]
     ELSEIF (ZMAX_$SYNCJAWS(I-1)>ZMIN_$SYNCJAWS(I)-AIRGAPMIN_$SYNCJAWS)[
        OUTPUT ICM_$SYNCJAWS, AIRGAPMIN_$SYNCJAWS, I-1, I, I,
                ZMAX_$SYNCJAWS(I-1)+AIRGAPMIN_$SYNCJAWS,ZMIN_$SYNCJAWS(I);
          (//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,102)ICM_$SYNCJAWS, AIRGAPMIN_$SYNCJAWS, I-1, I, I,
                ZMAX_$SYNCJAWS(I-1)+AIRGAPMIN_$SYNCJAWS,ZMIN_$SYNCJAWS(I);
        102 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        ZMIN_$SYNCJAWS(I)=ZMAX_$SYNCJAWS(I-1)+AIRGAPMIN_$SYNCJAWS;
     ]
   ]
   IF(ZMIN_$SYNCJAWS(I) >= ZMAX_$SYNCJAWS(I))[
      OUTPUT ICM_$SYNCJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   IF(ABS(XFP_$SYNCJAWS(I))>RMAX_CM(ICM_$SYNCJAWS))[
      OUTPUT ICM_$SYNCJAWS, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'XFP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   IF(ABS(XBP_$SYNCJAWS(I))>RMAX_CM(ICM_$SYNCJAWS))[
      OUTPUT ICM_$SYNCJAWS, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'XBP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   IF(ABS(XFN_$SYNCJAWS(I))>RMAX_CM(ICM_$SYNCJAWS))[
      OUTPUT ICM_$SYNCJAWS, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'XFN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   IF(ABS(XBN_$SYNCJAWS(I))>RMAX_CM(ICM_$SYNCJAWS))[
      OUTPUT ICM_$SYNCJAWS, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'XBN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   IF(XFP_$SYNCJAWS(I) < XFN_$SYNCJAWS(I))[
      OUTPUT ICM_$SYNCJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'XFP(',I4,') < XFN(',I4,')'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   ELSEIF(XFP_$SYNCJAWS(I) - XFN_$SYNCJAWS(I) < $BDY_TOL*3 )[
      XFP_$SYNCJAWS(I) = XFP_$SYNCJAWS(I) + $BDY_TOL*2;
      XFN_$SYNCJAWS(I) = XFN_$SYNCJAWS(I) - $BDY_TOL*2;
   ]
   IF(XBP_$SYNCJAWS(I) < XBN_$SYNCJAWS(I))[
      OUTPUT ICM_$SYNCJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'XBP(',I4,') < XBN(',I4,')'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   ELSEIF(XBP_$SYNCJAWS(I) - XBN_$SYNCJAWS(I) < $BDY_TOL*3 )[
      XBP_$SYNCJAWS(I) = XBP_$SYNCJAWS(I) + $BDY_TOL*2;
      XBN_$SYNCJAWS(I) = XBN_$SYNCJAWS(I) - $BDY_TOL*2;
   ]
 ]
] "end of loop over paired bars/jaws"
IF(MODE_$SYNCJAWS=1 | MODE_$SYNCJAWS=2)[
  OUTPUT;(/' Input full name of file containing jaw data:'/);
  READ(i_input,'(A256)')jaws_file;
  OUTPUT jaws_file;(A/);
  call replace_env(jaws_file);
  jaws_unit=70;
  jaws_unit=egs_get_unit(jaws_unit);
  IF(jaws_unit<1)[
    $egs_fatal(*,
         'SYNCJAWS data file: failed to get a free Fortran I/O unit');
  ]
  open(jaws_unit,file=jaws_file,status='old',err=:no-jaws-data-file:);
  read(jaws_unit,'(A80)') JAWS_TITLE;
  read(jaws_unit,'(I10)') NFIELDS_$SYNCJAWS;

  IF(NFIELDS_$SYNCJAWS>$MAXFIELD_$SYNCJAWS) [
   OUTPUT $MAXFIELD_$SYNCJAWS;
        (/' The number of fields is greater than $MAXFIELD_$SYNCJAWS: ',I10, /
        ' Increase $MAXFIELD_$SYNCJAWS in SYNCJAWS_macros.mortran'/);
   STOP;
  ];

  DO I=1,NFIELDS_$SYNCJAWS[
  "read in jaw positions for each field"
     read(jaws_unit,'(F15.0)')INDEX_$SYNCJAWS(I);
     DO J=1,ISCM_MAX_$SYNCJAWS[
       K=(I-1)*ISCM_MAX_$SYNCJAWS+J;
       read(jaws_unit,'(6F15.0)')DZMIN_$SYNCJAWS(K),DZMAX_$SYNCJAWS(K),
                                 DXFP_$SYNCJAWS(K), DXBP_$SYNCJAWS(K),
                                 DXFN_$SYNCJAWS(K), DXBN_$SYNCJAWS(K);
       IF(J=1)[
       IF(ICM_$SYNCJAWS=1 &
         Z_min_CM(ICM_$SYNCJAWS)>DZMIN_$SYNCJAWS(K)-AIRGAPMIN_$SYNCJAWS)[
         OUTPUT ICM_$SYNCJAWS, I, AIRGAPMIN_$SYNCJAWS,
         DZMIN_$SYNCJAWS(K)-AIRGAPMIN_$SYNCJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
            ' In field ',I4,' less than min. airgap (',F8.5,' cm) between top',
            ' of CM and 1st jaws.'/
            ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,103)ICM_$SYNCJAWS, I, AIRGAPMIN_$SYNCJAWS,
              DZMIN_$SYNCJAWS(K)-AIRGAPMIN_$SYNCJAWS,Z_min_CM(1);
          103 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
           ' In field ',I4,' less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_$SYNCJAWS(1)-AIRGAPMIN_$SYNCJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCJAWS)>DZMIN_$SYNCJAWS(K))[
         OUTPUT ICM_$SYNCJAWS,I;
           (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
              'In field ',I4,' overlaps with previous CM'//);
           IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_$SYNCJAWS)>DZMIN_$SYNCJAWS(K)-AIRGAPMIN_$SYNCJAWS)[
         OUTPUT ICM_$SYNCJAWS, I, AIRGAPMIN_$SYNCJAWS,
         Z_min_CM(ICM_$SYNCJAWS)+AIRGAPMIN_$SYNCJAWS,
                DZMIN_$SYNCJAWS(K);
           (//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
              ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,104)ICM_$SYNCJAWS, I, AIRGAPMIN_$SYNCJAWS,
                Z_min_CM(ICM_$SYNCJAWS)+AIRGAPMIN_$SYNCJAWS,DZMIN_$SYNCJAWS(K);
         104 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
              ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         DZMIN_$SYNCJAWS(K)=Z_min_CM(ICM_$SYNCJAWS)+AIRGAPMIN_$SYNCJAWS;
       ]
   ]
   ELSE[
     IF (DZMAX_$SYNCJAWS(K-1)>DZMIN_$SYNCJAWS(K))[
        OUTPUT ICM_$SYNCJAWS, I, J-1, J;
         (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
         'In field ',I4,' paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
     ]
     ELSEIF (DZMAX_$SYNCJAWS(K-1)>DZMIN_$SYNCJAWS(K)-AIRGAPMIN_$SYNCJAWS)[
        OUTPUT ICM_$SYNCJAWS, I, AIRGAPMIN_$SYNCJAWS,J-1, J, J,
                DZMAX_$SYNCJAWS(K-1)+AIRGAPMIN_$SYNCJAWS,DZMIN_$SYNCJAWS(K);
          (//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
             ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,105)ICM_$SYNCJAWS, I, AIRGAPMIN_$SYNCJAWS, J-1, J, J,
                DZMAX_$SYNCJAWS(K-1)+AIRGAPMIN_$SYNCJAWS,DZMIN_$SYNCJAWS(K);
        105 FORMAT(//' ***WARNING IN CM ',I4,' (SYNCJAWS):'/
             ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        DZMIN_$SYNCJAWS(K)=DZMAX_$SYNCJAWS(K-1)+AIRGAPMIN_$SYNCJAWS;
     ]
   ]
   IF(DZMIN_$SYNCJAWS(K) >= DZMAX_$SYNCJAWS(K))[
      OUTPUT ICM_$SYNCJAWS, I, J, J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
   ]
   IF(DZMAX_$SYNCJAWS(K)>TZMAX) TZMAX=DZMAX_$SYNCJAWS(K);
       IF(ABS(DXFP_$SYNCJAWS(K))>RMAX_CM(ICM_$SYNCJAWS))[
         OUTPUT ICM_$SYNCJAWS, I, J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' XFP(',I4,') beyond RMAX_CM'//);
         IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       IF(ABS(DXBP_$SYNCJAWS(K))>RMAX_CM(ICM_$SYNCJAWS))[
          OUTPUT ICM_$SYNCJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' XBP(',I4,') beyond RMAX_CM'//);
          IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       IF(ABS(DXFN_$SYNCJAWS(K))>RMAX_CM(ICM_$SYNCJAWS))[
          OUTPUT ICM_$SYNCJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' XFN(',I4,') beyond RMAX_CM'//);
          IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       IF(ABS(DXBN_$SYNCJAWS(K))>RMAX_CM(ICM_$SYNCJAWS))[
          OUTPUT ICM_$SYNCJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' XBN(',I4,') beyond RMAX_CM'//);
          IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       IF(DXFP_$SYNCJAWS(K) < DXFN_$SYNCJAWS(K))[
          OUTPUT ICM_$SYNCJAWS,I, J, J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' XFP(',I4,') < XFN(',I4,')'//);
          IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       ELSEIF(DXFP_$SYNCJAWS(K) - DXFN_$SYNCJAWS(K) < $BDY_TOL*3 )[
          DXFP_$SYNCJAWS(K) = DXFP_$SYNCJAWS(K) + $BDY_TOL*2;
          DXFN_$SYNCJAWS(K) = DXFN_$SYNCJAWS(K) - $BDY_TOL*2;
       ]
       IF(DXBP_$SYNCJAWS(K) < DXBN_$SYNCJAWS(K))[
          OUTPUT ICM_$SYNCJAWS, I,J, J;
        (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
           'In field ',I4,' XBP(',I4,') < XBN(',I4,')'//);
          IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
       ]
       ELSEIF(DXBP_$SYNCJAWS(K) - DXBN_$SYNCJAWS(K) < $BDY_TOL*3 )[
          DXBP_$SYNCJAWS(K) = DXBP_$SYNCJAWS(K) + $BDY_TOL*2;
          DXBN_$SYNCJAWS(K) = DXBN_$SYNCJAWS(K) - $BDY_TOL*2;
       ]
     ]
  ]
  CLOSE(UNIT=jaws_unit);

  OUTPUT;('******JAWS SEQUENCE FILE READ******');
  IF (MODE_$SYNCJAWS=1) [
      OUTPUT; ('**dynamic delivery**');
  ]
  ELSEIF (MODE_$SYNCJAWS=2) [
      OUTPUT; ('**step and shoot delivery**');
  ]
]

"set absolute region number to first region in CM for next set of inputs"
IRA = IRSTART_$SYNCJAWS; "absolute region number
OUTPUT ; (/'  Now input data re ECUT and PCUT for each region'/
         /' For central region which is assumed to be air'
         /' ECUT,       PCUT,   DOSE ZONE OF AIR,   REGION TO BIT '/' : ',$);
MINPUT ($SYNCJAWS) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
        (2F15.0,2I5);
OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA); (2F11.5,2I5);
IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
"get material for each bar and determine material number for these regions
MED(IRA) = AIR_INDEX; " medium of air
"
"now get info on each set of jaws"
DO IR_$SYNCJAWS = 2, N_$SYNCJAWS-1, 3[
   IRA = IRSTART_$SYNCJAWS  + IR_$SYNCJAWS - 1;"this is absolute region number"
   "central region air, so pick up same parameters as assigned above"
   "this is redundant on first time thru loop"
   ECUT(IRA-1) = ECUT(IRSTART_$SYNCJAWS);
   PCUT(IRA-1) = PCUT(IRSTART_$SYNCJAWS);
   DOSE_ZONE(IRA-1) = DOSE_ZONE(IRSTART_$SYNCJAWS);
   MED(IRA-1) = AIR_INDEX; " medium of air
   OUTPUT IR_$SYNCJAWS/3 + 1 ; (/' Paired bars/jaws no:',I3,
         /' ECUT,        PCUT,       DOSE ZONE,    IREGION_TO_BIT '/' :',$);
  ;MINPUT ($SYNCJAWS) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F15.0,2I5);
  ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F11.5,2I5);
   IREGION_TO_BIT(IRA -1) = IREGION_TO_BIT(IRSTART_$SYNCJAWS);
   IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
   "get material for each bar and determine material number for these regions
   OUTPUT;(' Medium in this region',$);
   $MED_INPUT($SYNCJAWS); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
      "error transfers to :ERROR_$SYNCJAWS:
   MED(IRA) = MED_INDEX; " medium of the planar slab
   "both parts of jaw are same material so transfer parameters"
   ECUT(IRA+1) = ECUT(IRA);
   PCUT(IRA+1) = PCUT(IRA);
   DOSE_ZONE(IRA+1) = DOSE_ZONE(IRA);
   IREGION_TO_BIT(IRA +1) = IREGION_TO_BIT(IRA);
   MED(IRA+1) = MED(IRA); "
] "end of loop over IR_$SYNCJAWS"
;
"  set up region numbers
"  =====================
"
"  CM has 4xISCM_MAX_$SYNCJAWS regions, series of paired bars/jaws surrounded
"  by an air region.  paired bars are numbered in sequence starting from the
"  furthest upstream.
"
IREND_$SYNCJAWS = IRSTART_$SYNCJAWS + N_$SYNCJAWS-1;  "Index of last region
NREG = NREG+N_$SYNCJAWS;           "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_$SYNCJAWS+1) = IREND_$SYNCJAWS+1;
]
ELSE [
      OUTPUT ICM_$SYNCJAWS,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (SYNCJAWS):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_$SYNCJAWS)=IERR_GEOM(ICM_$SYNCJAWS)+1;
]
"
"  parameter definition
"  ====================
"
"geometrical coordinates
"
"
IF(MODE_$SYNCJAWS=0)[
DO I = 1, ISCM_MAX_$SYNCJAWS[
   APO_$SYNCJAWS(I) = (XBP_$SYNCJAWS(I)-XFP_$SYNCJAWS(I))/
                           (ZMAX_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I));
   ANE_$SYNCJAWS(I) = (XBN_$SYNCJAWS(I)-XFN_$SYNCJAWS(I))/
                           (ZMAX_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I));
   BPO_$SYNCJAWS(I) =  XFP_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I)*APO_$SYNCJAWS(I);
   BNE_$SYNCJAWS(I) =  XFN_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I)*ANE_$SYNCJAWS(I);
   COSP_$SYNCJAWS(I)= (ZMAX_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I))/
                 SQRT( (ZMAX_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I))**2
                      +( XBP_$SYNCJAWS(I) - XFP_$SYNCJAWS(I) )**2 );
   COSN_$SYNCJAWS(I)= (ZMAX_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I))/
                 SQRT( (ZMAX_$SYNCJAWS(I) - ZMIN_$SYNCJAWS(I))**2
                       + (XBN_$SYNCJAWS(I) - XFN_$SYNCJAWS(I))**2 );
]

BDYTOL = $BDY_TOL;
DO I = 1,ISCM_MAX_$SYNCJAWS ["loop through bars"
   XFPT_$SYNCJAWS(I,1)  = XFP_$SYNCJAWS(I) + BDYTOL;
   XFPT_$SYNCJAWS(I,2)  = XFP_$SYNCJAWS(I) - BDYTOL;
   XBPT_$SYNCJAWS(I,1)  = XBP_$SYNCJAWS(I) + BDYTOL;
   XBPT_$SYNCJAWS(I,2)  = XBP_$SYNCJAWS(I) - BDYTOL;
   XFNT_$SYNCJAWS(I,1)  = XFN_$SYNCJAWS(I) - BDYTOL;
   XFNT_$SYNCJAWS(I,2)  = XFN_$SYNCJAWS(I) + BDYTOL;
   XBNT_$SYNCJAWS(I,1)  = XBN_$SYNCJAWS(I) - BDYTOL;
   XBNT_$SYNCJAWS(I,2)  = XBN_$SYNCJAWS(I) + BDYTOL;
   BPOT_$SYNCJAWS(I,1) =  BPO_$SYNCJAWS(I) + BDYTOL;
   BPOT_$SYNCJAWS(I,2) =  BPO_$SYNCJAWS(I) - BDYTOL;
   BNET_$SYNCJAWS(I,1) =  BNE_$SYNCJAWS(I) - BDYTOL;
   BNET_$SYNCJAWS(I,2) =  BNE_$SYNCJAWS(I) + BDYTOL;
] "end of loop over I"

]
"
"establish start of next CM
IF(MODE_$SYNCJAWS=0)[
Z_min_CM(ICM_$SYNCJAWS+1) = ZMAX_$SYNCJAWS(ISCM_MAX_$SYNCJAWS);
]
ELSE[
Z_min_CM(ICM_$SYNCJAWS+1) = TZMAX;
]
"
"
ZFRONT_$SYNCJAWS = Z_min_CM(ICM_$SYNCJAWS);
ZBACK_$SYNCJAWS = Z_min_CM(ICM_$SYNCJAWS+1);
"
"  establish CM boundary is a square
"  =================================
"
RMAX_CM_FLAG(ICM_$SYNCJAWS) = 2; "=> put a square boundary about CM

"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_$SYNCJAWS-1; "absolute region number
DO IR_$SYNCJAWS=1,N_$SYNCJAWS ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones and latch
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones"
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);

   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
] "end of loop over IR_$SYNCJAWS
E_min_out(ICM_$SYNCJAWS)=ECUT(IRA); "Minimum energy on exit from CM


"   return from INPUT_SYNCJAWS
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_$SYNCJAWS:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_$SYNCJAWS:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

:no-jaws-data-file:
;OUTPUT;(//' *** ERROR: SYNCJAWS position data file could not be opened');
STOP;
END;  "End of INPUT_$SYNCJAWS"
%E   "Start of subroutine ISUMRY_$SYNCJAWS "
"*******************************************************************************
"
"                          Subroutine ISUMRY_SYNCJAWS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_$SYNCJAWS;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_$SYNCJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_SYNCJAWS
"T>**********************************
"T>

INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IRA,       "T>absolute region number
   I,J;       "T>DO loop index

$REAL
   XYMAX,     "T>X or Y boundary
   VOLAIR_$SYNCJAWS,  "T>air volume
   VOL_$SYNCJAWS($MAX_N_$SYNCJAWS); "T>volume of air between bar
CHARACTER*1 XY_CHOICE(1);

"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$SYNCJAWS.
"
IRA = IRSTART_$SYNCJAWS-2; "absolute region number
VOLAIR_$SYNCJAWS=(ZBACK_$SYNCJAWS-ZFRONT_$SYNCJAWS)*
            4.*RMAX_CM2(ICM_$SYNCJAWS);"air volume"
DO I = 1,ISCM_MAX_$SYNCJAWS [
  IRA=IRA+3;
   VOL_$SYNCJAWS(I)=(ZMAX_$SYNCJAWS(I)-ZMIN_$SYNCJAWS(I))*
               (4.*RMAX_CM2(ICM_$SYNCJAWS)-
               RMAX_CM(ICM_$SYNCJAWS)*
               ABS(XFP_$SYNCJAWS(I)+
               XBP_$SYNCJAWS(I)-XFN_$SYNCJAWS(I)-
               XBN_$SYNCJAWS(I)));
   VOLAIR_$SYNCJAWS=VOLAIR_$SYNCJAWS-VOL_$SYNCJAWS(I);
   IF(DOSE_ZONE(IRA)~=0) [ "this is a dose zone"
      ID=DOSE_ZONE(IRA);
     AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOL_$SYNCJAWS(I);
   ]
] "end of loop over IR_$SYNCJAWS"
IRA = IRSTART_$SYNCJAWS; "absolute region number
IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLAIR_$SYNCJAWS;
]


"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_$SYNCJAWS,TITLE_$SYNCJAWS;
WRITE(IOUTLIST,120) Z_min_CM(ICM_$SYNCJAWS),RMAX_CM(ICM_$SYNCJAWS);
WRITE(IOUTLIST,122);
DO I=1, ISCM_MAX_$SYNCJAWS[
   IF(I=1)[
        WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_$SYNCJAWS),ZMIN_$SYNCJAWS(1)-
                           Z_min_CM(ICM_$SYNCJAWS),'NA','NA','NA','NA',
                           'NA';
   ]
   ELSE[
        WRITE(IOUTLIST,124)'airgap',ZMAX_$SYNCJAWS(I-1),ZMIN_$SYNCJAWS(I)-
                           ZMAX_$SYNCJAWS(I-1),'NA','NA','NA','NA',
                           'NA';
   ]
   IF(IXY_CHOICE_$SYNCJAWS(I) = 0)[XY_CHOICE(1) ='x';]
   ELSE[XY_CHOICE(1) ='y';]
   WRITE(IOUTLIST,123)I,ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I)-
                      ZMIN_$SYNCJAWS(I),XY_CHOICE(1),
                      XFP_$SYNCJAWS(I),XBP_$SYNCJAWS(I),
                      XFN_$SYNCJAWS(I),XBN_$SYNCJAWS(I);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_$SYNCJAWS-1;
DO I = 1, ISCM_MAX_$SYNCJAWS [
   IRA = IRSTART_$SYNCJAWS + 3*(I-1);
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+2)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
   ]
   WRITE(IOUTLIST,141)' ';
]
110 FORMAT(///1X,79('-')/
'  Component module',I3,' is SYNCJAWS '
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'$SYNCJAWS geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'jaw #    Z front    thickness    x or y               coordinates',
/T2,
'          face                   jaws        FP       BP       FN',
'      BN',
/T2,
'          (cm)        (cm)                                (cm)');
123 FORMAT(T2,I3,F12.3,F11.3,9X,A1,F12.3,F9.3,F9.3,F9.3);
124 FORMAT(T2,A6,F9.3,F11.3,8X,A2,A11,A9,A9,A8);
130 FORMAT(/T2,'$SYNCJAWS region parameters:',
           /T2,'---------------------------',
           /T2,'local jaw #   location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
141 FORMAT(15X,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ;$SELECT-COLOUR; "Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM"
   DO I =1,ISCM_MAX_$SYNCJAWS["Loop over local region number"
      XYMAX = RMAX_CM(ICM_$SYNCJAWS);
         IF(IXY_CHOICE_$SYNCJAWS(I) = 0)[
            WRITE(IOUTGEOM,200)
             ICOLOUR,'COLX',XYMAX,XFP_$SYNCJAWS(I),XBP_$SYNCJAWS(I),XYMAX,XYMAX,
               ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I);
            WRITE(IOUTGEOM,200)
              ICOLOUR,'COLX',XFN_$SYNCJAWS(I),-XYMAX,-XYMAX,XBN_$SYNCJAWS(I),
              XYMAX, ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I);
         ]
         ELSEIF(IXY_CHOICE_$SYNCJAWS(I) = 1)[
            J = ICOLOUR-1;
            IF(J < 1)[J = 4;]
            WRITE(IOUTGEOM,200)
               J,'COLY',XYMAX,XFP_$SYNCJAWS(I),XBP_$SYNCJAWS(I),XYMAX,XYMAX,
               ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I);
            WRITE(IOUTGEOM,200)
               J,'COLY',XFN_$SYNCJAWS(I),-XYMAX,-XYMAX,XBN_$SYNCJAWS(I),XYMAX,
               ZMIN_$SYNCJAWS(I),ZMAX_$SYNCJAWS(I);
         ]
   ]
] "End of graphics output"

200 FORMAT(' ',I1,A4,10(F7.2,','));

"   end of ISUMRY_SYNCJAWS
"   ===================
"
RETURN;
END;  "End of subroutine ISUMRY_$SYNCJAWS"

%E   "Start of subroutine HOWNEAR_$SYNCJAWS "
"******************************************************************************
"
"                          Subroutine HOWNEAR_SYNCJAWS
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Replaces the old HOWNEAR macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_$SYNCJAWS(DIST);


$IMPLICIT-NONE;

COMIN/CM_$SYNCJAWS,STACK,USER/;

$REAL DIST; "T> min. distance to nearest boundary

IR_$SYNCJAWS = IR(NP)-IRSTART_$SYNCJAWS+1;
ISCM_$SYNCJAWS = (IR_$SYNCJAWS-1)/3 + 1;
XY_$SYNCJAWS = X(NP);
UV_$SYNCJAWS = U(NP);
IF(IXY_CHOICE_$SYNCJAWS(ISCM_$SYNCJAWS) = 1)[
   XY_$SYNCJAWS = Y(NP);
   UV_$SYNCJAWS = V(NP);
]
IF(IR_$SYNCJAWS = 3*ISCM_$SYNCJAWS-1) [ "particle in positive bars"
   DIST = COSP_$SYNCJAWS(ISCM_$SYNCJAWS)
          *(XY_$SYNCJAWS-APO_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP)
           -BPOT_$SYNCJAWS(ISCM_$SYNCJAWS,2));
   DIST = MIN(DIST,
              ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS)-Z(NP),
              Z(NP) - ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS));
]
ELSEIF(IR_$SYNCJAWS = 3*ISCM_$SYNCJAWS) [ "particle in negative bars"
   DIST = COSN_$SYNCJAWS(ISCM_$SYNCJAWS)
          *(ANE_$SYNCJAWS(ISCM_$SYNCJAWS)*Z(NP)
          +BNET_$SYNCJAWS(ISCM_$SYNCJAWS,2)-XY_$SYNCJAWS) ;
   DIST = MIN(DIST,
              ZMAX_$SYNCJAWS(ISCM_$SYNCJAWS) - Z(NP),
              Z(NP) - ZMIN_$SYNCJAWS(ISCM_$SYNCJAWS) );
]
ELSE[ "particle in air"
   DIST = 0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_$SYNCJAWS "
"*******************************************************************************
"End of SYNCJAWS_cm.mortran "
