%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: dynamic Varian type MLC                   "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 2005                                       "
"                                                                             "
"  Contributors:    Iwan Kawrakow                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally derived from the VARMLC component module written  "
"  by Ajay Kapur and Charlie Ma in 2000.                                      "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
"  radiotherapy treatments units. BEAM was originally developed at the        "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin, and was originally      "
"  described in:                                                              "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%C80
"***********************************************************************
"
"                             *****************               ""toc:
"                             *               *               ""toc:
"                             *   DYNVMLC     *               ""toc:
"                             *               *               ""toc:
"                             *****************               ""toc:
"
"
"************************************************************************
"************************************************************************
"
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to
"   simulate one component module of a clinical linear accelerator:
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
"
"   1>. This module can be used as single or double focus multileaf
"       collimators.
"   2>. Used as x or y direction parallel to the leaf.
"   3>. it can have max 100 leaf which are equal width, symmetrical
"       arranged with y axis or x axis.
"   4>. Each leaf has two separate parts which can be moved in the leaf
"       direction independently.
"   5>. Rules to obey:
"           i.  Input the top z coordinates  as ZMIN_$DYNVMLC
"              and thickness respectively.
"           ii. Input the num of leaf and the total width of the leaf, each
"               leaf will have equal width.
"           iii. All leaf have the same material structures.
"           iv. The outside of the leaf will be the same material as leaf
"           v.  Input the focus points for both directions(x and y). each
"               leaf will be single or double focused according to the user.
"
"
"
;
"I>
"I> Geometry of DYNVMLC:
"I> **********************
"I>                                 top view
"I>
"I>            ------------------------------------------------
"I>                                |
"I>            ------------------------------------------------
"I>                           |           |
"I>           -----------------           ---------------------
"I>                      |        opening     |
"I>           ---------------     (IR=1)      -----------------
"I>                         |                 |
"I>           ------leaves--------      -----------------------
"I>                 (IR=2)      |     |
"I>           --------------------------------------------------
"I>                                  |
"I>           --------------------------------------------------
"I>
;
"I>       cross-section through leaves taken perpendicular to leaves
"I>
"I>                               * ZFOCUS(1)
"I>                           .   .   .
"I>                       .    . .|. .    .
"I> - - - - - - -     .     .   . | .   .     .
"I> airgap(IR=3)  .      .     .  |  .     .      .
"I>     -------- ------ ------ ---|--- ------ ------ ---------
"I>   leaf     / leaf / leaf /leaf|leaf\ leaf  \ leaf \  leaf
"I>   1    /    2  /     3  /  4  | 5   \  6     \  7    \  8
"I>    /        /          /      |      \          \        \
"I>    -------- ---------- -------|------- ---------- --------- -
"I>                            Z-axis
;
"I>            cross-section through leaf taken || to leaf
"I>             I)  FOR FOCUSED DIVERGENT LEAF ENDS :
"I>
"I>                               * ZFOCUS(2)
"I>  - - - - - - - - - - - -    . | .
"I>  airgap(IR=4)              .  |  .
"I>     ----------------------    |    ------------------------
"I>                          /    |    \
"I>        Leaf B  (-ve)    /     |     \    Leaf A (+ve)
"I>                        /      |      \
"I>    -------------------        |        ----------------------
"I>                            Z-axis

"I>              II)  FOR ROUNDED LEAF ENDS :
"I>
"I>                               *
"I>  - - - - - - - - - - - -      |
"I>  airgap(IR=4)                 |
"I>     -------------             |              --------------
"I>      --------\     \          |            /
"I>    hole IR=3 | A   |          |           |<------Leafradius
"I>     ---------/     /          |            \    B
"I>     -------------             |              --------------
"I>                            Z-axis
;
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |             Region            | Description         |
"I>            |-------------------------------|---------------------|
"I>            |  absolute       | local       |                     |
"I>            |-----------------|-------------|                     |
"I>            |                 |             |                     |
"I>            |IRSTART_MLC      | IR_MLC      |  as shown in above  |
"I>            |  +IR_MLC-1      |             |    (1 to 4)         |
"I>            |                 |             |                     |
"I>            |                 |             |                     |
"I>            -------------------------------------------------------
"I>
;

" Subroutines:
" ************
"                      INPUT_$DYNVMLC
"                      ISUMRY_$DYNVMLC
"                      HOWFAR_$DYNVMLC
"                      WHERE_AM_I_$DYNVMLC
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"************************************************************************
"
"                             RESTRICTIONS ON USE/KNOWN BUGS
"                             *******************
"
"************************************************************************
;
"
"                               INPUT FROM UNIT 5
"                               *****************
"
"I>
"I>  CARDS CM_$DYNVMLC
"I>  ********************
"I>  -1  Dummy line to indicate start of CM
"I>
"I>   0  RMAX_CM(ICM_$DYNVMLC) (F10.5):  Half-width of CM boundary (cm).
"I>
"I>   1  TITLE_$DYNVMLC (60A1):  Title of CM.
"I>
"I>   2  ORIENT_$DYNVMLC, NGROUP_$DYNVMLC, MODE_$DYNVMLC (3I5)
"I>
"I>            ORIENT_$DYNVMLC = 0 for leaves parallel to Y direction
"I>                            = 1 for leaves parallel to X direction
"I>            NGROUP_$DYNVMLC = number of groups of adjacent leaves where
"I>                              all leaves in a group are:
"I>                              1. FULL leaves
"I>                              2. TARGET/ISOCENTER pairs with TARGET leaf
"I>                                 on the -X (ORIENT=0) or -Y (ORIENT=1) side
"I>                              NGROUP_$DYNVMLC defaults to 3 if set <=0
"I>            MODE_$DYNVMLC = 0 for single setting of leaf openings (static
"I>                            field)
"I>                          = 1 for dynamic mlc delivery--simulated leaf
"I>                            movement while beam is on
"I>                          = 2 for step-and-shoot delivery--beam off while
"I>                            leaf positions change
"I>
"I>   3  ZMIN_$DYNVMLC (F15.0): Z of top of MLC (excluding airgap)
"I>
"I>   4  ZTHICK_$DYNVMLC (F15.0): Thickness of the leaves ( z-axis (cm))
"I>
"I>   5  LEAFWIDTH_$DYNVMLC(1), WTONGUE_$DYNVMLC(1), WGROOVE_$DYNVMLC(1),
"I>      WTIP_$DYNVMLC(1), WRAILTOP_$DYNVMLC(1), WRAILBOT_$DYNVMLC(1),
"I>      ZTIP_$DYNVMLC(1), ZLEAF_$DYNVMLC(1), ZTONGUE_$DYNVMLC(1),
"I>      ZGROOVE_$DYNVMLC(1), ZHOLETOP_$DYNVMLC(1), ZHOLEBOT_$DYNVMLC(1),
"I>      HOLEPOS_FULL_$DYNVMLC, ZRAILTOP_$DYNVMLC(1), ZRAILBOT_$DYNVMLC(1)
"I>         (15F15.0)
"I>
"I>        For a FULL type leaf (all dimensions in cm--all widths are
"I>                              projected back to ZMIN_$DYNVMLC):
"I>
"I>           LEAFWIDTH_$DYNVMLC(1): Width of leaf (not including tongue)
"I>             WTONGUE_$DYNVMLC(1): Width of tongue
"I>             WGROOVE_$DYNVMLC(1): Width of groove
"I>                WTIP_$DYNVMLC(1): Width of tip at top of leaf
"I>            WRAILTOP_$DYNVMLC(1): Width of top of support rail
"I>            WRAILBOT_$DYNVMLC(1): Width of bottom of support rail
"I>                ZTIP_$DYNVMLC(1): Z at which tip at top of leaf begins
"I>               ZLEAF_$DYNVMLC(1): Z of top of leaf
"I>             ZTONGUE_$DYNVMLC(1): Z of bottom of tongue
"I>             ZGROOVE_$DYNVMLC(1): Z of bottom of groove
"I>            ZHOLETOP_$DYNVMLC(1): Z of top of driving screw hole
"I>            ZHOLEBOT_$DYNVMLC(1): Z of bottom of driving screw hole
"I>           HOLEPOS_FULL_$DYNVMLC: Distance of hole from leaf tip
"I>            ZRAILTOP_$DYNVMLC(1): Z of top of support rail
"I>            ZRAILBOT_$DYNVMLC(1): Z of bottom of support rail
"I>
"I>       Note: Z positions are input in order of increasing Z.  Thus
"I>             ZLEAF_$DYNVMLC(1)>=ZTIP_$DYNVMLC(1), etc.  See the BEAM
"I>             manual or GUI help for restrictions on widths.
"I>
"I>
"I>   6  LEAFWIDTH_$DYNVMLC(2), WTONGUE_$DYNVMLC(2), WGROOVE_$DYNVMLC(2),
"I>      WTIP_$DYNVMLC(2), WRAILTOP_$DYNVMLC(2), WRAILBOT_$DYNVMLC(2),
"I>      ZRAILTOP_$DYNVMLC(2), ZRAILBOT_$DYNVMLC(2), ZHOLETOP_$DYNVMLC(2),
"I>      ZHOLEBOT_$DYNVMLC(2), HOLEPOS_TAR_$DYNVMLC, ZTONGUE_$DYNVMLC(2),
"I>      ZGROOVE_$DYNVMLC(2), ZLEAF_$DYNVMLC(2), ZTIP_$DYNVMLC(2) (15F15.0)
"I>
"I>        For a TARGET type leaf (all dimensions in cm--all widths are
"I>                              projected back to ZMIN_$DYNVMLC):
"I>
"I>           LEAFWIDTH_$DYNVMLC(2): Width of leaf (not including tongue)
"I>             WTONGUE_$DYNVMLC(2): Width of tongue
"I>             WGROOVE_$DYNVMLC(2): Width of groove
"I>                WTIP_$DYNVMLC(2): Width of tip at bottom of leaf
"I>            WRAILTOP_$DYNVMLC(2): Width of top of support rail
"I>            WRAILBOT_$DYNVMLC(2): Width of bottom of support rail
"I>            ZRAILTOP_$DYNVMLC(2): Z of top of support rail
"I>            ZRAILBOT_$DYNVMLC(2): Z of bottom of support rail
"I>            ZHOLETOP_$DYNVMLC(2): Z of top of driving screw hole
"I>            ZHOLEBOT_$DYNVMLC(2): Z of bottom of driving screw hole
"I>            HOLEPOS_TAR_$DYNVMLC: Distance of hole from leaf tip
"I>             ZTONGUE_$DYNVMLC(2): Z of bottom of tongue
"I>             ZGROOVE_$DYNVMLC(2): Z of top of groove
"I>               ZLEAF_$DYNVMLC(2): Z of bottom of leaf
"I>                ZTIP_$DYNVMLC(2): Z of bottom of tip at bottom of leaf
"I>
"I>       Note: Z positions are input in order of increasing Z.  Thus
"I>             ZLEAF_$DYNVMLC(1)>=ZTIP_$DYNVMLC(1), etc.  See the BEAM
"I>             manual or GUI help for restrictions on widths.
"I>
"I>
"I>   7  LEAFWIDTH_$DYNVMLC(3), WTONGUE_$DYNVMLC(3), WGROOVE_$DYNVMLC(3),
"I>      WTIP_$DYNVMLC(3), WRAILTOP_$DYNVMLC(3), WRAILBOT_$DYNVMLC(3),
"I>      ZTIP_$DYNVMLC(3), ZLEAF_$DYNVMLC(3), ZTONGUE_$DYNVMLC(3),
"I>      ZGROOVE_$DYNVMLC(3), ZHOLETOP_$DYNVMLC(3), ZHOLEBOT_$DYNVMLC(3),
"I>      HOLEPOS_ISO_$DYNVMLC, ZRAILTOP_$DYNVMLC(3), ZRAILBOT_$DYNVMLC(3)
"I>                  (15F15.0)
"I>
"I>        For a ISOCENTER type leaf (all dimensions in cm--all widths are
"I>                              projected back to ZMIN_$DYNVMLC):
"I>
"I>           LEAFWIDTH_$DYNVMLC(3): Width of leaf (not including tongue)
"I>             WTONGUE_$DYNVMLC(3): Width of tongue
"I>             WGROOVE_$DYNVMLC(3): Width of groove
"I>                WTIP_$DYNVMLC(3): Width of tip at top of leaf
"I>            WRAILTOP_$DYNVMLC(3): Width of top of support rail
"I>            WRAILBOT_$DYNVMLC(3): Width of bottom of support rail
"I>                ZTIP_$DYNVMLC(3): Z at which tip at top of leaf begins
"I>               ZLEAF_$DYNVMLC(3): Z of top of leaf
"I>             ZTONGUE_$DYNVMLC(3): Z of top of tongue
"I>             ZGROOVE_$DYNVMLC(3): Z of bottom of groove
"I>            ZHOLETOP_$DYNVMLC(3): Z of top of driving screw hole
"I>            ZHOLEBOT_$DYNVMLC(3): Z of bottom of driving screw hole
"I>            HOLEPOS_ISO_$DYNVMLC: Distance of hole from leaf tip
"I>            ZRAILTOP_$DYNVMLC(3): Z of top of support rail
"I>            ZRAILBOT_$DYNVMLC(3): Z of bottom of support rail
"I>
"I>       Note: Z positions are input in order of increasing Z.  Thus
"I>             ZLEAF_$DYNVMLC(1)>=ZTIP_$DYNVMLC(1), etc.  See the BEAM
"I>             manual or GUI help for restrictions on widths.
"I>
"I>        Note: 1. For TARGET and ISOCENTER leaves to fit together,
"I>                 ZTONGUE_$DYNVMLC(3)>=ZGROOVE_$DYNVMLC(2) and
"I>                 ZTONGUE_$DYNVMLC(2)<=ZGROOVE_$DYNVMLC(3).
"I>              2. For TARGET and FULL leaves to fit together (FULL
"I>                 leaf on -X [ORIENT=0] or -Y [ORIENT=1] side of TARGET
"I>                 leaf only) ZTONGUE_$DYNVMLC(2)<=ZGROOVE_$DYNVMLC(1)
"I>              3. For ISOCENTER and FULL leaves to fit together (FULL
"I>                 leaf on +X [ORIENT=0] or +Y [ORIENT=1] side of ISOCENTER
"I>                 leaf only) ZTONGUE_$DYNVMLC(1)<=ZGROOVE_$DYNVMLC(3)
"I>
"I>
"I>   Repeat 8 NGROUP_$DYNVMLC times
"I>
"I>   8  NUM_LEAF_$DYNVMLC(I), LEAFTYPE  (2I5)
"I>
"I>        NUM_LEAF_$DYNVMLC(I): Number of adjacent leaves in group I
"I>                    LEAFTYPE: Type of leaf in group I.
"I>                              Set to: 1 for FULL leaves
"I>                                      2 for TARGET/ISOCENTER pair with
"I>                                        TARGET leaf on the -X (ORIENT=0)
"I>                                        or -Y (ORIENT=1) side
"I>
"I>         Note: If LEAFTYPE is 2, then you must have an even number
"I>               of leaves in the group.
"I>
"I>   9  START_$DYNVMLC (F15.0) : the start position (cm) wrt the CAX of
"I>                       leaf 1 as projected to ZMIN_$DYNVMLC.
"I>
"I>  10  LEAFGAP_$DYNVMLC (F15.5) : The width of the interleaf air gap
"I>             at ZMIN_$DYNVMLC.
"I>
"I>            Note restriction: LEAFGAP_$DYNVMLC<=WTONGUE_$DYNVMLC(1,2,3),
"I>
"I>  11  ENDTYPE_$DYNVMLC (I5) : The  type of leaf end :
"I>             0 -- rounded leaf end and
"I>             1 -- focused divergent leaf end.
"I>
"I>  12  ZFOCUS_$DYNVMLC (F15.5) : Focal point on Z-axis of leaf ends
"I>                     (i.e. imaginary lines drawn extending the slopes
"I>                     of leaf ends will all intersect the Z-axis
"I>                     at this point) - chosen if ENDTYPE_$DYNVMLC = 1.
"I>
"I>        Note restriction: ZFOCUS_$DYNVMLC(1) < ZMIN_$DYNVMLC or
"I>                                     > ZMIN_$DYNVMLC + ZTHICK_$DYNVMLC
"I>
"I>      LEAFRADIUS_$DYNVMLC (F15.5) : Radius of the leaf end if
"I>                           ENDTYPE_$DYNVMLC = 0. This must be greater
"I>                           than or equal to half the leaf thickness.
"I>
"I>  13  ZFOCUS_$DYNVMLC(1) (F15.5): Focal point on Z-axis of leaf sides
"I>                        imaginary lines drawn extending the slopes of
"I>                        the leaf sides will all intersect the Z-axis
"I>                        at this point)
"I>
"I>        Note restriction: ZFOCUS_$DYNVMLC(1) < ZMIN_$DYNVMLC or
"I>                               > ZMIN_$DYNVMLC + ZTHICK_$DYNVMLC
"I>
"I>                      For focused ends the leaf position is defined
"I>                      at ZMIN_$DYNVMLC; for rounded at ZMIN_$DYNVMLC +
"I>                     0.5*ZTHICK_$DYNVMLC (ie center of the leaf in z)
"I>
"I>      If MODE_$DYNVMLC=0 (static field):
"I>
"I>     Repeat 14a until opening coordinates of all leaves are defined once.
"I>     Leaves are numbered 1,2,...TOT_LEAF_$DYNVMLC, where numbering goes from
"I>     leaf 1 to leaf TOT_LEAF_$DYNVMLC. Convention is lower to upper or
"I>     left to right depending on ORIENT_$DYNVMLC i.e from negative to
"I>     positive.  Note that for dynamic or step-and-shoot simulations, these
"I>     are the default coordinates, used unless specified otherwise in the
"I>     file of leaf opening data input in line 14a (see below).
"I>
"I>  14a  NEG_$DYNVMLC, POS_$DYNVMLC, NUM_$DYNVMLC (2F15.5,I5)
"I>
"I>     NEG_$DYNVMLC:  Min. Y (ORIENT_$DYNVMLC=0) or X (ORIENT_$DYNVMLC=1)
"I>                    of front opening in leaf I (ie the opening at
"I>                    ZMIN_$DYNVMLC) if ENDTYPE=1, or of rounded end
"I>                    of leaf I if ENDTYPE=0.
"I>     POS_$DYNVMLC:  Max. Y (ORIENT_$DYNVMLC=0) or X (ORIENT_$DYNVMLC=1)
"I>                    of front opening in leaf I if ENDTYPE=1, or of
"I>                    rounded end of leaf I if ENDTYPE=0.
"I>     NUM_$DYNVMLC:  Apply NEG_$DYNVMLC and POS_$DYNVMLC to leaves
"I>                    I,...,I+NUM_$DYNVMLC-1.  Defaults to 1 if set <=0.
"I>                    Defaults to TOT_LEAF_$DYNVMLC-I+1 if set >
"I>                    TOT_LEAF_$DYNVMLC-I+1.
"I>
"I>  If MODE_$DYNVMLC=1 or 2 (dynamic delivery or step-and-shoot delivery):
"I>
"I>  14b  mlc_file (A256)
"I>
"I>         mlc_file:  The full name of the file containing leaf opening
"I>                    data.  The format of the file contents is as follows:
"I>
"I>      MLC_TITLE (A80)
"I>      NFIELDS_$DYNVMLC (I10)
"I>      FOR I=1,NFIELDS_$DYNVMLC[
"I>       INDEX_$DYNVMLC(I) (F15.0)
"I>       NEG_$DYNVMLC, POS_$DYNVMLC, NUM_$DYNVMLC (2F15.0,I5) -- repeat this
"I>                                                               line until
"I>                                                               coordinates
"I>                                                               for all leaves
"I>                                                               have been
"I>                                                               defined for
"I>                                                               field I.
"I>      ]
"I>
"I>      where:
"I>
"I>             MLC_TITLE:  A title line
"I>      NFIELDS_$DYNVMLC:  Total number of fields
"I>     INDEX_$DYNVMLC(I):  Index of field I. 0 <= INDEX_$DYNVMLC(I) <= 1 and
"I>                         INDEX_$DYNVMLC(I) > INDEX_$DYNVMLC(I-1).  This
"I>                         number is compared to a random number on (0,1) at
"I>                         the start of each history; if the random number is
"I>                         <= INDEX_$DYNVMLC(I), then field I is used.
"I>          NEG_$DYNVMLC:  Min. Y (ORIENT_$DYNVMLC=0) or X (ORIENT_$DYNVMLC=1)
"I>                         of front opening in leaf (ie the opening at
"I>                         ZMIN_$DYNVMLC) if ENDTYPE=1, or of rounded end
"I>                         of leaf if ENDTYPE=0 for leaf J in field I.
"I>          POS_$DYNVMLC:  Max. Y (ORIENT_$DYNVMLC=0) or X (ORIENT_$DYNVMLC=1)
"I>                         of front opening in leaf if ENDTYPE=1, or of
"I>                         rounded end of leaf if ENDTYPE=0 for leaf J in
"I>                         field I.
"I>          NUM_$DYNVMLC:  Apply NEG_$DYNVMLC and POS_$DYNVMLC to leaves
"I>                         J,...,J+NUM_$DYNVMLC-1.  Defaults to 1 if set <=0.
"I>                         Defaults to TOT_LEAF_$DYNVMLC-J+1 if set >
"I>                         TOT_LEAF_$DYNVMLC-J+1.
"I>
"I>    Note that the inputs NEG_$DYNVMLC, POS_$DYNVMLC and NUM_$DYNVMLC have
"I>    the same meanings as in 14a (static field inputs) but that they must
"I>    now be repeated for every field I.
"I>
"I>  15   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in opening(s) and
"I>                                             air gaps (2F15.5,2I5)
"I>
"I>        ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to not score dose
"I>    IREGION_TO_BIT:   Bit number associated with this region
"I>
"I>  16  MED_IN (24A1):  Medium in opening(s) and air gaps
"I>                      used to set MED_INDEX.
"I>
"I>  17  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in leaves, IGNOREGAPS_$DYNVMLC
"I>                                                         (2F15.0,3I5):
"I>
"I>        ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to note score dose
"I>    IREGION_TO_BIT:   Bit number associated with this region
"I>        IGNOREGAPS:   If set to 1, ignore all air gaps and driving screw
"I>                      holes when doing range
"I>                      rejection in leaf material when the particle X position
"I>                      is < min X of all leaf openings (not including leaf
"I>                      ends) or > max X of leaf openings (not including ends)
"I>                      (ORIENT_$DYNVMLC=1) or if the particle Y position
"I>                      is < min Y of all leaf openings (not including leaf
"I>                      ends) or > max Y of leaf openings (not including ends)
"I>                      (ORIENT_$DYNVMLC=0). This approximation is designed
"I>                      to make range rejection more efficient deep in the
"I>                      leaves, while still preserving accurate transport
"I>                      in the leaf ends.  Note that if you have significant
"I>                      air gaps between leaves or are concerned with the
"I>                      effects of the driving screw holes it is recommended
"I>                      that you not use this option (ie run with the default
"I>                      setting of 0).
"I>
"I>  18  MED_IN (24A1):  Medium of leaves,
"I>                      used to set MED_INDEX.
"I>
"I>  19  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in driving screw holes
"I>                                                       (2F15.5,2I5):
"I>
"I>        ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to note score dose
"I>    IREGION_TO_BIT:   Bit number associated with this region
"I>
"I>  20  MED_IN (24A1):  Medium in driving screw holes,
"I>                      used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>   The following example defines a multi-leaf tungsten collimator design
"I>   based loosely on that used with the Varian Millenium MLC.
"I>   Actual parameters are DIFFERENT - this serves just as a template.
"I>   Do not attempt to use these parameters for a simulation of the real
"I>   machine.
"I>
"I>   The collimator starts at Z=48.25 cm and has 60 tungsten leaves opening
"I>   in the X direction. Leaves 1-10 and 51-60 are FULL and leaves 11-50 are
"I>   TARGET/ISOCENTER pairs.  The Z focus of the leaf sides is at Z=0 cm
"I>   which is the position of the source. The leaf ends are rounded with a
"I>    radius of 8 cm. In this example, leaf opening coordinates are chosen to
"I>   create a square of width ~ 2cm centred on the beam axis.
"I>
"I>   Electrons and photons in both the collimator and the opening regions
"I>   will be followed down to kinetic energies of 189 keV (ECUT=0.7,
"I>   PCUT=0.01).  Dose deposited in the tungsten leaves will be stored
"I>   in dose zone 2, and dose deposited in the opening will be stored
"I>   in dose zone 1.
"I>
"I> 20.5, RMAX
"I> CL21X - Millenium MLC
"I> 1, 3, ORIENT, NGROUP
"I> 48.25, ZMIN
"I> 6.7, ZTHICK
"I> 0.5, 0.04, 0.04, 0.1354, 0.3252, 0.1227, 48.25, 48.533, 51.524, 51.732,
"I>   52.98, 53.28, 2, 54.5474, 54.812, FULL leaf
"I> 0.25, 0.04, 0.04, 0.0929, 0.132, 0.132, 48.345, 48.6096, 49.5277,
"I>   49.8277, 2, 51.625, 51.627, 54.7, 54.746, TARGET leaf
"I> 0.25, 0.04, 0.04, 0.0354, 0.1285, 0.1235, 48.412, 48.531, 51.631, 51.732,
"I>   53.3293, 53.6293, 2, 54.5474, 54.812, ISOCENTER leaf
"I> 10, 1, FULL leaves
"I> 40, 2, TARGET/ISOCENTER pairs
"I> 10, 1, FULL leaves
"I> -10.2, START
"I> 0.006, LEAFGAP
"I> 0, ENDTYPE
"I> 8, ZFOCUS or RADIUS of leaf ends
"I> 0, ZFOCUS of leaf sides
"I> 0, 0, 26
"I> -1.0, 1.0, 8
"I> 0,0,26
"I> 0.7, 0.01, 1, 0,
"I> AIR521ICRU
"I> 0.7, 0.01, 2, 0, 0,
"I> W521ICRU
"I> 0.7, 0.01, 3, 0,
"I> AIR521ICRU
;
"*************************************************************************
"*************************  ERROR CONDITIONS  ****************************
"*************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"***********************************************************************
;
%E "Start of subroutine HOWFAR_$DYNVMLC"
"************************************************************************
"********************Component Module DYNVMLC *****************************
"************************************************************************
"
"                          Subroutine HOWFAR_$DYNVMLC
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module DYNVMLC,
" evaluate DIST, distance to region boundary along current trajectory.
" USTEP must not exceed DIST.
"
"   There are N_$DYNVMLC local regions + an air gap (if present):
"
"  local              absolute                                   description
"-------------- --------------------------------------------- ---------------
"IR_$DYNVMLC IR_start_CM(ICM_$DYNVMLC)+IR_$DYNVMLC-1 exclude front air gap
"-------------- --------------------------------------------- ---------------
"   Geometrical co-ordinates, as set in INPUT_$DYNVMLC are:
"
"   ZFRONT_$DYNVMLC     front of CM (upstream surface, air region)
"   ZMIN_$DYNVMLC       front of cone
"   ZBACK_$DYNVMLC      back of cone
"   RMAX_$DYNVMLC       radius of last cylinder (largest)
"
"*************************************************************************
;
;SUBROUTINE HOWFAR_$DYNVMLC;

"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it, otherwise no shift
;
REPLACE {$GEO_SHIFT_1_(#)} WITH {
  ;IF({P1}~=0.00 ) [
    IF({P1}+1.0E-5< USTEP) [{P1}={P1}+1.0E-5;]
   ]
   ELSE [{P1}={P1}+1.0E-5;];

}

;IMPLICIT NONE;
;COMIN/CMs,CM_$DYNVMLC,EPCONT,STACK,USER,EGS-IO/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_$DYNVMLC
"T>**********************************
"T>
INTEGER
   COUNT,
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   I, J,        "T>loop control
   REGION_$DYNVMLC,     "T>region number within CM (relative)
   NEWREGION_$DYNVMLC,     "T>region number within CM (relative)
   NX,NY,NZ,        "T> Subindices for region
   OUTOFCMFLAG,     "T> Flag to denote particle out of CM
   OUTOFMLCFLAG,    "T> Flag to denote particle out of MLC
   LEAFIS,          "T> Leaf number
   LHS,RHS,     "T> Macro variables to find + and - closest boundary index
   ZLHS,ZRHS,
   IDIR;        "T> direction sign, used in call to where_am_i

DOUBLE PRECISION
   DIST,      "T>Distance to z boundary along current particle trajectory
   UVL(2),    "T>temporary variable
   TRYY1,TRYY2,
   XoN,XoP,    "T> Negative and Positive leaf centers (rounded leaf)
   Zo,         "T> z position of rounded leaf tip
   XP,XN,YP,YN,ZP,ZN,    "T>+ and - distances in x,y, z directions
   XDIST,YDIST,ZDIST,    "T> x,y, Z distances to nearest boundaries
   DIST1,DIST2,DIST3,    "T> Variables to control particle propagation
   STEP2,                "T>  "
   TLHS,TRHS,            "T> temporary macro variables like lhs,rhs
   DISCRIMINANT,         "T> Variable for rounded leaf
   TEMP,TEMP1, TEMP2, TEMP3, TEMP4, TEMP5, HOLE,
   STEP_UNIT,
   XYL(2),     "T> rearranged x and y coordinates
   XYFL(2),
   ZFL;

$REAL one;
parameter (one = 1);

" prepare the local variables "
"============================="

IRL = IR(NP); "local region number (absolute)"
IR_$DYNVMLC = IRL - IRSTART_$DYNVMLC + 1;   "rel. local region number"
IF(ORIENT_$DYNVMLC=1) [
    XYL(1)=Y(NP); XYL(2)=X(NP);UVL(1)=V(NP);UVL(2)=U(NP);]
ELSE[ XYL(1)=X(NP); XYL(2)=Y(NP);UVL(1)=U(NP);UVL(2)=V(NP);]
;

STEP_UNIT=0.0;
COUNT = 0;
OUTOFCMFLAG=0;
OUTOFMLCFLAG=0;

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module ,if so
" evaluate DIST, distance to region boundary along current trajectory.
" USTEP must not exceed DIST.
"

" the following block double check:
"=================================
"      1. the particle is out of the CM or regions in z direction
"      2.                        the regions in xy directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap check if existed.
"=====================================
"

IF(N_GAP_$DYNVMLC=1 & IR_$DYNVMLC=4 ) ["Check the air gap first"
   IF(W(NP)>0.0) ["Particle going forward"
      DIST = (ZMIN_$DYNVMLC - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST <= 0.0) [
          USTEP=0.0;
          $DYNVMLC_FIND(IR_$DYNVMLC, 0.0);
          IF( IR_$DYNVMLC=1 ) "in air"
            [IRNEW =IRSTART_$DYNVMLC; RETURN;]
          ELSE[IRNEW =IRSTART_$DYNVMLC+1; RETURN;]
       ] "double check if a particle is out of the AIR GAP"
    ]
   ELSEIF(W(NP)<0.0) [ "particle going backward"
      DIST = (ZFRONT_$DYNVMLC - Z(NP))/W(NP); "distance to front of CM"
      IF(DIST <= 0.0) [
          USTEP=1.E-16;
          CALL WHERE_AM_I(ICM_$DYNVMLC,-1);
          RETURN;
      ] " double check if a particle is out of the CM"
    ];
 ]
ELSEIF(IR_$DYNVMLC=1 | IR_$DYNVMLC=2 | IR_$DYNVMLC=3) [
   IF(W(NP) > 0.0) ["particle going forward"
      DIST = (ZMAX_$DYNVMLC - Z(NP))/W(NP); "distance to back of CM"
      IF(DIST>USTEP) [ STEP_UNIT=USTEP; ]
      ELSE [ STEP_UNIT=DIST;  ]
      IF(DIST <=0.0) [
          USTEP=1.E-16;"ensures call to AUSGAB on leaving CM"
          CALL WHERE_AM_I(ICM_$DYNVMLC,1);
          RETURN;
       ] "double check if a particle is out of the CM"
    ]
   ELSEIF(W(NP) < 0.0) [
     "particle going backward"
      DIST = (ZMIN_$DYNVMLC - Z(NP))/W(NP); "distance to back of CM "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP;  ]
      ELSE [ STEP_UNIT=DIST; ]
      IF(DIST <= 0.0) [
          USTEP=0.0;
          IF(N_GAP_$DYNVMLC = 1)
            [IRNEW =IREND_$DYNVMLC; RETURN; ]
          ELSE[ USTEP=1.E-16; CALL WHERE_AM_I(ICM_$DYNVMLC,-1); RETURN; ]
      ] " double check if a particle is out of the main body to air gap"
    ]
   ELSE[STEP_UNIT=USTEP;]  " for w(np)=0.0 case"
 ];

" end of z direction check
"=========================

$DYNVMLC_FIND(REGION_$DYNVMLC,0.0);

IF(REGION_$DYNVMLC=4) [ "Particle is in the air gap "
  REGION_$DYNVMLC=IRSTART_$DYNVMLC-1+REGION_$DYNVMLC;
   IF(W(NP) > 0.0)[
    IF(DIST <= USTEP ) ["particle to be moved to region boundary"
      $GEO_SHIFT_1_(DIST);
      USTEP = DIST;
      $DYNVMLC_FIND(NEWREGION_$DYNVMLC,USTEP);
      IF( NEWREGION_$DYNVMLC=1) [IRNEW =IRSTART_$DYNVMLC; RETURN;]
      ELSE[IRNEW =IRSTART_$DYNVMLC+1; RETURN;]
    ]
    ELSE[ RETURN;];
    ] "end of particle going forward"
    ELSEIF(W(NP) < 0.0) ["particle going backward"
      IF(DIST <= USTEP ) ["particle to be moved to region boundary"
        $GEO_SHIFT_1_(DIST);
        USTEP = DIST;
        CALL WHERE_AM_I(ICM_$DYNVMLC,-1);
        RETURN;
        ]
      ELSE [RETURN;]
    ] " end of going backward"
    ELSE[RETURN;];   " W=0.0 CASE "
] ;" end of region 4"


IF(OUTOFMLCFLAG=1) [

"discard particle if it is outside lateral edges of MLC.  This was the
"intent of the original programmer, but we do not want to do this in general.
"  IF(Z(NP)>=ZMIN_$DYNVMLC & Z(NP)<=ZMAX_$DYNVMLC) [
"    TEMP1=SURPARA1_$DYNVMLC(1,1)*(ZFL-ZFOCUS_$DYNVMLC(1));
"    TEMP2=SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*
"          (ZFL-ZFOCUS_$DYNVMLC(1));
"    IF(XYFL(1)<=TEMP1|XYFL(1)>=TEMP2)[
"      IDISC=1; RETURN;];
"   ];

  STEP2=STEP_UNIT;
  TEMP1=(SURPARA1_$DYNVMLC(1,1)*(ZFL-ZFOCUS_$DYNVMLC(1))-XYFL(1));
  IF( (UVL(1)-SURPARA1_$DYNVMLC(1,1)*W(NP))~=0.0 ) [
     TEMP1=TEMP1/(UVL(1)-SURPARA1_$DYNVMLC(1,1)*W(NP));
   ]
  ELSE [ TEMP1 = -1000.00 ];

  TEMP2=(SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*
        (ZFL-ZFOCUS_$DYNVMLC(1))-XYFL(1));
  IF( (UVL(1)-SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*W(NP))~=0.0 ) [
    TEMP2=TEMP2/(UVL(1)-SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*W(NP));
  ]
  ELSE [ TEMP2 = -1000.00 ];

  IF( STEP2>=0.0)[
    TEMP=STEP2;
    IF( TEMP1>=0 ) [TEMP=MIN(TEMP,TEMP1);];
    IF( TEMP2>=0 ) [TEMP=MIN(TEMP,TEMP2);];
  ]
  ELSEIF ( (TEMP1>0.0) & (TEMP2>0.0) ) [TEMP=MIN(TEMP1,TEMP2);]
  ELSE [TEMP=MAX(TEMP2,TEMP1);];

  STEP2 = TEMP;

  $GEO_SHIFT_1_(STEP2);
  $DYNVMLC_FIND(IRNEW,STEP2);
  IRNEW=IRNEW+IRSTART_$DYNVMLC-1;
  USTEP=STEP2;
  RETURN;
 ]
;
$DYNVMLC_MINDISTANCE(DIST1);

IF((DIST1>=STEP_UNIT) | (DIST1<0)) [
    STEP2=STEP_UNIT;
    $GEO_SHIFT_1_(STEP2);
    $DYNVMLC_FIND(IRNEW,STEP2);
    USTEP=STEP2;
    IF(OUTOFCMFLAG=1)[ "call where_am_i"
       IDIR=SIGN(one,W(NP));
       CALL WHERE_AM_I(ICM_$DYNVMLC,IDIR);
       RETURN;
    ]
    ELSE[
      IRNEW=IRNEW+IRSTART_$DYNVMLC-1;
      RETURN;
    ]
]
ELSEIF( (STEP_UNIT>DIST1) & (DIST1>=0)) [
    REGION_$DYNVMLC=REGION_$DYNVMLC+IRSTART_$DYNVMLC-1;
    LOOP[
      DIST1=DIST1+1.0E-5; "we have to shift it regardless to avoid "
                          "infinite loops"
      IF(DIST1>=STEP_UNIT)[EXIT;]
      ELSE[
        $DYNVMLC_FIND(NEWREGION_$DYNVMLC,DIST1);
        NEWREGION_$DYNVMLC=NEWREGION_$DYNVMLC+IRSTART_$DYNVMLC-1;
        IF( OUTOFCMFLAG=1 ) [ EXIT;]
        ELSEIF( (NEWREGION_$DYNVMLC~=REGION_$DYNVMLC) | OUTOFMLCFLAG=1 )[
        USTEP = MIN(USTEP,DIST1); "take min. because we shifted DIST1"
        IRNEW = NEWREGION_$DYNVMLC;
        RETURN;
       ]
       ELSE [
         $DYNVMLC_MINDISTANCE(DIST2);
         DIST1=DIST1+DIST2;
       ];
      ]
    ];
;
"if it gets here, then it exited either because OUTOFCMFLAG=1"
"or because DIST1 >= STEP_UNIT, in either case DIST1 >= STEP_UNIT"
;
    DIST1=STEP_UNIT;
    $GEO_SHIFT_1_(DIST1);
    USTEP = DIST1;

    IF( OUTOFCMFLAG=0 ) [
      $DYNVMLC_FIND(NEWREGION_$DYNVMLC,DIST1);
      "still have to check if we have left the CM in case STEP_UNIT"
      "was the distance to the bottom of the CM"
      IF(OUTOFCMFLAG=1)[
        IDIR=SIGN(one,W(NP));
        CALL WHERE_AM_I(ICM_$DYNVMLC,IDIR);
        RETURN;
      ]
      ELSE["not leaving CM"
        NEWREGION_$DYNVMLC=NEWREGION_$DYNVMLC+IRSTART_$DYNVMLC-1;
        IRNEW = NEWREGION_$DYNVMLC;
        RETURN;
      ]
    ]
    ELSE[ "call where_am_i"
       "since flag is based on distance to Z bdy, DIST1 is >= STEP_UNIT now"
       IDIR=SIGN(one,W(NP));
       CALL WHERE_AM_I(ICM_$DYNVMLC,IDIR);
       RETURN;
    ]

]; "End of IF loop for step_unit>dist1

;
"   end of HOWFAR_$DYNVMLC
"   ===================
"
RETURN;
END; "End of subroutine HOWFAR_$DYNVMLC"
%E "Start of WHERE_AM_I_$DYNVMLC"
"************************************************************************
"
"                          Subroutine WHERE_AM_I_$DYNVMLC
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_$DYNVMLC determines the new region number when a particle
" traverses a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_$DYNVMLC subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_$DYNVMLC from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*************************************************************************

;SUBROUTINE WHERE_AM_I_$DYNVMLC(IDIR);
;
;IMPLICIT NONE;
;COMIN/CM_$DYNVMLC,EPCONT,STACK,CMs,USER/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_$DYNVMLC
"T>**************************************
"T>
INTEGER NX,NY,NZ,   "T>Indices of subregions
        I,
        OUTOFCMFLAG, "Flags to denote out of CM and
        OUTOFMLCFLAG, " MLC respectively
        LEAFIS,       " Leaf number
        IDIR;  "T>direction of particle, +1=forward, -1=backward
DOUBLE PRECISION   XYL(2), XYFL(2), ZFL, UVL(2), XoN, XoP, Zo, TEMP1, TEMP2,
                   TEMP3, TEMP4, HOLE;

IF(ORIENT_$DYNVMLC=1)
    [ XYL(1)=Y(NP); XYL(2)=X(NP);UVL(1)=V(NP);UVL(2)=U(NP);]
ELSE[ XYL(1)=X(NP); XYL(2)=Y(NP);UVL(1)=U(NP);UVL(2)=V(NP);];
IF (IDIR=1) [
 "particle entering this CM through front face (upstream)"
   IF(N_GAP_$DYNVMLC = 0) [ "no air gap this CM"
       IF(IRSTART_$DYNVMLC=2)   " the first CM"
         [$DYNVMLC_FIND(IR_$DYNVMLC,0.0); ]
       ELSE[$DYNVMLC_FIND(IR_$DYNVMLC, USTEP);]
       IF(IR_$DYNVMLC=1)
         [IRNEW=IRSTART_$DYNVMLC; RETURN;]
       ELSE[ IRNEW=IRSTART_$DYNVMLC+1; RETURN; ]
    ]         " end of the no air gap case"
   ELSE [ "this CM has an air gap at the front"
      IRNEW = IREND_$DYNVMLC;
        ]
 ]

ELSE [ "particle entering CM through back face (downstream)"
   $DYNVMLC_FIND(IR_$DYNVMLC, USTEP);
   IF(IR_$DYNVMLC=1)
     [IRNEW=IRSTART_$DYNVMLC; RETURN;]
   ELSE[ IRNEW=IRSTART_$DYNVMLC+1; RETURN; ]
 ];

RETURN;
;
END; "End of subroutine WHERE_AM_I_$DYNVMLC"
%E "Start of subroutine INPUT_$DYNVMLC"

"*************************************************************************

"                           Subroutine INPUT_$DYNVMLC
"
"*************************************************************************
"*************************************************************************

"  A CM input subroutine for a series of 2 or more slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section INPUT FROM UNIT 5
"   in the above documentation.
"
"************************************************************************

;SUBROUTINE INPUT_$DYNVMLC;
;

;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_$DYNVMLC,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"  **************************************************************** "
"              TYPE DECLARATIONS FOR INPUT_$DYNVMLC
"  **************************************************************** "

DOUBLE PRECISION  NEG_$DYNVMLC,     "T>Leaf B tip
                  POS_$DYNVMLC,     "T>Leaf A Tip
                  TEMP1,
                  TEMP2;

INTEGER I,J,K,L,        "T>DO loop indices
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,   "T>medium index, set after medium sort by $MED_INPUT
     NUM_$DYNVMLC, "T>number of adjacent leaves with same opening coordinates
       LEAFTYPE,     "T>temporary input variable for LEAFTYPE
       MIN_INDEX,   "T>index of leaf with min. opening coordinate
       MAX_INDEX,   "T>index of leaf with max. opening coordinate
       mlc_unit,    "T>unit no. to assign mlc_file
       egs_get_unit; "T>egs function used to assign unit to 2mlc_file
character*256 mlc_file;
CHARACTER*80 MLC_TITLE; "T> title line in mlc_file
$REAL INDEXTMP; "T>temporary input variable for field indices in dynamic and
                "  step-and-shoot simulations
" **************************************************************** "

"                 STEP I : INITIALIZE PARAMETERS
"                          =====================

" **************************************************************** "


"I. GET THE TITLE "
"================ "
;
OUTPUT;(/' Next component is a VARIAN type MLC'/' Title: ',$);
MINPUT ($DYNVMLC) TITLE_$DYNVMLC;(60A1);
          "MINPUT is a replacement macro with EOF and
          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_$DYNVMLC;(' ',60A1);
            "OUTPUT is a replacement macro which writes to
            "unit 5.  Used here for echo of user input

"II. CHOOSE THE DYNVMLC ORIENTATION "
"============================== "

OUTPUT; (' Input leaf orientation (0=parallel to y, 1=parallel to x) and '/
         ' no. of groups of leaves with equal width on one line'/' :',$);
MINPUT ($DYNVMLC) ORIENT_$DYNVMLC, NGROUP_$DYNVMLC, MODE_$DYNVMLC; (3I5);
OUTPUT ORIENT_$DYNVMLC,NGROUP_$DYNVMLC,MODE_$DYNVMLC; (2I5/);
IF(ORIENT_$DYNVMLC~=1) [
      ORIENT_$DYNVMLC=0;
      OUTPUT;(/' Orientation defaults to 0.'/);
 ];
IF(NGROUP_$DYNVMLC<=0) [
      NGROUP_$DYNVMLC=1;
      OUTPUT;(/' No. of groups defaults to 1.'/);
 ];
IF(MODE_$DYNVMLC<0 | MODE_$DYNVMLC>2) [
      MODE_$DYNVMLC=0;
      OUTPUT;(/' Mode of leaf opening input defaults to 0.'/);
 ];

"III. DESIGNATE REGION NUMBERS "
"============================= "

N_$DYNVMLC = 3;
           "Number of regions in this CM (excluding front air gap)
ICM_$DYNVMLC = ICM;      "CM index for this component module
IRSTART_$DYNVMLC = IR_start_CM(ICM_$DYNVMLC);
                      "Index of first region in this CM,
                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_$DYNVMLC) = 0; "Geometry-checking flag, 0 if no error detected

"IV. GET DISTANCE FROM THE REFERENCE PLANE, z=0 "
"============================================== "
;
OUTPUT; (' Z position of top of Varian MLC (>=0) : ',$);
;MINPUT ($DYNVMLC) ZMIN_$DYNVMLC;(F12.5);
OUTPUT ZMIN_$DYNVMLC;(F12.5/);
IF(Z_min_CM(ICM_$DYNVMLC)>ZMIN_$DYNVMLC) [
   IF(ICM_$DYNVMLC=1) [
      Z_min_CM(ICM_$DYNVMLC)=ZMIN_$DYNVMLC;
      OUTPUT ICM_$DYNVMLC, Z_min_CM(ICM_$DYNVMLC);
       (//' ***WARNING IN CM ',I4,' ($DYNVMLC):'/
           ' Z_min_CM(1)  > distance to front of MLC '/
           ' Z_min_CM(1) reset to ',F8.5,' cm'//);
 WRITE(IOUTLIST,
 '(//'' ***WARNING IN CM '',I4,
      '' ($DYNVMLC):''/
  '' Z_min_CM(1)  > distance to front of collimator''/
  '' Z_min_CM(1) reset to '',F8.5,'' cm''//)')
    ICM_$DYNVMLC, Z_min_CM(ICM_$DYNVMLC);
     ]
    ELSE[
      OUTPUT ICM_$DYNVMLC;
       (//' ***** WARNING WARNING WARNING *****'/
          ' ***ERROR IN CM ',I4,' ($DYNVMLC):'/
          ' Overlaps with previous CM'/
          ' Error will be propagated'//);
      WRITE(IOUTLIST,
         '(//'' ***WARNING IN CM '',I4,'' ($DYNVMLC):''/
          '' Overlaps with previous CM''//)')
          ICM_$DYNVMLC;
      IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
     ]
 ]
;
" ************************************************************** "

"              STEP TWO : GET DYNVMLC GEOMETRY INFORMATION
"                         ============================

" ************************************************************** "

" I. THICKNESS OF LEAVES "
" ======================= "
;

OUTPUT; (' MLC Leaf thickness (cm):',$);
MINPUT ($DYNVMLC) ZTHICK_$DYNVMLC; (F15.0);
OUTPUT ZTHICK_$DYNVMLC;(F15.5, ' cm'/);

" Validate the user-input thickness "

IF(ZTHICK_$DYNVMLC<0.0) [
    OUTPUT ICM_$DYNVMLC;(//' ***ERROR IN CM ',I4,' ($DYNVMLC):'/
                          ' ZTHICK < 0.0'//);
    IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ];

ZMAX_$DYNVMLC = ZMIN_$DYNVMLC + ZTHICK_$DYNVMLC;
;

" II. Input geometries of FULL, ISOCENTER and TARGET leaves"
" =============================================================== "
;
OUTPUT;
(/' For FULL leaves input (all in cm, widths projected to ZMIN): '/
' leaf width (excl. tongue), width of tongue, width of groove, width of'/
' tip at top, width of top of support rail, width of bottom of support rail,'/
' Z of top of tip, Z of top of leaf, Z of bottom of tongue, Z of bottom of'/
' groove, Z of top of driving screw hole, Z of bottom of driving screw hole,'/
' distance of hole from leaf tip, Z of top of support rail, Z of bottom of'/
' support rail:'/);
MINPUT ($DYNVMLC) LEAFWIDTH_$DYNVMLC(1), WTONGUE_$DYNVMLC(1),
      WGROOVE_$DYNVMLC(1), WTIP_$DYNVMLC(1), WRAILTOP_$DYNVMLC(1),
      WRAILBOT_$DYNVMLC(1), ZTIP_$DYNVMLC(1), ZLEAF_$DYNVMLC(1),
      ZTONGUE_$DYNVMLC(1), ZGROOVE_$DYNVMLC(1), ZHOLETOP_$DYNVMLC(1),
      ZHOLEBOT_$DYNVMLC(1), HOLEPOS_FULL_$DYNVMLC, ZRAILTOP_$DYNVMLC(1),
      ZRAILBOT_$DYNVMLC(1); (15F15.0);
OUTPUT LEAFWIDTH_$DYNVMLC(1), WTONGUE_$DYNVMLC(1), WGROOVE_$DYNVMLC(1),
      WTIP_$DYNVMLC(1), WRAILTOP_$DYNVMLC(1), WRAILBOT_$DYNVMLC(1),
      ZTIP_$DYNVMLC(1), ZLEAF_$DYNVMLC(1), ZTONGUE_$DYNVMLC(1),
      ZGROOVE_$DYNVMLC(1), ZHOLETOP_$DYNVMLC(1), ZHOLEBOT_$DYNVMLC(1),
      HOLEPOS_FULL_$DYNVMLC, ZRAILTOP_$DYNVMLC(1), ZRAILBOT_$DYNVMLC(1);
      (15F15.5);
"now do checks on input dimensions"
IF(WGROOVE_$DYNVMLC(1)>LEAFWIDTH_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
   ' WGROOVE_$DYNVMLC(1)>LEAFWIDTH_$DYNVMLC(1).  Groove is too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WTIP_$DYNVMLC(1)<WTONGUE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' WTIP_$DYNVMLC(1)<WTONGUE_$DYNVMLC(1).  Tip is too narrow.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WTIP_$DYNVMLC(1)>LEAFWIDTH_$DYNVMLC(1)+WTONGUE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' WTIP_$DYNVMLC(1)>LEAFWIDTH_$DYNVMLC(1)+WTONGUE_$DYNVMLC(1)'/
      '                  -WGROOVE_$DYNVMLC(1).  Tip is too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(1)>LEAFWIDTH_$DYNVMLC(1)-WGROOVE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' WRAILTOP_$DYNVMLC(1)>LEAFWIDTH_$DYNVMLC(1)+WGROOVE_$DYNVMLC(1).'/
      ' Upper rail too wide.'//);
        IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(1)<WTIP_$DYNVMLC(1)-WTONGUE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' WRAILTOP_$DYNVMLC(1)<WTIP_$DYNVMLC(1)-WTONGUE_$DYNVMLC(1).'/
      ' Upper rail too narrow or tip too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILBOT_$DYNVMLC(1)>WRAILTOP_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' WRAILBOT_$DYNVMLC(1)>WRAILTOP_$DYNVMLC(1).  Lower rail too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(1)-WRAILBOT_$DYNVMLC(1)<
   WTIP_$DYNVMLC(1)-WTONGUE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' WRAILTOP_$DYNVMLC(1)-WRAILBOT_$DYNVMLC(1)<'/
      ' WTIP_$DYNVMLC(1)-WTONGUE_$DYNVMLC(1).'/
      ' Lower rail too wide.  Or tip too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTIP_$DYNVMLC(1)<ZMIN_$DYNVMLC)[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZTIP_$DYNVMLC(1)<ZMIN_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZLEAF_$DYNVMLC(1)<ZTIP_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZLEAF_$DYNVMLC(1)<ZTIP_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTONGUE_$DYNVMLC(1)<ZLEAF_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZTONGUE_$DYNVMLC(1)<ZTIP_$DYNVMLC(1).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZGROOVE_$DYNVMLC(1)<ZTONGUE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZGROOVE_$DYNVMLC(1)<ZTONGUE_$DYNVMLC(1).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZHOLETOP_$DYNVMLC(1)<ZGROOVE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZHOLETOP_$DYNVMLC(1)<ZGROOVE_$DYNVMLC(1).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZHOLEBOT_$DYNVMLC(1)<ZHOLETOP_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZHOLEBOT_$DYNVMLC(1)<ZHOLETOP_$DYNVMLC(1).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILTOP_$DYNVMLC(1)<ZHOLEBOT_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZRAILTOP_$DYNVMLC(1)<ZHOLEBOT_$DYNVMLC(1).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILBOT_$DYNVMLC(1)<ZRAILTOP_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZRAILBOT_$DYNVMLC(1)<ZRAILTOP_$DYNVMLC(1).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILBOT_$DYNVMLC(1)>ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC)[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in FULL leaf definition:'/
      ' ZRAILBOT_$DYNVMLC(1)>ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]

OUTPUT;
(/' For TARGET leaves input (all in cm, widths projected to ZMIN): '/
' leaf width (excl. tongue), width of tongue, width of groove, width of'/
' tip at top, width of top of support rail, width of bottom of support rail,'/
' Z of top of support rail, Z of bottom of support rail, Z of top of driving'/
' screw hole, Z of bottom of driving screw hole, distance of hole from leaf'/
' tip, Z of bottom of tongue, Z of top of groove, Z of bottom of leaf, Z of'/
' bottom of tip:'/);
MINPUT ($DYNVMLC) LEAFWIDTH_$DYNVMLC(2), WTONGUE_$DYNVMLC(2),
      WGROOVE_$DYNVMLC(2), WTIP_$DYNVMLC(2), WRAILTOP_$DYNVMLC(2),
      WRAILBOT_$DYNVMLC(2), ZRAILTOP_$DYNVMLC(2), ZRAILBOT_$DYNVMLC(2),
      ZHOLETOP_$DYNVMLC(2), ZHOLEBOT_$DYNVMLC(2), HOLEPOS_TAR_$DYNVMLC,
      ZTONGUE_$DYNVMLC(2), ZGROOVE_$DYNVMLC(2), ZLEAF_$DYNVMLC(2),
      ZTIP_$DYNVMLC(2); (15F15.0);
OUTPUT LEAFWIDTH_$DYNVMLC(2), WTONGUE_$DYNVMLC(2), WGROOVE_$DYNVMLC(2),
      WTIP_$DYNVMLC(2), WRAILTOP_$DYNVMLC(2), WRAILBOT_$DYNVMLC(2),
      ZRAILTOP_$DYNVMLC(2), ZRAILBOT_$DYNVMLC(2), ZHOLETOP_$DYNVMLC(2),
      ZHOLEBOT_$DYNVMLC(2), HOLEPOS_TAR_$DYNVMLC, ZTONGUE_$DYNVMLC(2),
      ZGROOVE_$DYNVMLC(2), ZLEAF_$DYNVMLC(2), ZTIP_$DYNVMLC(2); (15F15.5);
"check input dimensions"
IF(WGROOVE_$DYNVMLC(2)>LEAFWIDTH_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' WGROOVE_$DYNVMLC(2)>LEAFWIDTH_$DYNVMLC(2).  Groove too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WTIP_$DYNVMLC(2)>LEAFWIDTH_$DYNVMLC(2)-WGROOVE_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' WTIP_$DYNVMLC(2)>LEAFWIDTH_$DYNVMLC(1)-WGROOVE_$DYNVMLC(1).'/
      ' Tip too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILBOT_$DYNVMLC(2)<WGROOVE_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
   ' WRAILBOT_$DYNVMLC(2)<WGROOVE_$DYNVMLC(2).  Lower rail too narrow.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILBOT_$DYNVMLC(2)>WGROOVE_$DYNVMLC(2)+WTIP_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' WRAILBOT_$DYNVMLC(2)>WGROOVE_$DYNVMLC(2)+WTIP_$DYNVMLC(2).'/
      ' Lower rail too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(2)>WRAILBOT_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' WRAILTOP_$DYNVMLC(2)>WRAILBOT_$DYNVMLC(2).  Top rail too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(2)<WRAILBOT_$DYNVMLC(2)-WGROOVE_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' WRAILTOP_$DYNVMLC(2)<WRAILBOT_$DYNVMLC(2)-WGROOVE_$DYNVMLC(2).'/
      ' Top rail too narrow.'//);
        IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILTOP_$DYNVMLC(2)<ZMIN_$DYNVMLC)[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZRAILTOP_$DYNVMLC(2)<ZMIN_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILBOT_$DYNVMLC(2)<ZRAILTOP_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZRAILBOT_$DYNVMLC(2)<ZRAILTOP_$DYNVMLC(2).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZHOLETOP_$DYNVMLC(2)<ZRAILBOT_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZHOLETOP_$DYNVMLC(2)<ZRAILBOT_$DYNVMLC(2).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZHOLEBOT_$DYNVMLC(2)<ZHOLETOP_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZHOLEBOT_$DYNVMLC(3)<ZHOLETOP_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTONGUE_$DYNVMLC(2)<ZHOLEBOT_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZTONGUE_$DYNVMLC(2)<ZHOLEBOT_$DYNVMLC(2).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZGROOVE_$DYNVMLC(2)<ZTONGUE_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZGROOVE_$DYNVMLC(2)<ZTONGUE_$DYNVMLC(2).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZLEAF_$DYNVMLC(2)<ZTONGUE_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZLEAF_$DYNVMLC(2)<ZTONGUE_$DYNVMLC(2).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTIP_$DYNVMLC(2)<ZLEAF_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZTIP_$DYNVMLC(2)<ZLEAF_$DYNVMLC(2).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTIP_$DYNVMLC(2)>ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC)[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in TARGET leaf definition:'/
      ' ZTIP_$DYNVMLC(2)>ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]


OUTPUT;
(/' For ISOCENTER leaves input (all in cm, widths projected to ZMIN): '/
' leaf width (excl. tongue), width of tongue, width of groove, width of'/
' tip at top, width of top of support rail, width of bottom of support rail,'/
' Z of top of tip, Z of top of leaf, Z of top of tongue, Z of bottom of'/
' groove, Z of top of driving screw hole, Z of bottom of driving screw hole,'/
' distance of hole from leaf tip, Z of top of support rail, Z of bottom of'/
' support rail:'/);
MINPUT ($DYNVMLC) LEAFWIDTH_$DYNVMLC(3), WTONGUE_$DYNVMLC(3),
     WGROOVE_$DYNVMLC(3), WTIP_$DYNVMLC(3),WRAILTOP_$DYNVMLC(3),
     WRAILBOT_$DYNVMLC(3), ZTIP_$DYNVMLC(3), ZLEAF_$DYNVMLC(3),
     ZTONGUE_$DYNVMLC(3),ZGROOVE_$DYNVMLC(3), ZHOLETOP_$DYNVMLC(3),
     ZHOLEBOT_$DYNVMLC(3), HOLEPOS_ISO_$DYNVMLC, ZRAILTOP_$DYNVMLC(3),
     ZRAILBOT_$DYNVMLC(3); (15F15.0);
OUTPUT LEAFWIDTH_$DYNVMLC(3), WTONGUE_$DYNVMLC(3), WGROOVE_$DYNVMLC(3),
       WTIP_$DYNVMLC(3), WRAILTOP_$DYNVMLC(3), WRAILBOT_$DYNVMLC(3),
       ZTIP_$DYNVMLC(3), ZLEAF_$DYNVMLC(3), ZTONGUE_$DYNVMLC(3),
      ZGROOVE_$DYNVMLC(3), ZHOLETOP_$DYNVMLC(3), ZHOLEBOT_$DYNVMLC(3),
      HOLEPOS_ISO_$DYNVMLC, ZRAILTOP_$DYNVMLC(3), ZRAILBOT_$DYNVMLC(3);
      (15F15.5);
"now do checks on input dimensions"
IF(WGROOVE_$DYNVMLC(3)>LEAFWIDTH_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' WGROOVE_$DYNVMLC(3)>LEAFWIDTH_$DYNVMLC(3).  Groove too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WTIP_$DYNVMLC(3)>LEAFWIDTH_$DYNVMLC(3)-WGROOVE_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' WTIP_$DYNVMLC(3)>LEAFWIDTH_$DYNVMLC(3)-WGROOVE_$DYNVMLC(3).'/
      ' Tip too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(3)>LEAFWIDTH_$DYNVMLC(3)+WTONGUE_$DYNVMLC(3)-
   WGROOVE_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' WRAILTOP_$DYNVMLC(3)>LEAFWIDTH_$DYNVMLC(3)+WTONGUE_$DYNVMLC(3)-'/
      '                  WGROOVE_$DYNVMLC(3).  Top of rail too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILTOP_$DYNVMLC(3)<WTONGUE_$DYNVMLC(3)+WTIP_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' WRAILTOP_$DYNVMLC(3)<WTONGUE_$DYNVMLC(3)+WTIP_$DYNVMLC(3).'/
      ' Top of rail too narrow.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILBOT_$DYNVMLC(3)>WRAILTOP_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
' WRAILBOT_$DYNVMLC(3)>WRAILTOP_$DYNVMLC(3).  Bottom of rail too wide.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WRAILBOT_$DYNVMLC(3)<WRAILTOP_$DYNVMLC(3)-WTONGUE_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' WRAILBOT_$DYNVMLC(3)<WRAILTOP_$DYNVMLC(3)-WTONGUE_$DYNVMLC(3).'/
      ' Bottom of rail too narrow.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTIP_$DYNVMLC(3)<ZMIN_$DYNVMLC)[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZTIP_$DYNVMLC(3)<ZMIN_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZLEAF_$DYNVMLC(3)<ZTIP_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZLEAF_$DYNVMLC(3)<ZTIP_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTONGUE_$DYNVMLC(3)<ZLEAF_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZTONGUE_$DYNVMLC(3)<ZLEAF_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZGROOVE_$DYNVMLC(3)<ZTONGUE_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZGROOVE_$DYNVMLC(3)<ZTONGUE_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZHOLETOP_$DYNVMLC(3)<ZGROOVE_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZHOLETOP_$DYNVMLC(3)<ZGROOVE_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZHOLEBOT_$DYNVMLC(3)<ZHOLETOP_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZHOLEBOT_$DYNVMLC(3)<ZHOLETOP_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILTOP_$DYNVMLC(3)<ZHOLEBOT_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZRAILTOP_$DYNVMLC(3)<ZHOLEBOT_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILBOT_$DYNVMLC(3)<ZRAILTOP_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZRAILBOT_$DYNVMLC(3)<ZRAILTOP_$DYNVMLC(3).'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZRAILBOT_$DYNVMLC(3)>ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC)[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in ISOCENTER leaf definition:'/
      ' ZRAILBOT_$DYNVMLC(3)>ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC.'//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]

"now check dimensions between leaf types"
IF(ZTONGUE_$DYNVMLC(3)<=ZGROOVE_$DYNVMLC(2))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in leaf definition:'/
      ' ZTONGUE_$DYNVMLC(3)<=ZGROOVE_$DYNVMLC(2).'/
      ' ISOCENTER/TARGET leaves will not fit together.'//);
       IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTONGUE_$DYNVMLC(2)>=ZGROOVE_$DYNVMLC(3))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in leaf definition:'/
      ' ZTONGUE_$DYNVMLC(2)>=ZGROOVE_$DYNVMLC(3).'/
      ' ISOCENTER/TARGET leaves will not fit together.'//);
       IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZGROOVE_$DYNVMLC(3)<=ZTONGUE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in leaf definition:'/
      ' ZGROOVE_$DYNVMLC(3)<=ZTONGUE_$DYNVMLC(1).'/
      ' ISOCENTER leaf will not fit with'/
      ' FULL leaf if ISOCENTER leaf is on -X or -Y side.'//);
       IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(ZTONGUE_$DYNVMLC(2)>=ZGROOVE_$DYNVMLC(1))[
   OUTPUT ICM_$DYNVMLC;
   (//' ***ERROR IN CM ',I3,' ($DYNVMLC) in leaf definition:'/
      ' ZTONGUE_$DYNVMLC(2)>=ZGROOVE_$DYNVMLC(1).'/
      ' TARGET leaf will not fit with'/
      ' FULL leaf if FULL leaf is on -X or -Y side.'//);
       IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]

TOT_LEAF_$DYNVMLC=0;
K=0;
OUTPUT;(' ');
DO I=1,NGROUP_$DYNVMLC [
   OUTPUT I;
   (' Group ',I3,':'/
    '   No. of leaves, leaf type (1. FULL leaves--the default, '/
    '   2. TARGET/ISOCENTER pairs with TARGET leaf on -X or -Y side)'/
    '   :',$);
   MINPUT ($DYNVMLC) NUM_LEAF_$DYNVMLC(I), LEAFTYPE; (2I5);
   OUTPUT NUM_LEAF_$DYNVMLC(I), LEAFTYPE; (2I5);

   TOT_LEAF_$DYNVMLC=TOT_LEAF_$DYNVMLC+NUM_LEAF_$DYNVMLC(I);

   IF(LEAFTYPE<=0|LEAFTYPE>2)[
     LEAFTYPE=1;
     OUTPUT ICM_$DYNVMLC,I;
         (//' ***WARNING IN CM ',I3,' ($DYNVMLC)'/
            ' Leaf type for group ',I3,' not recognized.'/
            ' Will default to 1.'//);
   ]
   IF(MOD(NUM_LEAF_$DYNVMLC(I),2)~=0 & (LEAFTYPE=2 |
     LEAFTYPE=3))[
      OUTPUT ICM_$DYNVMLC,I;
         (//' ***ERROR IN CM ',I3,' ($DYNVMLC)'/
            ' Leaf group ',I3,' consists of TARGET/ISOCENTER pairs but'/
            ' does not have an even number of leaves.'//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
   ]
   "now set LEAFTYPE for each leaf"
   DO J=1,NUM_LEAF_$DYNVMLC(I)[
      K=K+1;
      IF(LEAFTYPE=1)[
         LEAFTYPE_$DYNVMLC(K)=1;
      ]
      ELSE["target/isocenter pair"
        IF(MOD(J,2)~=0)["target leaf"
           LEAFTYPE_$DYNVMLC(K)=2;
        ]
        ELSE[
           LEAFTYPE_$DYNVMLC(K)=3;
        ]
      ]
   ]
]
;
IF(TOT_LEAF_$DYNVMLC>$MAXLEAF) [
    TOT_LEAF_$DYNVMLC=$MAXLEAF;
    OUTPUT ICM_$DYNVMLC,TOT_LEAF_$DYNVMLC;
            (//' ***ERROR IN CM ',I3,' ($DYNVMLC)'/
             ' Total # of leaves > max allowed'/
             ' Total # of leaves reduced to ',I3,' for now'//);
    IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ]
;
IF(TOT_LEAF_$DYNVMLC<=0) [
    TOT_LEAF_$DYNVMLC=1;
    OUTPUT ICM_$DYNVMLC,TOT_LEAF_$DYNVMLC;
            (//' ***ERROR IN CM ',I3,' ($DYNVMLC)'/
             ' Total # of leaves <= 0'/
             ' Total # of leaves set to ',I3,' for now'//);
    IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ];

" III. START POSITION OF LEAVES"
" ============================="
;
OUTPUT ZMIN_$DYNVMLC; (/' Input the starting X (ORIENT_$DYNVMLC=0) or '/
         ' Y (ORIENT_$DYNVMLC=1) position at z = ',F15.0, ' cm : ', $);
MINPUT ($DYNVMLC) START_$DYNVMLC; (F15.0);
OUTPUT START_$DYNVMLC; (F12.5);

" Checking the validity of user-input"

IF(ABS(START_$DYNVMLC)-RMAX_CM(ICM_$DYNVMLC)>1.E-5) [
  OUTPUT ICM_$DYNVMLC;
   (//'***ERROR IN CM ',I4,' ($DYNVMLC)'/
   ' START POSITION EXCEEDS CM BOUNDARY'//);
   IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ];

"IV. INTER-LEAF AIR GAP "
"====================== "

OUTPUT; (/'Input the inter-leaf air gap(>=0.0) : ',$);
  "leaf gap defined at ZMIN"
MINPUT ($DYNVMLC) LEAFGAP_$DYNVMLC; (F15.0);
OUTPUT LEAFGAP_$DYNVMLC; (F12.5);

IF (LEAFGAP_$DYNVMLC<0.0) [
      LEAFGAP_$DYNVMLC=0;
      OUTPUT ICM_$DYNVMLC;
         (//'***ERROR IN CM ',I4,' ($DYNVMLC)'/
         ' Inter-leaf air gap is negative - reset to 0   '//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
      ];

"Check that there are no unblocked areas between adjacent leaves"
IF(LEAFGAP_$DYNVMLC>WTONGUE_$DYNVMLC(1))[
        LEAFGAP_$DYNVMLC = WTONGUE_$DYNVMLC(1);
        OUTPUT ICM_$DYNVMLC;
        (//'**ERROR IN CM ',I4,' ($DYNVMLC)'/
       ' Width of inter-leaf airgap exceeds that of the FULL leaf tongue.',/
       ' Reset to be equal to the width of the tongue. '//);
         IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(LEAFGAP_$DYNVMLC>WTONGUE_$DYNVMLC(3))[
        LEAFGAP_$DYNVMLC = WTONGUE_$DYNVMLC(3);
        OUTPUT ICM_$DYNVMLC;
        (//'**ERROR IN CM ',I4,' ($DYNVMLC)'/
   ' Width of inter-leaf airgap exceeds that of the ISOCENTER leaf tongue.',/
   ' Reset to be equal to the width of the tongue. '//);
        IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(LEAFGAP_$DYNVMLC>WTONGUE_$DYNVMLC(2))[
        LEAFGAP_$DYNVMLC = WTONGUE_$DYNVMLC(2);
        OUTPUT ICM_$DYNVMLC;
        (//'**ERROR IN CM ',I4,' ($DYNVMLC)'/
   ' Width of inter-leaf airgap exceeds that of the TARGET leaf tongue.',/
   ' Reset to be equal to the width of the tongue. '//);
        IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]

"check leaf gap between adjacent tongue and groove"
IF(WGROOVE_$DYNVMLC(1)+LEAFGAP_$DYNVMLC-WTONGUE_$DYNVMLC(1)<0.0)[
    OUTPUT ICM_$DYNVMLC;
     (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
        ' Tongue in FULL leaf too wide for groove in FULL leaf. '//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WGROOVE_$DYNVMLC(2)+LEAFGAP_$DYNVMLC-WTONGUE_$DYNVMLC(3)<0.0)[
    OUTPUT ICM_$DYNVMLC;
     (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
        ' Tongue in ISOCENTER leaf too wide for groove in TARGET leaf. '//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WGROOVE_$DYNVMLC(1)+LEAFGAP_$DYNVMLC-WTONGUE_$DYNVMLC(2)<0.0)[
    OUTPUT ICM_$DYNVMLC;
     (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
        ' Tongue in TARGET leaf too wide for groove in FULL leaf. '//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]
IF(WGROOVE_$DYNVMLC(3)+LEAFGAP_$DYNVMLC-WTONGUE_$DYNVMLC(1)<0.0)[
    OUTPUT ICM_$DYNVMLC;
     (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
        ' Tongue in FULL leaf too wide for groove in ISOCENTER leaf. '//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
]

"V. TYPE OF LEAF ENDS - ROUNDED VS FLAT DIVERGENT "
"================================================ "

OUTPUT; (/'Input the type of leaf end desired : ',/,
          '   0 --- Rounded leaf end or ',/
          '   1 --- Focused leaf end  ');
OUTPUT; ('Input your choice : ', $);
MINPUT ($DYNVMLC) ENDTYPE_$DYNVMLC; (I5);
OUTPUT ENDTYPE_$DYNVMLC; (I5/);
;
IF(ENDTYPE_$DYNVMLC=1) [
   OUTPUT; (' Input the z focus of the leaf ends : ',$);
   MINPUT ($DYNVMLC) ZFOCUS_$DYNVMLC(2); (F15.0);
   OUTPUT ZFOCUS_$DYNVMLC(2);(F12.5/);

   IF(ABS(ZFOCUS_$DYNVMLC(2)-ZMIN_$DYNVMLC)<1.E-5) [
      ZFOCUS_$DYNVMLC(2)=ZMIN_$DYNVMLC-1.E-4;
      OUTPUT ICM_$DYNVMLC,ZFOCUS_$DYNVMLC(2);
          (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
           ' ZFOCUS(2) cannot be equal to ZMIN_$DYNVMLC'/
           ' ZFOCUS(2) reset to ',F15.5,' cm for now'//);
      IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
     ]
   ELSEIF(ZFOCUS_$DYNVMLC(2)>ZMIN_$DYNVMLC &
          ZFOCUS_$DYNVMLC(2)<ZMAX_$DYNVMLC)[
        ZFOCUS_$DYNVMLC(2)=ZMAX_$DYNVMLC;
        OUTPUT ICM_$DYNVMLC,ZFOCUS_$DYNVMLC(2);
          (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
          ' ZFOCUS(2) is between ZMIN_$DYNVMLC and ZMAX_$DYNVMLC'/
          ' This will cause leaf ends to overlap'/
          ' ZFOCUS(2) reset to ',F15.5,' cm for now'//);
       IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
     ];
 ]
ELSE  [ "Defaults to rounded ends "

   OUTPUT (ZTHICK_$DYNVMLC/2);
          (' Input the radius >= ', F12.5, ' cm ', /
          ' of the leaf ends : ',$);

   MINPUT ($DYNVMLC) LEAFRADIUS_$DYNVMLC; (F15.0);
   OUTPUT LEAFRADIUS_$DYNVMLC; (F15.0/);

   IF((LEAFRADIUS_$DYNVMLC < (0.5*ZTHICK_$DYNVMLC)) |
      (LEAFRADIUS_$DYNVMLC < 0.0)) [

" This is done to ensure that the leaf end is rounded all the"
" way from zmin_$dynvmlc to zmax_$dynvmlc. "
" Otherwise the curvature will fall short."

     LEAFRADIUS_$DYNVMLC=0.5*ZTHICK_$DYNVMLC;
     OUTPUT ICM_$DYNVMLC,LEAFRADIUS_$DYNVMLC;
      (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
      ' LEAFRADIUS_$DYNVMLC is less than minimum acceptable'/
      ' RESET TO ', F15.5, ' cm for now'//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
    ]
    IF(HOLEPOS_FULL_$DYNVMLC>=LEAFRADIUS_$DYNVMLC) [
      HOLEPOS_FULL_$DYNVMLC=LEAFRADIUS_$DYNVMLC-0.1;
      OUTPUT ICM_$DYNVMLC,LEAFRADIUS_$DYNVMLC;
      (//'***ERROR IN CM ',I4,' ($DYNVMLC)'/
      ' Hole position in FULL leaves is greater than leaf'/
      ' radius. Reset to ',F12.5,' cm for now'//);
      IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
    ]
    IF(HOLEPOS_ISO_$DYNVMLC>=LEAFRADIUS_$DYNVMLC) [
      HOLEPOS_ISO_$DYNVMLC=LEAFRADIUS_$DYNVMLC-0.1;
      OUTPUT ICM_$DYNVMLC,LEAFRADIUS_$DYNVMLC;
      (//'***ERROR IN CM ',I4,' ($DYNVMLC)'/
      ' Hole position in ISOCENTER leaves is greater than leaf'/
      ' radius. Reset to ',F12.5,' cm for now'//);
      IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
    ]
    IF(HOLEPOS_TAR_$DYNVMLC>=LEAFRADIUS_$DYNVMLC) [
      HOLEPOS_TAR_$DYNVMLC=LEAFRADIUS_$DYNVMLC-0.1;
      OUTPUT ICM_$DYNVMLC,LEAFRADIUS_$DYNVMLC;
      (//'***ERROR IN CM ',I4,' ($DYNVMLC)'/
      ' Hole position in TARGET leaves is greater than leaf'/
      ' radius. Reset to ',F12.5,' cm for now'//);
      IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
    ]
 ]; " End of checking the leaf end ;


"VI. FOCUS FOR DIVERGENT LEAF SIDES "
"==================================== "

OUTPUT; (' Input the Z focus point of the leaf sides: ',$);
MINPUT ($DYNVMLC) ZFOCUS_$DYNVMLC(1); (F15.0);
OUTPUT ZFOCUS_$DYNVMLC(1); (F12.5/);
IF(ABS(ZFOCUS_$DYNVMLC(1)-ZMIN_$DYNVMLC)<1.E-5) [
   ZFOCUS_$DYNVMLC(1)=ZMIN_$DYNVMLC-1.E-4;
   OUTPUT ICM_$DYNVMLC,ZFOCUS_$DYNVMLC(1);
      (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
       ' ZFOCUS(1) cannot be equal to ZMIN_$DYNVMLC'/
       ' ZFOCUS(1) reset to ',F15.5,' cm for now'//);
   IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ]
ELSEIF(ZFOCUS_$DYNVMLC(1)>ZMIN_$DYNVMLC & ZFOCUS_$DYNVMLC(1)<ZMAX_$DYNVMLC) [
   ZFOCUS_$DYNVMLC(1)=ZMAX_$DYNVMLC;
   OUTPUT ICM_$DYNVMLC,ZFOCUS_$DYNVMLC(1);
      (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
       ' ZFOCUS(1) is between ZMIN_$DYNVMLC and ZMAX_$DYNVMLC'/
       ' This will cause leaf sides to overlap'/
       ' ZFOCUS(1) reset to ',F15.5,' cm for now'//);
   IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ];

"VII. CALCULATE THE Z-AXIS COORDINATES OF DIFFERENT SUB-REGIONS "
"============================================================= "
"this is done on a leaf-by-leaf basis"
I=0;
DO J=1,NGROUP_$DYNVMLC[
  DO K=1,NUM_LEAF_$DYNVMLC(J)[
    I=I+1;
    ZREG_$DYNVMLC(I,1)=ZMIN_$DYNVMLC;
    IF(LEAFTYPE_$DYNVMLC(I)=1)["full leaf"
      ZREG_$DYNVMLC(I,2)=ZTIP_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,3)=ZLEAF_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,4)=ZTONGUE_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,5)=ZGROOVE_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,6)=ZHOLETOP_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,7)=ZHOLEBOT_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,8)=ZRAILTOP_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,9)=ZRAILBOT_$DYNVMLC(1);
      ZREG_$DYNVMLC(I,10)=ZREG_$DYNVMLC(I,1)+ZTHICK_$DYNVMLC;
      HOLEPOS_$DYNVMLC(I)=HOLEPOS_FULL_$DYNVMLC;"do this here"
    ]
    ELSEIF(LEAFTYPE_$DYNVMLC(I)=2)["target leaf"
      ZREG_$DYNVMLC(I,2)=ZRAILTOP_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,3)=ZRAILBOT_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,4)=ZHOLETOP_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,5)=ZHOLEBOT_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,6)=ZTONGUE_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,7)=ZGROOVE_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,8)=ZLEAF_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,9)=ZTIP_$DYNVMLC(2);
      ZREG_$DYNVMLC(I,10)=ZREG_$DYNVMLC(I,1)+ZTHICK_$DYNVMLC;
      HOLEPOS_$DYNVMLC(I)=HOLEPOS_TAR_$DYNVMLC;
    ]
    ELSE["isocenter"
      ZREG_$DYNVMLC(I,2)=ZTIP_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,3)=ZLEAF_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,4)=ZTONGUE_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,5)=ZGROOVE_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,6)=ZHOLETOP_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,7)=ZHOLEBOT_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,8)=ZRAILTOP_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,9)=ZRAILBOT_$DYNVMLC(3);
      ZREG_$DYNVMLC(I,10)=ZREG_$DYNVMLC(I,1)+ZTHICK_$DYNVMLC;
      HOLEPOS_$DYNVMLC(I)=HOLEPOS_ISO_$DYNVMLC;
    ]
  ]
];

"VIII. CALC PARAMETERS IN DIRECTION PERPENDICULAR TO LEAF ORIENTATION
"==================================================================

TEMP1 = (ZMIN_$DYNVMLC-ZFOCUS_$DYNVMLC(1));

I=0;
IF(TOT_LEAF_$DYNVMLC>0) [
  DO L = 1,NGROUP_$DYNVMLC[
   DO K = 1,NUM_LEAF_$DYNVMLC(L) [
     I=I+1;
     IF(I=1)[
       YREG_$DYNVMLC(I,1)=START_$DYNVMLC;
     ]
     ELSEIF(LEAFTYPE_$DYNVMLC(I)=1)[
       YREG_$DYNVMLC(I,1)=YREG_$DYNVMLC(I-1,7)+LEAFGAP_$DYNVMLC-
                          WTONGUE_$DYNVMLC(1);
     ]
     ELSEIF(LEAFTYPE_$DYNVMLC(I)=2)["target leaf"
         YREG_$DYNVMLC(I,1)=YREG_$DYNVMLC(I-1,7)+LEAFGAP_$DYNVMLC-
                          WTONGUE_$DYNVMLC(2);
     ]
     ELSE["isocenter leaf"
         YREG_$DYNVMLC(I,1)=YREG_$DYNVMLC(I-1,7)+LEAFGAP_$DYNVMLC-
                          WTONGUE_$DYNVMLC(3);
     ]
     "we have now defined YREG_$DYNVMLC(I,1)"
     IF(LEAFTYPE_$DYNVMLC(I)=1)["full leaf"
       YREG_$DYNVMLC(I,2)=YREG_$DYNVMLC(I,1)+WTONGUE_$DYNVMLC(1);
       YREG_$DYNVMLC(I,3)=YREG_$DYNVMLC(I,1)+WTIP_$DYNVMLC(1);
       YREG_$DYNVMLC(I,4)=YREG_$DYNVMLC(I,2)+WRAILTOP_$DYNVMLC(1)-
                          WRAILBOT_$DYNVMLC(1);
       YREG_$DYNVMLC(I,5)=YREG_$DYNVMLC(I,2)+WRAILTOP_$DYNVMLC(1);
       YREG_$DYNVMLC(I,6)=YREG_$DYNVMLC(I,2)+LEAFWIDTH_$DYNVMLC(1)-
                          WGROOVE_$DYNVMLC(1);
       YREG_$DYNVMLC(I,7)=YREG_$DYNVMLC(I,2)+LEAFWIDTH_$DYNVMLC(1);
     ]
     ELSEIF(LEAFTYPE_$DYNVMLC(I)=2)["target leaf"
       YREG_$DYNVMLC(I,2)=YREG_$DYNVMLC(I,1)+WTONGUE_$DYNVMLC(2);
       YREG_$DYNVMLC(I,4)=YREG_$DYNVMLC(I,2)+LEAFWIDTH_$DYNVMLC(2)-
                          WRAILBOT_$DYNVMLC(2);
       YREG_$DYNVMLC(I,3)=YREG_$DYNVMLC(I,2)+LEAFWIDTH_$DYNVMLC(2)-
                           WGROOVE_$DYNVMLC(2)-WTIP_$DYNVMLC(2);
       YREG_$DYNVMLC(I,5)=YREG_$DYNVMLC(I,2)+LEAFWIDTH_$DYNVMLC(2)-
                          WGROOVE_$DYNVMLC(2);
       YREG_$DYNVMLC(I,6)=YREG_$DYNVMLC(I,4)+WRAILTOP_$DYNVMLC(2);
       YREG_$DYNVMLC(I,7)=YREG_$DYNVMLC(I,2)+LEAFWIDTH_$DYNVMLC(2);
     ]
     ELSE["isocenter leaf"
       YREG_$DYNVMLC(I,2)=YREG_$DYNVMLC(I,1)+WRAILTOP_$DYNVMLC(3)-
                          WRAILBOT_$DYNVMLC(3);
       YREG_$DYNVMLC(I,3)=YREG_$DYNVMLC(I,1)+WTONGUE_$DYNVMLC(3);
       YREG_$DYNVMLC(I,4)=YREG_$DYNVMLC(I,3)+WTIP_$DYNVMLC(3);
       YREG_$DYNVMLC(I,5)=YREG_$DYNVMLC(I,1)+WRAILTOP_$DYNVMLC(3);
       YREG_$DYNVMLC(I,6)=YREG_$DYNVMLC(I,3)+LEAFWIDTH_$DYNVMLC(3)-
                          WGROOVE_$DYNVMLC(3);
       YREG_$DYNVMLC(I,7)=YREG_$DYNVMLC(I,3)+LEAFWIDTH_$DYNVMLC(3);
     ]
     DO J = 1, 7 [
    SURPARA1_$DYNVMLC(I,J)=YREG_$DYNVMLC(I,J)/TEMP1;
            ];                "End of J Loop"
  ]; "End of K Loop"
 ]; "End of L loop"
];   "End of IF statement"

" Check to see if the DYNVMLC will go outside the CM boundary "

TEMP1 = ABS((ZMAX_$DYNVMLC-ZFOCUS_$DYNVMLC(1))*SURPARA1_$DYNVMLC(1,2));
TEMP2 = ABS((ZMAX_$DYNVMLC-ZFOCUS_$DYNVMLC(1))*
            SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,6));

IF(TEMP1>RMAX_CM(ICM_$DYNVMLC)|TEMP2>RMAX_CM(ICM_$DYNVMLC)) [
   OUTPUT; (/' The DYNVMLC is not contained within the CM boundaries', /
        ' Please check ZFOCUS_$DYNVMLC(1) and RMAX_CM(ICM_$DYNVMLC)'/);
   STOP;
  ];


"IX. INPUT THE COORDINATES NEG_$DYNVMLC AND POS_$DYNVMLC "
"===================================================== "
mlc_unit=70;
DO I=1, TOT_LEAF_$DYNVMLC
[
    LEAFB_$DYNVMLC(I)=0.0;LEAFA_$DYNVMLC(I)=0.0;
]
IF(MODE_$DYNVMLC=1|MODE_$DYNVMLC=2)["dynamic or step-and-shoot leaf inputs"
  OUTPUT;(/' Input full name of file containing leaf opening data:'/);
  READ(i_input,'(A256)')mlc_file;
  OUTPUT mlc_file;(A/);
  call replace_env(mlc_file);
  mlc_unit=egs_get_unit(mlc_unit);
  IF(mlc_unit<1)[
    $egs_fatal(*,
         'MLC leaf opening file: failed to get a free Fortran I/O unit');
  ]
  open(mlc_unit,file=mlc_file,status='old',err=:no-mlc-data-file:);
  read(mlc_unit,'(A80)') MLC_TITLE;
  read(mlc_unit,'(I10)') NFIELDS_$DYNVMLC;
  OUTPUT NFIELDS_$DYNVMLC; (I10);
  DO I=1,NFIELDS_$DYNVMLC[
  "read in non-default leaf positions for each field"
     read(mlc_unit,'(F15.0)')INDEX_$DYNVMLC(I);
     J=1;"counter for total no. of leaves input so far"
     LOOP[
       read(mlc_unit,'(2F15.0,I5)')NEG_$DYNVMLC, POS_$DYNVMLC, NUM_$DYNVMLC;
       IF(NUM_$DYNVMLC<=0) NUM_$DYNVMLC=1;
       DO K=J,J+NUM_$DYNVMLC-1[
         IF(K>TOT_LEAF_$DYNVMLC) EXIT;
         LEAFNEG_$DYNVMLC(K+(I-1)*TOT_LEAF_$DYNVMLC)=NEG_$DYNVMLC;
         LEAFPOS_$DYNVMLC(K+(I-1)*TOT_LEAF_$DYNVMLC)=POS_$DYNVMLC;
       ]
       J=K;
     ]WHILE(J<=TOT_LEAF_$DYNVMLC);
  ]
  CLOSE(UNIT=mlc_unit);

  OUTPUT;('******MLC SEQUENCE FILE READ******');
  IF (MODE_$DYNVMLC=1) [
      OUTPUT; ('**dynamic delivery**');
  ]
  ELSEIF (MODE_$DYNVMLC=2) [
      OUTPUT; ('**step and shoot delivery**');
  ]
]
ELSE[
OUTPUT; (' Input for MLC A and B leaf tips '/);
IF(ORIENT_$DYNVMLC=1)[
    IF(ENDTYPE_$DYNVMLC=1)[
      OUTPUT;(' Input min. X, max. X of top of opening in leaves,');
    ]
    ELSE[
      OUTPUT;(' Input min. X, max. X of rounded leaf ends,');
    ]
]
ELSE[
    IF(ENDTYPE_$DYNVMLC=1)[
      OUTPUT;(' Input min. Y, max. Y of top of opening in leaves,');
    ]
    ELSE[
      OUTPUT;(' Input min. Y, max. Y of rounded leaf ends,');
    ]
]
OUTPUT;(' # of adjacent leaves with these coordinates:');
I=1;
LOOP[
  OUTPUT I;('   For leaf',I4,' :',$)
  MINPUT ($DYNVMLC) NEG_$DYNVMLC, POS_$DYNVMLC, NUM_$DYNVMLC; (2F15.0,I5);
  IF(NUM_$DYNVMLC<=0) NUM_$DYNVMLC=1;
  OUTPUT NEG_$DYNVMLC, POS_$DYNVMLC, NUM_$DYNVMLC; (2F12.5,I5);
  IF(NEG_$DYNVMLC > POS_$DYNVMLC)[
     NEG_$DYNVMLC = POS_$DYNVMLC;
     OUTPUT ICM_$DYNVMLC,I,I+NUM_$DYNVMLC-1,NEG_$DYNVMLC;
      (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
   ' Min. and max. opening coordinates in leaves ',I4,' - ',I4,' overlap'/
   ' Both coordinates set to ',F15.5,' cm for now'//);
     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
                               ]

  IF(ABS(NEG_$DYNVMLC)>RMAX_CM(ICM_$DYNVMLC)|
     ABS(POS_$DYNVMLC)>RMAX_CM(ICM_$DYNVMLC)) [

     OUTPUT ICM_$DYNVMLC,I,I+NUM_$DYNVMLC-1;
      (//' ***ERROR IN CM ',I4,' ($DYNVMLC)'/
      ' Tip of leaves ',I4,' - ',I4,' are outside CM '//);

     IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
                                            ];
  DO J=I,I+NUM_$DYNVMLC-1["define opening for all leaves in group"
    IF(J>TOT_LEAF_$DYNVMLC) EXIT;
    LEAFB_$DYNVMLC(J)=NEG_$DYNVMLC;
    LEAFA_$DYNVMLC(J)=POS_$DYNVMLC;
  ]
  I=J;
]WHILE(I<=TOT_LEAF_$DYNVMLC);"End of Coordinate inputs for || direction "

IF(ENDTYPE_$DYNVMLC=1)[
DO I=1, TOT_LEAF_$DYNVMLC [

SURPARA2_B_$DYNVMLC(I)=LEAFB_$DYNVMLC(I)/(ZMIN_$DYNVMLC-ZFOCUS_$DYNVMLC(2) );

SURPARA2_A_$DYNVMLC(I)=LEAFA_$DYNVMLC(I)/(ZMIN_$DYNVMLC-ZFOCUS_$DYNVMLC(2) );

                         ];
                    ];
]


"X. ESTABLISH TOP OF FIRST CM
"==============================

ZFRONT_$DYNVMLC = Z_min_CM(ICM_$DYNVMLC);

"
"XI. ESTABLISH START OF NEXT CM
"================================

Z_min_CM(ICM_$DYNVMLC+1) = ZMAX_$DYNVMLC;

"
"XII. GET ECUT, PCUT, DOSE SCORING ZONE AND MATERIAL IN EACH REGION
"==================================================================

IRA = IRSTART_$DYNVMLC-1;
DO IR_$DYNVMLC = 1,N_$DYNVMLC ["loop through regions to get information"
   IRA = IRA+1;
   IF(IR_$DYNVMLC=1) [
       OUTPUT IR_$DYNVMLC;
        (/' Region',I4,' (MLC opening):'/
          ' ECUT, PCUT (MeV), DOSE ZONE (0=NO DOSE SCORED), IREGION_TO_BIT'/
          ' :',$);
   ]
   ELSEIF(IR_$DYNVMLC=2) [
       OUTPUT IR_$DYNVMLC;
        (/' Region',I4,' (MLC leaves):'/
' ECUT, PCUT (MeV), DOSE ZONE (0=NO DOSE SCORED), IREGION_TO_BIT, IGNOREGAPS'/
         ' :',$);
   ]
   ELSE[
       OUTPUT IR_$DYNVMLC;
        (/' Region',I4,' (driving screw holes):'/
         ' ECUT, PCUT (MeV), DOSE ZONE (0=NO DOSE SCORED), IREGION_TO_BIT'/
         ' :',$);
   ]
   IF(IR_$DYNVMLC~=2)[
      MINPUT ($DYNVMLC) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.0,2I5);
      OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
             (2F15.5,2I5);
   ]
   ELSE[
      MINPUT ($DYNVMLC) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),
                        IREGION_TO_BIT(IRA),IGNOREGAPS_$DYNVMLC; (2F15.0,3I5);
      OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
             IGNOREGAPS_$DYNVMLC; (2F15.5,3I5);
   ]
   IF(ECUT(IRA) < ECUTIN) [ECUT(IRA)=ECUTIN;];
   IF(PCUT(IRA) < PCUTIN) [PCUT(IRA)=PCUTIN;];
   OUTPUT IR_$DYNVMLC; (' material of region ',I3,' ',$);
     $MED_INPUT($DYNVMLC); " inputs character array MED_IN from unit 5, loops"
  "through array MEDIA(24,I) to check if medium was previously input."
  "If so, sets MED_INDEX to index of previous medium.  If not,"
  "increments NMED and sets MED_INDEX to NMED."
   MED(IRA) = MED_INDEX; " medium of the planar slab"
 ] "end of loop over IR_$DYNVMLC"
;

IF(IGNOREGAPS_$DYNVMLC=1 & IREJCT_GLOBAL>0)[
   IF(ORIENT_$DYNVMLC=1)["leaves parallel to X"
       OUTPUT;(/' *******Range rejection in $DYNVMLC will ignore all'/
               ' air gaps if the particle is in the leaves and has'/
               ' X < min. X of leaf openings (not including leaf ends)'/
               ' or X > max. X of leaf openings (not including ends)'/);
   ]
   ELSE["leaves parallel to Y"
       OUTPUT;(/' *******Range rejection in $DYNVMLC will ignore all'/
               ' air gaps if the particle is in the leaves and has'/
               ' Y < min. Y of leaf openings (not including leaf ends)'/
               ' or Y > max. Y of leaf openings (not including ends)'/);
   ]
   IF(MODE_$DYNVMLC=0)[
   DO I=1,TOT_LEAF_$DYNVMLC["loop through leaves to find index of those with"
                           "max. +ve opening and min. -ve opening"
       IF(I=1)[
           MIN_INDEX=I;
           MAX_INDEX=I;
       ]
       ELSE[
           IF(LEAFB_$DYNVMLC(I)<LEAFB_$DYNVMLC(I-1))MIN_INDEX=I;
           IF(LEAFA_$DYNVMLC(I)>LEAFA_$DYNVMLC(I-1))MAX_INDEX=I;
       ]
   ]
   IF(ENDTYPE_$DYNVMLC=1)["straight, focused ends"
       MIN_PLANE_$DYNVMLC=MIN(LEAFB_$DYNVMLC(MIN_INDEX),
                        SURPARA2_B_$DYNVMLC(MIN_INDEX)*
                       (ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC-ZFOCUS_$DYNVMLC(2)));
       MAX_PLANE_$DYNVMLC=MAX(LEAFB_$DYNVMLC(MAX_INDEX),
                         SURPARA2_B_$DYNVMLC(MAX_INDEX)*
                         (ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC-ZFOCUS_$DYNVMLC(2)));
   ]
   ELSE["rounded leaf ends"
       MIN_PLANE_$DYNVMLC=LEAFB_$DYNVMLC(MIN_INDEX)-LEAFRADIUS_$DYNVMLC+
                         SQRT(LEAFRADIUS_$DYNVMLC**2-(ZTHICK_$DYNVMLC/2.)**2);
       MAX_PLANE_$DYNVMLC=LEAFA_$DYNVMLC(MAX_INDEX)+LEAFRADIUS_$DYNVMLC-
                         SQRT(LEAFRADIUS_$DYNVMLC**2-(ZTHICK_$DYNVMLC/2.)**2);
   ]
   ]
]
ELSE["set to default"
   IGNOREGAPS_$DYNVMLC=0;
]
"
"XIII. SET UP AIR GAP TO PREVIOUS CM IF PRESENT
"  =========================================
"
"  The air gap has the highest region number in the CM, even though its
"  the top of the component module.  This is to allow the assignment of
"  region numbers on input of the parameters of each local region
"  (mainly to assign the medium number of the region).
"  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_$mlc=1) then the gap thickness
"Z_gap_THICK(ICM_$dynvmlc) = 0, which is used as a flag for no air gap

Z_gap_THICK(ICM_$DYNVMLC) = ZMIN_$DYNVMLC - Z_min_CM(ICM_$DYNVMLC);
IF (Z_gap_THICK(ICM_$DYNVMLC) < = 0.0) [
   Z_gap_THICK(ICM_$DYNVMLC) = 0.;
   N_GAP_$DYNVMLC = 0; "no air gap for this CM"
  ]
ELSE [
   N_GAP_$DYNVMLC = 1; "this CM has an air gap"
   IRA = IRSTART_$DYNVMLC+N_$DYNVMLC; "absolute region number of air gap"
   MED(IRA) = AIR_INDEX; "medium is air"
 ];
"
"XIV. SET UP REGION NUMBERS
"===========================
"
"  This CM has N_$DYNVMLC+N_GAP_$mlc regions
"
;
"Index last region
IREND_$DYNVMLC = (IRSTART_$DYNVMLC -1) + N_$DYNVMLC+N_GAP_$DYNVMLC;
NREG = NREG+N_$DYNVMLC+N_GAP_$DYNVMLC;
                            "Total no of regions in full geometry up
                            "to and including this CM
IF (NREG <= $MXREG) [
   IR_start_CM(ICM_$DYNVMLC+1) = IREND_$DYNVMLC+1;
  ]    "have not exceeded maximum region number
       "Index of first region in next CM:"
ELSE [
   OUTPUT ICM_$DYNVMLC,NREG,$MXREG;
   (//' ***ERROR IN CM ',I4,' ($DYNVMLC):'/
   T2,I4,' regions requested, only ',I4,' available'//);
   IERR_GEOM(ICM_$DYNVMLC)=IERR_GEOM(ICM_$DYNVMLC)+1;
 ];

"
"XV.  ESTABLISH CM BOUNDARY
"============================
"
RMAX_CM_FLAG(ICM_$DYNVMLC) = 2; "put a square boundary about CM
"
"XVI. ESTABLISH DOSE SCORING ZONES AND BIT SETTING FOR EACH REGION
"===================================================================
"
IRA = IRSTART_$DYNVMLC-1; "absolute region number"
DO IR_$DYNVMLC=1,N_$DYNVMLC ["loop over local region number"
   IRA = IRA+1;
   "dose-scoring zones"
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones"
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maximum"
   "charged particle range rejection parameters"
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are"
                            "considered for range rejection"
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region GXD"
   E_min_out(ICM_$DYNVMLC)=ECUT(IRA); "Minimum energy on exit from CM"
  ] "end of loop over IR_$DYNVMLC

"XVII. ESTABLISH SUB-REGION IR VALUES
"===================================
DO L=1,TOT_LEAF_$DYNVMLC [
      DO I=1,5 [ "NX"
           DO J =1,6 [ "NY"
                DO K = 1,9 [ "NZ"
                  SUBINDEX_$DYNVMLC(L,I,J,K)=1; "set all regions to air"
                  ];
            ];
         ];
      ];
;
"Now define regions containing leaf medium"
DO L=1,TOT_LEAF_$DYNVMLC[
  DO I =2,5 [
   IF(LEAFTYPE_$DYNVMLC(L)=2) ["This is a target leaf"
      SUBINDEX_$DYNVMLC(L,I,1,1)=2;
      SUBINDEX_$DYNVMLC(L,I,1,2)=2;
      SUBINDEX_$DYNVMLC(L,I,1,3)=2;
      SUBINDEX_$DYNVMLC(L,I,1,5)=2;
      SUBINDEX_$DYNVMLC(L,I,2,1)=2;
      SUBINDEX_$DYNVMLC(L,I,2,2)=2;
      SUBINDEX_$DYNVMLC(L,I,2,3)=2;
      SUBINDEX_$DYNVMLC(L,I,2,5)=2;
      SUBINDEX_$DYNVMLC(L,I,2,6)=2;
      SUBINDEX_$DYNVMLC(L,I,2,7)=2;
      SUBINDEX_$DYNVMLC(L,I,3,1)=2;
      SUBINDEX_$DYNVMLC(L,I,3,2)=2;
      SUBINDEX_$DYNVMLC(L,I,3,3)=2;
      SUBINDEX_$DYNVMLC(L,I,3,5)=2;
      SUBINDEX_$DYNVMLC(L,I,3,6)=2;
      SUBINDEX_$DYNVMLC(L,I,3,7)=2;
      SUBINDEX_$DYNVMLC(L,I,3,8)=2;
      SUBINDEX_$DYNVMLC(L,I,4,1)=2;
      SUBINDEX_$DYNVMLC(L,I,4,3)=2;
      SUBINDEX_$DYNVMLC(L,I,4,5)=2;
      SUBINDEX_$DYNVMLC(L,I,4,6)=2;
      SUBINDEX_$DYNVMLC(L,I,4,7)=2;
      SUBINDEX_$DYNVMLC(L,I,4,8)=2;
      SUBINDEX_$DYNVMLC(L,I,5,1)=2;
      SUBINDEX_$DYNVMLC(L,I,5,3)=2;
      SUBINDEX_$DYNVMLC(L,I,5,5)=2;
      SUBINDEX_$DYNVMLC(L,I,5,6)=2;
      SUBINDEX_$DYNVMLC(L,I,6,3)=2;
      SUBINDEX_$DYNVMLC(L,I,6,5)=2;
      SUBINDEX_$DYNVMLC(L,I,6,6)=2;
    ]
   ELSEIF(LEAFTYPE_$DYNVMLC(L)=1) ["full leaf"
      SUBINDEX_$DYNVMLC(L,I,1,2)=2;
      SUBINDEX_$DYNVMLC(L,I,1,3)=2;
      SUBINDEX_$DYNVMLC(L,I,2,2)=2;
      SUBINDEX_$DYNVMLC(L,I,2,3)=2;
      SUBINDEX_$DYNVMLC(L,I,2,4)=2;
      SUBINDEX_$DYNVMLC(L,I,2,5)=2;
      SUBINDEX_$DYNVMLC(L,I,2,6)=2;
      SUBINDEX_$DYNVMLC(L,I,2,7)=2;
      SUBINDEX_$DYNVMLC(L,I,3,3)=2;
      SUBINDEX_$DYNVMLC(L,I,3,4)=2;
      SUBINDEX_$DYNVMLC(L,I,3,5)=2;
      SUBINDEX_$DYNVMLC(L,I,3,6)=2;
      SUBINDEX_$DYNVMLC(L,I,3,7)=2;
      SUBINDEX_$DYNVMLC(L,I,4,3)=2;
      SUBINDEX_$DYNVMLC(L,I,4,4)=2;
      SUBINDEX_$DYNVMLC(L,I,4,5)=2;
      SUBINDEX_$DYNVMLC(L,I,4,6)=2;
      SUBINDEX_$DYNVMLC(L,I,4,7)=2;
      SUBINDEX_$DYNVMLC(L,I,4,9)=2;
      SUBINDEX_$DYNVMLC(L,I,5,3)=2;
      SUBINDEX_$DYNVMLC(L,I,5,4)=2;
      SUBINDEX_$DYNVMLC(L,I,5,5)=2;
      SUBINDEX_$DYNVMLC(L,I,5,6)=2;
      SUBINDEX_$DYNVMLC(L,I,5,7)=2;
      SUBINDEX_$DYNVMLC(L,I,5,8)=2;
      SUBINDEX_$DYNVMLC(L,I,5,9)=2;
      SUBINDEX_$DYNVMLC(L,I,6,5)=2;
      SUBINDEX_$DYNVMLC(L,I,6,6)=2;
      SUBINDEX_$DYNVMLC(L,I,6,7)=2;
      SUBINDEX_$DYNVMLC(L,I,6,8)=2;
      SUBINDEX_$DYNVMLC(L,I,6,9)=2;
    ]
   ELSE[ "This is an isocenter leaf"
      SUBINDEX_$DYNVMLC(L,I,1,4)=2;
      SUBINDEX_$DYNVMLC(L,I,1,5)=2;
      SUBINDEX_$DYNVMLC(L,I,1,7)=2;
      SUBINDEX_$DYNVMLC(L,I,2,4)=2;
      SUBINDEX_$DYNVMLC(L,I,2,5)=2;
      SUBINDEX_$DYNVMLC(L,I,2,7)=2;
      SUBINDEX_$DYNVMLC(L,I,2,9)=2;
      SUBINDEX_$DYNVMLC(L,I,3,2)=2;
      SUBINDEX_$DYNVMLC(L,I,3,3)=2;
      SUBINDEX_$DYNVMLC(L,I,3,4)=2;
      SUBINDEX_$DYNVMLC(L,I,3,5)=2;
      SUBINDEX_$DYNVMLC(L,I,3,7)=2;
      SUBINDEX_$DYNVMLC(L,I,3,9)=2;
      SUBINDEX_$DYNVMLC(L,I,4,3)=2;
      SUBINDEX_$DYNVMLC(L,I,4,4)=2;
      SUBINDEX_$DYNVMLC(L,I,4,5)=2;
      SUBINDEX_$DYNVMLC(L,I,4,7)=2;
      SUBINDEX_$DYNVMLC(L,I,4,9)=2;
      SUBINDEX_$DYNVMLC(L,I,5,3)=2;
      SUBINDEX_$DYNVMLC(L,I,5,4)=2;
      SUBINDEX_$DYNVMLC(L,I,5,5)=2;
      SUBINDEX_$DYNVMLC(L,I,5,7)=2;
      SUBINDEX_$DYNVMLC(L,I,5,8)=2;
      SUBINDEX_$DYNVMLC(L,I,5,9)=2;
      SUBINDEX_$DYNVMLC(L,I,6,5)=2;
      SUBINDEX_$DYNVMLC(L,I,6,7)=2;
      SUBINDEX_$DYNVMLC(L,I,6,8)=2;
      SUBINDEX_$DYNVMLC(L,I,6,9)=2;
    ];
  ];
"Now set driving screw hole medium"
   DO J=1,6 [
    IF(LEAFTYPE_$DYNVMLC(L)=2) ["target leaf"
      SUBINDEX_$DYNVMLC(L,2,J,4)=3;
      SUBINDEX_$DYNVMLC(L,5,J,4)=3;
     ]
    ELSE ["full or isocenter leaf"
      SUBINDEX_$DYNVMLC(L,2,J,6)=3;
      SUBINDEX_$DYNVMLC(L,5,J,6)=3;
     ]
   ];
   IF(LEAFTYPE_$DYNVMLC(L)=1) ["full leaf"
     SUBINDEX_$DYNVMLC(L,2,1,6)=1;
     SUBINDEX_$DYNVMLC(L,5,1,6)=1;
   ];
 ];
  "   =======================
"
RETURN;

"XVIII. ERROR MESSAGES
"==================
"
:EOF_$DYNVMLC:
;OUTPUT ICM;
  (//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_$DYNVMLC:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

:no-mlc-data-file:
;OUTPUT;(//' *** ERROR: MLC leaf data file could not be opened');
STOP;

END;  "End of INPUT_$DYNVMLC"

%E "Start of subroutine ISUMRY_$DYNVMLC"
"***********************************************************************
"
"                          Subroutine ISUMRY_$DYNVMLC
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters
" that require medium information obtained from HATCH call.
"
"***********************************************************************

;SUBROUTINE ISUMRY_$DYNVMLC;

;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_$DYNVMLC,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_$DYNVMLC
"T>**********************************
"T>
INTEGER
   ICOLOUR, "T>colour of CM for EGS_Windows
"   ID,     already defined gf  T>index of dose scoring zone
   IRA,     "T>absolute region number
   I,J,     "T>DO loop index
   ISTART,IEND, "T>indices for outputting info"
   YY1(9),          "T> YY1 and YY2 index subregion along perpendicular..
   YY2(9),          "T> direction to MLC orientation
   YY3(9),          "T> specific for target leaf
   YY4(9),          "T>
   YY5(9),          "T> same for full leaf
   YY6(9),          "T>
   YY7(9),          "T> same for isocenter leaf
   YY8(9);         "T>

$REAL  VOL_$DYNVMLC(3), "T> region volumes
       Zo,             "T> THe z-coordinate of the leaf center
       XoP,XoN,        "T> The center of the rounded leaves ends along leaf
       M1,M2,          "T> Variables related to partial(rounded) leaf volume
       THETASUB,       "T> Angle at leaf end subtended by Z boundaries of reg.
       TOTALVOL,       "T> Total volume of MLC CM
       ZSQUARE,ZCUBE,AREA,    "T> Variables related to partial leaf volumes
       TEMP,TEMP1,TEMP2,TEMP3,"T> Variables related to partial leaf volumes
       HOLD;            "T> to hold a TEMP value

"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the
"region density is set if it was allowed to default in INPUT_$mlc.
"This volume calculation is approximate, but close enough
"

TOTALVOL = (ZMAX_$DYNVMLC-ZMIN_$DYNVMLC)*4*RMAX_CM(ICM_$DYNVMLC)**2;
VOL_$DYNVMLC(1) = 0.;
VOL_$DYNVMLC(2) = 0.;
VOL_$DYNVMLC(3) = 0.;

Zo = ZMIN_$DYNVMLC + (ZTHICK_$DYNVMLC/2);

DATA ( YY3(I), I=1,9) /1,1,1,1,1,2,2,4,7/; "target leaf"
DATA ( YY4(I), I=1,9) /6,3,7,7,7,7,5,5,7/;
DATA ( YY5(I), I=1,9) /1,1,1,2,2,2,2,5,4/; "full leaf"
DATA ( YY6(I), I=1,9) /1,3,6,6,7,7,7,7,7/;
DATA ( YY7(I), I=1,9) /1,3,3,1,1,1,1,5,2/; "isocenter leaf"
DATA ( YY8(I), I=1,9) /1,4,6,6,7,7,7,7,7/;

DO J = 1, TOT_LEAF_$DYNVMLC [
  IF(LEAFTYPE_$DYNVMLC(J)=2) [
    DO I=1,9[
      YY1(I)=YY3(I);
      YY2(I)=YY4(I);
    ]
   ]
  ELSEIF(LEAFTYPE_$DYNVMLC(J)=1) [
    DO I=1,9[
      YY1(I)=YY5(I);
      YY2(I)=YY6(I);
    ]
   ]
  ELSE [
    DO I=1,9[
      YY1(I)=YY7(I);
      YY2(I)=YY8(I);
    ]
   ]
  DO I = 2,10 [ "9 subregions in z-direction"
      ZSQUARE=(ZREG_$DYNVMLC(J,I)**2)-(ZREG_$DYNVMLC(J,I-1)**2) -
              2*ZREG_$DYNVMLC(J,I)*ZFOCUS_$DYNVMLC(1) +
              2*ZREG_$DYNVMLC(J,I-1)*ZFOCUS_$DYNVMLC(1);
      AREA=SURPARA1_$DYNVMLC(J,YY2(I-1))/2*ZSQUARE -
               SURPARA1_$DYNVMLC(J,YY1(I-1))/2*ZSQUARE;
      IF(ENDTYPE_$DYNVMLC=0) [ "Rounded leaf end"
        XoN=LEAFB_$DYNVMLC(J)-LEAFRADIUS_$DYNVMLC;
        XoP=LEAFA_$DYNVMLC(J)+LEAFRADIUS_$DYNVMLC;
        TEMP1=SQRT(LEAFRADIUS_$DYNVMLC**2-(ZREG_$DYNVMLC(J,I-1)-Zo)**2);
        TEMP2=SQRT(LEAFRADIUS_$DYNVMLC**2-(ZREG_$DYNVMLC(J,I)-Zo)**2);
        M1=ASIN(TEMP1/LEAFRADIUS_$DYNVMLC);
        M2=ASIN(TEMP2/LEAFRADIUS_$DYNVMLC);
        THETASUB=ABS(M1-M2);
        TEMP=AREA*(2*RMAX_CM(ICM_$DYNVMLC)-(XoP-MIN(TEMP1,TEMP2)-
                      XoN-MIN(TEMP1,TEMP2)));
        TEMP=TEMP+((ZREG_$DYNVMLC(J,I)-ZREG_$DYNVMLC(J,I-1))*ABS(TEMP1-TEMP2)
             +LEAFRADIUS_$DYNVMLC**2*(THETASUB-SIN(THETASUB)))*
             ((SURPARA1_$DYNVMLC(J,YY2(I-1))-SURPARA1_$DYNVMLC(J,YY1(I-1)))*
             (ZREG_$DYNVMLC(J,I)-ZFOCUS_$DYNVMLC(1)) +
             (SURPARA1_$DYNVMLC(J,YY2(I-1))-SURPARA1_$DYNVMLC(J,YY1(I-1)))*
             (ZREG_$DYNVMLC(J,I-1)-ZFOCUS_$DYNVMLC(1)))/2;
        VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)+TEMP;
       ]
      ELSE[ "Focused divergent leaf end "
        TEMP1=SURPARA2_A_$DYNVMLC(J)*
              (ZREG_$DYNVMLC(J,I-1)-ZFOCUS_$DYNVMLC(2));
        TEMP2=SURPARA2_A_$DYNVMLC(J)*(ZREG_$DYNVMLC(J,I)-ZFOCUS_$DYNVMLC(2));
        "do positive part of leaf first"
        TEMP=AREA*(RMAX_CM(ICM_$DYNVMLC)-MAX(TEMP1,TEMP2));
        TEMP=TEMP+(ABS(TEMP1-TEMP2)*(ZREG_$DYNVMLC(J,I)-
             ZREG_$DYNVMLC(J,I-1)))/2*((SURPARA1_$DYNVMLC(J,YY2(I-1))-
             SURPARA1_$DYNVMLC(J,YY1(I-1)))*(ZREG_$DYNVMLC(J,I)-
             ZFOCUS_$DYNVMLC(1))+(SURPARA1_$DYNVMLC(J,YY2(I-1))-
             SURPARA1_$DYNVMLC(J,YY1(I-1)))*(ZREG_$DYNVMLC(J,I-1)-
             ZFOCUS_$DYNVMLC(1)))/2;
        "now do negative part of leaf"
        TEMP1=SURPARA2_B_$DYNVMLC(J)*
              (ZREG_$DYNVMLC(J,I-1)-ZFOCUS_$DYNVMLC(2));
        TEMP2=SURPARA2_B_$DYNVMLC(J)*(ZREG_$DYNVMLC(J,I)-ZFOCUS_$DYNVMLC(2));
        TEMP=TEMP+AREA*(MIN(TEMP1,TEMP2)+RMAX_CM(ICM_$DYNVMLC));
        TEMP=TEMP+(ABS(TEMP1-TEMP2)*(ZREG_$DYNVMLC(J,I)-
             ZREG_$DYNVMLC(J,I-1)))/2*((SURPARA1_$DYNVMLC(J,YY2(I-1))-
             SURPARA1_$DYNVMLC(J,YY1(I-1)))*(ZREG_$DYNVMLC(J,I)-
             ZFOCUS_$DYNVMLC(1))+(SURPARA1_$DYNVMLC(J,YY2(I-1))-
             SURPARA1_$DYNVMLC(J,YY1(I-1)))*(ZREG_$DYNVMLC(J,I-1)-
             ZFOCUS_$DYNVMLC(1)))/2;
        VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)+TEMP;
       ];

     "IF(I=5 & J=1) HOLD=TEMP;  <-- not using this for now"
    ];  "End of I loop"
    "now subtract volume of driving screw hole"
   IF(LEAFTYPE_$DYNVMLC(J)=2) ["target leaf"
     ZSQUARE=(ZREG_$DYNVMLC(J,5)**2)-(ZREG_$DYNVMLC(J,4)**2) -
              2*ZREG_$DYNVMLC(J,5)*ZFOCUS_$DYNVMLC(1) +
              2*ZREG_$DYNVMLC(J,4)*ZFOCUS_$DYNVMLC(1);
     AREA=SURPARA1_$DYNVMLC(J,7)/2*ZSQUARE -
               SURPARA1_$DYNVMLC(J,1)/2*ZSQUARE;
     "positive portion of leaf"
     TEMP=AREA*(RMAX_CM(ICM_$DYNVMLC)-LEAFA_$DYNVMLC(J)-HOLEPOS_$DYNVMLC(J));
     VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)-TEMP;
     VOL_$DYNVMLC(3)=VOL_$DYNVMLC(3)+TEMP;
     "negative portion of leaf"
     TEMP=AREA*(LEAFB_$DYNVMLC(J)-HOLEPOS_$DYNVMLC(J)+RMAX_CM(ICM_$DYNVMLC));
     VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)-TEMP;
     VOL_$DYNVMLC(3)=VOL_$DYNVMLC(3)+TEMP;
    ]
  IF(LEAFTYPE_$DYNVMLC(J)=1) ["full leaf"
     ZSQUARE=(ZREG_$DYNVMLC(J,7)**2)-(ZREG_$DYNVMLC(J,6)**2) -
              2*ZREG_$DYNVMLC(J,7)*ZFOCUS_$DYNVMLC(1) +
              2*ZREG_$DYNVMLC(J,6)*ZFOCUS_$DYNVMLC(1);
     AREA=SURPARA1_$DYNVMLC(J,7)/2*ZSQUARE -
               SURPARA1_$DYNVMLC(J,2)/2*ZSQUARE;
     "positive portion of leaf"
     TEMP=AREA*(RMAX_CM(ICM_$DYNVMLC)-LEAFA_$DYNVMLC(J)-HOLEPOS_$DYNVMLC(J));
     VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)-TEMP;
     VOL_$DYNVMLC(3)=VOL_$DYNVMLC(3)+TEMP;
     "negative portion of leaf"
     TEMP=AREA*(LEAFB_$DYNVMLC(J)-HOLEPOS_$DYNVMLC(J)+RMAX_CM(ICM_$DYNVMLC));
     VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)-TEMP;
     VOL_$DYNVMLC(3)=VOL_$DYNVMLC(3)+TEMP;
    ]
  ELSE ["isocenter leaf"
     ZSQUARE=(ZREG_$DYNVMLC(J,7)**2)-(ZREG_$DYNVMLC(J,6)**2) -
              2*ZREG_$DYNVMLC(J,7)*ZFOCUS_$DYNVMLC(1) +
              2*ZREG_$DYNVMLC(J,6)*ZFOCUS_$DYNVMLC(1);
     AREA=SURPARA1_$DYNVMLC(J,7)/2*ZSQUARE -
               SURPARA1_$DYNVMLC(J,1)/2*ZSQUARE;
     "positive portion of leaf"
     TEMP=AREA*(RMAX_CM(ICM_$DYNVMLC)-LEAFA_$DYNVMLC(J)-HOLEPOS_$DYNVMLC(J));
     VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)-TEMP;
     VOL_$DYNVMLC(3)=VOL_$DYNVMLC(3)+TEMP;
     "negative portion of leaf"
     TEMP=AREA*(LEAFB_$DYNVMLC(J)-HOLEPOS_$DYNVMLC(J)+RMAX_CM(ICM_$DYNVMLC));
     VOL_$DYNVMLC(2)=VOL_$DYNVMLC(2)-TEMP;
     VOL_$DYNVMLC(3)=VOL_$DYNVMLC(3)+TEMP;
    ]

 ];       "End of J Loop"

VOL_$DYNVMLC(1) = TOTALVOL - VOL_$DYNVMLC(2) - VOL_$DYNVMLC(3);

"i.e. Air Volume = Total Volume - Volume of Leaves

IRA = IRSTART_$DYNVMLC-1; "absolute region number
DO IR_$DYNVMLC=1,N_$DYNVMLC [ "loop over local region number"
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_$DYNVMLC(IR_$DYNVMLC)*RHOR(IRA);
    ];
 ]; "end of loop over IR_$DYNVMLC"

"   Summarize geometrical information for this CM in listing file
"   ==============================================================
"
WRITE(IOUTLIST,110) ICM_$DYNVMLC,TITLE_$DYNVMLC;
WRITE(IOUTLIST,120) Z_min_CM(ICM_$DYNVMLC), RMAX_CM(ICM_$DYNVMLC);
IF(N_GAP_$DYNVMLC~=0) [
   WRITE(IOUTLIST,124) Z_min_CM(ICM_$DYNVMLC),
                       ZMIN_$DYNVMLC-Z_min_CM(ICM_$DYNVMLC);
  ];
WRITE(IOUTLIST,122) ZTHICK_$DYNVMLC;
IF(ORIENT_$DYNVMLC~=0) [
   WRITE(IOUTLIST,123) 'X';
]
ELSE[
   WRITE(IOUTLIST,123) 'Y';
]
IF(ENDTYPE_$DYNVMLC=1) [
   WRITE(IOUTLIST,125) ZFOCUS_$DYNVMLC(2);
]
ELSE[
   WRITE(IOUTLIST,126) LEAFRADIUS_$DYNVMLC;
]
WRITE(IOUTLIST,127) ZFOCUS_$DYNVMLC(1),LEAFGAP_$DYNVMLC,
                     VOL_$DYNVMLC(1),VOL_$DYNVMLC(2),
                     VOL_$DYNVMLC(3),TOTALVOL;
WRITE(IOUTLIST,128) (LEAFWIDTH_$DYNVMLC(I),I=1,3),
                    (WTONGUE_$DYNVMLC(I),I=1,3),
                    (WGROOVE_$DYNVMLC(I),I=1,3),
                    (WTIP_$DYNVMLC(I),I=1,3),
                    (WRAILTOP_$DYNVMLC(I),I=1,3),
                    (WRAILBOT_$DYNVMLC(I),I=1,3),
                    (ZTIP_$DYNVMLC(I),I=1,3),
                    (ZLEAF_$DYNVMLC(I),I=1,3),
                    (ZTONGUE_$DYNVMLC(I),I=1,3),
                    (ZGROOVE_$DYNVMLC(I),I=1,3),
                    (ZHOLETOP_$DYNVMLC(I),I=1,3),
                    (ZHOLEBOT_$DYNVMLC(I),I=1,3),
                     HOLEPOS_FULL_$DYNVMLC,HOLEPOS_TAR_$DYNVMLC,
                     HOLEPOS_ISO_$DYNVMLC,
                    (ZRAILTOP_$DYNVMLC(I),I=1,3),
                    (ZRAILBOT_$DYNVMLC(I),I=1,3);
IF(ORIENT_$DYNVMLC~=0) [
      WRITE(IOUTLIST,129)'Y','X';
 ]
ELSE [
      WRITE(IOUTLIST,129)'X','Y';
]
ISTART=1;
IEND=2;
LOOP[
  IF(IEND>TOT_LEAF_$DYNVMLC |
     LEAFB_$DYNVMLC(IEND)~=LEAFB_$DYNVMLC(ISTART)|
     LEAFA_$DYNVMLC(IEND)~=LEAFA_$DYNVMLC(ISTART)|
     (LEAFTYPE_$DYNVMLC(ISTART)=1 &
        LEAFTYPE_$DYNVMLC(IEND)~=LEAFTYPE_$DYNVMLC(ISTART))|
     (LEAFTYPE_$DYNVMLC(ISTART)>1 & LEAFTYPE_$DYNVMLC(IEND)=1))[
     IF(LEAFTYPE_$DYNVMLC(ISTART)=1)[
        WRITE(IOUTLIST,130)ISTART,IEND-1,'1',
                       YREG_$DYNVMLC(ISTART,1),YREG_$DYNVMLC(IEND-1,7),
                       LEAFB_$DYNVMLC(ISTART),LEAFA_$DYNVMLC(ISTART);
     ]
     ELSE[
        WRITE(IOUTLIST,130)ISTART,IEND-1,'2/3',
                       YREG_$DYNVMLC(ISTART,1),YREG_$DYNVMLC(IEND-1,7),
                       LEAFB_$DYNVMLC(ISTART),LEAFA_$DYNVMLC(ISTART);
     ]
     ISTART=IEND;
  ]
  ELSE[
     IEND=IEND+1;
  ]
]WHILE(ISTART<=TOT_LEAF_$DYNVMLC);
WRITE(IOUTLIST,131);
IRA=IRSTART_$DYNVMLC-1;
DO IR_$DYNVMLC=1,N_$DYNVMLC [
   IRA = IRA+1;
   IF(IR_$DYNVMLC=1) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,140) IR_$DYNVMLC,'opening',ECUT(IRA),PCUT(IRA),
           ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
       ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,140) IR_$DYNVMLC,'opening',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
      ];
   ]
   ELSEIF(IR_$DYNVMLC=2 | IR_$DYNVMLC=3) [
      IF (MED(IRA)=0) ["Medium is vacuum"
         WRITE(IOUTLIST,140) IR_$DYNVMLC,'leaves',ECUT(IRA),PCUT(IRA),
           ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
       ]
      ELSE ["Medium is not vacuum"
         WRITE(IOUTLIST,140) IR_$DYNVMLC,'leaves',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9)
       ]
   ];
];

IF(N_GAP_$DYNVMLC~=0) [
   IRA=IRSTART_$DYNVMLC+N_$DYNVMLC;
   WRITE(IOUTLIST,140) IR_$DYNVMLC,'airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
   WRITE(IOUTLIST,141)'at top'
 ];

IF(IGNOREGAPS_$DYNVMLC=1 & IREJCT_GLOBAL>0)[
  IF(ORIENT_$DYNVMLC=1)["leaves parallel to X"
   WRITE(IOUTLIST,'(/'' *******Range rejection in $DYNVMLC will ignore all''/
                   '' air gaps if the particle is in the leaves and has''/
                   '' X < min. X of leaf openings (not including leaf ends)''/
                   '' or X > max. X of leaf openings (not including ends)''/)');
  ]
  ELSE["leaves parallel to Y"
   WRITE(IOUTLIST,'(/'' *******Range rejection in $DYNVMLC will ignore all''/
                   '' air gaps if the particle is in the leaves and has''/
                   '' Y < min. Y of leaf openings (not including leaf ends)''/
                   '' or Y > max. Y of leaf openings (not including ends)''/)');
  ]
]

110 FORMAT(/'  Component module',I3,' is a multi-leaf collimator',
           /' (3 regions)',
           /'  -------------------------------------------------',
           /'------------------',
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'$DYNVMLC geometry parameters:',
           /T2,'------------------------',
           /T2,'Distance from front of CM from reference plane = ',T51,
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',T51,F15.5,' cm');
122 FORMAT(T2,'Thickness of collimator = ',T51,F15.5,' cm');
123 FORMAT(T2,'Leaves open parallel to the ',A1,' axis');
124 FORMAT(T2,'There is an airgap starting at Z = ',F8.3,' cm with',
              ' thickness ',F8.3,' cm');
125 FORMAT(T2,'Straight leaf ends with Z focus = ',T51,F15.5,' cm');
126 FORMAT(T2,'Cylindrical leaf ends with radius = ',T51,F15.5,' cm');
127 FORMAT(T2,'Z focus of leaf sides = ',T51,F15.5,' cm'/
T2,'Gap between adjacent leaves = ',T51,F15.5,' cm'/
T2,'Volume of region between leaves = ',T51,F15.5, 'cm**3'/
T2,'Volume of leaves = ',T51,F15.5, 'cm**3'/
T2,'Volume of driving screw holes = ',T51,F15.5, 'cm**3'/
T2,'Volume of Multileaf Collimator Component Module = ',T51,F15.5, 'cm**3');
128 FORMAT(/T2,'Dimensions for leaf types (all in cm):'/
T2,
'                                        FULL(1)     TARGET(2)   ISOCENTER(3)'/
T2,'                                         ----         ------     ---------'/
T2,'        Leaf width (excl. tongue):',3F13.5/
T2,'                  Width of tongue:',3F13.5/
T2,'                  Width of groove:',3F13.5/
T2,'                     Width of tip:',3F13.5/
T2,'      Width of upper support rail:',3F13.5/
T2,'      Width of lower support rail:',3F13.5/
T2,'           Z of top/bottom of tip:',3F13.5/
T2,'          Z of top/bottom of leaf:',3F13.5/
T2,'        Z of top/bottom of tongue:',3F13.5/
T2,'        Z of top/bottom of groove:',3F13.5/
T2,'   Z of top of driving screw hole:',3F13.5/
T2,'Z of bottom of driving screw hole:',3F13.5/
T2,'   Distance of hole from leaf tip:',3F13.5/
T2,'         Z of top of support rail:',3F13.5/
T2,'      Z of bottom of support rail:',3F13.5);
129 FORMAT(/
T2,' Leaves     type            ',A1,' range             ',A1,
' coordinates of opening'/
T2,'                           spanned (cm)              NEG   (cm)   POS');
130 FORMAT(T2,I3,'-',I3,5X,A3,4X,F10.5,' - ',F10.5,5X,F10.5,5X,F10.5);
131 FORMAT(/T2,'$DYNVMLC region parameters:',
           /T2,'---------------------------',
           /T2,'local  location  electron  photon',
               '  range-rejection   dose  bit  medium'
           /T2,'region            cutoff   cutoff',
               '   level     max    zone  set'
           /T2,'                   (MeV)    (MeV)',
               '   (MeV)    (MeV)');
140 FORMAT(T2,I3,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,3X,9A1);
141 FORMAT(T9,A7);

"   Output representation of this component module to file for EGS_Windows
"   ======================================================================

IF (IWATCH=4|IZLAST=2) [   "Graphics file requested"
   ;
    ]
; "End of graphics output"

200 FORMAT(' ',I1,A3,A1,10(F7.2,','));
RETURN;
END;

%E "Start of subroutine HOWNEAR_$DYNVMLC"
"***********************************************************************"
"                                                                       "
"                          Subroutine HOWNEAR_$DYNVMLC               "
"                          ******************************               "
"                                                                       "
" Calculates min. distance to nearest region boundary                   "
" Used to be HOWNEAR macro, but is now called from that macro.          "
"                                                                       "
"***********************************************************************"

;SUBROUTINE HOWNEAR_$DYNVMLC(DIST_sngl);
;
$IMPLICIT-NONE;

COMIN/CMs,CM_$DYNVMLC,STACK,USER,EGS-IO/;

$REAL   DIST_sngl; "T> min. distance to nearest region boundary"
DOUBLE PRECISION   XYL1,XYL2, "T> X(NP) and Y(NP)"
                   XoN, XoP, DIST,
                   UVL1,UVL2,
                   TEMP1,TEMP2,TEMP3,TEMP4,
                   TEMP5,TEMP6,HOLE, "T> temp. distance variables"
                   XL,XR,Lo,Ro,Zo;          "T>temp distance variables"
$INTEGER I,J, "T> looping index"
         NZ, "T> index of subregion in Z direction"
         NY, "T> index of subregion perpendicular to leaf opening direction"
         NX, "T> index of subregion in direction of leaf opening"
         LEAFIS, "T> leaf no. where particle is located"
         I1,I2; "T> used to mark min. max. Z boundaries for calculating dist"


IR_$DYNVMLC=IR(NP)-IRSTART_$DYNVMLC+1;
IF(IR_$DYNVMLC=4) [ "in the air gap at the top"
  DIST=MIN(Z(NP)-ZFRONT_$DYNVMLC,ZMIN_$DYNVMLC-Z(NP));
  ]

ELSE [
  IF(ORIENT_$DYNVMLC=1) [ XYL1=Y(NP);XYL2=X(NP);UVL1=V(NP);UVL2=U(NP); ]
  ELSE [ XYL1=X(NP);XYL2=Y(NP);UVL1=U(NP);UVL2=V(NP);];

  IF(IGNOREGAPS_$DYNVMLC=1 & XYL2 < MIN_PLANE_$DYNVMLC &
  XYL1 > SURPARA1_$DYNVMLC(1,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1)) &
  XYL1 < SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*(Z(NP)-ZFOCUS_$DYNVMLC(1)) &
  IR_$DYNVMLC=2)[
   "particle within negative leaves, ignore air gaps for range rejection"

   "distance to most -ve leaf side...note this is to the tip of the tongue"
   TEMP1=SURPARA1_$DYNVMLC(1,1);
   TEMP1=ABS((TEMP1*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/SQRT(1+TEMP1**2));

   "distance to most +ve leaf side...note this is to the back of the last"
   "leaf...ie not to the groove"
   TEMP2=SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7);
   TEMP2=ABS((TEMP2*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/SQRT(1+TEMP2**2));

   DIST=MIN(Z(NP)-ZMIN_$DYNVMLC,ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC-Z(NP),
           MIN_PLANE_$DYNVMLC-XYL2,TEMP1,TEMP2);
  ]
  ELSEIF(IGNOREGAPS_$DYNVMLC=1 & XYL2 > MAX_PLANE_$DYNVMLC &
  XYL1 > SURPARA1_$DYNVMLC(1,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1)) &
  XYL1 < SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*(Z(NP)-ZFOCUS_$DYNVMLC(1)) &
  IR_$DYNVMLC=2)[
   "particle within positive leaves, ignore air gaps for range rejection"

   "distance to most -ve leaf side...note this is to the tip of the tongue"
   TEMP1=SURPARA1_$DYNVMLC(1,1);
   TEMP1=ABS((TEMP1*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/SQRT(1+TEMP1**2));

   "distance to most +ve leaf side...note this is to the back of the last"
   "leaf...ie not just to the groove"
   TEMP2=SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7);
   TEMP2=ABS((TEMP2*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/SQRT(1+TEMP2**2));

   DIST=MIN(Z(NP)-ZMIN_$DYNVMLC,ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC-Z(NP),
           XYL2-MAX_PLANE_$DYNVMLC,TEMP1,TEMP2);
  ]
  ELSE["do not ignore air gaps for range rejection"

LEAFIS=0; "Determine which leaf we are in, I is index of leaf number"
DO I = 1,TOT_LEAF_$DYNVMLC [
    TEMP1=SURPARA1_$DYNVMLC(I,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
    TEMP2=SURPARA1_$DYNVMLC(I,7)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
    IF(XYL1>=TEMP1 & TEMP2>=XYL1) [
       LEAFIS=I; EXIT;];
 ];

IF(LEAFIS~=0) [
  TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
  TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
  IF(XYL1<TEMP1)[
    NY=1;
  ]
  ELSEIF(XYL1>TEMP2)[
    NY=6;
  ]
  ELSE[

    DO J =1,6 [ "Determine which Y region we are in"
      TEMP1=SURPARA1_$DYNVMLC(LEAFIS,J)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
      TEMP2=SURPARA1_$DYNVMLC(LEAFIS,J+1)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
      IF(TEMP1<=XYL1 & XYL1<=TEMP2) [NY=J; EXIT;]
      ];
  ]
  IF(Z(NP)<ZREG_$DYNVMLC(LEAFIS,1))[
    NZ=1;
  ]
  ELSEIF(Z(NP)>ZREG_$DYNVMLC(LEAFIS,10))[
    NZ=9;
  ]
  ELSE[
    DO J = 1,9 [ "Determine which Z region we are in for leaf I"
   IF((ZREG_$DYNVMLC(LEAFIS,J)<=Z(NP))&(Z(NP)<=ZREG_$DYNVMLC(LEAFIS,J+1)))[
       NZ=J; EXIT;];
    ];
  ]

  "Check if we are in groove on leaf and move to adjacent leaf"
  IF(LEAFTYPE_$DYNVMLC(LEAFIS)=2) [ "target leaf"
    IF((NY=5|NY=6) & (NZ=7|NZ=8|NZ=9) & LEAFIS~=TOT_LEAF_$DYNVMLC) [
       IF(XYL1>SURPARA1_$DYNVMLC(LEAFIS+1,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1)))[
          LEAFIS=LEAFIS+1;
          TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
          TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
          IF(XYL1<TEMP1)[
            NY=1;
          ]
          ELSEIF(XYL1>TEMP2)[
            NY=6;
          ]
          ELSE[
            DO J=1,6 [ "recheck Y region"
             TEMP1=SURPARA1_$DYNVMLC(LEAFIS,J)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
             TEMP2=SURPARA1_$DYNVMLC(LEAFIS,J+1)*(Z(NP)-ZFOCUS_$DYNVMLC(1));
             IF(TEMP1<=XYL1 & XYL1<=TEMP2) [NY=J; EXIT;]
            ];
          ]
          IF(Z(NP)<ZREG_$DYNVMLC(LEAFIS,1))[
            NZ=1;
          ]
          ELSEIF(Z(NP)>ZREG_$DYNVMLC(LEAFIS,10))[
            NZ=9;
          ]
          ELSE[
            DO J= 1,9 [ "recheck Z region"
              IF((ZREG_$DYNVMLC(LEAFIS,J)<=Z(NP))
               & (Z(NP)<=ZREG_$DYNVMLC(LEAFIS,J+1)) ) [NZ=J; EXIT;];
            ];
          ]
         ];
       ];
      ]
    ELSE [ "we are on a full leaf or isocenter leaf"
       IF(NY=6 & NZ<=4 & LEAFIS~=TOT_LEAF_$DYNVMLC) [
          IF(XYL1>SURPARA1_$DYNVMLC(LEAFIS+1,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1)))[
             LEAFIS=LEAFIS+1; NY=1;
             IF(Z(NP)<ZREG_$DYNVMLC(LEAFIS,1))[
                NZ=1;
             ]
             ELSEIF(Z(NP)>ZREG_$DYNVMLC(LEAFIS,10))[
                NZ=9;
             ]
             ELSE[
               DO J=1,9 [ "recheck Z region"
                  IF((ZREG_$DYNVMLC(LEAFIS,J)<=Z(NP))
                   & (Z(NP)<=ZREG_$DYNVMLC(LEAFIS,J+1))) [NZ=J; EXIT;];
               ];
             ]
             "***check that we have not moved into air gap on next leaf**"
             IF(LEAFTYPE_$DYNVMLC(LEAFIS)=2) [
                "target leaf"
                IF(NZ>=6) [LEAFIS=LEAFIS-1; NY=6; "****************"
                  IF(Z(NP)<ZREG_$DYNVMLC(LEAFIS,1))[
                    NZ=1;
                  ]
                  ELSEIF(Z(NP)>ZREG_$DYNVMLC(LEAFIS,10))[
                    NZ=9;
                  ]
                  ELSE[
                       DO J=1,9 [ "recheck Z"
                         IF((ZREG_$DYNVMLC(LEAFIS,J)<=Z(NP))
                         & (Z(NP)<=ZREG_$DYNVMLC(LEAFIS,J+1))) [NZ=J; EXIT;];
                       ];
                  ]
                ];
             ]
             ELSE ["full leaf"
                 IF(NZ>=4) [LEAFIS=LEAFIS-1; NY=6; "****************"
                  IF(Z(NP)<ZREG_$DYNVMLC(LEAFIS,1))[
                    NZ=1;
                  ]
                  ELSEIF(Z(NP)>ZREG_$DYNVMLC(LEAFIS,10))[
                    NZ=9;
                  ]
                  ELSE[
                   DO J=1,9 [ "recheck Z"
                    IF((ZREG_$DYNVMLC(LEAFIS,J)<=Z(NP))
                    & (Z(NP)<=ZREG_$DYNVMLC(LEAFIS,J+1))) [NZ=J; EXIT;];
                   ];
                  ]
                 ];
                ]
           ];
         ];
      ];

  "Determine which X region we are in"
  IF(ENDTYPE_$DYNVMLC=1) [ "Focused leaf end"
    TEMP1=SURPARA2_B_$DYNVMLC(LEAFIS)*(Z(NP)-ZFOCUS_$DYNVMLC(2));
    TEMP2=SURPARA2_A_$DYNVMLC(LEAFIS)*(Z(NP)-ZFOCUS_$DYNVMLC(2));
    HOLE=HOLEPOS_$DYNVMLC(LEAFIS);
    TEMP3=LEAFB_$DYNVMLC(LEAFIS)-HOLE;
    TEMP4=LEAFA_$DYNVMLC(LEAFIS)+HOLE;
    IF((XYL2>TEMP1 & XYL2<TEMP2) | (XYL2=TEMP1 & UVL2>=0.0) |
       (XYL2=TEMP2 & UVL2<0.0)) [NX=1;]
    ELSEIF((XYL2<TEMP1 & XYL2>TEMP3) | (XYL2=TEMP1 & UVL2>=0.0) |
           (XYL2=TEMP3 & UVL2>=0.0)) [NX=3;]
    ELSEIF((XYL2<TEMP3) | (XYL2=TEMP3 & UVL2<0.0)) [NX=2;]
    ELSEIF((XYL2>TEMP2 & XYL2<TEMP4) | (XYL2=TEMP2 & UVL2>=0.0) |
           (XYL2=TEMP4 & UVL2<0.0)) [NX=4;]
    ELSEIF((XYL2>TEMP4) | (XYL2=TEMP4 & UVL2>=0.0)) [NX=5;]
  ]
  ELSE ["Rounded leaf end"
    XoN=LEAFB_$DYNVMLC(LEAFIS)-LEAFRADIUS_$DYNVMLC;
    XoP=LEAFA_$DYNVMLC(LEAFIS)+LEAFRADIUS_$DYNVMLC;
    Zo=ZMIN_$DYNVMLC + (ZTHICK_$DYNVMLC)/2;
    TEMP1=SQRT((XYL2-XoN)**2+(Zo-Z(NP))**2)-LEAFRADIUS_$DYNVMLC;
    TEMP2=SQRT((XYL2-XoP)**2+(Zo-Z(NP))**2)-LEAFRADIUS_$DYNVMLC;
    HOLE=HOLEPOS_$DYNVMLC(LEAFIS);
    TEMP3=LEAFB_$DYNVMLC(LEAFIS)-HOLE;
    TEMP4=LEAFA_$DYNVMLC(LEAFIS)+HOLE;
    IF(XYL2>=XoN & XYL2<=XoP & ((TEMP1>0.0 & TEMP2>0.0) |
       (TEMP1=0.0 & UVL2*(XYL2-XoN)+W(NP)*(Z(NP)-Zo)>0.0) |
       (TEMP2=0.0 & UVL2*(XYL2-XoP)+W(NP)*(Z(NP)-Zo)>0.0))) [NX=1;]
    ELSEIF((TEMP1<0.0 & XYL2>TEMP3) | (XYL2=TEMP3 & UVL2>0.0) |
           (TEMP1=0.0 & UVL2*(XYL2-XoN)+W(NP)*(Z(NP)-Zo)<=0.0)) [NX=3;]
    ELSEIF((XYL2<TEMP3) | (XYL2=TEMP3 & UVL2<=0.0)) [NX=2;]
    ELSEIF((TEMP2<0.0 & XYL2<TEMP4) | (XYL2=TEMP4 & UVL2<0.0) |
           (TEMP2=0.0 & UVL2*(XYL2-XoP)+W(NP)*(Z(NP)-Zo)<=0.0)) [NX=4;]
    ELSEIF((XYL2>TEMP4) | (XYL2=TEMP4 & UVL2>=0.0)) [NX=5;]
  ];
   "Set minimum and maximum Z boundaries"
    IF(LEAFTYPE_$DYNVMLC(LEAFIS)=2) ["Target leaf"
      IF((NY=1|NY=2) & NZ<=3) [I1=1; I2=4;]
      ELSEIF(NY=1 & NZ=5) [I1=5; I2=6;]
      ELSEIF(NY=1 & NZ>=6) [I1=6; I2=10;]
      ELSEIF(NZ=4) [I1=4; I2=5;]
      ELSEIF((NY=2|NY=3) & NZ>=8) [I1=8; I2=10;]
      ELSEIF((NY=3|NY=4|NY=5) & NZ=1) [I1=1; I2=2;]
      ELSEIF((NY=3|NY=4|NY=5) & NZ=2) [I1=2; I2=3;]
      ELSEIF(NY>=3 & NZ=3) [I1=3; I2=4;]
      ELSEIF((NY=2|NY=3) & (NZ=5|NZ=6|NZ=7)) [I1=5; I2=8;]
      ELSEIF(NY=4 & (NZ=5|NZ=6|NZ=7|NZ=8)) [I1=5; I2=9;]
      ELSEIF(NY=4 & NZ=9) [I1=9; I2=10;]
      ELSEIF((NY=5|NY=6) & (NZ=5|NZ=6)) [I1=5; I2=7;]
      ELSEIF((NY=5|NY=6) & NZ>=7) [I1=7; I2=10;]
      ELSEIF(NY=6 & NZ<=2) [I1=1; I2=3;]
     ]
    ELSEIF(LEAFTYPE_$DYNVMLC(LEAFIS)=1) ["Full leaf"
      IF((NY=1|NY=2) & NZ=1) [I1=1; I2=2;]
      ELSEIF(NY=1 & (NZ=2|NZ=3)) [I1=2; I2=4;]
      ELSEIF(NY=1 & NZ>=4) [I1=4; I2=10;]
      ELSEIF(NY=2 & (NZ=2|NZ=3|NZ=4|NZ=5)) [I1=2; I2=6;]
      ELSEIF(NY>=2 & NZ=6) [I1=6; I2=7;]
      ELSEIF((NY=2|NY=3|NY=4) & NZ=7) [I1=7; I2=8;]
      ELSEIF(NY=2 & NZ>=8) [I1=8; I2=10;]
      ELSEIF((NY=3|NY=4|NY=5) & (NZ=1|NZ=2)) [I1=1; I2=3;]
      ELSEIF((NY=3|NY=4|NY=5) & (NZ=3|NZ=4|NZ=5)) [I1=3; I2=6;]
      ELSEIF(NY=3 & NZ>=8) [I1=8; I2=10;]
      ELSEIF(NY=4 & NZ=8) [I1=8; I2=9;]
      ELSEIF(NY=4 & NZ=9) [I1=9; I2=10;]
      ELSEIF((NY=5|NY=6) & NZ>=7) [I1=7; I2=10;]
      ELSEIF(NY=6 & NZ<=4) [I1=1; I2=5;]
      ELSEIF(NY=6 & NZ=5) [I1=5; I2=6;]
     ]
    ELSE ["Isocenter leaf"
      IF((NY=1|NY=2) & NZ<=3) [I1=1; I2=4;]
      ELSEIF((NY=1|NY=2) & (NZ=4|NZ=5)) [I1=4; I2=6;]
      ELSEIF(NZ=6) [I1=6; I2=7;]
      ELSEIF(NY<=4 & NZ=7) [I1=7; I2=8;]
      ELSEIF(NY=1 & NZ>=8) [I1=8; I2=10;]
      ELSEIF((NY=2|NY=3|NY=4) & NZ=8) [I1=8; I2=9;]
      ELSEIF((NY=2|NY=3|NY=4) & NZ=9) [I1=9; I2=10;]
      ELSEIF(NY=3 & NZ=1) [I1=1; I2=2;]
      ELSEIF(NY=3 & (NZ=2|NZ=3|NZ=4|NZ=5)) [I1=2; I2=6;]
      ELSEIF((NY=4|NY=5) & NZ<=2) [I1=1; I2=3;]
      ELSEIF((NY=4|NY=5) & (NZ=3|NZ=4|NZ=5)) [I1=3; I2=6;]
      ELSEIF((NY=5|NY=6) & NZ>=7) [I1=7; I2=10;]
      ELSEIF(NY=6 & NZ<=4) [I1=1; I2=5;]
      ELSEIF(NY=6 & NZ=5) [I1=5; I2=6;]
     ];

    DIST=MIN(ABS(ZREG_$DYNVMLC(LEAFIS,I1)-Z(NP)),
             ABS(ZREG_$DYNVMLC(LEAFIS,I2)-Z(NP)));

    "Calculates distance to closest boundary in z direction"
    "Calculate distance to nearest boundary perp to leaf openings --->"
    IF(LEAFTYPE_$DYNVMLC(LEAFIS)=2) ["Target leaf"
      IF(NZ=1 & NY<=5) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,6);
       ]
     ELSEIF(NZ=1 & NY=6) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,6);
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [
          TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,3);]
       ]
     ELSEIF(NZ=2 & NY<=2) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,3);
       ]
     ELSEIF(NZ=2 & NY>=3) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,3);
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [
          TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,3);]
       ]
     ELSEIF(NZ=3|NZ=4|NZ=5) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
     ELSEIF(NY=1 & (NZ=6|NZ=7)) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);]
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,2);
       ]
     ELSEIF(NY>=2 & NZ=6) [
       TEMP1=SURPARA1_$DYNVMLC(LEAFIS,2);
       TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
     ELSEIF(NZ=7 & (NY=2|NY=3|NY=4)) [
       TEMP1=SURPARA1_$DYNVMLC(LEAFIS,2);
       TEMP2=SURPARA1_$DYNVMLC(LEAFIS,5);
       ]
     ELSEIF((NZ=7|NZ=8) & NY>=5) [
       TEMP1=SURPARA1_$DYNVMLC(LEAFIS,5);
       IF(LEAFIS=TOT_LEAF_$DYNVMLC) [
         TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
       ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);]
      ]
     ELSEIF(NZ=8 & NY<=3) [IF(LEAFIS=1) [
       TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
       ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);]
       TEMP2=SURPARA1_$DYNVMLC(LEAFIS,4);
      ]
     ELSEIF(NZ=8 & NY=4) [
       TEMP1=SURPARA1_$DYNVMLC(LEAFIS,4);
       TEMP2=SURPARA1_$DYNVMLC(LEAFIS,5);
      ]
     ELSEIF(NZ=9) [IF(LEAFIS=1) [
       TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
       ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);]
       IF(LEAFIS=TOT_LEAF_$DYNVMLC) [
         TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
       ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);]
     ]
    ]
   ELSEIF(LEAFTYPE_$DYNVMLC(LEAFIS)=1) ["Full leaf"
      IF(NZ=1) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,6);]
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);]
       ]
      ELSEIF(NZ=2 & NY<=2) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,3);
       ]
      ELSEIF(NZ=2 & NY>=3) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,3);
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);]
       ]
      ELSEIF(NZ=3 & NY<=5) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,6);
       ]
      ELSEIF((NZ=3|NZ=4) & NY=6) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,6);
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);]
       ]
      ELSEIF((NZ=4|NZ=5|NZ=6|NZ=7) & NY=1) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);]
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,2);
       ]
      ELSEIF(NZ=4 & (NY=2|NY=3|NY=4|NY=5)) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,2);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,6);
       ]
      ELSEIF((NZ=5|NZ=6|NZ=7) & NY>=2) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,2);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
      ELSEIF(NZ=8 & NY<=4) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);]
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,5);
       ]
      ELSEIF(NZ=8 & NY>=5) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,5);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
      ELSEIF(NZ=9 & NY<=3) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);]
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,4);
       ]
      ELSEIF(NZ=9 & NY>=4) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,4);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
     ]
    ELSE ["Isocenter leaf"
      IF(NZ=1) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);];
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);];
       ]
      ELSEIF((NZ=2|NZ=3) & (NY=1|NY=2)) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,7);];
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,3);
       ]
      ELSEIF(NZ=2 & NY=3) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,3);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,4);
       ]
      ELSEIF(NZ=2 & NY>=4) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,4);
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);];
       ]
      ELSEIF(NZ=3 & (NY=3|NY=4|NY=5)) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,3);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,6);
       ]
      ELSEIF((NZ=3|NZ=4) & NY=6) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,6);
        IF(LEAFIS=TOT_LEAF_$DYNVMLC) [TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);]
        ELSE [TEMP2=SURPARA1_$DYNVMLC(LEAFIS+1,1);];
       ]
      ELSEIF(NZ=4 & NY<=5) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,6);
       ]
      ELSEIF(NZ=5|NZ=6|NZ=7) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
      ELSEIF(NZ=8 & NY<=4) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,5);];
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,5);
       ]
      ELSEIF(NZ=8 & NY>=5) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,5);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
      ELSEIF(NZ=9 & NY=1) [
        IF(LEAFIS=1) [TEMP1=SURPARA1_$DYNVMLC(LEAFIS,1);]
        ELSE [TEMP1=SURPARA1_$DYNVMLC(LEAFIS-1,5);]
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,2);
       ]
      ELSEIF(NZ=9 & NY>=2) [
        TEMP1=SURPARA1_$DYNVMLC(LEAFIS,2);
        TEMP2=SURPARA1_$DYNVMLC(LEAFIS,7);
       ]
     ];
    TEMP1=ABS((TEMP1*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/
          SQRT(1+TEMP1**2));
    TEMP2=ABS((TEMP2*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/
          SQRT(1+TEMP2**2));

    DIST = MIN(DIST,TEMP1,TEMP2);
 "NOW CHECK DISTANCE IN X DIRECTION"
    IF(ENDTYPE_$DYNVMLC=1) [ "focused leaf end"
      TEMP1=SURPARA2_B_$DYNVMLC(LEAFIS);
      TEMP1=1/SQRT(1+TEMP1**2);
      TEMP2=SURPARA2_A_$DYNVMLC(LEAFIS);
      TEMP2=1/SQRT(1+TEMP2**2);
      HOLE=HOLEPOS_$DYNVMLC(LEAFIS);
      TEMP3=LEAFB_$DYNVMLC(LEAFIS)-HOLE;
      TEMP4=LEAFA_$DYNVMLC(LEAFIS)+HOLE;
      TEMP5=SURPARA2_B_$DYNVMLC(LEAFIS)*(Z(NP)-ZFOCUS_$DYNVMLC(2));
      TEMP6=SURPARA2_A_$DYNVMLC(LEAFIS)*(Z(NP)-ZFOCUS_$DYNVMLC(2));
      IF(NX=1) [
        XL=ABS((TEMP5-XYL2)*TEMP1);
        XR=ABS((TEMP6-XYL2)*TEMP2);
       ]
      ELSEIF(NX=2) [
        XL=ABS(RMAX_CM(ICM_$DYNVMLC)-XYL2);
        XR=ABS(TEMP3-XYL2);
       ]
      ELSEIF(NX=3) [
        XL=ABS(XYL2-TEMP3);
        XR=ABS((TEMP5-XYL2)*TEMP1);
       ]
      ELSEIF(NX=4) [
        XL=ABS((XYL2-TEMP6)*TEMP2);
        XR=ABS(XYL2-TEMP4);
       ]
      ELSEIF(NX=5) [
        XL=ABS(XYL2-TEMP4);
        XR=ABS(RMAX_CM(ICM_$DYNVMLC)-XYL2);
       ]
      DIST=MIN(DIST,XL,XR);
     ]
    ELSE ["rounded leaf end"
      TEMP1=ABS(SQRT((Z(NP)-(ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC/2))**2+
                     (XYL2-(LEAFB_$DYNVMLC(LEAFIS)-LEAFRADIUS_$DYNVMLC))**2)-
                      LEAFRADIUS_$DYNVMLC);
      TEMP2=ABS(SQRT((Z(NP)-(ZMIN_$DYNVMLC+ZTHICK_$DYNVMLC/2))**2+
                     (XYL2-(LEAFA_$DYNVMLC(LEAFIS)+LEAFRADIUS_$DYNVMLC))**2)-
                     LEAFRADIUS_$DYNVMLC);
      HOLE=HOLEPOS_$DYNVMLC(LEAFIS);
      TEMP3=LEAFB_$DYNVMLC(LEAFIS)-HOLE;
      TEMP4=LEAFA_$DYNVMLC(LEAFIS)+HOLE;
      IF(NX=1) [
        XL=TEMP1;
        XR=TEMP2;
        ]
      IF(NX=3) [
        XL=ABS(XYL2-TEMP3);
        XR=TEMP1;
       ]
      IF(NX=2) [
        XL=ABS(-RMAX_CM(ICM_$DYNVMLC)-XYL2);
        XR=ABS(XYL2-TEMP3);
       ]
      IF(NX=4) [
        XL=TEMP2;
        XR=ABS(TEMP4-XYL2);
       ]
      IF(NX=5) [
        XL=ABS(XYL2-TEMP4);
        XR=ABS(RMAX_CM(ICM_$DYNVMLC)-XYL2);
       ]
      DIST=MIN(DIST,XL,XR);
    ]
IF(DIST<0) [OUTPUT LEAFIS,NX,NY,NZ; ('negative dist: ',4I3);]
 ]
ELSE[ "beyond outer edges of leaf bank"
  IF(XYL1 <= SURPARA1_$DYNVMLC(1,1)*(Z(NP)-ZFOCUS_$DYNVMLC(1)))[
      TEMP1=SURPARA1_$DYNVMLC(1,1);
      TEMP1=ABS((TEMP1*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/
                 SQRT(1+TEMP1**2));
    ]
  ELSEIF(XYL1 >= SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7)*
                   (Z(NP)-ZFOCUS_$DYNVMLC(1)))[
      TEMP1=SURPARA1_$DYNVMLC(TOT_LEAF_$DYNVMLC,7);
      TEMP1=ABS((TEMP1*(Z(NP)-ZFOCUS_$DYNVMLC(1))-XYL1)/
                 SQRT(1+TEMP1**2));
    ]
  DIST=MIN(Z(NP)-ZMIN_$DYNVMLC,ZMAX_$DYNVMLC-Z(NP),TEMP1);
 ]
 ]
 ];
 DIST_sngl=SNGL(DIST);
RETURN;
END; "End of subroutine HOWNEAR_$DYNVMLC"
"************************************************************************"
"End of DYNVMLC_cm.mortran"


