%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: dynamic jaws                              "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Blake Walters, 2007                                       "
"                                                                             "
"  Contributors:
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally derived from the JAWS component module written by "
"  George Ding, starting in 1992.                                             "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
"  radiotherapy treatments units. BEAM was originally developed at the        "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin, and was originally      "
"  described in:                                                              "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


"*******************************************************************************
"
"                             **************      ""toc:
"                             *            *      ""toc:
"                             *    JAWS    *      ""toc:
"                             *            *      ""toc:
"                             **************      ""toc:
"
"   Programmer:  George Ding.
"
"   Development  Version, begun September 5, 1992. Completed in October,1992
"
"   For complete history see sccs record.
"*******************************************************************************
"*******************************************************************************
"
"                               PURPOSE
"                               *******
"   Component module for BEAM.
"   Set of paired bars.(collimator jaws or applicator)
"
"*******************************************************************************
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to simulate
"   one component module of a clinical linear accelerator:  a set of 1 or more
"   paired bars. The bas are of arbitrary thickness and material,and X or Y.
"   orintation.
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module in
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
%E   "JAWS_cm.mortran - start of geometry description
"I>
"I> Geometry of JAWS:                             ""toc:
"I> ******************
"I>                                  ||
"I>                                \ || /   beam
"I>                                 \||/
"I>                                  \/
"I>
"I>             ---------------------------------------------------
"I>
"I>             -------------     IR=1      ----------------
"I>                         /              |
"I>  ISCM=1       IR=3     /               |   IR=2
"I>            ------------  - - - - - - -  -----------------
"I>
"I>           ---------------    IR=4     ---------------------
"I>                         /            \
"I>  ISCM=2       IR=6     /              \  IR=5
"I>       ----------------- - - - - - - -  -----------------------
"I>
"I>
"I>   IR is the region number within the CM.  There are N_JAWS local
"I>   regions. The first region is between bars or jaws.  An air gap is
"I>   always present at the front.
"I>
"I>
"I>            --------------------------------------------------------
"I>            |          Region               | Description          |
"I>            |-------------------------------|----------------------|
"I>            |  absolute       | local       |                      |
"I>            |-----------------|-------------|                      |
"I>            | IRSTART_JAWS    |  IR_JAWS    |   see graph          |
"I>            |   +IR_JAWS-1    |             |                      |
"I>            --------------------------------------------------------
"I>
" Subroutines:
" ************
"                      INPUT_$DYNJAWS
"                      ISUMRY_$DYNJAWS
"                      HOWFAR_$DYNJAWS
"                      WHERE_AM_I_$DYNJAWS
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"*******************************************************************************
"
"                             RESTRICTIONS ON USE/BUGS
"                             ************************
"
" 1. Very small jaw angles lead to approximations because of boundary
"    tolerance.  Particles may step right through the tips of jaws,
"    without recognizing that they have entered and exited a distinct
"    region, where jaw thickness is ~$BDY_TOL cm.
"
"*******************************************************************************
"*******************************************************************************
"**************************  DESCRIPTION OF VARIABLES  *************************
"*******************************************************************************
"
"                             COMMON BLOCK VARIABLES
"                             **********************
"
"  Refer to the replacement macros in BEAM.MORTRAN and BEAM_COMMON.MORTRAN
"  which define the common block variables.
"
"*******************************************************************************
"
"                                OTHER VARIABLES
"                                ***************
"
"  Refer to the section on type declarations for each subroutine. The following
"  section describes the variables input from unit 5.  These variables define
"  the parameters of each simulation.
"
"*******************************************************************************
"
"                   Description of Users Input from Unit 5   ""toc:
"                   **************************************
"
"I>
"I>  CARDS CM_$DYNJAWS(JAWS: Rev 1.8)
"I>  **************
"I>
"I>  -1  dummy line read in main used to separate input for CMs
"I>
"I>   0  RMAX_CM(ICM_JAWS) (F10.0):
"I>                         Perpendicular distance from Z-axis to boundary
"I>                         surrounding component module.  This component
"I>                         module has a square boundary.
"I>
"I>   1  TITLE_$DYNJAWS (60A1):  Title of CM.
"I>
"I>   2  ISCM_MAX_$DYNJAWS, MODE_$DYNJAWS (2I5)
"I>
"I>           ISCM_MAX_$DYNJAWS = Number of paired bars or jaws in CM.
"I>               MODE_$DYNJAWS = 0 for static settings of jaw openings
"I>                            1 for dynamic settings with simulated
"I>                              jaw movement while beam is on
"I>                            2 for step-and-shoot jaw movement--beam
"I>                              off while jaw settings are changed
"I>
"I>   Repeat 3 (if MODE_$DYNJAWS=1,2) or 3 and 4 (if MODE_$DYNJAWS=0)
"I>               for I=1,ISCM_MAX_$DYNJAWS
"I>
"I>   3  XY_CHOICE (A1):  indicate orientation of the paired bars/jaws
"I>                        X means bars/jaws perpendicular to x axis
"I>                       i.e. separation and movement is along x-axis
"I>
"I>   Next input is only required if MODE_$DYNJAWS=0 (static)
"I>
"I>   4  ZMIN_$DYNJAWS(I), ZMAX_$DYNJAWS(I), (XFP_$DYNJAWS(I), XBP_$DYNJAWS(I),
"I>      XFN_$DYNJAWS(I), XBN_$DYNJAWS(I)) (6F15.0)
"I>
"I>        ZMIN_$DYNJAWS(I): Distance front of bars/jaws to reference plane.
"I>        ZMAX_$DYNJAWS(I): Distance back of bars/jaws to reference plane.
"I>        XFP_$DYNJAWS(I):  positive bar/jaw x or y coodinate at front.
"I>        XBP_$DYNJAWS(I):  positive bar/jaw x or y coodinate at back.
"I>        XFN_$DYNJAWS(I):  negative bar/jaw x or y coodinate at front.
"I>        XBN_$DYNJAWS(I):  negative bar/jaw x or y coodinate at back.
"I>
"I>   Next input is only required if MODE_$DYNJAWS=1 or 2
"I>
"I>   4a jaws_file (A80)
"I>
"I>        jaws_file: The full name of a file containing jaw opening data
"I>                   in the following format:
"I>
"I>      NFIELDS_$DYNJAWS (I10)
"I>      FOR J=1,NFIELDS_$DYNJAWS[
"I>       INDEX_$DYNJAWS(J) (F15.0)
"I>       (ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I),XFP_$DYNJAWS(I),XBP_$DYNJAWS(I),
"I>        XFN_$DYNJAWS(I),XBN_$DYNJAWS(I), I=1,ISCM_MAX_$DYNJAWS)
"I>      ]
"I>
"I>      where:
"I>
"I>      NFIELDS_$DYNVMLC:  Total number of jaw settings.
"I>      INDEX_$DYNJAWS(J):  Index of setting J. 0 <= INDEX_$DYNVMLC(J) <= 1
"I>                         and INDEX_$DYNVMLC(J) > INDEX_$DYNVMLC(J-1).  This
"I>                         number is compared to a random number on [0,1] at
"I>                         the start of each history; if the random number is
"I>                         <= INDEX_$DYNVMLC(J), then, if MODE_$DYNJAWS=2,
"I>                         settings J are used.  If MODE_$DYNJAWS=1, then
"I>                         the settings used are a linear interpolation
"I>                         between fields J-1 and J based on the random
"I>                         number selected.  See manual for more details.
"I>      ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I),XFP_$DYNJAWS(I),XBP_$DYNJAWS(I),
"I>      XFN_$DYNJAWS(I),XBN_$DYNJAWS(I):
"I>                         See description of input 4.  These are defined
"I>                         for each field, J.
"I>
"I>   5   ECUT, PCUT, DOSE_ZONE, IREGION_to_BIT (2F15.0,2I5): for interior
"I>                                                     (assumed to be AIR)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons.
"I>          DOSE_ZONE:      Dose scoring zone of air surrounding bars.
"I>          IREGION_TO_BIT: This region associated with this bit in LATCH
"I>
"I>   Repeat 6 and 7 for I=1,ISCM_MAX_$DYNJAWS
"I>
"I>   6   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT (2F15.0,2I5)
"I>
"I>          ECUT, PCUT:     Cutoff energies for electrons and photons in
"I>                          jaw I.
"I>          DOSE_ZONE:      Dose scoring zone for jaw I.
"I>          IREGION_TO_BIT: Both bars of jaw I associated with this bit.
"I>
"I>   7   MED_IN (24A1):  Medium of jaw I, used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>  The following input defines a single tungsten jaw oriented in the Y
"I>  direction operating in step-and-shoot (MODE_$DYNJAWS=2) mode.
"I>  The jaw settings (Z position, opening coordinates) are defined
"I>  in the file $OMEGA_HOME/beamnrc/CMs/dynjaw.opening.file
"I>  (included with the distribution).
"I>
"I>  40.0, RMAX
"I>  CM #7: jaws set for a 10x10cm field at SSD=100 cm
"I>  1,2, # PAIRED BARS OR JAWS, MODE
"I>  Y
"I>  $OMEGA_HOME/beamnrc/CMs/dynjaw.opening.file
"I>  0.7, 0.01, 0, 21,
"I>  0.7, 0.01, 0, 13,
"I>  W700ICRU
"I>
"
;
"*******************************************************************************
"*******************************  ERROR CONDITIONS  ****************************
"*******************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules not allowed
"
"   2)  Overlapping bars not allowed
"
"   3)  Air gap at front of CM required
"
"   4)  Inner boundary of all bars must be within CM boundary, RMAX_CM
"
"*******************************************************************************

%E   "Start of subroutine HOWFAR_$DYNJAWS (Rev 1.8)"
"*******************************************************************************
"************************** Component Module JAWS ******************************
"*******************************************************************************
"
"                          Subroutine HOWFAR_JAWS
"                          ***********************
"
" HOWFAR routine for set of paired bars.
"
" Determine if current region number is within component module JAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
"   There are 4xISCM local regions see above graph:
"
"      local                    absolute                   description
"   ------------  ------------------------------------   ---------------
"       IRL       IR_start_CM(ICM_JAWS)+IRL-1               IRL
"
"   Geometrical co-ordinates, as set in INPUT_JAWS are:
"
"   ZFRONT_JAWS     front of CM (upstream surface, air region)
"   ZBACK_JAWS      back of CM (downstream surface, air region)
"   ZMIN_JAWS(IRL)  front of bars ISCM,
"   ZMAX_JAWS(IRL)  back of bars ISCM
"
"*******************************************************************************
;SUBROUTINE HOWFAR_$DYNJAWS;


;IMPLICIT NONE;
;COMIN/CMs,CM_$DYNJAWS,EPCONT,STACK,EGS-IO,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_JAWS
"T>**********************************
"T>
INTEGER
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   IB_$DYNJAWS,    "T>index to deal with round off errors
   I_tpo,I_tne, "T>error indices
   IRNEW_$DYNJAWS; "T>tentative new region number within CM (absolute)

$REAL
   DIST,       "T>distance to region boundary along current particle trajectory
   DIST1,      "T>holds value of DIST while further checks are done
   XPLN_$DYNJAWS,  "T>X or Y at a plane surface along particle trajectory
   ZPLN_$DYNJAWS;  "T>Z along particle trajectory

DATA I_tpo,I_tne/0,0/;

IRL = IR(NP); "local region number (absolute)
"
" This replacement macros sets DNEAR as well as defining IR_$DYNJAWS,
 ;$DYNJAWS_CM_HOWNEAR(DNEAR(NP));

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module JAWS, and if
" so evaluate DIST, distance to region boundary along current trajectory.  USTEP
" must not exceed DIST.
"
";$DYNJAWS_SET_XY_UV(ISCM_$DYNJAWS);"" needed if no dnear caln in howfar"
IF(IR_$DYNJAWS = 3*ISCM_$DYNJAWS-2) ["particle not in positive or negative bar
   IB_$DYNJAWS=1;
   IF(W(NP) > 0.0 )[
      IF(Z(NP) < ZMIN_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL) [
         DIST = (ZMIN_$DYNJAWS(ISCM_$DYNJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
         ZPLN_$DYNJAWS = Z(NP)+DIST*W(NP);
         IF(XPLN_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
            BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
            "must check against plane of jaws at actual Z posn of particle"
            IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
         ]
         ELSEIF(XPLN_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
                BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
            IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
         ]
         ELSE[
            DIST = (ZMAX_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP) + $BDY_TOL)/W(NP);
            IF(DIST < 0) [DIST = 0.0;]
            IF(DIST=0. & ISCM_$DYNJAWS=ISCM_MAX_$DYNJAWS)[DIST=1.E-16;]
            XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
            ZPLN_$DYNJAWS = Z(NP)+DIST*W(NP);
            IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*ISCM_$DYNJAWS;
            IF(ISCM_$DYNJAWS = ISCM_MAX_$DYNJAWS)[IRNEW_$DYNJAWS =1;]
            DIST1=DIST;
            IF(XPLN_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
               BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
               ;$DYNJAWS_TPOSITIVE;
               IF(DIST<DIST1)[
                 IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
            ELSEIF(XPLN_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
                BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
               ;$DYNJAWS_TNEGATIVE;
               IF(DIST<DIST1)[
                 IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
               ]
               ELSE[
                 DIST=DIST1;
               ]
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_$DYNJAWS(ISCM_$DYNJAWS)
         IF( XY_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP) +
             BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS) &
             Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_$DYNJAWS(ISCM_$DYNJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP) +
             BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS) &
             Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_$DYNJAWS(ISCM_$DYNJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMAX_$DYNJAWS(ISCM_$DYNJAWS) - Z(NP) + $BDY_TOL)/W(NP);
         IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*ISCM_$DYNJAWS;
         IF(ISCM_$DYNJAWS = ISCM_MAX_$DYNJAWS)[IRNEW_$DYNJAWS =1;]
         XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
         ZPLN_$DYNJAWS = Z(NP)+DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
               BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
            ;$DYNJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
                BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
            ;$DYNJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IF (IRNEW_$DYNJAWS=1) ["leaving CM through back"
            CALL WHERE_AM_I(ICM_$DYNJAWS,1);
         ]
         ELSE ["still in CM, entering between bars
            IRNEW = IRNEW_$DYNJAWS; "new region number"
         ]
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      IF(Z(NP) < ZMIN_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL) [
         IF(ISCM_$DYNJAWS = 1)[
            DIST = (ZFRONT_$DYNJAWS - Z(NP))/W(NP);
            IF(DIST <= 0)[ DIST = 1.E-16;]
            IRNEW_$DYNJAWS = 1;
         ]
         ELSE[ "  ISCM_$DYNJAWS > 1
            ;$DYNJAWS_SET_XY_UV(ISCM_$DYNJAWS-1);
            DIST = (ZMAX_$DYNJAWS(ISCM_$DYNJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
            XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
            ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
            IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-2);
            IF(XPLN_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS-1)*ZPLN_$DYNJAWS +
               BPOT_$DYNJAWS(ISCM_$DYNJAWS-1,IB_$DYNJAWS))[
               IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-2) + 1;
            ]
            ELSEIF(XPLN_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS-1)*ZPLN_$DYNJAWS +
                BNET_$DYNJAWS(ISCM_$DYNJAWS-1,IB_$DYNJAWS))[
               IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-2) + 2;
            ]
         ]
      ]
      ELSE[ "Z(NP)> ZMIN_$DYNJAWS(ISCM_$DYNJAWS)
         IF( XY_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP) +
             BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS) &
             Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL  &
             Z(NP) < ZMAX_$DYNJAWS(ISCM_$DYNJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
            USTEP = 0.0;
            RETURN;
         ]
         IF( XY_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP) +
             BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS) &
             Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL &
             Z(NP) < ZMAX_$DYNJAWS(ISCM_$DYNJAWS) - $BDY_TOL )[
            IRNEW = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
            USTEP = 0.0;
            RETURN;
         ]
         DIST = (ZMIN_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP) - $BDY_TOL)/W(NP);
         IF(DIST < 0)[ DIST = 0.0;]
         XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
         ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
         DIST1=DIST;
         IF(XPLN_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
               BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
            ;$DYNJAWS_TPOSITIVE;
            IF(DIST<DIST1)[
              IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSEIF(XPLN_$DYNJAWS < ANE_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
                BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
            ;$DYNJAWS_TNEGATIVE;
            IF(DIST<DIST1)[
              IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
            ]
            ELSE[
              DIST=DIST1;
            ]
         ]
         ELSE[
            IF(ISCM_$DYNJAWS = 1)[
               DIST = (ZFRONT_$DYNJAWS - Z(NP))/W(NP);
               IF(DIST <= 0)[ DIST = 1.E-16;]
               IRNEW_$DYNJAWS = 1;
            ]
            ELSE[ "  ISCM_$DYNJAWS > 1
               ;$DYNJAWS_SET_XY_UV(ISCM_$DYNJAWS-1);
               DIST = (ZMAX_$DYNJAWS(ISCM_$DYNJAWS-1) - Z(NP) - $BDY_TOL)/W(NP);
               IF(DIST < 0)[ DIST = 0.0;]
               XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
               ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
               IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-2);
               IF(XPLN_$DYNJAWS > APO_$DYNJAWS(ISCM_$DYNJAWS-1)*ZPLN_$DYNJAWS +
                  BPOT_$DYNJAWS(ISCM_$DYNJAWS-1,IB_$DYNJAWS))[
                  IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-2) + 1;
               ]
               ELSEIF(XPLN_$DYNJAWS <
                      ANE_$DYNJAWS(ISCM_$DYNJAWS-1)*ZPLN_$DYNJAWS +
                      BNET_$DYNJAWS(ISCM_$DYNJAWS-1,IB_$DYNJAWS))[
                  IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-2) + 2;
               ]
            ]
         ]
      ]
      IF(DIST <= USTEP ) [
         USTEP = DIST;
         IF(IRNEW_$DYNJAWS = 1)["particle moving out from front CM
            CALL WHERE_AM_I(ICM_$DYNJAWS,-1);
         ]
         ELSE[  "still in CM
            USTEP = DIST;
            IRNEW = IRNEW_$DYNJAWS; "new region number"
         ]
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) ) [
         IF(UV_$DYNJAWS > 0.0)[
            IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 1;
            ;$DYNJAWS_TPOSITIVE;
         ]
         ELSE[
            IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1) + 2;
            ;$DYNJAWS_TNEGATIVE;
         ]
      ]
      IF(DIST <= USTEP ) ["particle to be moved to region boundary
         USTEP = DIST;
         IRNEW = IRNEW_$DYNJAWS; "new region number"
      ]
   ]"end of w = 0.0
] "end of region 1
ELSEIF(IR_$DYNJAWS = 3*ISCM_$DYNJAWS-1) [ "particle in positive bars
   IB_$DYNJAWS=2;
   IF( XY_$DYNJAWS < APO_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP) +
       BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS) &
      Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) - $BDY_TOL  &
      Z(NP) < ZMAX_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_$DYNJAWS = ISCM_MAX_$DYNJAWS)[DIST=1.E-16;]
      IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*ISCM_$DYNJAWS;
      IF(ISCM_$DYNJAWS = ISCM_MAX_$DYNJAWS)[IRNEW_$DYNJAWS =1;]
      XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
      ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$DYNJAWS < APO_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
       BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
         IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
         ;$DYNJAWS_TPOSITIVE;
      ]
   ]"end of w > 0.0
   ELSEIF (W(NP) < 0.0)[
      DIST = (ZMIN_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
      XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
      ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$DYNJAWS < APO_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
       BPOT_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
         ;$DYNJAWS_TPOSITIVE;
      ]
   ] "end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_$DYNJAWS < 0.0)[
         IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
         ;$DYNJAWS_TPOSITIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_$DYNJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_$DYNJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_$DYNJAWS; "new region number"
      ]
   ]
]  "end of region 2
ELSEIF(IR_$DYNJAWS = 3*ISCM_$DYNJAWS) [ "particle in negative bars
   IB_$DYNJAWS=2;
   IF( XY_$DYNJAWS > ANE_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP) +
       BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS) &
      Z(NP) > ZMIN_$DYNJAWS(ISCM_$DYNJAWS) - $BDY_TOL &
      Z(NP) < ZMAX_$DYNJAWS(ISCM_$DYNJAWS) + $BDY_TOL )[
      IRNEW = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
      USTEP = 0.0;
      RETURN;
   ]
   IF (W(NP) > 0.0) [
      DIST = (ZMAX_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP)+$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IF(DIST=0. & ISCM_$DYNJAWS = ISCM_MAX_$DYNJAWS)[DIST=1.E-16;]
      IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*ISCM_$DYNJAWS;
      IF(ISCM_$DYNJAWS = ISCM_MAX_$DYNJAWS)[IRNEW_$DYNJAWS =1;]
      XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
      ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$DYNJAWS > ANE_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
       BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
         IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
         ;$DYNJAWS_TNEGATIVE;
      ]
   ] "end of w > 0.0
   ELSEIF(W(NP) < 0.0)[
      DIST = (ZMIN_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP)-$BDY_TOL)/W(NP);
      IF(DIST < 0)[DIST = 0.0;]
      IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
      XPLN_$DYNJAWS = XY_$DYNJAWS + UV_$DYNJAWS * DIST;
      ZPLN_$DYNJAWS = Z(NP) + DIST*W(NP);
      IF(XPLN_$DYNJAWS > ANE_$DYNJAWS(ISCM_$DYNJAWS)*ZPLN_$DYNJAWS +
       BNET_$DYNJAWS(ISCM_$DYNJAWS,IB_$DYNJAWS))[
         ;$DYNJAWS_TNEGATIVE;
      ]
   ]"end of w < 0.0
   ELSE[ "(W(NP) = 0.0
      DIST=1.0E20;
      IF(UV_$DYNJAWS > 0.0)[
         IRNEW_$DYNJAWS = IRSTART_$DYNJAWS + 3*(ISCM_$DYNJAWS-1);
         ;$DYNJAWS_TNEGATIVE;
      ]
   ]
   IF(DIST <= USTEP ) ["particle to be moved to region boundary
      USTEP = DIST;
      IF (IRNEW_$DYNJAWS=1) ["leaving CM through back"
         CALL WHERE_AM_I(ICM_$DYNJAWS,1);
      ]
      ELSE ["still in CM, entering between bars
         IRNEW = IRNEW_$DYNJAWS; "new region number"
      ]
   ]
] "end of region 3
"end of CM regions"

"   outside of CM, something is wrong
"   =================================
"
ELSE ["something is wrong"
   OUTPUT IR(NP)-IRSTART_$DYNJAWS+1, IR(NP), ICM_$DYNJAWS,
          IR_start_CM(ICM_$DYNJAWS);
      (//' ************'//' HOWFAR_JAWS error'/
         '    Region, local, absolute =',2I5/
         '    CM number=',I5,' start region =',I5/
         ' *********'//);
   STOP;
] "end of IF statement"
RETURN;
END; "End of subroutine HOWFAR_$DYNJAWS"
%E   "Start of subroutine WHERE_AM_I_$DYNJAWS (Rev 1.8)"
"*******************************************************************************
"
"                          Subroutine WHERE_AM_I_JAWS
"                          ***************************
"
" WHERE_AM_I routine for set of JAWS.
"
" WHERE_AM_I_$DYNJAWS determines the new region number when a particle traverses
" a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_$DYNJAWS subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_$DYNJAWS from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*******************************************************************************
;SUBROUTINE WHERE_AM_I_$DYNJAWS(IDIR);


;IMPLICIT NONE;
;COMIN/CM_$DYNJAWS,EPCONT,STACK,USER/;

"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_JAWS
"T>**************************************
"T>
INTEGER IDIR;       "T>direction of particle, +1=forward, -1=backward
$REAL XBDY_$DYNJAWS;
XBDY_$DYNJAWS = X(NP) + U(NP)*USTEP;
IF(IXY_CHOICE_$DYNJAWS(ISCM_MAX_$DYNJAWS) = 1)[
   XBDY_$DYNJAWS = Y(NP) + V(NP)*USTEP;
]
IF (IDIR=1) ["particle entering this CM through front face (upstream)
   "$CHECK_FRONT_$DYNJAWS;"
   IRNEW = IRSTART_$DYNJAWS;
]
ELSE ["particle entering this CM through back face (downstream)
   IRNEW = IRSTART_$DYNJAWS + 3*ISCM_MAX_$DYNJAWS - 3;
   "$CHECK_BACK_$DYNJAWS;"
   IF(XBDY_$DYNJAWS > XBP_$DYNJAWS(ISCM_MAX_$DYNJAWS))[
      IRNEW = IRSTART_$DYNJAWS + 3*ISCM_MAX_$DYNJAWS-2;
   ]
   ELSEIF(XBDY_$DYNJAWS < XBN_$DYNJAWS(ISCM_MAX_$DYNJAWS))[
      IRNEW = IRSTART_$DYNJAWS + 3*ISCM_MAX_$DYNJAWS - 1;
   ]
]
RETURN;
END; "End of subroutine WHERE_AM_I_$DYNJAWS"
%E   "Start of subroutine INPUT_$DYNJAWS (Rev 1.8)"
"*******************************************************************************
"
"                           Subroutine INPUT_JAWS
"                           **********************
"
"  A CM input subroutine for a series of 1 or more paired bars.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section `INPUT FROM UNIT 5' in
"  the above documentation.
"
"*******************************************************************************

;SUBROUTINE INPUT_$DYNJAWS;


;IMPLICIT NONE;
;COMIN/BOUNDS,CMs,CM_$DYNJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"T>
"T>*********************************
"T>TYPE DECLARATIONS FOR INPUT_JAWS
"T>*********************************
"T>
INTEGER I,J,K,         "T>DO loop indeces
        IRA,         "T>Absolute region number
        MED_FLAG,    "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,   "T>medium index, set after medium sort by $MED_INPUT
        jaws_unit,   "T>unit no. for file of dynamic jaws settings
        egs_get_unit; "T>EGS function to assign unit to jaws_file

$REAL AIRGAPMIN_$DYNJAWS,  "T>minimum air gap in front and back of CM
      BDYTOL,          "T>stores $BDY_TOL
      TZMAX;           "T>stores max value of ZMAX (for MODE=1,2)
CHARACTER*1 XY_CHOICE(1);
CHARACTER*80 jaws_file, "T>name of file containing dynamic jaw settings
             JAWS_TITLE; "T> title line in file
"
"  initialize parameters
"  =====================
"
ICM_$DYNJAWS = ICM;      "CM index for this component module
IRSTART_$DYNJAWS = IR_start_CM(ICM_$DYNJAWS); "Index of first region in this CM,
                                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_$DYNJAWS) = 0; "Geometry-checking flag, 0 if no error detected
AIRGAPMIN_$DYNJAWS = 0.01; "Minimum 0.01 cm air gap at front and back of CM

TZMAX=-999.;

OUTPUT RMAX_CM(ICM); (' This component is sets of paired bars or jaws'/
  '      Outer boundary is a square with |x| & |y| <',F10.2,' cm');
OUTPUT;(' TITLE: ',$);
;MINPUT ($DYNJAWS) TITLE_$DYNJAWS;(60A1);
                          ";MINPUT is a replacement macro with EOF and
                          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_$DYNJAWS;(' ',60A1);
IF(ICM_$DYNJAWS = 1)[
   OUTPUT;(' This is the first component and starts at the reference plane');]
ELSE
   [OUTPUT Z_min_CM(ICM_$DYNJAWS);(' Previous CM ends at:',F12.5,' cm');]

"
"   get geometry information
"   =============================
"
"get the number of paired bars/jaws"
ISCM_MAX_$DYNJAWS = $MAX_N_$DYNJAWS; "Max number of paired bars/jaws permitted
OUTPUT ISCM_MAX_$DYNJAWS;
       (' NUMBER OF paired bars/jaws (minimum 1, maximum',I3,'),'/
        ' MODE of JAWS (0--static, 1--dynamic, 2--step-and-shoot)'/
        ' : ',$);
;MINPUT ($DYNJAWS) ISCM_MAX_$DYNJAWS,MODE_$DYNJAWS; (2I5);
OUTPUT ISCM_MAX_$DYNJAWS,MODE_$DYNJAWS; (2I5);
IF(ISCM_MAX_$DYNJAWS > $MAX_N_$DYNJAWS)[
   OUTPUT ICM_$DYNJAWS, $MAX_N_$DYNJAWS;
   (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
      '# of paired bars > max. allowed.'/
      '# of pared bars reduced to ',I4,' for now.'//);
   ISCM_MAX_$DYNJAWS=$MAX_N_$DYNJAWS;
   IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
]
ELSEIF(ISCM_MAX_$DYNJAWS<1)[
   ISCM_MAX_$DYNJAWS=1;
   OUTPUT ICM_$DYNJAWS;
   (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
      '# of paired bars < 1'/
      '# of pared bars reset to 1 for now.'//);
   IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
]
N_$DYNJAWS = 3*ISCM_MAX_$DYNJAWS;
IF(MODE_$DYNJAWS<0 | MODE_$DYNJAWS>2)[
   MODE_$DYNJAWS=0;
   OUTPUT;(/' Mode of jaws defaults to 0 (static).'/);
]

"loop over bars
DO I = 1,ISCM_MAX_$DYNJAWS ["loop to get each bar location"
 OUTPUT I;(/' Paired bar/jaw set no:',I3,/
    ' Are bars/jaws perpendicular to x or y axis'/
    ' i.e. is separation measured on x or y axis'/
    ' (Input "y" or "Y" for Y jaws, any other character for X jaws): ',$);
 ;MINPUT ($DYNJAWS) XY_CHOICE;(1A1);
 OUTPUT XY_CHOICE;(' ',1A1);
 IXY_CHOICE_$DYNJAWS(I) = 0;
 IF(XY_CHOICE(1) ='Y' | XY_CHOICE(1) ='y')[ IXY_CHOICE_$DYNJAWS(I) = 1;]
 IF(MODE_$DYNJAWS=0)[
   IF(IXY_CHOICE_$DYNJAWS(I) = 0)["this is x bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: XFP, XBP,',
         ' XFN, XBN(cm) all on one line');
   ]
   ELSE ["this is y bars/jaws"
         OUTPUT;(' Input ZMIN, ZMAX & jaw coordinates: YFP, YBP,',
         ' YFN, YBN(cm) all on one line');
   ]
   IF(I=1)[
         OUTPUT AIRGAPMIN_$DYNJAWS;
          (' (leave at least min. airgap = ',F8.5,' before 1st jaws)',
          /' : ',$);
   ]
   ELSE[
         OUTPUT AIRGAPMIN_$DYNJAWS;
          (' (leave at least min. airgap = ',F8.5,' between jaws)',
           /' : ',$);
   ]
   ;MINPUT ($DYNJAWS) ZMIN_$DYNJAWS(I), ZMAX_$DYNJAWS(I), XFP_$DYNJAWS(I),
      XBP_$DYNJAWS(I), XFN_$DYNJAWS(I), XBN_$DYNJAWS(I);(6F15.0);
      ;OUTPUT ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I), XFP_$DYNJAWS(I),
      XBP_$DYNJAWS(I), XFN_$DYNJAWS(I),XBN_$DYNJAWS(I); (6F11.5);
   IF(I=1)[
       IF(ICM_$DYNJAWS=1 &
         Z_min_CM(ICM_$DYNJAWS)>ZMIN_$DYNJAWS(1)-AIRGAPMIN_$DYNJAWS)[
         OUTPUT ICM_$DYNJAWS, AIRGAPMIN_$DYNJAWS,
         ZMIN_$DYNJAWS(1)-AIRGAPMIN_$DYNJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,100)ICM_$DYNJAWS, AIRGAPMIN_$DYNJAWS,
              ZMIN_$DYNJAWS(1)-AIRGAPMIN_$DYNJAWS,Z_min_CM(1);
          100 FORMAT(//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_$DYNJAWS(1)-AIRGAPMIN_$DYNJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_$DYNJAWS)>ZMIN_$DYNJAWS(1))[
         OUTPUT ICM_$DYNJAWS;
           (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
              'Overlaps with previous CM'//);
           IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_$DYNJAWS)>ZMIN_$DYNJAWS(1)-AIRGAPMIN_$DYNJAWS)[
         OUTPUT ICM_$DYNJAWS, AIRGAPMIN_$DYNJAWS,
         Z_min_CM(ICM_$DYNJAWS)+AIRGAPMIN_$DYNJAWS,
                ZMIN_$DYNJAWS(1);
           (//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,101)ICM_$DYNJAWS, AIRGAPMIN_$DYNJAWS,
                Z_min_CM(ICM_$DYNJAWS)+AIRGAPMIN_$DYNJAWS,ZMIN_$DYNJAWS(1);
         101 FORMAT(//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
              ' Less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         ZMIN_$DYNJAWS(1)=Z_min_CM(ICM_$DYNJAWS)+AIRGAPMIN_$DYNJAWS;
       ]
   ]
   ELSE[
     IF (ZMAX_$DYNJAWS(I-1)>ZMIN_$DYNJAWS(I))[
        OUTPUT ICM_$DYNJAWS, I-1, I;
         (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
            'Paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
     ]
     ELSEIF (ZMAX_$DYNJAWS(I-1)>ZMIN_$DYNJAWS(I)-AIRGAPMIN_$DYNJAWS)[
        OUTPUT ICM_$DYNJAWS, AIRGAPMIN_$DYNJAWS, I-1, I, I,
                ZMAX_$DYNJAWS(I-1)+AIRGAPMIN_$DYNJAWS,ZMIN_$DYNJAWS(I);
          (//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,102)ICM_$DYNJAWS, AIRGAPMIN_$DYNJAWS, I-1, I, I,
                ZMAX_$DYNJAWS(I-1)+AIRGAPMIN_$DYNJAWS,ZMIN_$DYNJAWS(I);
        102 FORMAT(//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
             ' Less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        ZMIN_$DYNJAWS(I)=ZMAX_$DYNJAWS(I-1)+AIRGAPMIN_$DYNJAWS;
     ]
   ]
   IF(ZMIN_$DYNJAWS(I) >= ZMAX_$DYNJAWS(I))[
      OUTPUT ICM_$DYNJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   IF(ABS(XFP_$DYNJAWS(I))>RMAX_CM(ICM_$DYNJAWS))[
      OUTPUT ICM_$DYNJAWS, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'XFP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   IF(ABS(XBP_$DYNJAWS(I))>RMAX_CM(ICM_$DYNJAWS))[
      OUTPUT ICM_$DYNJAWS, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'XBP(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   IF(ABS(XFN_$DYNJAWS(I))>RMAX_CM(ICM_$DYNJAWS))[
      OUTPUT ICM_$DYNJAWS, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'XFN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   IF(ABS(XBN_$DYNJAWS(I))>RMAX_CM(ICM_$DYNJAWS))[
      OUTPUT ICM_$DYNJAWS, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'XBN(',I4,') beyond RMAX_CM'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   IF(XFP_$DYNJAWS(I) < XFN_$DYNJAWS(I))[
      OUTPUT ICM_$DYNJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'XFP(',I4,') < XFN(',I4,')'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   ELSEIF(XFP_$DYNJAWS(I) - XFN_$DYNJAWS(I) < $BDY_TOL*3 )[
      XFP_$DYNJAWS(I) = XFP_$DYNJAWS(I) + $BDY_TOL*2;
      XFN_$DYNJAWS(I) = XFN_$DYNJAWS(I) - $BDY_TOL*2;
   ]
   IF(XBP_$DYNJAWS(I) < XBN_$DYNJAWS(I))[
      OUTPUT ICM_$DYNJAWS, I, I;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'XBP(',I4,') < XBN(',I4,')'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   ELSEIF(XBP_$DYNJAWS(I) - XBN_$DYNJAWS(I) < $BDY_TOL*3 )[
      XBP_$DYNJAWS(I) = XBP_$DYNJAWS(I) + $BDY_TOL*2;
      XBN_$DYNJAWS(I) = XBN_$DYNJAWS(I) - $BDY_TOL*2;
   ]
 ]
] "end of loop over paired bars/jaws"
IF(MODE_$DYNJAWS=1 | MODE_$DYNJAWS=2)[
  OUTPUT;(/' Input full name of file containing jaw data:'/);
  READ(i_input,'(A80)')jaws_file;
  OUTPUT jaws_file;(A80/);
  jaws_unit=70;
  jaws_unit=egs_get_unit(jaws_unit);
  IF(jaws_unit<1)[
    $egs_fatal(*,
         'DYNJAWS data file: failed to get a free Fortran I/O unit');
  ]
  open(jaws_unit,file=jaws_file,status='old',err=:no-jaws-data-file:);
  read(jaws_unit,'(A80)') JAWS_TITLE;
  read(jaws_unit,'(I10)') NFIELDS_$DYNJAWS;
  DO I=1,NFIELDS_$DYNJAWS[
  "read in jaw positions for each field"
     read(jaws_unit,'(F15.0)')INDEX_$DYNJAWS(I);
     DO J=1,ISCM_MAX_$DYNJAWS[
       K=(I-1)*ISCM_MAX_$DYNJAWS+J;
       read(jaws_unit,'(6F15.0)')DZMIN_$DYNJAWS(K),DZMAX_$DYNJAWS(K),
                                 DXFP_$DYNJAWS(K), DXBP_$DYNJAWS(K),
                                 DXFN_$DYNJAWS(K), DXBN_$DYNJAWS(K);
       IF(J=1)[
       IF(ICM_$DYNJAWS=1 &
         Z_min_CM(ICM_$DYNJAWS)>DZMIN_$DYNJAWS(K)-AIRGAPMIN_$DYNJAWS)[
         OUTPUT ICM_$DYNJAWS, I, AIRGAPMIN_$DYNJAWS,
         DZMIN_$DYNJAWS(K)-AIRGAPMIN_$DYNJAWS,Z_min_CM(1);
           (//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
            ' In field ',I4,' less than min. airgap (',F8.5,' cm) between top',
            ' of CM and 1st jaws.'/
            ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
           WRITE(IOUTLIST,103)ICM_$DYNJAWS, I, AIRGAPMIN_$DYNJAWS,
              DZMIN_$DYNJAWS(K)-AIRGAPMIN_$DYNJAWS,Z_min_CM(1);
          103 FORMAT(//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
           ' In field ',I4,' less than min. airgap (',F8.5,' cm) between top',
              ' of CM and 1st jaws.'/
              ' Z_min_CM(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
          Z_min_CM(1)=ZMIN_$DYNJAWS(1)-AIRGAPMIN_$DYNJAWS;
       ]
       ELSEIF(Z_min_CM(ICM_$DYNJAWS)>DZMIN_$DYNJAWS(K))[
         OUTPUT ICM_$DYNJAWS,I;
           (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
              'In field ',I4,' overlaps with previous CM'//);
           IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       ELSEIF(Z_min_CM(ICM_$DYNJAWS)>DZMIN_$DYNJAWS(K)-AIRGAPMIN_$DYNJAWS)[
         OUTPUT ICM_$DYNJAWS, I, AIRGAPMIN_$DYNJAWS,
         Z_min_CM(ICM_$DYNJAWS)+AIRGAPMIN_$DYNJAWS,
                DZMIN_$DYNJAWS(K);
           (//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
              ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         WRITE(IOUTLIST,104)ICM_$DYNJAWS, I, AIRGAPMIN_$DYNJAWS,
                Z_min_CM(ICM_$DYNJAWS)+AIRGAPMIN_$DYNJAWS,DZMIN_$DYNJAWS(K);
         104 FORMAT(//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
              ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
              ' top of CM and first jaws.'/
              ' ZMIN(1) reset to ',F8.5,' cm from ',F8.5,' cm'//);
         DZMIN_$DYNJAWS(K)=Z_min_CM(ICM_$DYNJAWS)+AIRGAPMIN_$DYNJAWS;
       ]
   ]
   ELSE[
     IF (DZMAX_$DYNJAWS(K-1)>DZMIN_$DYNJAWS(K))[
        OUTPUT ICM_$DYNJAWS, I, J-1, J;
         (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
         'In field ',I4,' paired bars ',I4,' overlap with paired bars ',I4//);
        IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
     ]
     ELSEIF (DZMAX_$DYNJAWS(K-1)>DZMIN_$DYNJAWS(K)-AIRGAPMIN_$DYNJAWS)[
        OUTPUT ICM_$DYNJAWS, I, AIRGAPMIN_$DYNJAWS, J-1, J, J,
                DZMAX_$DYNJAWS(K-1)+AIRGAPMIN_$DYNJAWS,DZMIN_$DYNJAWS(K);
          (//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
             ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        WRITE(IOUTLIST,105)ICM_$DYNJAWS, I, AIRGAPMIN_$DYNJAWS, J-1, J, J,
                DZMAX_$DYNJAWS(K-1)+AIRGAPMIN_$DYNJAWS,DZMIN_$DYNJAWS(K);
        105 FORMAT(//' ***WARNING IN CM ',I4,' (DYNJAWS):'/
             ' In field ',I4,' less than min. airgap (',F8.5,' cm) between',
             ' jaws ',I4,' and jaws',I4/
             ' ZMIN(',I4,') reset to ',F8.5,' cm from ',F8.5,' cm'//);
        DZMIN_$DYNJAWS(K)=DZMAX_$DYNJAWS(K-1)+AIRGAPMIN_$DYNJAWS;
     ]
   ]
   IF(DZMIN_$DYNJAWS(K) >= DZMAX_$DYNJAWS(K))[
      OUTPUT ICM_$DYNJAWS, I, J, J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' ZMIN(',I4,') >= ZMAX(',I4,')'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
   ]
   IF(DZMAX_$DYNJAWS(K)>TZMAX) TZMAX=DZMAX_$DYNJAWS(K);
       IF(ABS(DXFP_$DYNJAWS(K))>RMAX_CM(ICM_$DYNJAWS))[
         OUTPUT ICM_$DYNJAWS, I, J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' XFP(',I4,') beyond RMAX_CM'//);
         IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       IF(ABS(DXBP_$DYNJAWS(K))>RMAX_CM(ICM_$DYNJAWS))[
          OUTPUT ICM_$DYNJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' XBP(',I4,') beyond RMAX_CM'//);
          IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       IF(ABS(DXFN_$DYNJAWS(K))>RMAX_CM(ICM_$DYNJAWS))[
          OUTPUT ICM_$DYNJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' XFN(',I4,') beyond RMAX_CM'//);
          IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       IF(ABS(DXBN_$DYNJAWS(K))>RMAX_CM(ICM_$DYNJAWS))[
          OUTPUT ICM_$DYNJAWS, I,J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' XBN(',I4,') beyond RMAX_CM'//);
          IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       IF(DXFP_$DYNJAWS(K) < DXFN_$DYNJAWS(K))[
          OUTPUT ICM_$DYNJAWS,I, J, J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' XFP(',I4,') < XFN(',I4,')'//);
          IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       ELSEIF(DXFP_$DYNJAWS(K) - DXFN_$DYNJAWS(K) < $BDY_TOL*3 )[
          DXFP_$DYNJAWS(K) = DXFP_$DYNJAWS(K) + $BDY_TOL*2;
          DXFN_$DYNJAWS(K) = DXFN_$DYNJAWS(K) - $BDY_TOL*2;
       ]
       IF(DXBP_$DYNJAWS(K) < DXBN_$DYNJAWS(K))[
          OUTPUT ICM_$DYNJAWS, I,J, J;
        (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
           'In field ',I4,' XBP(',I4,') < XBN(',I4,')'//);
          IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
       ]
       ELSEIF(DXBP_$DYNJAWS(K) - DXBN_$DYNJAWS(K) < $BDY_TOL*3 )[
          DXBP_$DYNJAWS(K) = DXBP_$DYNJAWS(K) + $BDY_TOL*2;
          DXBN_$DYNJAWS(K) = DXBN_$DYNJAWS(K) - $BDY_TOL*2;
       ]
     ]
  ]
  CLOSE(UNIT=jaws_unit);

  OUTPUT;('******JAWS SEQUENCE FILE READ******');
  IF (MODE_$DYNJAWS=1) [
      OUTPUT; ('**dynamic delivery**');
  ]
  ELSEIF (MODE_$DYNJAWS=2) [
      OUTPUT; ('**step and shoot delivery**');
  ]
]

"set absolute region number to first region in CM for next set of inputs"
IRA = IRSTART_$DYNJAWS; "absolute region number
OUTPUT ; (/'  Now input data re ECUT and PCUT for each region'/
         /' For central region which is assumed to be air'
         /' ECUT,       PCUT,   DOSE ZONE OF AIR,   REGION TO BIT '/' : ',$);
MINPUT ($DYNJAWS) ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
        (2F15.0,2I5);
OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA); (2F11.5,2I5);
IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
"get material for each bar and determine material number for these regions
MED(IRA) = AIR_INDEX; " medium of air
"
"now get info on each set of jaws"
DO IR_$DYNJAWS = 2, N_$DYNJAWS-1, 3[
   IRA = IRSTART_$DYNJAWS  + IR_$DYNJAWS - 1;"this is absolute region number"
   "central region air, so pick up same parameters as assigned above"
   "this is redundant on first time thru loop"
   ECUT(IRA-1) = ECUT(IRSTART_$DYNJAWS);
   PCUT(IRA-1) = PCUT(IRSTART_$DYNJAWS);
   DOSE_ZONE(IRA-1) = DOSE_ZONE(IRSTART_$DYNJAWS);
   MED(IRA-1) = AIR_INDEX; " medium of air
   OUTPUT IR_$DYNJAWS/3 + 1 ; (/' Paired bars/jaws no:',I3,
         /' ECUT,        PCUT,       DOSE ZONE,    IREGION_TO_BIT '/' :',$);
  ;MINPUT ($DYNJAWS) ECUT(IRA), PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F15.0,2I5);
  ;OUTPUT ECUT(IRA),PCUT(IRA), DOSE_ZONE(IRA),
          IREGION_TO_BIT(IRA); (2F11.5,2I5);
   IREGION_TO_BIT(IRA -1) = IREGION_TO_BIT(IRSTART_$DYNJAWS);
   IF (ECUT(IRA) <  ECUTIN) ECUT(IRA)=ECUTIN;
   IF (PCUT(IRA) <  PCUTIN) PCUT(IRA)=PCUTIN;
   "get material for each bar and determine material number for these regions
   OUTPUT;(' Medium in this region',$);
   $MED_INPUT($DYNJAWS); " inputs character array MED_IN from unit 5, loops
      "through array MEDIA(24,I) to check if medium was previously input.
      "If so, sets MED_INDEX to index of previous medium.  If not,
      "increments NMED and sets MED_INDEX to NMED.
      "error transfers to :ERROR_$DYNJAWS:
   MED(IRA) = MED_INDEX; " medium of the planar slab
   "both parts of jaw are same material so transfer parameters"
   ECUT(IRA+1) = ECUT(IRA);
   PCUT(IRA+1) = PCUT(IRA);
   DOSE_ZONE(IRA+1) = DOSE_ZONE(IRA);
   IREGION_TO_BIT(IRA +1) = IREGION_TO_BIT(IRA);
   MED(IRA+1) = MED(IRA); "
] "end of loop over IR_$DYNJAWS"
;
"  set up region numbers
"  =====================
"
"  CM has 4xISCM_MAX_$DYNJAWS regions, series of paired bars/jaws surrounded
"  by an air region.  paired bars are numbered in sequence starting from the
"  furthest upstream.
"
IREND_$DYNJAWS = IRSTART_$DYNJAWS + N_$DYNJAWS-1;  "Index of last region
NREG = NREG+N_$DYNJAWS;           "Total number of regions in full geometry up
                                "to and including this CM
IF (NREG <= $MXREG) ["have not exceeded maximum region number
      "Index of first region in next CM:"
      IR_start_CM(ICM_$DYNJAWS+1) = IREND_$DYNJAWS+1;
]
ELSE [
      OUTPUT ICM_$DYNJAWS,NREG,$MXREG;
      (//'***ERROR IN CM ',I4,' (DYNJAWS):'/
         I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_$DYNJAWS)=IERR_GEOM(ICM_$DYNJAWS)+1;
]
"
"  parameter definition
"  ====================
"
"geometrical coordinates
"
"
IF(MODE_$DYNJAWS=0)[
DO I = 1, ISCM_MAX_$DYNJAWS[
   APO_$DYNJAWS(I) = (XBP_$DYNJAWS(I)-XFP_$DYNJAWS(I))/
                           (ZMAX_$DYNJAWS(I) - ZMIN_$DYNJAWS(I));
   ANE_$DYNJAWS(I) = (XBN_$DYNJAWS(I)-XFN_$DYNJAWS(I))/
                           (ZMAX_$DYNJAWS(I) - ZMIN_$DYNJAWS(I));
   BPO_$DYNJAWS(I) =  XFP_$DYNJAWS(I) - ZMIN_$DYNJAWS(I)*APO_$DYNJAWS(I);
   BNE_$DYNJAWS(I) =  XFN_$DYNJAWS(I) - ZMIN_$DYNJAWS(I)*ANE_$DYNJAWS(I);
   COSP_$DYNJAWS(I)= (ZMAX_$DYNJAWS(I) - ZMIN_$DYNJAWS(I))/
                 SQRT( (ZMAX_$DYNJAWS(I) - ZMIN_$DYNJAWS(I))**2
                      +( XBP_$DYNJAWS(I) - XFP_$DYNJAWS(I) )**2 );
   COSN_$DYNJAWS(I)= (ZMAX_$DYNJAWS(I) - ZMIN_$DYNJAWS(I))/
                 SQRT( (ZMAX_$DYNJAWS(I) - ZMIN_$DYNJAWS(I))**2
                       + (XBN_$DYNJAWS(I) - XFN_$DYNJAWS(I))**2 );
]

BDYTOL = $BDY_TOL;
DO I = 1,ISCM_MAX_$DYNJAWS ["loop through bars"
   XFPT_$DYNJAWS(I,1)  = XFP_$DYNJAWS(I) + BDYTOL;
   XFPT_$DYNJAWS(I,2)  = XFP_$DYNJAWS(I) - BDYTOL;
   XBPT_$DYNJAWS(I,1)  = XBP_$DYNJAWS(I) + BDYTOL;
   XBPT_$DYNJAWS(I,2)  = XBP_$DYNJAWS(I) - BDYTOL;
   XFNT_$DYNJAWS(I,1)  = XFN_$DYNJAWS(I) - BDYTOL;
   XFNT_$DYNJAWS(I,2)  = XFN_$DYNJAWS(I) + BDYTOL;
   XBNT_$DYNJAWS(I,1)  = XBN_$DYNJAWS(I) - BDYTOL;
   XBNT_$DYNJAWS(I,2)  = XBN_$DYNJAWS(I) + BDYTOL;
   BPOT_$DYNJAWS(I,1) =  BPO_$DYNJAWS(I) + BDYTOL;
   BPOT_$DYNJAWS(I,2) =  BPO_$DYNJAWS(I) - BDYTOL;
   BNET_$DYNJAWS(I,1) =  BNE_$DYNJAWS(I) - BDYTOL;
   BNET_$DYNJAWS(I,2) =  BNE_$DYNJAWS(I) + BDYTOL;
] "end of loop over I"

]
"
"establish start of next CM
IF(MODE_$DYNJAWS=0)[
Z_min_CM(ICM_$DYNJAWS+1) = ZMAX_$DYNJAWS(ISCM_MAX_$DYNJAWS);
]
ELSE[
Z_min_CM(ICM_$DYNJAWS+1) = TZMAX;
]
"
"
ZFRONT_$DYNJAWS = Z_min_CM(ICM_$DYNJAWS);
ZBACK_$DYNJAWS = Z_min_CM(ICM_$DYNJAWS+1);
"
"  establish CM boundary is a square
"  =================================
"
RMAX_CM_FLAG(ICM_$DYNJAWS) = 2; "=> put a square boundary about CM

"
"  establish dose-scoring zones and range rejection parameters for each region
"  ===========================================================================
"
IRA = IRSTART_$DYNJAWS-1; "absolute region number
DO IR_$DYNJAWS=1,N_$DYNJAWS ["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones and latch
   "
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones"
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT);

   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region
] "end of loop over IR_$DYNJAWS
E_min_out(ICM_$DYNJAWS)=ECUT(IRA); "Minimum energy on exit from CM


"   return from INPUT_JAWS
"   =======================
"
RETURN;

"   error messages
"   ==============
"
:EOF_$DYNJAWS:
;OUTPUT ICM;(//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_$DYNJAWS:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

:no-jaws-data-file:
;OUTPUT;(//' *** ERROR: DYNJAWS position data file could not be opened');
STOP;
END;  "End of INPUT_$DYNJAWS"
%E   "Start of subroutine ISUMRY_$DYNJAWS (Rev 1.8)"
"*******************************************************************************
"
"                          Subroutine ISUMRY_JAWS
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters that
" require medium information obtained from HATCH call.
"
"*******************************************************************************

;SUBROUTINE ISUMRY_$DYNJAWS;


;IMPLICIT NONE;

;COMIN/
   BOUNDS,CMs,CM_$DYNJAWS,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;

"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_JAWS
"T>**********************************
"T>

INTEGER
   ICOLOUR,   "T>colour of CM for EGS_Windows
   IRA,       "T>absolute region number
   I,J;       "T>DO loop index

$REAL
   XYMAX,     "T>X or Y boundary
   VOLAIR_$DYNJAWS,  "T>air volume
   VOL_$DYNJAWS($MAX_N_$DYNJAWS); "T>volume of air between bar
CHARACTER*1 XY_CHOICE(1);

"   Mass of dose zone
"   =================
"Need to calculate mass of dose zone here, after call to HATCH, where the region
"density is set if it was allowed to default in INPUT_$DYNJAWS.
"
IRA = IRSTART_$DYNJAWS-2; "absolute region number
VOLAIR_$DYNJAWS=(ZBACK_$DYNJAWS-ZFRONT_$DYNJAWS)*
            4.*RMAX_CM2(ICM_$DYNJAWS);"air volume"
DO I = 1,ISCM_MAX_$DYNJAWS [
  IRA=IRA+3;
   VOL_$DYNJAWS(I)=(ZMAX_$DYNJAWS(I)-ZMIN_$DYNJAWS(I))*
               (4.*RMAX_CM2(ICM_$DYNJAWS)-
               RMAX_CM(ICM_$DYNJAWS)*
               ABS(XFP_$DYNJAWS(I)+
               XBP_$DYNJAWS(I)-XFN_$DYNJAWS(I)-
               XBN_$DYNJAWS(I)));
   VOLAIR_$DYNJAWS=VOLAIR_$DYNJAWS-VOL_$DYNJAWS(I);
   IF(DOSE_ZONE(IRA)~=0) [ "this is a dose zone"
      ID=DOSE_ZONE(IRA);
     AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOL_$DYNJAWS(I);
   ]
] "end of loop over IR_$DYNJAWS"
IRA = IRSTART_$DYNJAWS; "absolute region number
IF(DOSE_ZONE(IRA)~=0) ["this is a dose zone"
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+RHOR(IRA)*VOLAIR_$DYNJAWS;
]


"   Summarize geometrical information for this component module in listing file
"   ===========================================================================
"
WRITE(IOUTLIST,110) ICM_$DYNJAWS,TITLE_$DYNJAWS;
WRITE(IOUTLIST,120) Z_min_CM(ICM_$DYNJAWS),RMAX_CM(ICM_$DYNJAWS);
WRITE(IOUTLIST,122);
DO I=1, ISCM_MAX_$DYNJAWS[
   IF(I=1)[
        WRITE(IOUTLIST,124)'airgap',Z_min_CM(ICM_$DYNJAWS),ZMIN_$DYNJAWS(1)-
                           Z_min_CM(ICM_$DYNJAWS),'NA','NA','NA','NA',
                           'NA';
   ]
   ELSE[
        WRITE(IOUTLIST,124)'airgap',ZMAX_$DYNJAWS(I-1),ZMIN_$DYNJAWS(I)-
                           ZMAX_$DYNJAWS(I-1),'NA','NA','NA','NA',
                           'NA';
   ]
   IF(IXY_CHOICE_$DYNJAWS(I) = 0)[XY_CHOICE(1) ='x';]
   ELSE[XY_CHOICE(1) ='y';]
   WRITE(IOUTLIST,123)I,ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I)-
                      ZMIN_$DYNJAWS(I),XY_CHOICE(1),
                      XFP_$DYNJAWS(I),XBP_$DYNJAWS(I),
                      XFN_$DYNJAWS(I),XBN_$DYNJAWS(I);
]
WRITE(IOUTLIST,130);
IRA = IRSTART_$DYNJAWS-1;
DO I = 1, ISCM_MAX_$DYNJAWS [
   IRA = IRSTART_$DYNJAWS + 3*(I-1);
   IF(MED(IRA)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+1,I,'airgap',
        ECUT(IRA),PCUT(IRA), ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
        WRITE(IOUTLIST,141)'above &';
        WRITE(IOUTLIST,141)'centre';
   ]
   IF(MED(IRA+1)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),(MEDIA(J,MED(IRA+1)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+2,I,'+ve jaw',
        ECUT(IRA+1),PCUT(IRA+1), ECUTRR(IRA+1),ESAVE(IRA+1),
        DOSE_ZONE(IRA+1),
         IREGION_TO_BIT(IRA+1),'V','a','c','u','u','m';
   ]
   IF(MED(IRA+2)~=0)[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),(MEDIA(J,MED(IRA+2)),J=1,9);
   ]
   ELSE[
      WRITE(IOUTLIST,140) 3*(I-1)+3,I,'-ve jaw',
        ECUT(IRA+2),PCUT(IRA+2), ECUTRR(IRA+2),ESAVE(IRA+2),
        DOSE_ZONE(IRA+2),
         IREGION_TO_BIT(IRA+2),'V','a','c','u','u','m';
   ]
   WRITE(IOUTLIST,141)' ';
]
110 FORMAT(///1X,79('-')/
'  Component module',I3,' is JAWS (Rev 1.8)'
           /1X,79('-')
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'$DYNJAWS geometry parameters:',
           /T2,'-----------------------------',
           /T2,'Distance of front of CM from reference plane = ',
           F15.5,' cm',
           /T2,'Half-width of outer boundary of CM = ',F15.5,' cm');
122 FORMAT(/T2,
'jaw #    Z front    thickness    x or y               coordinates',
/T2,
'          face                   jaws        FP       BP       FN',
'      BN',
/T2,
'          (cm)        (cm)                                (cm)');
123 FORMAT(T2,I3,F12.3,F11.3,9X,A1,F12.3,F9.3,F9.3,F9.3);
124 FORMAT(T2,A6,F9.3,F11.3,8X,A2,A11,A9,A9,A8);
130 FORMAT(/T2,'$DYNJAWS region parameters:',
           /T2,'---------------------------',
           /T2,'local jaw #   location  electron  photon',
           '  range-rejection   dose  bit  medium'
           /T2,'region                   cutoff   cutoff',
           '   level     max    zone  set'
           /T2,'                          (MeV)    (MeV)',
           '   (MeV)    (MeV)');
140 FORMAT(T2,I3,I7,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,2X,9A1);
141 FORMAT(15X,A7);


"   Output representation of this component module to file for EGS_Windows
"   ======================================================================
"
IF (IWATCH = 4 | IZLAST = 2) ["Graphics file requested"
   ;$SELECT-COLOUR; "Macro for selecting ICOLOUR = 1, 2, or 3, colour of CM"
   DO I =1,ISCM_MAX_$DYNJAWS["Loop over local region number"
      XYMAX = RMAX_CM(ICM_$DYNJAWS);
         IF(IXY_CHOICE_$DYNJAWS(I) = 0)[
            WRITE(IOUTGEOM,200)
               ICOLOUR,'COLX',XYMAX,XFP_$DYNJAWS(I),XBP_$DYNJAWS(I),XYMAX,XYMAX,
               ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I);
            WRITE(IOUTGEOM,200)
              ICOLOUR,'COLX',XFN_$DYNJAWS(I),-XYMAX,-XYMAX,XBN_$DYNJAWS(I),
              XYMAX, ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I);
         ]
         ELSEIF(IXY_CHOICE_$DYNJAWS(I) = 1)[
            J = ICOLOUR-1;
            IF(J < 1)[J = 4;]
            WRITE(IOUTGEOM,200)
               J,'COLY',XYMAX,XFP_$DYNJAWS(I),XBP_$DYNJAWS(I),XYMAX,XYMAX,
               ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I);
            WRITE(IOUTGEOM,200)
               J,'COLY',XFN_$DYNJAWS(I),-XYMAX,-XYMAX,XBN_$DYNJAWS(I),XYMAX,
               ZMIN_$DYNJAWS(I),ZMAX_$DYNJAWS(I);
         ]
   ]
] "End of graphics output"

200 FORMAT(' ',I1,A4,10(F7.2,','));

"   end of ISUMRY_JAWS
"   ===================
"
RETURN;
END;  "End of subroutine ISUMRY_$DYNJAWS"

%E   "Start of subroutine HOWNEAR_$DYNJAWS (Rev 1.8)"
"******************************************************************************
"
"                          Subroutine HOWNEAR_JAWS
"                          ***********************
"
" Returns min. distance to nearest region boundary
" Replaces the old HOWNEAR macro.
"
"*******************************************************************************
;SUBROUTINE HOWNEAR_$DYNJAWS(DIST);


$IMPLICIT-NONE;

COMIN/CM_$DYNJAWS,STACK,USER/;

$REAL DIST; "T> min. distance to nearest boundary

IR_$DYNJAWS = IR(NP)-IRSTART_$DYNJAWS+1;
ISCM_$DYNJAWS = (IR_$DYNJAWS-1)/3 + 1;
XY_$DYNJAWS = X(NP);
UV_$DYNJAWS = U(NP);
IF(IXY_CHOICE_$DYNJAWS(ISCM_$DYNJAWS) = 1)[
   XY_$DYNJAWS = Y(NP);
   UV_$DYNJAWS = V(NP);
]
IF(IR_$DYNJAWS = 3*ISCM_$DYNJAWS-1) [ "particle in positive bars"
   DIST = COSP_$DYNJAWS(ISCM_$DYNJAWS)
          *(XY_$DYNJAWS-APO_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP)
           -BPOT_$DYNJAWS(ISCM_$DYNJAWS,2));
   DIST = MIN(DIST,
              ZMAX_$DYNJAWS(ISCM_$DYNJAWS)-Z(NP),
              Z(NP) - ZMIN_$DYNJAWS(ISCM_$DYNJAWS));
]
ELSEIF(IR_$DYNJAWS = 3*ISCM_$DYNJAWS) [ "particle in negative bars"
   DIST = COSN_$DYNJAWS(ISCM_$DYNJAWS)
          *(ANE_$DYNJAWS(ISCM_$DYNJAWS)*Z(NP)
          +BNET_$DYNJAWS(ISCM_$DYNJAWS,2)-XY_$DYNJAWS) ;
   DIST = MIN(DIST,
              ZMAX_$DYNJAWS(ISCM_$DYNJAWS) - Z(NP),
              Z(NP) - ZMIN_$DYNJAWS(ISCM_$DYNJAWS) );
]
ELSE[ "particle in air"
   DIST = 0.0;
]
RETURN;
END; "End of subroutine HOWNEAR_$DYNJAWS (Rev 1.8)"
"*******************************************************************************
"End of JAWS_cm.mortran (Rev 1.8)"
