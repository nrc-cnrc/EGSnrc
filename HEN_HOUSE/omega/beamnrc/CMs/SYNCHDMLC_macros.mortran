%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module macros: synchronized dynamic HDMLC 120     "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Tony Popescu, 2010                                        "
"                   Julio Lobo, 2010                                          "
"                                                                             "
"  Contributors:    Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally derived from the existing BEAMnrc DYNVMLC         "
"  component module and contributed back to NRC by the authors in 2013.       "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
"  radiotherapy treatments units. BEAM was originally developed at the        "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin, and was originally      "
"  described in:                                                              "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%C80
%Q1
"************************************************************************"
"         -------------------------------------------------------        "
"        Modifications by Tony Popsescu and Julio Lobo  (2012)           "
"         *******************************************************        "
"         Modifications were made to HDDYN to allow for                  "
"         - dynamic delivery using sequence file                         "
"	  - synchronization with other CMs and DOSXYZnrc		 "
"         In practice, SYNCHDMLC is similar to SYNCVMLC but includes     "
"         The definitions of two classes of target/isocentre leaves:     "
"         half and quarter.                                              "

"--------------------------------------------------------------------"
"     SYNCHDMLC miscellaneous replacement macros                    "
"--------------------------------------------------------------------"
"                                                                    "
REPLACE {$MAX_N_$SYNCHDMLC} WITH {{REDUCE $MAXIMUM_N_$SYNCHDMLC}};
"       ==========="

REPLACE {$MAXIMUM_N_$SYNCHDMLC} WITH {3};
"       ==================="

" THE MAX # OF the leaves TO BE ALLOWED IN THIS MODULE"
REPLACE {$MAXLEAF} WITH {160}

" The max no. of different fields--dynamic and step-and-shoot only"
REPLACE {$MAXFIELD_$SYNCHDMLC} WITH {1024}

"used for arrays that store data for each leaf for each field"
REPLACE {$MAXFIELDLEAF} WITH {{COMPUTE $MAXLEAF*$MAXFIELD_$SYNCHDMLC}}
;
"---------------------------------------------------------------------"
"     SYNCHDMLC component module common                              "
"---------------------------------------------------------------------"

"V>COMMON/CM_$SYNCHDMLC/
"V>================
"V>ICM_$SYNCHDMLC        = index of CM, set as ICM in INPUT_$SYNCHDMLC,not reset
"V>IRSTART_$SYNCHDMLC    = first region number for this CM
"V>IREND_$SYNCHDMLC      = last region number for this CM
"V>N_$SYNCHDMLC          = number of regions in CM
"V>TITLE_$SYNCHDMLC      = title of CM
"V>ZMIN_$SYNCHDMLC       = Front of SYNCHDMLC
"V>ZMAX_$SYNCHDMLC       = back of SYNCHDMLC
"V>ZTHICK_$SYNCHDMLC     = Thickness of leaves
"V>ZFRONT_$SYNCHDMLC     = Upstream Z boundary of this CM
"V>NGROUP_$SYNCHDMLC     = the number of groups of leaves where the leaves
"V>                         in each group have the same width
"V>NUM_LEAF_$SYNCHDMLC(I)= the number of leaves in group I
"V>LEAFWIDTH_$SYNCHDMLC(I)=the width of each leaf in group I at ZMIN_$SYNCHDMLC
"V>                          excluding the tongue
"V>TOT_LEAF_$SYNCHDMLC   = the total number of leaves in the MLC
"V>ORIENT_$SYNCHDMLC     = the index to indicate the leave direction
"V>                      0: default, leaf orientation in y
"V>                      1:                           in x
"V>START_$SYNCHDMLC      = the start position wrt the CAX of the lowermost
"V>                       leaf ie leaf 1 tongue as projected to ZMIN_$SYNCHDMLC
"V>HOLEPOS_$SYNCHDMLC(I) =distance from leaf tip to start of driving screw hole
"V>                      for each leaf in group I
"V>LEAFGAP_$SYNCHDMLC   = the width of the interleaf air gap at ZMIN_$SYNCHDMLC
"V>ENDTYPE_$SYNCHDMLC    = the leaf end geomery ( 0 = rounded, 1 = focused )
"V>LEAFRADIUS_$SYNCHDMLC = the radius of the leaf end if ENDTYPE_$SYNCHDMLC = 0
"V>ZREG_$SYNCHDMLC(TOT_LEAF_$SYNCHDMLC,8) =z boundaries of 7 sub-regions in
"V>                                     z direction
"V>YREG_$SYNCHDMLC(TOT_LEAF_$SYNCHDMLC,7)
"V>                   = the boundaries along the perpendicular direction
"V>                     to the leaf orientation of sub-regions
"V>SUBINDEX_$SYNCHDMLC   = an index number to represent which region the
"V>          belongs in based on sub-dividing each leaf into regions.
"V>ZFOCUS_$SYNCHDMLC(2) = the two focus point coordinates: 1. for leave side
"V>                                                  2. for leave end.
"V>SURPARA1_$SYNCHDMLC($MAXLEAF,6)  the parameters to describe the leaf side
"V>                               surface i.e. tangent along that side.
"V>LEAFA_$SYNCHDMLC(TOT_LEAF_$SYNCHDMLC) = coordinates of A side leaves at
"V>                     ZMIN_$SYNCHDMLC if ENDTYPE_$SYNCHDMLC = 1 or at
"V>                    rounded leaf tip @ ZMIN_$SYNCHDMLC+(ZTHICK_$SYNCHDMLC)/2
"V>LEAFB_$SYNCHDMLC(TOT_LEAF_$SYNCHDMLC) = coordinates of B side leaves at
"V>                     ZMIN_$SYNCHDMLC if ENDTYPE_$SYNCHDMLC = 1 or at
"V>                   rounded leaf tip @ ZMIN_$SYNCHDMLC+(ZTHICK_$SYNCHDMLC)/2.
"V>SURPARA2_B_$SYNCHDMLC($MAXLEAF)the parameters to describe the leaf end
"V>                               surface i.e. tangent along that end.
"V>SURPARA2_A_$SYNCHDMLC($MAXLEAF)the parameters to describe the leaf end
"V>                               surface i.e. tangent along that end.
"V>IR_$SYNCHDMLC          local region number
"V>LEAFTYPE_$SYNCHDMLC(I) Leaf type of leaf I: 1=FULL leaf
"V>                                          2=HALF TARGET leaf
"V>                                          3=HALF ISOCENTER leaf
"V>                                          4=QUARTER TARGET leaf
"V>                                          5=QUARTER ISOCENTER leaf
"V>LEAFWIDTH_$SYNCHDMLC(LEAFTYPE) = width of leaf of type LEAFTYPE excl. tongue
"V>WTONGUE_$SYNCHDMLC(LEAFTYPE) = width of tongue for LEAFTYPE leaves
"V>WGROOVE_$SYNCHDMLC(LEAFTYPE) = width of groove for LEAFTYPE leaves
"V>WTIP_$SYNCHDMLC(LEAFTYPE) = width of leaf tip for LEAFTYPE leaves
"V>WRAILTOP_$SYNCHDMLC(LEAFTYPE) = width of upper support rail for LEAFTYPE
"V>WRAILBOT_$SYNCHDMLC(LEAFTYPE) = width of lower support rail for LEAFTYPE
"V>ZTIP_$SYNCHDMLC(LEAFTYPE) = Z where leaf tip starts/ends for LEAFTYPE
"V>ZLEAF_$SYNCHDMLC(LEAFTYPE) = Z where leaf starts/ends for LEAFTYPE
"V>ZTONGUE_$SYNCHDMLC(LEAFTYPE) = Z where tongue starts/ends for LEAFTYPE
"V>ZGROOVE_$SYNCHDMLC(LEAFTYPE) = Z where groove starts/ends for LEAFTYPE
"V>ZHOLETOP_$SYNCHDMLC(LEAFTYPE) = Z of top of driving screw hole for LEAFTYPE
"V>ZHOLEBOT_$SYNCHDMLC(LEAFTYPE) = Z of bottom of driving screw hole
"V>HOLEPOS_FULL/TAR/ISO_$SYNCHDMLC = Distance of hole from leaf tip for leaf
"V>                                type specified.  Later stored in
"V>                                HOLEPOS_$SYNCHDMLC(I) for each leaf.
"V>ZRAILTOP_$SYNCHDMLC(LEAFTYPE) = Z of upper support rail for LEAFTYPE
"V>ZRAILBOT_$SYNCHDMLC(LEAFTYPE) = Z of lower support rail for LEAFTYPE
"V>MIN_PLANE_$SYNCHDMLC  min. plane perp. to leaf direction.  For particles
"V>                    in leaves with position < MIN_PLANE_$SYNCHDMLC,
"V>                    air gaps and driving screw holes will be ignored when
"V>                    doing range rejection (IGNOREGAPS_$SYNCHDMLC=1)
"V>MAX_PLANE_$SYNCHDMLC  max. plane perp. to leaf direction.  For particles
"V>                    in leaves with position > MAX_PLANE_$SYNCHDMLC,
"V>                    air gaps and driving screw holes will be ignored when
"V>                    doing range rejection (IGNOREGAPS_$SYNCHDMLC=1)
"V>IGNOREGAPS_$SYNCHDMLC Set to 1 to ignore air gaps and driving screw holes
"I>                    when doing range rejection
"V>                    for particles in the leaves and beyond the most open
"V>                    leaf.  0 (default) otherwise.
;
REPLACE{;COMIN/CM_$SYNCHDMLC/;} WITH {
;COMMON/CM_$SYNCHDMLC/
      ZMAX_$SYNCHDMLC,
      ZFRONT_$SYNCHDMLC,
      START_$SYNCHDMLC,
      HOLEPOS_$SYNCHDMLC,
      LEAFGAP_$SYNCHDMLC,
      SURPARA1_$SYNCHDMLC,
      ZREG_$SYNCHDMLC,
      YREG_$SYNCHDMLC,
      LEAFWIDTH_$SYNCHDMLC,WTONGUE_$SYNCHDMLC,WGROOVE_$SYNCHDMLC,
      WTIP_$SYNCHDMLC,WRAILTOP_$SYNCHDMLC,WRAILBOT_$SYNCHDMLC,
      ZTIP_$SYNCHDMLC,ZLEAF_$SYNCHDMLC,
      ZTONGUE_$SYNCHDMLC,ZGROOVE_$SYNCHDMLC,ZHOLETOP_$SYNCHDMLC,
      ZHOLEBOT_$SYNCHDMLC,
      HOLEPOS_FULL_$SYNCHDMLC,HOLEPOS_TAR_$SYNCHDMLC,HOLEPOS_ISO_$SYNCHDMLC,
      HOLEPOS_QTAR_$SYNCHDMLC,HOLEPOS_QISO_$SYNCHDMLC,
      ZRAILTOP_$SYNCHDMLC,ZRAILBOT_$SYNCHDMLC,
      ICM_$SYNCHDMLC,IRSTART_$SYNCHDMLC,IREND_$SYNCHDMLC,N_$SYNCHDMLC,
      N_GAP_$SYNCHDMLC,
      IR_$SYNCHDMLC,NUM_LEAF_$SYNCHDMLC, ORIENT_$SYNCHDMLC,
      SUBINDEX_$SYNCHDMLC,NGROUP_$SYNCHDMLC,
      LEAFTYPE_$SYNCHDMLC,
      TITLE_$SYNCHDMLC;
   DOUBLE PRECISION
      ZMAX_$SYNCHDMLC,
      ZFRONT_$SYNCHDMLC,
      START_$SYNCHDMLC,
      HOLEPOS_$SYNCHDMLC($MAXLEAF),
      LEAFGAP_$SYNCHDMLC,
      SURPARA1_$SYNCHDMLC($MAXLEAF,7),
      ZREG_$SYNCHDMLC($MAXLEAF,10),
      YREG_$SYNCHDMLC($MAXLEAF,7);
  $REAL
      LEAFWIDTH_$SYNCHDMLC(5),WTONGUE_$SYNCHDMLC(5),WGROOVE_$SYNCHDMLC(5),
      WTIP_$SYNCHDMLC(5),WRAILTOP_$SYNCHDMLC(5),WRAILBOT_$SYNCHDMLC(5),
      ZTIP_$SYNCHDMLC(5),ZLEAF_$SYNCHDMLC(5),
      ZTONGUE_$SYNCHDMLC(5),ZGROOVE_$SYNCHDMLC(5),ZHOLETOP_$SYNCHDMLC(5),
      ZHOLEBOT_$SYNCHDMLC(5),
      HOLEPOS_FULL_$SYNCHDMLC,HOLEPOS_TAR_$SYNCHDMLC,HOLEPOS_ISO_$SYNCHDMLC,
      HOLEPOS_QTAR_$SYNCHDMLC,HOLEPOS_QISO_$SYNCHDMLC,
      ZRAILTOP_$SYNCHDMLC(5),ZRAILBOT_$SYNCHDMLC(5);
  INTEGER
      ICM_$SYNCHDMLC,IRSTART_$SYNCHDMLC,IREND_$SYNCHDMLC,N_$SYNCHDMLC,
      N_GAP_$SYNCHDMLC,IR_$SYNCHDMLC,NUM_LEAF_$SYNCHDMLC($MAXLEAF),
      ORIENT_$SYNCHDMLC,SUBINDEX_$SYNCHDMLC($MAXLEAF,5,6,9),
      NGROUP_$SYNCHDMLC,
      LEAFTYPE_$SYNCHDMLC($MAXLEAF);
  CHARACTER*1 TITLE_$SYNCHDMLC(60);

}
 "end of replacement defining common for this CM"

"V>COMMON/USERSYNCHDMLC/
"V>
"V> the following variables are required in the the main beam code
"V> to set leaf positions during the simulation when dynamic and step-and-shoot
"V> (MODE_$SYNCHDMLC=1,2) options are used.  This common block is part of
"V> the larger USER common block.  It is defined as {;} in
"V> beamnrc_user_macros.mortran, but is superceded by this definition if
"V> SYNCHDMLC is present in the accelerator.
"V>
"V>LEAFA_$SYNCHDMLC($MAXLEAF) = coordinates of A (+ve) side leaves at
"V>                     ZMIN_$SYNCHDMLC if ENDTYPE_$SYNCHDMLC = 1 or at
"V>                     rounded leaf tip @ ZMIN_$SYNCHDMLC+(ZTHICK_$SYNCHDMLC)/2
"V>LEAFB_$SYNCHDMLC($MAXLEAF) = coordinates of B (-ve) side leaves at
"V>                     ZMIN_$SYNCHDMLC if ENDTYPE_$SYNCHDMLC = 1 or at
"V>                    rounded leaf tip @ ZMIN_$SYNCHDMLC+(ZTHICK_$SYNCHDMLC)/2.
"V>SURPARA2_B_$SYNCHDMLC($MAXLEAF)the parameters to describe the leaf end
"V>                               surface i.e. tangent along that end.
"V>SURPARA2_A_$SYNCHDMLC($MAXLEAF)the parameters to describe the leaf end
"V>                               surface i.e. tangent along that end.
"V>ZFOCUS_$SYNCHDMLC(2) = the two focus point coordinates: 1. for leave side
"V>                                                  2. for leave end.
"V>ZMIN_$SYNCHDMLC       = Front of SYNCHDMLC
"V>ZTHICK_$SYNCHDMLC     = Thickness of leaves
"V>MIN_PLANE_$SYNCHDMLC  min. plane perp. to leaf direction.  For particles
"V>                    in leaves with position < MIN_PLANE_$SYNCHDMLC,
"V>                    air gaps and driving screw holes will be ignored when
"V>                    doing range rejection (IGNOREGAPS_$SYNCHDMLC=1)
"V>MAX_PLANE_$SYNCHDMLC  max. plane perp. to leaf direction.  For particles
"V>                    in leaves with position > MAX_PLANE_$SYNCHDMLC,
"V>                    air gaps and driving screw holes will be ignored when
"V>                    doing range rejection (IGNOREGAPS_$SYNCHDMLC=1)
"V>LEAFRADIUS_$SYNCHDMLC = the radius of the leaf end if ENDTYPE_$SYNCHDMLC = 0
"V>LEAFNEG_$SYNCHDMLC($MAXFIELDLEAF)=negative opening coordinates for all leaves
"V>                                  for all fields.
"V>                              LEAFNEG_$SYNCHDMLC(J+(I-1)*TOT_LEAF_$SYNCHDMLC)
"V>                                  defines coordinate for leaf J in field I
"V>LEAFPOS_$SYNCHDMLC($MAXFIELDLEAF)=positive opening coordinates for all leaves
"V>                                  for all fields.
"V>INDEX_$SYNCHDMLC($MAXFIELD) = index for field I.  If INDEX_$SYNCHDMLC(I)>=
"V>                            RNDM1_$SYNCHDMLC then field I is used.
"V>INDEX1_$SYNCHDMLC,INDEX2_$SYNCHDMLC = temporary variables to store
"V>                                  INDEX_$SYNCHDMLC(I) values so that
"V>                                  leaf positions can be interpolated during
"V>                                  dynamic simulations
"V>POS1_$SYNCHDMLC,POS2_$SYNCHDMLC,NEG1_$SYNCHDMLC,NEG2_$SYNCHDMLC = temporary
"V>                               variables to store LEAFNEG_$SYNCHDMLC and
"V>                               LEAFPOS_$SYNCHDMLC to allow leaf positions
"V>                               to be interpolated during dynamic field
"V>                               simulations
"V>RNDM1_$SYNCHDMLC = random no. (0,1) selected before each history and compared
"V>                 to INDEX_$SYNCHDMLC(I) to determin what field to use
"V>NFIELDS_$SYNCHDMLC = no. of fields
"V>MODE_$SYNCHDMLC = 0 for static field
"V>                1 for dynamic field
"V>                2 for step-and-shoot
"V>I_$SYNCHDMLC,J_$SYNCHDMLC = looping indices
"V>TOT_LEAF_$SYNCHDMLC = total no. of leaves in MLC
"V>IGNOREGAPS_$SYNCHDMLC Set to 1 to ignore air gaps and driving screw holes
"I>                    when doing range rejection
"V>                    for particles in the leaves and beyond the most open
"V>                    leaf.  0 (default) otherwise.
"V>ENDTYPE_$SYNCHDMLC    = the leaf end geomery ( 0 = rounded, 1 = focused )
"V>MININD_$SYNCHDMLC,MAXIND_$SYNCHDMLC = indices used to determine
"V>                               MIN_PLANE_$SYNCHDMLC and MAX_PLANE_$SYNCHDMLC

REPLACE {;COMIN/USER-$SYNCHDMLC/;} WITH {;
COMMON/USER$SYNCHDMLC/LEAFA_$SYNCHDMLC($MAXLEAF),
LEAFB_$SYNCHDMLC($MAXLEAF),SURPARA2_B_$SYNCHDMLC($MAXLEAF),
SURPARA2_A_$SYNCHDMLC($MAXLEAF),ZMIN_$SYNCHDMLC,
ZFOCUS_$SYNCHDMLC(2),ZTHICK_$SYNCHDMLC,
MIN_PLANE_$SYNCHDMLC,MAX_PLANE_$SYNCHDMLC,LEAFRADIUS_$SYNCHDMLC,
LEAFNEG_$SYNCHDMLC($MAXFIELDLEAF),
LEAFPOS_$SYNCHDMLC($MAXFIELDLEAF),INDEX_$SYNCHDMLC($MAXFIELD_$SYNCHDMLC),
INDEX1_$SYNCHDMLC,INDEX2_$SYNCHDMLC,POS1_$SYNCHDMLC,POS2_$SYNCHDMLC,
NEG1_$SYNCHDMLC,NEG2_$SYNCHDMLC,RNDM1_$SYNCHDMLC,
NFIELDS_$SYNCHDMLC,MODE_$SYNCHDMLC,J_$SYNCHDMLC,I_$SYNCHDMLC,
TOT_LEAF_$SYNCHDMLC,ENDTYPE_$SYNCHDMLC,IGNOREGAPS_$SYNCHDMLC,MININD_$SYNCHDMLC,
MAXIND_$SYNCHDMLC;
DOUBLE PRECISION LEAFA_$SYNCHDMLC,LEAFB_$SYNCHDMLC,
       SURPARA2_B_$SYNCHDMLC,SURPARA2_A_$SYNCHDMLC,ZMIN_$SYNCHDMLC,
       ZFOCUS_$SYNCHDMLC,ZTHICK_$SYNCHDMLC,MIN_PLANE_$SYNCHDMLC,
       MAX_PLANE_$SYNCHDMLC,LEAFRADIUS_$SYNCHDMLC;
$REAL LEAFNEG_$SYNCHDMLC,LEAFPOS_$SYNCHDMLC,INDEX_$SYNCHDMLC,
      INDEX1_$SYNCHDMLC,INDEX2_$SYNCHDMLC,POS1_$SYNCHDMLC,
      POS2_$SYNCHDMLC,NEG1_$SYNCHDMLC,NEG2_$SYNCHDMLC,RNDM1_$SYNCHDMLC;
$INTEGER NFIELDS_$SYNCHDMLC,MODE_$SYNCHDMLC,
      J_$SYNCHDMLC,I_$SYNCHDMLC,TOT_LEAF_$SYNCHDMLC,ENDTYPE_$SYNCHDMLC,
      IGNOREGAPS_$SYNCHDMLC,MININD_$SYNCHDMLC,MAXIND_$SYNCHDMLC;
$INTEGER BIMIN_$SYNCHDMLC, BIMAX_$SYNCHDMLC, BIMID_$SYNCHDMLC;
}

"Macro called upon each history to determine the field no. and set the"
"opening coordinates"

REPLACE {$SYNCHDMLC_SET_COMP} WITH {;
IF(MODE_$SYNCHDMLC=1 | MODE_$SYNCHDMLC=2)[
  IF(BEAM_MU_INDEX=BEAM_MU_INDEX_OLD)[
  "added by Tony Popescu and Julio Lobo to communicate setting."
  "The random number has not been set before this CM"
       $RANDOMSET RNDM1_$SYNCHDMLC;
       BEAM_MU_INDEX = RNDM1_$SYNCHDMLC;
  ]
  ELSE[
       "the random number has already been set before this CM"
       "so use this already set number"

       RNDM1_$SYNCHDMLC = BEAM_MU_INDEX;
  ]

    IF (RNDM1_$SYNCHDMLC < INDEX_$SYNCHDMLC(NFIELDS_$SYNCHDMLC))  [

        "Binary search"
        IF (RNDM1_$SYNCHDMLC < INDEX_$SYNCHDMLC(1)) [
            BIMAX_$SYNCHDMLC = 1;
        ]
        ELSE [
            BIMIN_$SYNCHDMLC = 1;
            BIMAX_$SYNCHDMLC = NFIELDS_$SYNCHDMLC;
            WHILE (BIMIN_$SYNCHDMLC < BIMAX_$SYNCHDMLC-1) [
                BIMID_$SYNCHDMLC = BIMIN_$SYNCHDMLC +
                          (BIMAX_$SYNCHDMLC-BIMIN_$SYNCHDMLC)/2;
                IF (INDEX_$SYNCHDMLC(BIMID_$SYNCHDMLC) >= RNDM1_$SYNCHDMLC) [
                BIMAX_$SYNCHDMLC = BIMID_$SYNCHDMLC; ]
                ELSE [ BIMIN_$SYNCHDMLC = BIMID_$SYNCHDMLC; ];
            ]
        ]
        I_$SYNCHDMLC = BIMAX_$SYNCHDMLC;

         INDEX2_$SYNCHDMLC = INDEX_$SYNCHDMLC(I_$SYNCHDMLC);
         IF(MODE_$SYNCHDMLC=1 & I_$SYNCHDMLC>1)
                 INDEX1_$SYNCHDMLC = INDEX_$SYNCHDMLC(I_$SYNCHDMLC-1);
         DO J_$SYNCHDMLC=1,TOT_LEAF_$SYNCHDMLC[
           NEG2_$SYNCHDMLC = LEAFNEG_$SYNCHDMLC(J_$SYNCHDMLC+(I_$SYNCHDMLC-1)*
                                              TOT_LEAF_$SYNCHDMLC);
           POS2_$SYNCHDMLC = LEAFPOS_$SYNCHDMLC(J_$SYNCHDMLC+(I_$SYNCHDMLC-1)*
                                              TOT_LEAF_$SYNCHDMLC);
           IF(MODE_$SYNCHDMLC=1 & I_$SYNCHDMLC>1)[
             NEG1_$SYNCHDMLC = LEAFNEG_$SYNCHDMLC(J_$SYNCHDMLC+(I_$SYNCHDMLC-2)*
                                              TOT_LEAF_$SYNCHDMLC);
             POS1_$SYNCHDMLC = LEAFPOS_$SYNCHDMLC(J_$SYNCHDMLC+(I_$SYNCHDMLC-2)*
                                              TOT_LEAF_$SYNCHDMLC);
             LEAFB_$SYNCHDMLC(J_$SYNCHDMLC)=NEG1_$SYNCHDMLC+
                     (NEG2_$SYNCHDMLC-NEG1_$SYNCHDMLC)*
                     ((RNDM1_$SYNCHDMLC-INDEX1_$SYNCHDMLC)/
                      (INDEX2_$SYNCHDMLC-INDEX1_$SYNCHDMLC));
             LEAFA_$SYNCHDMLC(J_$SYNCHDMLC)=POS1_$SYNCHDMLC+
                        (POS2_$SYNCHDMLC-POS1_$SYNCHDMLC)*
                        ((RNDM1_$SYNCHDMLC-INDEX1_$SYNCHDMLC)/
                       (INDEX2_$SYNCHDMLC-INDEX1_$SYNCHDMLC));
           ]
           ELSE[
             LEAFB_$SYNCHDMLC(J_$SYNCHDMLC)=NEG2_$SYNCHDMLC;
             LEAFA_$SYNCHDMLC(J_$SYNCHDMLC)=POS2_$SYNCHDMLC;
           ]
           IF(ENDTYPE_$SYNCHDMLC=1)[
             SURPARA2_B_$SYNCHDMLC(J_$SYNCHDMLC)=LEAFB_$SYNCHDMLC(J_$SYNCHDMLC)/
                                        (ZMIN_$SYNCHDMLC-ZFOCUS_$SYNCHDMLC(2) );
             SURPARA2_A_$SYNCHDMLC(J_$SYNCHDMLC)=LEAFA_$SYNCHDMLC(J_$SYNCHDMLC)/
                                        (ZMIN_$SYNCHDMLC-ZFOCUS_$SYNCHDMLC(2) );
           ]
           IF(IGNOREGAPS_$SYNCHDMLC=1 & IREJCT_GLOBAL>0)[
             IF(J_$SYNCHDMLC=1)[
               MININD_$SYNCHDMLC=J_$SYNCHDMLC;
               MAXIND_$SYNCHDMLC=J_$SYNCHDMLC;
             ]
             ELSE[
               IF(LEAFB_$SYNCHDMLC(J_$SYNCHDMLC)<
			LEAFB_$SYNCHDMLC(J_$SYNCHDMLC-1))
                     MININD_$SYNCHDMLC=J_$SYNCHDMLC;
               IF(LEAFA_$SYNCHDMLC(J_$SYNCHDMLC)>
			LEAFA_$SYNCHDMLC(J_$SYNCHDMLC-1))
                     MAXIND_$SYNCHDMLC=J_$SYNCHDMLC;
             ]
           ]
         ]
         IF(IGNOREGAPS_$SYNCHDMLC=1 & IREJCT_GLOBAL>0)[
           IF(ENDTYPE_$SYNCHDMLC=1)[
              MIN_PLANE_$SYNCHDMLC=MIN(LEAFB_$SYNCHDMLC(MININD_$SYNCHDMLC),
                        SURPARA2_B_$SYNCHDMLC(MININD_$SYNCHDMLC)*
                      (ZMIN_$SYNCHDMLC+ZTHICK_$SYNCHDMLC-ZFOCUS_$SYNCHDMLC(2)));
              MAX_PLANE_$SYNCHDMLC=MAX(LEAFB_$SYNCHDMLC(MAXIND_$SYNCHDMLC),
                         SURPARA2_B_$SYNCHDMLC(MAXIND_$SYNCHDMLC)*
                      (ZMIN_$SYNCHDMLC+ZTHICK_$SYNCHDMLC-ZFOCUS_$SYNCHDMLC(2)));
           ]
           ELSE[
              MIN_PLANE_$SYNCHDMLC=LEAFB_$SYNCHDMLC(MININD_$SYNCHDMLC)-
                         LEAFRADIUS_$SYNCHDMLC+
                       SQRT(LEAFRADIUS_$SYNCHDMLC**2-(ZTHICK_$SYNCHDMLC/2.)**2);
              MAX_PLANE_$SYNCHDMLC=LEAFA_$SYNCHDMLC(MAXIND_$SYNCHDMLC)+
                         LEAFRADIUS_$SYNCHDMLC-
                       SQRT(LEAFRADIUS_$SYNCHDMLC**2-(ZTHICK_$SYNCHDMLC/2.)**2);
           ]
         ]
    ]
]

}

;
" $SYNCHDMLC_FIND(REGION, DISTANCE)"
"======================================="
" this macro is used to determine the region #"
"{p1}: the return region value, local region"
"{p2}: the step dist which is used to calc. the particle final position"
REPLACE {$SYNCHDMLC_FIND(#,#);} WITH {;
    XYFL(1)=XYL(1)+{P2}*UVL(1);
    XYFL(2)=XYL(2)+{P2}*UVL(2);
    ZFL=Z(NP)+{P2}*W(NP);
IF((W(NP)>0. & ZFL>=ZMAX_$SYNCHDMLC) | (W(NP)<0. & ZFL<=ZFRONT_$SYNCHDMLC)) [
    OUTOFCMFLAG=1;];
"put in = signs to get this to exit stepping loop in HOWFAR"
IF(N_GAP_$SYNCHDMLC=1 & ZFL<=ZMIN_$SYNCHDMLC & ZFL>=ZFRONT_$SYNCHDMLC) [
		      {P1}=4; ]
ELSE ["inside leaf bank"
  LEAFIS=0;
  DO I = 1,TOT_LEAF_$SYNCHDMLC [ "Determine which leaf we are in"
    TEMP1=SURPARA1_$SYNCHDMLC(I,1)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
    TEMP2=SURPARA1_$SYNCHDMLC(I,7)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
   IF(XYFL(1)>=TEMP1 & TEMP2>=XYFL(1)) [
     LEAFIS=I; EXIT; ];
   ];

  IF(LEAFIS=0) [
    {P1}=1;
    OUTOFMLCFLAG=1;
   " OUTPUT LEAFIS,XYFL(2),XYFL(1),ZFL,{P1};"
  "(//I2,': ',(F12.8),',', (F12.8), ',', (F12.8), ' ->',(I3) //)"

  ] "assume going into air"
 " IF(LEAFIS=0) [{P1}=0;OUTOFMLCFLAG=1;] assume going into air, set"
                                        "{P1}=2 for going into solid block"
  ELSE [
    IF(ZFL<ZREG_$SYNCHDMLC(LEAFIS,1))[
       NZ=1;
    ]
    ELSEIF(ZFL>ZREG_$SYNCHDMLC(LEAFIS,10))[
       NZ=9;
    ]
    ELSE[
     DO I = 1,9 [ "Determine Z region"
      IF(ZFL>=ZREG_$SYNCHDMLC(LEAFIS,I) & ZREG_$SYNCHDMLC(LEAFIS,I+1)>=ZFL) [
         NZ=I; EXIT; ];
     ];
    ]
    IF(NZ~=9 & W(NP)>0)[
     DO I=NZ+1,10[
       IF(I=10 | ZREG_$SYNCHDMLC(LEAFIS,I)>ZFL) EXIT;
       NZ=I;
     ]
    ]
    TEMP1=SURPARA1_$SYNCHDMLC(LEAFIS,1)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
    TEMP2=SURPARA1_$SYNCHDMLC(LEAFIS,7)*(ZFL-ZFOCUS_$SYNCHDMLC(1));

    IF(XYFL(1)<TEMP1)[
       NY=1;
    ] ELSEIF(XYFL(1)>TEMP2)[
       NY=6;
    ] ELSE[

      DO I =1,6 [ "Determine Y region"

        TEMP1=SURPARA1_$SYNCHDMLC(LEAFIS,I)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
        TEMP2=SURPARA1_$SYNCHDMLC(LEAFIS,I+1)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
        IF(XYFL(1)>=TEMP1 & TEMP2>=XYFL(1)) [
          NY=I; EXIT;
        ];
      ];
    ]

    IF(NY~=6 & XYFL(1)=SURPARA1_$SYNCHDMLC(LEAFIS,NY+1)*
      (ZFL-ZFOCUS_$SYNCHDMLC(1)) & UVL(1)>0) [

      NY=NY+1;
    ];

    IF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=2 | LEAFTYPE_$SYNCHDMLC(LEAFIS)=4) [
       "Originally on Target (Quarter or Half) Leaf"

       IF((NY=5|NY=6) & (NZ=7|NZ=8|NZ=9) & (LEAFIS~=TOT_LEAF_$SYNCHDMLC)) [

         "In groove check if on next leaf"
         IF(XYFL(1)>SURPARA1_$SYNCHDMLC(LEAFIS+1,1)*
            (ZFL-ZFOCUS_$SYNCHDMLC(1))) [

           LEAFIS=LEAFIS+1;
           TEMP1=SURPARA1_$SYNCHDMLC(LEAFIS,1)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
           TEMP2=SURPARA1_$SYNCHDMLC(LEAFIS,7)*(ZFL-ZFOCUS_$SYNCHDMLC(1));

           IF(XYFL(1)<TEMP1)[
             NY=1;
           ] ELSEIF(XYFL(1)>TEMP2)[
             NY=6;
           ] ELSE[

             DO I=1,6 ["check y region"
               TEMP1=SURPARA1_$SYNCHDMLC(LEAFIS,I)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
              TEMP2=SURPARA1_$SYNCHDMLC(LEAFIS,I+1)*(ZFL-ZFOCUS_$SYNCHDMLC(1));
               IF(XYFL(1)>=TEMP1 & TEMP2>=XYFL(1)) [NY=I; EXIT;];
             ]
           ]

           IF(NY~=6 & XYFL(1)=SURPARA1_$SYNCHDMLC(LEAFIS,NY+1)*
              (ZFL-ZFOCUS_$SYNCHDMLC(1)) & UVL(1)>0) [NY=NY+1;];
           IF(ZFL<ZREG_$SYNCHDMLC(LEAFIS,1))[
             NZ=1;
           ] ELSEIF(ZFL>ZREG_$SYNCHDMLC(LEAFIS,10))[
             NZ=9;
           ] ELSE[
             DO I=1,9 [ "recheck Z region"
              IF((ZFL>=ZREG_$SYNCHDMLC(LEAFIS,I)) &
                (ZREG_$SYNCHDMLC(LEAFIS,I+1)>=ZFL)) [NZ=I; EXIT;];
             ];
           ]

           IF(NZ~=9 & W(NP)>0)[
             DO I=NZ+1,10[
               IF(I=10 | ZREG_$SYNCHDMLC(LEAFIS,I)>ZFL) EXIT;
               NZ=I;
             ]
           ]
       ];
     ];
   ] ELSE [
     "Full or Isocenter (either Quarter or Half) leaf"

     IF ((NY=6 & NZ<=4 & (LEAFIS~=TOT_LEAF_$SYNCHDMLC)
         & ((LEAFTYPE_$SYNCHDMLC(LEAFIS)=3) | (LEAFTYPE_$SYNCHDMLC(LEAFIS)=1)))
         | (NY=6 & NZ<=3 & (LEAFIS~=TOT_LEAF_$SYNCHDMLC)
            & (LEAFTYPE_$SYNCHDMLC(LEAFIS)=5))) [
       "In groove for Half Isocenter or Full OR Quarter Isocenter"

       IF(XYFL(1)>SURPARA1_$SYNCHDMLC(LEAFIS+1,1)*
             (ZFL-ZFOCUS_$SYNCHDMLC(1))) [

         LEAFIS=LEAFIS+1;
         NY=1;
         IF(ZFL<ZREG_$SYNCHDMLC(LEAFIS,1))[
              NZ=1;
         ] ELSEIF(ZFL>ZREG_$SYNCHDMLC(LEAFIS,10))[
              NZ=9;
         ] ELSE[
             DO I=1,9 ["recheck Z region"
              IF((ZFL>=ZREG_$SYNCHDMLC(LEAFIS,I)) &
                (ZREG_$SYNCHDMLC(LEAFIS,I+1)>=ZFL)) [NZ=I; EXIT];
              ];
         ]

         IF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=2 | LEAFTYPE_$SYNCHDMLC(LEAFIS)=4) [
         "Half Target or Quarter Target leaf (we were in Groove of Iso)"

           IF (NZ>=6) [
             LEAFIS=LEAFIS-1;
             NY=6; "****************"
             IF(ZFL<ZREG_$SYNCHDMLC(LEAFIS,1)) [
                  NZ=1;
             ] ELSEIF(ZFL>ZREG_$SYNCHDMLC(LEAFIS,10)) [
                  NZ=9;
             ] ELSE [
               DO I=1,9 [ "recheck Z"
                    IF((ZFL>=ZREG_$SYNCHDMLC(LEAFIS,I)) &
                      (ZREG_$SYNCHDMLC(LEAFIS,I+1)>=ZFL)) [
                      NZ=I; EXIT;
                    ];
               ];
             ]
           ];
         ] ELSE [
           "Full leaf"
          " OUTPUT; (//'BIMBO'//)  "
           IF(NZ>=4) [
             LEAFIS=LEAFIS-1; NY=6; "****************"

             IF(ZFL<ZREG_$SYNCHDMLC(LEAFIS,1))[
               NZ=1;
             ] ELSEIF(ZFL>ZREG_$SYNCHDMLC(LEAFIS,10))[
               NZ=9;
             ] ELSE[
                    DO I=1,9 [ "recheck Z"
                      IF(ZFL>=ZREG_$SYNCHDMLC(LEAFIS,I) &
                       ZREG_$SYNCHDMLC(LEAFIS,I+1)>=ZFL) [NZ=I; EXIT;];
                    ];
             ]
           ];
         ]
       ];
     ];
    ];
"Now determine X region index"
  IF(ENDTYPE_$SYNCHDMLC=1)[
         TEMP1=SURPARA2_B_$SYNCHDMLC(LEAFIS)*(ZFL-ZFOCUS_$SYNCHDMLC(2));
         TEMP2=SURPARA2_A_$SYNCHDMLC(LEAFIS)*(ZFL-ZFOCUS_$SYNCHDMLC(2));
         HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
         TEMP3=LEAFB_$SYNCHDMLC(LEAFIS)-HOLE;
         TEMP4=LEAFA_$SYNCHDMLC(LEAFIS)+HOLE;
         IF((XYFL(2)>TEMP1 & TEMP2>XYFL(2)) | (TEMP1=XYFL(2) &
             UVL(2)>0.0) | (TEMP2=XYFL(2) & UVL(2)<0.0)) [NX=1;]
         ELSEIF((TEMP1>XYFL(2) & XYFL(2)>TEMP3) |
                (XYFL(2)=TEMP1 & UVL(2)<=0.0) | (XYFL(2)=TEMP3 &
                 UVL(2)>0.0)) [NX=3;]
         ELSEIF((TEMP3>XYFL(2)) | (XYFL(2)=TEMP3 & UVL(2)<=0.0)) [NX=2;]
         ELSEIF((XYFL(2)>TEMP2 & TEMP4>XYFL(2)) |
                (XYFL(2)=TEMP2 & UVL(2)>0.0) |
                (XYFL(2)=TEMP4 & UVL(2)<=0.0)) [NX=4;]
         ELSEIF((XYFL(2)>TEMP4) | (XYFL(2)=TEMP4 & UVL(2)>0.0)) [NX=5;]
      ]
  ELSE [ "rounded leaf tip"
    XoN=LEAFB_$SYNCHDMLC(LEAFIS)-LEAFRADIUS_$SYNCHDMLC;
    XoP=LEAFA_$SYNCHDMLC(LEAFIS)+LEAFRADIUS_$SYNCHDMLC;
    Zo=ZMIN_$SYNCHDMLC + (ZTHICK_$SYNCHDMLC)/2;
    TEMP1=SQRT((XYFL(2)-XoN)**2+(Zo-ZFL)**2)-LEAFRADIUS_$SYNCHDMLC;
    TEMP2=SQRT((XYFL(2)-XoP)**2+(Zo-ZFL)**2)-LEAFRADIUS_$SYNCHDMLC;
    HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
    TEMP3=LEAFB_$SYNCHDMLC(LEAFIS)-HOLE;
    TEMP4=LEAFA_$SYNCHDMLC(LEAFIS)+HOLE;
    IF(XYFL(2)>=XoN & XoP>=XYFL(2) & ((TEMP1>0 & TEMP2>0) |
       (TEMP1=0 & (UVL(2)*(XYFL(2)-XoN)+W(NP)*(ZFL-Zo))>0) |
       (TEMP2=0 & (UVL(2)*(XYFL(2)-XoP)+W(NP)*(ZFL-Zo))>0))) [NX=1;]
    ELSEIF((TEMP1<0 & XYFL(2)>TEMP3) | (XYFL(2)=TEMP3 & UVL(2)>0) |
           (TEMP1=0 & (UVL(2)*(XYFL(2)-XoN)+W(NP)*(ZFL-Zo))<=0)) [
             NX=3;]
    ELSEIF((TEMP3>XYFL(2)) | (XYFL(2)=TEMP3 & UVL(2)<=0)) [NX=2;]
    ELSEIF((TEMP2=0 & (UVL(2)*(XYFL(2)-XoP)+W(NP)*(ZFL-Zo))<=0) |
           (TEMP2<0 & TEMP4>XYFL(2)) | (XYFL(2)=TEMP4 & UVL(2)<0)) [NX=4;]
    ELSEIF((XYFL(2)>TEMP4) | (XYFL(2)=TEMP4 & UVL(2)>=0)) [
         NX=5;]
 ];
 {P1}=SUBINDEX_$SYNCHDMLC(LEAFIS,NX,NY,NZ);

 "OUTPUT LEAFIS,XYFL(2),XYFL(1),ZFL,{P1};"
 "(//'FIND_SYNCHDMLC', I2,': ', (F12.8), ',',(F12.8),',', (F12.8),'->',(I3) //)"

" OUTPUT LEAFIS,{P2},X(NP),XYFL(2),Y(NP),XYFL(1),Z(NP),ZFL,W(NP),{P1};"
"  (//I2,': ',(F12.8),' -> ', (F12.8),' / ',(F12.8),',',(F12.8),' / ',(F12.8),"
"   ',',(F12.8),' / ',(F12.8),',',(F12.8),(I3) //)"
 ]; ]
;}
;

" $SYNCHDMLC_MINDISTANCE;            "
"===============================   "
" The following macro will give the nearest distance the particle"
" can travel along its given direction before it strikes the boundary"
" in the x, y or z direction."
"{P1}: The change value for ir region #"

REPLACE {$SYNCHDMLC_MINDISTANCE(#);} WITH {; "boundaries in Z direction"
  IF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=2 | LEAFTYPE_$SYNCHDMLC(LEAFIS)=4) [
				   "Target leaf"

    IF((NY=1|NY=2) & NZ<=3) [ZLHS=1; ZRHS=4;]
    ELSEIF(NY=1 & NZ=5) [ZLHS=5; ZRHS=6;]
    ELSEIF(NY=1 & NZ>=6) [ZLHS=6; ZRHS=10;]
    ELSEIF(NZ=4) [ZLHS=4; ZRHS=5;]
    ELSEIF((NY=2|NY=3) & NZ>=8) [ZLHS=8; ZRHS=10;]
    ELSEIF((NY=3|NY=4|NY=5) & NZ=1) [ZLHS=1; ZRHS=2;]
    ELSEIF((NY=3|NY=4|NY=5) & NZ=2) [ZLHS=2; ZRHS=3;]
    ELSEIF(NY>=3 & NZ=3) [ZLHS=3; ZRHS=4;]
    ELSEIF((NY=2|NY=3) & (NZ=5|NZ=6|NZ=7)) [ZLHS=5; ZRHS=8;]
    ELSEIF(NY=4 & (NZ=5|NZ=6|NZ=7|NZ=8)) [ZLHS=5; ZRHS=9;]
    ELSEIF(NY=4 & NZ=9) [ZLHS=9; ZRHS=10;]
    ELSEIF((NY=5|NY=6) & (NZ=5|NZ=6)) [ZLHS=5; ZRHS=7;]
    ELSEIF((NY=5|NY=6) & NZ>=7) [ZLHS=7; ZRHS=10;]
    ELSEIF(NY=6 & NZ<=2) [ZLHS=1; ZRHS=3;]

  ] ELSEIF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=1) ["Full leaf"

    IF((NY=1|NY=2) & NZ=1) [ZLHS=1; ZRHS=2;]
    ELSEIF(NY=1 & (NZ=2|NZ=3)) [ZLHS=2; ZRHS=4;]
    ELSEIF(NY=1 & NZ>=4) [ZLHS=4; ZRHS=10;]
    ELSEIF(NY=2 & (NZ=2|NZ=3|NZ=4|NZ=5)) [ZLHS=2; ZRHS=6;]
    ELSEIF(NY>=2 & NZ=6) [ZLHS=6; ZRHS=7;]
    ELSEIF(NY=2 & NZ>=8) [ZLHS=8; ZRHS=10;]
    ELSEIF((NY=3|NY=4|NY=5) & (NZ=1|NZ=2)) [ZLHS=1; ZRHS=3;]
    ELSEIF((NY=3|NY=4|NY=5) & (NZ=3|NZ=4|NZ=5)) [ZLHS=3; ZRHS=6;]
    ELSEIF(NY=3 & NZ>=8) [ZLHS=8; ZRHS=10;]
    ELSEIF((NY=2|NY=3|NY=4) & NZ=7) [ZLHS=7; ZRHS=8;]
    ELSEIF(NY=4 & NZ=8) [ZLHS=8; ZRHS=9;]
    ELSEIF(NY=4 & NZ=9) [ZLHS=9; ZRHS=10;]
    ELSEIF((NY=5|NY=6) & NZ>=7) [ZLHS=7; ZRHS=10;]
    ELSEIF(NY=6 & NZ<=4) [ZLHS=1; ZRHS=5;]
    ELSEIF(NY=6 & NZ=5) [ZLHS=5; ZRHS=6;]

  ] ELSEIF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=3) [
    "Half Isocenter leaf"

    IF((NY=1|NY=2) & NZ<=3) [ZLHS=1; ZRHS=4;]
    ELSEIF((NY=1|NY=2) & (NZ=4|NZ=5)) [ZLHS=4; ZRHS=6;]
    ELSEIF(NZ=6) [ZLHS=6; ZRHS=7;]
    ELSEIF(NY<=4 & NZ=7) [ZLHS=7; ZRHS=8;]
    ELSEIF(NY=1 & NZ>=8) [ZLHS=8; ZRHS=10;]
    ELSEIF((NY=2|NY=3|NY=4) & NZ=8) [ZLHS=8; ZRHS=9;]
    ELSEIF((NY=2|NY=3|NY=4) & NZ=9) [ZLHS=9; ZRHS=10;]
    ELSEIF(NY=3 & NZ=1) [ZLHS=1; ZRHS=2;]
    ELSEIF(NY=3 & (NZ=2|NZ=3|NZ=4|NZ=5)) [ZLHS=2; ZRHS=6;]
    ELSEIF((NY=4|NY=5) & NZ<=2) [ZLHS=1; ZRHS=3;]
    ELSEIF((NY=4|NY=5) & (NZ=3|NZ=4|NZ=5)) [ZLHS=3; ZRHS=6;]
    ELSEIF((NY=5|NY=6) & NZ>=7) [ZLHS=7; ZRHS=10;]
    ELSEIF(NY=6 & NZ<=4) [ZLHS=1; ZRHS=5;]
    ELSEIF(NY=6 & NZ=5) [ZLHS=5; ZRHS=6;]

  ] ELSE [
    "Quarter Isocenter leaf"

    "!= from Half Isocenter"
    IF((NY=1|NY=2) & NZ<=4) [ZLHS=1; ZRHS=5;]
    "!= from Half Isocenter"
    ELSEIF((NY=1|NY=2) & (NZ=5)) [ZLHS=5; ZRHS=6;]
    ELSEIF(NZ=6) [ZLHS=6; ZRHS=7;]
    ELSEIF(NY<=4 & NZ=7) [ZLHS=7; ZRHS=8;]
    ELSEIF(NY=1 & NZ>=8) [ZLHS=8; ZRHS=10;]
    ELSEIF((NY=2|NY=3|NY=4) & NZ=8) [ZLHS=8; ZRHS=9;]
    ELSEIF((NY=2|NY=3|NY=4) & NZ=9) [ZLHS=9; ZRHS=10;]
    ELSEIF(NY=3 & NZ=1) [ZLHS=1; ZRHS=2;]
    ELSEIF(NY=3 & (NZ=2|NZ=3|NZ=4|NZ=5)) [ZLHS=2; ZRHS=6;]
    ELSEIF((NY=4|NY=5) & NZ<=2) [ZLHS=1; ZRHS=3;]
    ELSEIF((NY=4|NY=5) & (NZ=3|NZ=4|NZ=5)) [ZLHS=3; ZRHS=6;]
    ELSEIF((NY=5|NY=6) & NZ>=7) [ZLHS=7; ZRHS=10;]
    "!= from Half Isocenter"
    ELSEIF(NY=6 & NZ<=3) [ZLHS=1; ZRHS=4;]
    "!= from Half Isocenter"
    ELSEIF(NY=6 & (NZ=4|NZ=5)) [ZLHS=4; ZRHS=6;]
  ]

  IF(W(NP)~=0) [
     ZP = (ZREG_$SYNCHDMLC(LEAFIS,ZRHS)-ZFL)/W(NP);
     ZN = (ZREG_$SYNCHDMLC(LEAFIS,ZLHS)-ZFL)/W(NP);
     IF( (ZP>=0.0) & (ZN>=0.0) ) [ ZDIST =MIN(ZP, ZN); ]
     ELSE [ ZDIST = MAX(ZP, ZN); ]
   ]
  ELSE [ ZDIST = 1.0E20; ];
  IF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=2 | LEAFTYPE_$SYNCHDMLC(LEAFIS)=4) [
     "Target leaf"
     IF(NZ=1 & NY<=5) [
       LHS=1; J=LEAFIS;
       RHS=6; I=LEAFIS;
     ] ELSEIF(NZ=1 & NY=6) [
        LHS=6; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=3; I=LEAFIS+1;]
     ] ELSEIF(NZ=2 & NY<=2) [
        LHS=1; J=LEAFIS;
        RHS=3; I=LEAFIS;
     ] ELSEIF(NZ=2 & NY>=3) [
        LHS=3; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=3; I=LEAFIS+1;]
     ] ELSEIF(NZ=3|NZ=4|NZ=5) [
        LHS=1; J=LEAFIS;
        RHS=7; I=LEAFIS;
     ] ELSEIF(NY=1 & (NZ=6|NZ=7)) [
        IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        RHS=2; I=LEAFIS;
     ] ELSEIF(NY>=2 & NZ=6) [
       LHS=2; J=LEAFIS;
       RHS=7; I=LEAFIS;
     ] ELSEIF(NZ=7 & (NY=2|NY=3|NY=4)) [
       LHS=2; J=LEAFIS;
       RHS=5; I=LEAFIS;
     ] ELSEIF((NZ=7|NZ=8) & NY>=5) [
       LHS=5; J=LEAFIS;
       IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
       ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF(NZ=8 & NY<=3) [
       IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
       ELSE [LHS=7; J=LEAFIS-1;]
       RHS=4; I=LEAFIS;
     ] ELSEIF(NZ=8 & NY=4) [
       LHS=4; J=LEAFIS;
       RHS=5; I=LEAFIS;
     ] ELSEIF(NZ=9) [
       IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
       ELSE [LHS=7; J=LEAFIS-1;]
       IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
       ELSE [RHS=1; I=LEAFIS+1;]
     ]
   ]
  ELSEIF(LEAFTYPE_$SYNCHDMLC(LEAFIS)=1) ["full leaf"
     IF(NZ=1) [IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=6; J=LEAFIS-1;]
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
       ]
     ELSEIF(NZ=2 & NY<=2) [LHS=1; J=LEAFIS;
        RHS=3; I=LEAFIS;
       ]
     ELSEIF(NZ=2 & NY>=3) [LHS=3; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
       ]
     ELSEIF(NZ=3 & NY<=5) [LHS=1; J=LEAFIS;
        RHS=6; I=LEAFIS;
       ]
     ELSEIF((NZ=3|NZ=4) & NY=6) [LHS=6; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
       ]
     ELSEIF((NZ=4|NZ=5|NZ=6|NZ=7) & NY=1) [
        IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        RHS=2; I=LEAFIS;
       ]
     ELSEIF(NZ=4 & (NY=2|NY=3|NY=4|NY=5)) [LHS=2; J=LEAFIS;
        RHS=6; I=LEAFIS;
       ]
     ELSEIF((NZ=5|NZ=6|NZ=7) & NY>=2) [LHS=2; J=LEAFIS;
        RHS=7; I=LEAFIS;
       ]
     ELSEIF(NZ=8 & NY<=4) [IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        RHS=5; I=LEAFIS;
       ]
     ELSEIF(NZ=8 & NY>=5) [LHS=5; J=LEAFIS;
        RHS=7; I=LEAFIS;
       ]
     ELSEIF(NZ=9 & NY<=3) [IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
       ELSE [LHS=7; J=LEAFIS-1;]
       RHS=4; I=LEAFIS;
       ]
     ELSEIF(NZ=9 & NY>=4) [LHS=4; J=LEAFIS;
       RHS=7; I=LEAFIS;
       ]
     ]
  ELSEIF (LEAFTYPE_$SYNCHDMLC(LEAFIS)=3) [
     "Isocenter Half"
     IF(NZ=1) [
        IF(LEAFIS=1) [ LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF((NZ=2|NZ=3) & (NY=1|NY=2)) [
        IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        RHS=3; I=LEAFIS;
     ] ELSEIF(NZ=2 & NY=3) [
        LHS=3; J=LEAFIS;
        RHS=4; I=LEAFIS;
     ] ELSEIF(NZ=2 & NY>=4) [
        LHS=4; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF(NZ=3 & (NY=3|NY=4|NY=5)) [
        LHS=3; J=LEAFIS;
        RHS=6; I=LEAFIS;
     ] ELSEIF((NZ=3|NZ=4) & NY=6) [
        LHS=6; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF(NZ=4 & NY<=5) [
        LHS=1; J=LEAFIS;
        RHS=6; I=LEAFIS;
     ] ELSEIF(NZ=5|NZ=6|NZ=7) [
        LHS=1; J=LEAFIS;
        RHS=7; I=LEAFIS;
     ] ELSEIF(NZ=8 & NY<=4) [
        IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=5; J=LEAFIS-1;]
        RHS=5; I=LEAFIS;
     ] ELSEIF(NZ=8 & NY>=5) [
        LHS=5; J=LEAFIS;
        RHS=7; I=LEAFIS;
     ] ELSEIF(NZ=9 & NY=1) [
       IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
       ELSE [LHS=5; J=LEAFIS-1;]
       RHS=2; I=LEAFIS;
     ] ELSEIF(NZ=9 & NY>=2) [
       LHS=2; J=LEAFIS;
       RHS=7; I=LEAFIS;
     ]
   ] ELSE [
     "Isocenter Quarter"
     IF(NZ=1) [
        IF(LEAFIS=1) [ LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF((NZ=2|NZ=3|NZ=4) & (NY=1|NY=2)) [
        "!= from Half Isocenter - Block 2"
        IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=7; J=LEAFIS-1;]
        RHS=3; I=LEAFIS;
     ] ELSEIF(NZ=2 & NY=3) [
        LHS=3; J=LEAFIS;
        RHS=4; I=LEAFIS;
     ] ELSEIF(NZ=2 & NY>=4) [
        LHS=4; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF(NZ=3 & (NY=3|NY=4|NY=5)) [
        LHS=3; J=LEAFIS;
        RHS=6; I=LEAFIS;
     ] ELSEIF(NZ=3 & NY=6) [
        "!= from Half Isocenter - Block 5"
        LHS=6; J=LEAFIS;
        IF(LEAFIS=TOT_LEAF_$SYNCHDMLC) [RHS=7; I=LEAFIS;]
        ELSE [RHS=1; I=LEAFIS+1;]
     ] ELSEIF(NZ=4 & (NY>=3)) [
        "!= from Half Isocenter - Block 7"
        LHS=3; J=LEAFIS;
        RHS=7; I=LEAFIS;
     ] ELSEIF(NZ=5|NZ=6|NZ=7) [
        LHS=1; J=LEAFIS;
        RHS=7; I=LEAFIS;
     ] ELSEIF(NZ=8 & NY<=4) [
        IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
        ELSE [LHS=5; J=LEAFIS-1;]
        RHS=5; I=LEAFIS;
     ] ELSEIF(NZ=8 & NY>=5) [
        LHS=5; J=LEAFIS;
        RHS=7; I=LEAFIS;
     ] ELSEIF(NZ=9 & NY=1) [
       IF(LEAFIS=1) [LHS=1; J=LEAFIS;]
       ELSE [LHS=5; J=LEAFIS-1;]
       RHS=2; I=LEAFIS;
     ] ELSEIF(NZ=9 & NY>=2) [
       LHS=2; J=LEAFIS;
       RHS=7; I=LEAFIS;
     ]
   ];
  IF((UVL(1)-SURPARA1_$SYNCHDMLC(I,RHS)*W(NP))~ = 0 ) [
     YP = (SURPARA1_$SYNCHDMLC(I,RHS)*(ZFL-ZFOCUS_$SYNCHDMLC(1))-XYFL(1));
     YP = YP/(UVL(1) - SURPARA1_$SYNCHDMLC(I,RHS)*W(NP));
    ]
  ELSE [ YP = 1.0E20; ];
  IF((UVL(1) - SURPARA1_$SYNCHDMLC(J,LHS)*W(NP))~ = 0 ) [
     YN = (SURPARA1_$SYNCHDMLC(J,LHS)*(ZFL-ZFOCUS_$SYNCHDMLC(1))-XYFL(1));
     YN = YN/(UVL(1) - SURPARA1_$SYNCHDMLC(J,LHS)*W(NP));
     ]
  ELSE [ YN = 1.0E20; ];
  IF((YP>=0.0) & (YN>=0.0) ) [ YDIST =MIN(YP, YN); ]
  ELSE [ YDIST = MAX(YP,YN);];
 IF(ENDTYPE_$SYNCHDMLC = 1) ["focused leaf end"
      HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
      TEMP3=LEAFB_$SYNCHDMLC(LEAFIS)-HOLE;
      TEMP4=LEAFA_$SYNCHDMLC(LEAFIS)+HOLE;
      IF(NX=1) [
        IF((UVL(2)-SURPARA2_B_$SYNCHDMLC(LEAFIS)*W(NP))~=0) [
          XN=SURPARA2_B_$SYNCHDMLC(LEAFIS)*(ZFL-ZFOCUS_$SYNCHDMLC(2))-XYFL(2);
          XN=XN/(UVL(2)-SURPARA2_B_$SYNCHDMLC(LEAFIS)*W(NP));
        ]
        ELSE [XN=1.0E20;];
        IF((UVL(2)-SURPARA2_A_$SYNCHDMLC(LEAFIS)*W(NP))~=0) [
          XP=SURPARA2_A_$SYNCHDMLC(LEAFIS)*(ZFL-ZFOCUS_$SYNCHDMLC(2))-XYFL(2);
          XP=XP/(UVL(2)-SURPARA2_A_$SYNCHDMLC(LEAFIS)*W(NP));
         ]
        ELSE [XP=1.0E20;];
      ]
      ELSEIF(NX=2) [
        IF(UVL(2)~=0) [XN=(-RMAX_CM(ICM_$SYNCHDMLC)-XYFL(2))/UVL(2);
          XP=(TEMP3-XYFL(2))/UVL(2);
         ]
        ELSE [XN=1.0E20; XP=1.0E20;];
       ]
      ELSEIF(NX=3) [
        IF(UVL(2)~=0) [XN=(TEMP3-XYFL(2))/UVL(2);]
        ELSE [XN=1.0E20;];
        IF((UVL(2)-SURPARA2_B_$SYNCHDMLC(LEAFIS)*W(NP))~=0) [
          XP=SURPARA2_B_$SYNCHDMLC(LEAFIS)*
             (ZFL-ZFOCUS_$SYNCHDMLC(2))-XYFL(2);
          XP=XP/(UVL(2)-SURPARA2_B_$SYNCHDMLC(LEAFIS)*W(NP));
         ]
        ELSE [XP=1.0E20;];
       ]
      ELSEIF(NX=4) [
        IF((UVL(2)-SURPARA2_A_$SYNCHDMLC(LEAFIS)*W(NP))~=0) [
          XN=SURPARA2_A_$SYNCHDMLC(LEAFIS)*
             (ZFL-ZFOCUS_$SYNCHDMLC(2))-XYFL(2);
          XN=XN/(UVL(2)-SURPARA2_A_$SYNCHDMLC(LEAFIS)*W(NP));
         ]
        ELSE [XN=1.0E20;];
        IF(UVL(2)~=0) [XP=(TEMP4-XYFL(2))/UVL(2);]
        ELSE [XP=1.0E20;];
       ]
      ELSEIF(NX=5) [
        IF(UVL(2)~=0) [XN=(TEMP4-XYFL(2))/UVL(2);
          XP=(RMAX_CM(ICM_$SYNCHDMLC)-XYFL(2))/UVL(2);]
        ELSE [XN=1.0E20; XP=1.0E20;];
       ]
   ] "end of focused leaf end"
 ELSE [ "rounded leaf end"
    TEMP1 = UVL(2)**2+W(NP)**2; "A in eqn"
    TEMP2 = UVL(2)*(XYFL(2)-XoN)+W(NP)*(ZFL-Zo); "B in eqn"
    TEMP3 = UVL(2)*(XYFL(2)-XoP)+W(NP)*(ZFL-Zo); "B in eqn"
    TEMP4 = (XYFL(2)-XoN)**2 + (ZFL-Zo)**2; "part of C"
    TEMP5 = (XYFL(2)-XoP)**2 + (ZFL-Zo)**2; "part of C"
    IF((XYFL(2)>=XoN) & (SQRT((XYFL(2)-XoN)**2+(ZFL-Zo)**2)-
      LEAFRADIUS_$SYNCHDMLC=0.0) & (UVL(2)*(XYFL(2)-XoN)+W(NP)*(ZFL-Zo)=0.0)) [
         XN=0.0;  XP=1.0E20; "on edge of negative leaf"
       ]
    ELSEIF((XYFL(2)<=XoP) & (SQRT((XYFL(2)-XoP)**2+(ZFL-Zo)**2)-
            LEAFRADIUS_$SYNCHDMLC=0.0) & (UVL(2)*(XYFL(2)-XoP)+
            W(NP)*(ZFL-Zo)=0.0)) [XP=0;  XN=1.0E20; "on edge of positive leaf"
      ]
    ELSEIF(NX = 1) [ "in centre air"
       "check to see whether it hits negative leaf"
       IF(TEMP2>=0.0 | TEMP1=0.0) [XN=1.0E20;] "no component in z/x direction"
       ELSE [TEMP4=TEMP4-LEAFRADIUS_$SYNCHDMLC**2; "C"
         IF(TEMP4 < 0.0) [TEMP4=0.0;]; "should never happen"
         TEMP1=TEMP2**2-TEMP1*TEMP4; "B^2 - AC"
         IF(TEMP1 < 0.0) [XN=1.0E20;]
         ELSE [
           IF(TEMP4/TEMP2**2 < 1.0E-3) [
             XN=-0.5*TEMP4/TEMP2;
            ]
           ELSE [
             IF(SQRT(TEMP1)-TEMP2~=0.0) [
               XN=TEMP4/(SQRT(TEMP1)-TEMP2);
              ]
             ELSE[XN=1.0E20;];
           ];
          ];
        ]; "now check positive leaf"
       IF(TEMP3>=0.0 | TEMP1=0.0) [XP=1.0E20;]
       ELSE [TEMP5=TEMP5-LEAFRADIUS_$SYNCHDMLC**2; "C"
         IF(TEMP5 < 0.0)[TEMP5=0.0;] "should never happen"
         TEMP1=TEMP3**2-TEMP1*TEMP5; "B^2 - AC"
         IF(TEMP1 < 0.0)[XP=1.0E20;]
         ELSE[
           IF(TEMP5/TEMP3**2 < 1.0E-3)[
             XP=-0.5*TEMP5/TEMP3;
            ]
           ELSE[
             IF(SQRT(TEMP1)-TEMP3~=0.0)[
               XP=TEMP5/(SQRT(TEMP1)-TEMP3);
             ]
             ELSE[XP=1.0E20;];
            ];
          ];
        ];
      ]
    ELSEIF(NX = 3) [ "in negative portion of leaf"
       HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
       XN = ((LEAFB_$SYNCHDMLC(LEAFIS)-HOLE)-XYFL(2))/UVL(2);
       IF(XYFL(2)<=XoN & UVL(2)<0.0) [XP = 1.0E20;]
       ELSE [TEMP4=TEMP4-LEAFRADIUS_$SYNCHDMLC**2; "C"
         IF(TEMP4>0.0 & XYFL(2)>=XoN) [TEMP4=0.0;]; "should never happen"
         IF((TEMP2**2-TEMP1*TEMP4)<0.0) [XP=1.0E20;]
         ELSEIF(TEMP4<=0.0) ["follows rules for being within cylinder"
           IF(TEMP2 > 0.0) [
             IF(TEMP4/TEMP2**2 > -1.0E-3) [XP=-0.5*TEMP4/TEMP2;]
             ELSE [XP=-TEMP4/(SQRT(TEMP2**2-TEMP1*TEMP4)+TEMP2);];
           ]
           ELSEIF(TEMP2 < 0.0) [
             IF(TEMP4/TEMP2**2 > -1.0E-3) [
               XP=-2*TEMP2/TEMP1*(1.-0.25*TEMP1*TEMP4/TEMP2**2);
              ]
             ELSE [XP=(SQRT(TEMP2**2-TEMP1*TEMP4)-TEMP2)/TEMP1;];
           ]
           ELSEIF(TEMP1~=0.0) [XP=SQRT(-TEMP4/TEMP1);]
           ELSE [XP=1.0E20;];
           IF(XYFL(2)+UVL(2)*XP<XoN)[XP=1.0E20;];
         ]
         ELSE [ "we are in the leaf but beyond the cylinder"
           IF(TEMP2>=0.0) [XP=1.0E20;]
           ELSE [XP=(SQRT(TEMP2**2-TEMP1*TEMP4)-TEMP2)/TEMP1;];
           IF(XYFL(2)+UVL(2)*XP<XoN) [XP=1.0E20;];
          ];
      ];
    ]
    ELSEIF(NX=2) [XN=(-RMAX_CM(ICM_$SYNCHDMLC)-XYFL(2))/UVL(2);
      HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
      XP=(LEAFA_$SYNCHDMLC(LEAFIS)-HOLE-XYFL(2))/UVL(2);
     ]
    ELSEIF(NX=4) ["in positive portion of leaf"
       HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
       XP = (LEAFA_$SYNCHDMLC(LEAFIS)+HOLE-XYFL(2))/UVL(2);
       IF(XYFL(2)>=XoP & UVL(2) > 0.0) [XN = 1.0E20;]
       ELSE [TEMP5=TEMP5-LEAFRADIUS_$SYNCHDMLC**2; "C"
         IF(TEMP5>0.0 & XYFL(2)<=XoP) [TEMP5=0.0;]; "should never happen"
         IF(TEMP3**2-TEMP1*TEMP5 < 0.0) [XN=1.0E20;]
         ELSEIF(TEMP5<=0.0) ["follows rules for being within cylinder"
           IF(TEMP3 > 0.0) [
             IF(TEMP5/TEMP3**2 > -1.0E-3) [XN=-0.5*TEMP5/TEMP3;]
             ELSE [XN=-TEMP5/(SQRT(TEMP3**2-TEMP1*TEMP5)+TEMP3);]
            ]
           ELSEIF(TEMP3 < 0.0) [
             IF(TEMP5/TEMP3**2 > -1.0E-3) [
                XN=-2*TEMP3/TEMP1*(1.-0.25*TEMP1*TEMP5/TEMP3**2);
              ]
             ELSE [XN=(SQRT(TEMP3**2-TEMP1*TEMP5)-TEMP3)/TEMP1;];
            ]
           ELSEIF(TEMP1~=0.0) [XN=SQRT(-TEMP5/TEMP1);]
           ELSE [XN=1.0E20;];
           IF(XYFL(2)+UVL(2)*XN>XoP) [XN=1.0E20;]
          ]
         ELSE[ "we are in the leaf but beyond the cylinder"
           IF(TEMP3 >= 0.0) [XN=1.0E20;]
           ELSE [XN=(SQRT(TEMP3**2-TEMP1*TEMP5)-TEMP3)/TEMP1;];
           IF(XYFL(2)+UVL(2)*XN>XoP) [XN=1.0E20;];
          ];
        ];
     ]
   ELSEIF(NX=5) ["in positive portion of leaf"
     HOLE=HOLEPOS_$SYNCHDMLC(LEAFIS);
     XN=(LEAFB_$SYNCHDMLC(LEAFIS)+HOLE-XYFL(2))/UVL(2);
     XP=(RMAX_CM(ICM_$SYNCHDMLC)-XYFL(2))/UVL(2);
   ]
 ];
IF( (XP>=0.0) & (XN>=0.0) ) [ XDIST =MIN(XP, XN); ]
ELSE [ XDIST = MAX(XP,XN); ];
IF( ZDIST>=0.0) [TEMP=ZDIST;
    IF( YDIST>=0.0 ) [TEMP=MIN(TEMP,YDIST);];
    IF( XDIST>=0.0 ) [TEMP=MIN(TEMP,XDIST);];
  ]
ELSEIF ( (YDIST>=0.0) & (XDIST>=0.0) ) [TEMP=MIN(XDIST,YDIST);]
ELSE [TEMP=MAX(XDIST,YDIST);];
IF(TEMP<0) [OUTPUT NX,NY,NZ,LEAFIS; "should not happen"
     ('neg dist nx = ',I3,' NY= ',I3,' NZ= ',I3,' LEAF= ',I3);
   ];
{P1}=TEMP;
;} " End of $SYNCHDMLC_MINDISTANCE macro"
;
" NEXT COMES HOWNEAR MACRO"
"========================="

REPLACE {$SYNCHDMLC_CM_HOWNEAR(#);} WITH {
CALL HOWNEAR_$SYNCHDMLC({P1});
}
;
"End of SYNCHDMLC_macros.mortran"
