%C80
"#############################################################################"
"                                                                             "
"  EGSnrc BEAMnrc component module: synchronized dynamic Elekta MLC           "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Tony Popescu, 2010                                        "
"                   Julio Lobo, 2010                                          "
"                                                                             "
"  Contributors:    Frederic Tessier                                          "
"                   Ernesto Mainegra-Hing                                     "
"                   Blake Walters                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally derived from the existing BEAMnrc MLCE            "
"  component module and contributed back to NRC by the authors in 2010.       "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code is part of the BEAMnrc code system for Monte Carlo simulation of "
"  radiotherapy treatments units. BEAM was originally developed at the        "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin, and was originally      "
"  described in:                                                              "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"


%C80
"***********************************************************************
"
"                             **************               ""toc:
"                             *            *               ""toc:
"                             *    SYNCMLCE    *               ""toc:
"                             *            *               ""toc:
"                             **************               ""toc:
"
"
"************************************************************************
"************************************************************************
"
"
"                          GENERAL DESCRIPTION
"                          *******************
"
"   This set of routines is used in conjunction with BEAM.MORTRAN to
"   simulate one component module of a clinical linear accelerator:
"
"   This component module can be added to the simulation by including these
"   routines in the MORTRAN file BEAM_CM.MORTRAN and including the MORTRAN
"   replacement macros associated with this component module in the file
"   BEAM_COMMON.MORTRAN.  The order of the component modules in either of
"   these files is unimportant.  To explicitly include this component module
"   the simulation it must be included in the $CM_LIST replacement statement.
"   The component modules in this list are stacked sequentially for the
"   simulation, one on top of the other, and must not overlap.
"
"   1>. This module can be used for the Elekta  multileaf
"       collimators.
"   2>. Used as x or y direction parallel to the leaf.
"   3>. it can have max 100 leaf which are equal wide, symmetrical arranged
"       with y axis or x axis.
"   4>. Each leaf has two separate parts which can be moved in the leaf
"       direction independently.
"
;
"I>
"I> Geometry of SYNCMLCE:
"I> *********************
"I>                                 top view
"I>
"I>            ------------------------------------------------
"I>                                |
"I>            ------------------------------------------------
"I>                           |           |
"I>           -----------------           ---------------------
"I>                      |        opening     |
"I>           ---------------     (IR=1)      -----------------
"I>                         |                 |
"I>           ------leaves--------      -----------------------
"I>                 (IR=2)      |     |
"I>           --------------------------------------------------
"I>                                  |
"I>           --------------------------------------------------
"I>
;
"I>       cross-section through leaves taken perpendicular to leaves
"I>
"I>                               * ZFOCUS(1)
"I>                           .   .   .
"I>                       .    . .|. .    .
"I> - - - - - - -     .     .   . | .   .     .
"I> airgap(IR=3)  .      .     .  |  .     .      .
"I>     -------- ------ ------ ---|--- ------ ------ ---------
"I>   leaf     / leaf / leaf /leaf|leaf\ leaf  \ leaf \  leaf
"I>   1    /    2  /     3  /  4  | 5   \  6     \  7    \  8
"I>    /        /          /      |      \          \        \
"I>    -------- ---------- -------|------- ---------- --------- -
"I>                            Z-axis
;
"I>            cross-section through leaf taken || to leaf
"I>
"I>              I)  FOR FOCUSED DIVERGENT LEAF ENDS :
"I>
"I>                               * ZFOCUS(2)
"I>  - - - - - - - - - - - -    . | .
"I>  airgap(IR=3)              .  |  .
"I>     ----------------------    |    ------------------------
"I>                          /    |    \
"I>        Leaf B  (-ve)    /     |     \    Leaf A (+ve)
"I>                        /      |      \
"I>    -------------------        |        ----------------------
"I>                            Z-axis

"I>              II)  FOR ROUNDED LEAF ENDS :
"I>
"I>                               *
"I>  - - - - - - - - - - - -      |
"I>  airgap(IR=3)                 |
"I>     -------------             |              --------------
"I>                   \           |            /
"I>                    |          |           |<------Leafradius
"I>       A           /           |            \    B
"I>     -------------             |              --------------
"I>                            Z-axis
;
"I>   IR is the region number within the CM.  There are three local regions
"I>   shown above.
"I>
"I>
"I>            ------------------------------------------------------
"I>            |             Region            | Description         |
"I>            |-------------------------------|---------------------|
"I>            |  absolute       | local       |                     |
"I>            |-----------------|-------------|                     |
"I>            |                 |             |                     |
"I>            |IRSTART_MLC      | IR_MLC      |  as shown in above  |
"I>            |  +IR_MLC-1      |             |    (1 to 3)         |
"I>            |                 |             |                     |
"I>            |                 |             |                     |
"I>            -------------------------------------------------------
"I>


" Subroutines:
" ************
"                      INPUT_$SYNCMLCE
"                      ISUMRY_$SYNCMLCE
"                      HOWFAR_$SYNCMLCE
"                      WHERE_AM_I_$SYNCMLCE
"
"       Called from BEAM's subroutines:
"                      INPUT
"                      ISUMRY
"                      HOWFAR
"
"       Subroutines called:
"                      WHERE_AM_I (a BEAM subroutine)
"
"************************************************************************
"
"                             RESTRICTIONS ON USE/KNOWN BUGS
"                             *******************
"
"************************************************************************
;
"
"                               INPUT FROM UNIT 5
"                               *****************
"
"I>
"I>  CARDS CM_$SYNCMLCE
"I>  **************
"I>  -1  Dummy line to indicate start of CM
"I>
"I>   0  RMAX_CM(ICM_$SYNCMLCE) (F10.0):  Half-width of CM boundary (cm).
"I>
"I>   1  TITLE_$SYNCMLCE (60A1):  Title of CM.
"I>
"I>   2  ORIENT_$SYNCMLCE, MODE_$SYNCMLCE (2I5)
"I>
"I>        ORIENT_$SYNCMLCE = 0 for leaves parallel to Y direction
"I>                         = 1 for leaves parallel to X direction
"I>        MODE_$SYNCMLCE = 0 for static mode (same as MLCE)
"I>                       = 1 for dynamic mode
"I>                       = 2 for step-and-shoot mode
"I>
"I>   3  NUM_LEAF_$SYNCMLCE: Number of leaves.  Note: this must be even.
"I>
"I>   4  ZMIN_$SYNCMLCE,ZMAX_$SYNCMLCE (2F15.0): upper and lower z coordinates
"I>        of leafbank (before tilt, see below)
"I>
"I>   5  ZSTEPL_$SYNCMLCE, ZSTEPR_$SYNCMLCE: Z-coordinates of left and right
"I>        step in central leaf (an imaginary, unrotated leaf on the Z axis).
"I>
"I>   6  TGW_$SYNCMLCE (F15.0): X (ORIENT_$SYNCMLCE=0) or Y (ORIENT_$SYNCMLCE=1)
"I>        width of steps in central leaf (cm).
"I>
"I>   7  X3_$SYNCMLCE, X4_$SYNCMLCE (2F15.0): X (ORIENT_$SYNCMLCE=0) or Y
"I>         (ORIENT_$SYNCMLCE=1) coordinates of the upper right and
"I>         lower right corners of central leaf, ignoring steps defined above.
"I>
"I>   8  SPACE_$SYNCMLCE, SSD_$SYNCMLCE (2F15.0)
"I>
"I>         SPACE_$SYNCMLCE: distance between centres of adjacent leaves in X
"I>                  (ORIENT_$SYNCMLCE=0) or Y (ORIENT_$SYNCMLCE=1) direction
"I>                  as projected to SSD_$SYNCMLCE (cm).
"I>           SSD_$SYNCMLCE: distance from Z=0 at which SPACE_$SYNCMLCE is
"I>                  defined (cm).
"I>
"I>        Leaf numbers I= 1-NUM_LEAF_$SYNCMLCE/2 are created by rotating a
"I>        duplicate of the central leaf about the axis X=0 (if
"I>        ORIENT_$SYNCMLCE=0) or Y=0 (if ORIENT_$SYNCMLCE=1),
"I>        Z=ZMIN_$SYNCMLCE by an angle:
"I>        ARCTAN(-(2I-1)*SPACE_$SYNCMLCE/2.*ZMIN_$SYNCMLCE/SSD_$SYNCMLCE)
"I>        and then translating it in the X (if ORIENT_$SYNCMLCE=0) or
"I>        or Y (ORIENT_$SYNCMLCE=1) direction by a distance
"I>        -(2I-1)*SPACE_$SYNCMLCE/2.*ZMIN_$SYNCMLCE/SSD_$SYNCMLCE
"I>
"I>    Leaf numbers I= NUM_LEAF_$SYNCMLCE/2+1 NUM_LEAF_$SYNCMLCE are created by
"I>    rotating a duplicate of the central leaf about the axis X=0
"I>    (if ORIENT_$SYNCMLCE=0) or Y=0 (if ORIENT_$SYNCMLCE=1), Z=ZMIN_$SYNCMLCE
"I>    by: ARCTAN((2I-1)*SPACE_$SYNCMLCE/2.*ZMIN_$SYNCMLCE/SSD_$SYNCMLCE)
"I>    and then translating it in the X (if ORIENT_$SYNCMLCE=0) or
"I>    or Y (ORIENT_$SYNCMLCE=1) direction by a distance
"I>    (2I-1)*SPACE_$SYNCMLCE/2.*ZMIN_$SYNCMLCE/SSD_$SYNCMLCE
"I>
"I>   9  LBROT_$SYNCMLCE (F15.0): Leaf bank rototian angle (tilt) about
"I>    X=0 (ORIENT_$SYNCMLCE=0) or Y=0 (ORIENT_$SYNCMLCE=1) and Z=ZMIN_$SYNCMLCE
"I>    (radians).  This is applied to the leaves after they have been
"I>    translated/rotated according to SPACE_$SYNCMLCE, SSD_$SYNCMLCE above.
"I>
"I>  10  ENDTYPE_$SYNCMLCE (I5) : The  type of leaf end :
"I>             0 -- rounded (cylindrical) leaf end and
"I>             1 -- focused divergent leaf end.
"I>
"I>  IF ENDTYPE_$SYNCMLCE=0
"I>  11  LEAFRADIUS_$SYNCMLCE,CIL_$SYNCMLCE (2F15.0)
"I>
"I>          LEAFRADIUS_$SYNCMLCE:  Radius curvature leaf ends
"I>                 CIL_$SYNCMLCE:  Z position from which LEAFRADIUS_$SYNCMLCE
"I>                                 is defined
"I>
"I>  IF ENDTYPE_$SYNCMLCE=1
"I>  11  ZFOCUS_$SYNCMLCE (F15.0):  Z position of focal point of leaf ends
"I>
"I>   If MODE_$SYNCMLCE=0 (static field)
"I>
"I>   Repeat 12a until coordinates of all leaves are defined once.  Leaves
"I>   are numbered 1,2,...NUM_LEAF_$SYNCMLCE, where numbering goes from leaf
"I>   1 to leaf NUM_LEAF_$SYNCMLCE. Convention is lower to upper or
"I>   left to right depending on ORIENT_$SYNCMLCE i.e from negative to
"I>   positive.
"I>
"I>  12a  NEG_$SYNCMLCE, POS_$SYNCMLCE, NUM_$SYNCMLCE (2F15.0,I5)
"I>
"I>    NEG_$SYNCMLCE:   Min. Y (ORIENT_$SYNCMLCE=0) or X (ORIENT_$SYNCMLCE=1)
"I>                   of a) opening in leaf I at ZMIN_$SYNCMLCE (ENDTYPE=1)
"I>                   or b) of origin of cylindrical leaf end (ENDTYPE=0)
"I>    POS_$SYNCMLCE:   Max. Y (ORIENT_$SYNCMLCE=0) or X (ORIENT_$SYNCMLCE=1)
"I>                   of a) opening in leaf I at ZMIN_$SYNCMLCE (ENDTYPE=1)
"I>                   or b) of origin of cylindrical leaf end (ENDTYPE=0)
"I>    NUM_$SYNCMLCE:   Apply NEG_$SYNCMLCE and POS_$SYNCMLCE to leaves
"I>                   I,...,I+NUM_$SYNCMLCE-1.  Defaults to 1 if set <=0.
"I>                   Defaults to NUM_LEAF_$SYNCMLCE-I+1 if set >
"I>                   NUM_LEAF_$SYNCMLCE-I+1.
"I>
"I>   If MODE_$SYNCMLCE=1 (dynamic delivery) or 2 (step-and-shoot delivery)
"I>
"I>  12b  mlc_file (A256): The full name of the file containing leaf opening
"I>                       data.  The format of the file contents is as follows:
"I>
"I>      MLC_TITLE (A80)
"I>      NFIELDS_$SYNCMLCE (I10)
"I>      FOR I=1,NFIELDS_$SYNCMLCE[
"I>       MUINDEX_$SYNCMLCE(I) (F15.0)
"I>       NEG_$SYNCMLCE, POS_$SYNCMLCE, NUM_$SYNCMLCE (2F15.0,I5) -- repeat this
"I>                                                               line until
"I>                                                               coordinates
"I>                                                               for all leaves
"I>                                                               have been
"I>                                                               defined for
"I>                                                               field I.
"I>      ]
"I>
"I>      where:
"I>
"I>              MLC_TITLE:  A title line
"I>      NFIELDS_$SYNCMLCE:  Total number of fields
"I>   MUINDEX_$SYNCMLCE(I):  Fractional monitor unit index up to and including
"I>                          field I. 0 <= MUINDEX_$SYNCMLCE(I) <= 1 and
"I>                          MUINDEX_$SYNCMLCE(I) > MUINDEX_$SYNCMLCE(I-1).
"I>                          This number is compared to a random number on
"I>                          [0,1] at the start of each history; if the random
"I>                          number is <= MUINDEX_$SYNCMLCE(I), then field I is
"I>                          used.
"I>          NEG_$SYNCMLCE:  Min. Y (ORIENT_$SYNCMLCE=0) or X (ORIENT_$SYNCMLCE=
"I>                          1) of front opening in leaf (ie the opening at
"I>                          ZMIN_$SYNCMLCE) if ENDTYPE=1, or of origin of
"I>                          cylinder defining rounded end of leaf if ENDTYPE=0
"I>                          for leaf J in field I.
"I>          POS_$SYNCMLCE:  Max. Y (ORIENT_$SYNCMLCE=0) or X (ORIENT_$SYNCMLCE=
"I>                          1) of front opening in leaf if ENDTYPE=1, or of 9
"I>                          origin of cylinder defining rounded end of leaf if
"I>                          ENDTYPE=0 for leaf J in field I.
"I>          NUM_$SYNCMLCE:  Apply NEG_$SYNCMLCE and POS_$SYNCMLCE to leaves
"I>                          J,...,J+NUM_$SYNCMLCE-1.  Defaults to 1 if set <=0.
"I>                          Defaults to TOT_LEAF_$SYNCMLCE-J+1 if set >
"I>                          TOT_LEAF_$SYNCMLCE-J+1.
"I>
"I>    Note that the inputs NEG_$SYNCMLCE, POS_$SYNCMLCE and NUM_$SYNCMLCE have
"I>    the same meanings as in 12a (static field inputs) but that they must
"I>    now be repeated for every field I.
"I>
"I>
"I>  13   ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in opening(s) and
"I>                                             air gaps (2F15.0,I5)
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to not score dose
"I>    IREGION_TO_BIT:   Bit number associated with this region
"I>
"I>  14  MED_IN (24A1):  Medium in opening(s) and air gaps
"I>                      used to set MED_INDEX.
"I>
"I>  15  ECUT, PCUT, DOSE_ZONE, IREGION_TO_BIT in leaves (2F15.0,I5):
"I>
"I>         ECUT, PCUT:  Cutoff energies for electrons and photons.
"I>         DOSE_ZONE:   Dose scoring flag, 0 to note score dose
"I>    IREGION_TO_BIT:   Bit number associated with this region
"I>
"I>  16  MED_IN (24A1):  Medium of leaves,
"I>                      used to set MED_INDEX.
"I>
"I>   Example
"I>   *******
"I>
"I>   The following example defines a multi-leaf collimator design based
"I>   loosely on that used with the Elekta SLiplus 40 leaf pair.
"I>   Actual parameters are DIFFERENT - this serves just as a template.
"I>   Do not attempt to use these parameters for a simulation of the real
"I>   machine.
"I>
"I>   The collimator starts at Z=30 cm and has 40 tungsten leaves opening
"I>   in the X direction.  The leaves are each ~0.4cm wide and 7.0 cm
"I>   thick.  In this example, the leaf openings will form a barbel shape
"I>   with its long axis parallel to Y.  It will be slightly off-centre
"I>   due to the leaf bank rotation of -0.01 rads.
"I>
"I>   Electrons and photons in both the collimator and the opening regions
"I>   will be followed down to kinetic energies of 10 keV (ECUT=0.521,
"I>   PCUT=0.01).  Dose deposited in the tungsten leaves will be stored
"I>   in dose zone 2, and dose deposited in the opening will be stored
"I>   in dose zone 1.
"I>
"I>   In this example, the MLC is being used in step-and-shoot mode, with
"I>   the leaf opening coordinates specified in a file.
"I>
"I>   26.0,           RMAX_CM
"I>   MLC based on mock 40 leaf pair Elekta SLiplus type of accelerator
"I>   1,2             Leaves open in X direction, step-and-shoot mode
"I>   40,             40 leaf paires
"I>   30.0,37.0,      ZMIN,ZMAX
"I>   34.0, 33.5,     ZSTEPL,ZSTEPR
"I>   0.04,           step width
"I>   0.17,0.2,       X3, X4 of central leaf
"I>   1.2, 100.0,     leaf centres spaced 1.2 cm apart projected to SSD=100cm
"I>   -0.01,          leaf bank tilt angle (radians)
"I>   0,              ENDTYPE IS CURVED
"I>   15.0,33.5,      curvature radius, zposition cylinder axis curvature
"I>   /home/bwalters/HEN_HOUSE/omega/beamnrc/CMs/sample_syncmlce.sequence
"I>  0.5210,  0.010,  1,  0
"I>  AIR700ICRU
"I>  0.5210,  0.010,  2,  0
"I>  W700ICRU
;
"*************************************************************************
"*************************  ERROR CONDITIONS  ****************************
"*************************************************************************
"
"                              SIMULATION PARAMETERS
"                              *********************
"
" Geometry checks:
" ****************
"
"   1)  Overlapping component modules
"
"***********************************************************************

%E "SYNCMLCE_cm.mortran  start of subroutine HOWFAR_$SYNCMLCE (SID 1.12)"
"************************************************************************
"********************Component Module SYNCMLCE *****************************
"************************************************************************
"
"                          Subroutine HOWFAR_$SYNCMLCE
"                          ***********************
"
" HOWFAR routine for stacked planar media.
"
" Determine if current region number is within component module SYNCMLCE,
" evaluate DIST, distance to region boundary along current trajectory.
" USTEP must not exceed DIST.
"
"   There are N_$SYNCMLCE local regions + an air gap (if present):
"
"  local              absolute                       description
"--------   ------------------------------     ----------------------
" IR_$SYNCMLCE   IR_start_CM(ICM_$SYNCMLCE)+IR_$SYNCMLCE-1
" exclude front air gap
"--------   ------------------------------     -----------------------
"   Geometrical co-ordinates, as set in INPUT_$SYNCMLCE are:
"
"   ZFRONT_$SYNCMLCE     front of CM (upstream surface, air region)
"   ZMIN_$SYNCMLCE       front of cone
"   ZBACK_$SYNCMLCE      back of cone
"   RMAX_$SYNCMLCE       radius of last cylinder (largest)
"
"*************************************************************************
;
;SUBROUTINE HOWFAR_$SYNCMLCE;

"V>$GEO_SHIFT_1_(#)
"V>=============
"V>{p1} the value to compare with ustep
"V> if {p1}+1.0e-5 < ustep shift it by 1.0e-5, otherwise use USTEP
;
REPLACE {$GEO_SHIFT_1_(#)} WITH {
  ;{P1}=MIN(USTEP,{P1}+1.0e-5);
}

;IMPLICIT NONE;
;COMIN/CMs,CM_$SYNCMLCE,EPCONT,STACK,GEOM,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR HOWFAR_$SYNCMLCE
"T>**********************************
"T>
INTEGER
   COUNT,
   IRL,        "T>local region number (absolute), required by HOWNEAR macro
   I, J, N,       "T>loop control
   REGION_$SYNCMLCE,     "T>region number within CM (relative)
   NEWREGION_$SYNCMLCE,     "T>region number within CM (relative)
   NX,NY,NZ,        "T> Subindices for region
   OUTOFCMFLAG,     "T> Flag to denote particle out of CM
   OUTOFMLCFLAG,    "T> Flag to denote particle out of MLC
   OFFEDGECM,       "T> Flag to denote particle beyond RMAX_CM
   LEAFIS,          "T> Leaf number
   BETWEEN_LEAF,  "T> Set to 1 if in gap between leaves but not associated
                    "   with any leaf
   ITEL,
   IDIR;        "T> direction sign, used in call to where_am_i

$REAL
   XYL(2),    "T>rearranged x and y coordinates
   DIST,      "T>Distance to z boundary along current particle trajectory
   XYFL(2),   "T>temporary variable
   UVL(2),    "T>temporary variable
   ZFL,
   TRYY1,TRYY2,
   XoN,XoP,    "T> Negative and Positive leaf centers (rounded leaf)
   Zo,         "T> z position of rounded leaf tip
   XP,XN,YP,YN,ZP,ZN,    "T>+ and - distances in x,y, z directions
   XDIST,YDIST,ZDIST,    "T> x,y, Z distances to nearest boundaries
   DIST1,DIST2,DIST3,    "T> Variables to control particle propagation
   STEP2,                "T>  "
   TLHS,TRHS,            "T> temporary macro variables like lhs,rhs
   DISCRIMINANT,         "T> Variable for rounded leaf
   TEMP,TEMP1, TEMP2, TEMP3, TEMP4, TEMP5,
   STEP_UNIT,ZBORDER,
   TMP_A,TMP_B,DET_A,DET_B,SOL1,SOL2,SOL3,SOL4,
   TMP1,TMP2,TMP3,TMP4,TMP5,TMP6,TMP7,TMP8,one;
parameter (one = 1);

" prepare the local variables
"=============================

IRL = IR(NP); "local region number (absolute)
IR_$SYNCMLCE = IRL - IRSTART_$SYNCMLCE + 1;   "rel. local region number
IF(ORIENT_$SYNCMLCE=1) [
    XYL(1)=Y(NP); XYL(2)=X(NP);UVL(1)=V(NP);UVL(2)=U(NP);
]
ELSE[ XYL(1)=X(NP); XYL(2)=Y(NP);UVL(1)=U(NP);UVL(2)=V(NP);]
;


STEP_UNIT=0.0;
COUNT = 0;
OUTOFCMFLAG=0;
OFFEDGECM=0;
OUTOFMLCFLAG=0;

" Boundary-crossing check
" ***********************
"
" Determine if current region number is within component module ,if so
" evaluate DIST, distance to region boundary along current trajectory.
" USTEP must not exceed DIST.


" the following block double check:
"=================================
"      1. the particle is out of the CM or regions in z direction
"      2.                        the regions in xy directions
"     if so reset the ir #, and print out the warning message.
"comment: this block is not time consumming, can be kept in the final version
"=======
"
"  now do the air gap check if existed.
"=====================================

IF(N_GAP_$SYNCMLCE=1 & IR_$SYNCMLCE=3 ) "  check the air gap first
[
   IF(W(NP)>0.0)
   ["Particle going forward
      DIST = (ZMIN_$SYNCMLCE - Z(NP))/W(NP); "distance to front of CM
      IF(DIST <= 0.0)
      [
          USTEP=0.0;
          $SYNCMLCE_FIND(IR_$SYNCMLCE, 0.0);
          IF( IR_$SYNCMLCE=1 )
          [  IRNEW =IRSTART_$SYNCMLCE; RETURN;]
          ELSE[IRNEW =IRSTART_$SYNCMLCE+1; RETURN;]
      ] " double check if a particle is out of the AIR GAP

   ]
   ELSEIF(W(NP)<0.0)
   [ " particle going backward"
      DIST = (ZFRONT_$SYNCMLCE - Z(NP))/W(NP); "distance to front of CM
      IF(DIST <= 0.0)
      [
          USTEP=1.E-16; "ensures call to AUSGAB on leaving CM";
          CALL WHERE_AM_I(ICM_$SYNCMLCE,-1);
          RETURN;
      ] " double check if a particle is out of the CM
   ]
]
ELSEIF(IR_$SYNCMLCE=1 | IR_$SYNCMLCE=2)  " in the local region 1 or 2
[
   IF(W(NP) > 0.0)
   [  "particle going forward"
      DIST = (ZMAX_$SYNCMLCE - Z(NP))/W(NP); "distance to back of CM
      IF(DIST>USTEP) [ STEP_UNIT=USTEP;  ]
      ELSE [ STEP_UNIT=DIST;  ]
      IF(DIST <=0.0)
      [
          USTEP=1.E-16; "ensures call to AUSGAB on leaving CM";
          CALL WHERE_AM_I(ICM_$SYNCMLCE,1);
          RETURN;
      ] " double check if a particle is out of the CM
   ]
   ELSEIF(W(NP) < 0.0)
   [  "particle going backward"
      DIST = (ZMIN_$SYNCMLCE - Z(NP))/W(NP); "distance to back of CM "
      IF(DIST>USTEP) [ STEP_UNIT=USTEP;  ]
      ELSE [ STEP_UNIT=DIST; ]
      IF(DIST <= 0.0)
      [
          USTEP=0.0;
          IF(N_GAP_$SYNCMLCE = 1)
          [ IRNEW =IREND_$SYNCMLCE; RETURN; ]
          ELSE[ USTEP=1.E-16; CALL WHERE_AM_I(ICM_$SYNCMLCE,-1); RETURN; ]
      ] " double check if a particle is out of the main body to air gap
   ]
   ELSE[  STEP_UNIT=USTEP;]  " for w(np)=0.0 case
]

" end of z direction check
"=========================

$SYNCMLCE_FIND(REGION_$SYNCMLCE,0.0);
IF(REGION_$SYNCMLCE=3) [ "Particle is in the air gap "

  REGION_$SYNCMLCE=IRSTART_$SYNCMLCE-1 +REGION_$SYNCMLCE;

  IF(W(NP) > 0.0)[
    IF(DIST <= USTEP ) ["particle to be moved to region boundary
      $GEO_SHIFT_1_(DIST);
      USTEP = DIST;
      $SYNCMLCE_FIND(NEWREGION_$SYNCMLCE,USTEP);
      IF( NEWREGION_$SYNCMLCE=1) [  IRNEW =IRSTART_$SYNCMLCE; RETURN;]
      ELSE[IRNEW =IRSTART_$SYNCMLCE+1; RETURN;]
    ]
    ELSE[ RETURN;]
  ] "end of particle going forward
  ELSEIF(W(NP) < 0.0) ["particle going backward"
    IF(DIST <= USTEP ) ["particle to be moved to region boundary
      $GEO_SHIFT_1_(DIST);
      USTEP = DIST;
      CALL WHERE_AM_I(ICM_$SYNCMLCE,-1);
      RETURN;
    ]
    ELSE [RETURN;]
  ] " end of going backward"
  ELSE[RETURN;]   " W=0.0 CASE "
] ;" end of region 3

IF( OUTOFMLCFLAG=1 ) [

  STEP2=STEP_UNIT;
TEMP1=((A_$SYNCMLCE(1,1)*XYFL(1))-(A_$SYNCMLCE(1,1)*B_$SYNCMLCE(1,1))-
(ZFL*(A_$SYNCMLCE(1,1)**2)))**2;
TEMP1=TEMP1+((A_$SYNCMLCE(1,1)*ZFL)+B_$SYNCMLCE(1,1)-XYFL(1))**2;
TEMP1=(1/(1+(A_$SYNCMLCE(1,1))**2))*sqrt(TEMP1);
TEMP2=((A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*XYFL(1))-
(A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4))-
(ZFL*(A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)**2)))**2;
TEMP2=TEMP2+((A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*ZFL)+
B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)-XYFL(1))**2;
TEMP2=(1/(1+(A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4))**2))*sqrt(TEMP2);
  IF( STEP2>=0.0)[
    TEMP=STEP2;
    IF( TEMP1>=0 ) [TEMP=MIN(TEMP,TEMP1);];
    IF( TEMP2>=0 ) [TEMP=MIN(TEMP,TEMP2);];
  ]
  ELSEIF ( (TEMP1>0.0) & (TEMP2>0.0) ) [TEMP=MIN(TEMP1,TEMP2);]
  ELSE [TEMP=MAX(TEMP2,TEMP1);];

  STEP2 = TEMP;

  $GEO_SHIFT_1_(STEP2);
  $SYNCMLCE_FIND(IRNEW,STEP2);
  IRNEW=IRNEW+IRSTART_$SYNCMLCE-1;
  USTEP=STEP2;
  RETURN;
]

$SYNCMLCE_MINDISTANCE(DIST1);

IF( (STEP_UNIT<=DIST1) | (DIST1<0.0) ) [
    STEP2=STEP_UNIT;
    $GEO_SHIFT_1_(STEP2);
    $SYNCMLCE_FIND(IRNEW,STEP2);
    USTEP=STEP2;
    IF(OUTOFCMFLAG=1)["call where_am_i"
       IDIR=SIGN(one,W(NP));
       CALL WHERE_AM_I(ICM_$SYNCMLCE,IDIR);
       RETURN;
    ]
    ELSEIF(OFFEDGECM=1)["call where_am_i with IDIR=0"
       IDIR=0;
       CALL WHERE_AM_I(ICM_$SYNCMLCE,IDIR);
       RETURN;
    ]
    ELSE[
      IRNEW=IRNEW+IRSTART_$SYNCMLCE-1;
      RETURN;
    ]
]
ELSEIF( (STEP_UNIT>DIST1) & (DIST1>=0.0) ) [
    REGION_$SYNCMLCE=REGION_$SYNCMLCE+IRSTART_$SYNCMLCE-1;
    LOOP[
      DIST1=DIST1+1.0E-5; "we have to shift it regardless to avoid infinite"
                          "loops"
      $SYNCMLCE_FIND(NEWREGION_$SYNCMLCE,DIST1);
      NEWREGION_$SYNCMLCE=NEWREGION_$SYNCMLCE+IRSTART_$SYNCMLCE-1;

      IF( OUTOFCMFLAG=1 | OFFEDGECM=1) [ EXIT;]
      ELSEIF(DIST1>=STEP_UNIT)[EXIT;]
      ELSEIF( (NEWREGION_$SYNCMLCE~=REGION_$SYNCMLCE) | OUTOFMLCFLAG=1 )[
         USTEP = MIN(USTEP,DIST1);"take min. because we shifted DIST1"
         IRNEW = NEWREGION_$SYNCMLCE;
         RETURN;
      ]
      ELSE [
         $SYNCMLCE_MINDISTANCE(DIST2);
         DIST1=DIST1+DIST2;
      ]
    ];

"if it gets here, then it exited either because OUTOFCMFLAG=1, OFFEDGECM=1"
"or because DIST1 >= STEP_UNIT"

    IF( OFFEDGECM=1)[
      "DIST1 is <= STEP_UNIT"
      USTEP=DIST1;
      IDIR=0;
      CALL WHERE_AM_I(ICM_$SYNCMLCE,IDIR);
      RETURN;
    ]
    ELSE[
      "DIST1 is >= STEP_UNIT, even if OUTOFCMFLAG=1, since that flag is"
      "based on distance to Z bdy"
      DIST1=STEP_UNIT;
      $GEO_SHIFT_1_(DIST1);
      USTEP = DIST1;
      OUTOFCMFLAG=0; "needs to be reset before FIND"
      $SYNCMLCE_FIND(NEWREGION_$SYNCMLCE,DIST1);
      IF( OUTOFCMFLAG=0 ) [
        NEWREGION_$SYNCMLCE=NEWREGION_$SYNCMLCE+IRSTART_$SYNCMLCE-1;
        IRNEW = NEWREGION_$SYNCMLCE;
        RETURN;
      ]
      ELSE[ "call where_am_i"
        IDIR=SIGN(one,W(NP));
        CALL WHERE_AM_I(ICM_$SYNCMLCE,IDIR);
        RETURN;
      ]
    ]

]; "End of IF loop for step_unit>dist1

;
"   end of HOWFAR_$SYNCMLCE
"   ===================
"
RETURN;
END; "End of subroutine HOWFAR_$SYNCMLCE"
%E "SYNCMLCE_cm.mortran  start of subroutine WHERE_AM_I_$SYNCMLCE (SID 1.12)"
"************************************************************************
"
"                          Subroutine WHERE_AM_I_$SYNCMLCE
"                          ***************************
"
" WHERE_AM_I routine for a stacked right cylinder slabs.
"
" WHERE_AM_I_$SYNCMLCE determines the new region number when a particle
" traverses a component module boundary.  The scheme is as follows:
"
"      Whenever a particle is to be transported to a component module
"      boundary in HOWFAR, the subroutine WHERE_AM_I is called.  The
"      current component module and particle direction (backwards or
"      forwards) are transferred to WHERE_AM_I in the CALL statement.
"      WHERE_AM_I determines which component module the particle is
"      about to enter and calls the WHERE_AM_I_$SYNCMLCE subroutine for
"      that component module, transferring the particle direction.
"      The region number that the particle is about to enter is
"      determined in WHERE_AM_I_$SYNCMLCE from the knowledge of which
"      surface the particle is entering through (front if IDIR=1,
"      back if IDIR=-1) and the (X,Y) coordinates of the particle.
"      The current particle being transported is NP (in /STACK/).
"
"*************************************************************************

;SUBROUTINE WHERE_AM_I_$SYNCMLCE(IDIR);

;IMPLICIT NONE;
;COMIN/CM_$SYNCMLCE,EPCONT,STACK,CMs,GEOM,USER/;
"T>
"T>**************************************
"T>TYPE DECLARATIONS FOR WHERE_AM_I_$SYNCMLCE
"T>**************************************
"T>
INTEGER
        NX,NY,NZ,   "T>Indices of subregions
        I,
        OUTOFCMFLAG, "Flags to denote out of CM and
        OUTOFMLCFLAG, " MLC respectively
        OFFEDGECM,    "Flag for particle beyond RMAX_CM
        LEAFIS,       " Leaf number
        BETWEEN_LEAF, "set to 1 if in air between leaves
        IDIR;  "T>direction of particle, +1=forward, -1=backward
$REAL XYL(2), XYFL(2), UVL(2),ZFL, XoN, XoP, Zo, TEMP1,TEMP2,ZBORDER,
      TMP1,TMP2;
IF(ORIENT_$SYNCMLCE=1)

   [ XYL(1)=Y(NP); XYL(2)=X(NP);UVL(1)=V(NP);UVL(2)=U(NP);]

ELSE[ XYL(1)=X(NP); XYL(2)=Y(NP);UVL(1)=U(NP);UVL(2)=V(NP);]
IF (IDIR=1)
["particle entering this CM through front face (upstream)
   IF(N_GAP_$SYNCMLCE = 0)
   ["no air gap this CM"
       IF(IRSTART_$SYNCMLCE=2)   " the first CM
       [$SYNCMLCE_FIND(IR_$SYNCMLCE,0.0); ]
       ELSE[$SYNCMLCE_FIND(IR_$SYNCMLCE, USTEP);]
       IF(IR_$SYNCMLCE=1)
       [IRNEW=IRSTART_$SYNCMLCE; RETURN;]
       ELSE[ IRNEW=IRSTART_$SYNCMLCE+1; RETURN; ]
   ]         " end of the no air gap case
   ELSE
   ["this CM has an air gap at the front
      IRNEW = IREND_$SYNCMLCE;
   ]
]
ELSE
["particle entering this CM through back face (downstream)
   $SYNCMLCE_FIND(IR_$SYNCMLCE, USTEP);
   IF(IR_$SYNCMLCE=1)
   [IRNEW=IRSTART_$SYNCMLCE; RETURN;]
   ELSE[ IRNEW=IRSTART_$SYNCMLCE+1; RETURN; ]
]

RETURN;

END; "End of subroutine WHERE_AM_I_$SYNCMLCE"
%E "SYNCMLCE_cm.mortran  start of subroutine INPUT_$SYNCMLCE (SID 1.12)"

"*************************************************************************

"                           Subroutine INPUT_$SYNCMLCE
"
"*************************************************************************
"*************************************************************************

"  A CM input subroutine for a series of 2 or more slabs.
"
"  It must fill all parameters in COMMON/CMs/ associated with this CM.
"
"  Routine prints error messages on unit 6 for
"      format error on input
"      end of file hit
"      error in logic of input file
"
"  The format of the input is presented in the section INPUT FROM UNIT 5
"   in the above documentation.
"
"************************************************************************

;SUBROUTINE INPUT_$SYNCMLCE;

;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_$SYNCMLCE,GEOM,IO_INFO,MEDIA,MISC,SCORE,USER,EGS-IO/;

"  **************************************************************** "
"              TYPE DECLARATIONS FOR INPUT_$SYNCMLCE
"  **************************************************************** "

$REAL  NEG_$SYNCMLCE,     "T>Leaf B tip
       POS_$SYNCMLCE,     "T>Leaf A Tip
       TEMP1,
       TEMP2,
       TRANSLR($MAXLEAF),
       TRANSLL($MAXLEAF),  "leaf right and left translations
       TRANSLR1, "store TRANSLR(1)
       TRANSLL1, "store TRANSLL(1)
       ROTR, "right rotation of leaves
       ROTL, "left rotation of leaves
       XREF(8),ZREF(8), "used to calculate X,Z parameters on input"
       XTEMPR1(8),XTEMPR2(8),ZTEMPR2(8),XTEMPL1(8),XTEMPL2(8),
       ZTEMPL2(8),
       XTEMPR_STORE5,ZTEMPR_STORE5;



INTEGER I,J,K,N,IJ,        "T>DO loop indices
        IRA,            "T>Absolute region number
        MED_FLAG,       "T>flag used by media-sort macro $MED_INPUT
        MED_INDEX,   "T>medium index, set after medium sort by $MED_INPUT
	egs_get_unit, "T>egs function used to assign unit to mlc_file
	mlc_unit,    "T>unit no. to assign mlc_file
        NUM_$SYNCMLCE; "T>number of adjacent leaves same opening coordinates
character*256 mlc_file;
CHARACTER*80 MLC_TITLE; "T> title line in mlc_file
CHARACTER*1 BEAM_NR(60);

" **************************************************************** "

"                 STEP I : INITIALIZE PARAMETERS
"                          =====================

" **************************************************************** "

"I. GET THE TITLE "
"================ "

OUTPUT;(/' Next component is an SYNCMLCE type MLC'/' Title: ',$);
MINPUT ($SYNCMLCE) TITLE_$SYNCMLCE;(60A1);
          "MINPUT is a replacement macro with EOF and
          "ERR branching to :EOF_{P1}: and :ERR_{P1}:
OUTPUT TITLE_$SYNCMLCE;(' ',60A1);
            "OUTPUT is a replacement macro which writes to
            "unit 5.  Used here for echo of user input

"II. CHOOSE THE SYNCMLCE ORIENTATION "
"============================== "

OUTPUT; (' The leaves can be arranged as:',/,
            ' 0 ---- parallel to y direction',/,
            ' 1 ---- parallel to x direction (default).');

OUTPUT; (' Input your choice: ',$);
MINPUT ($SYNCMLCE) ORIENT_$SYNCMLCE, MODE_$SYNCMLCE; (2I5);
IF(ORIENT_$SYNCMLCE~=0)[ORIENT_$SYNCMLCE=1;OUTPUT;(' Default to ');]
OUTPUT ORIENT_$SYNCMLCE; (I5/);

IF(MODE_$SYNCMLCE<0 | MODE_$SYNCMLCE>2) [
      MODE_$SYNCMLCE=0;
      OUTPUT;(/' Mode of leaf opening input defaults to 0.'/);
 ];

"III. DESIGNATE REGION NUMBERS "
"============================= "

N_$SYNCMLCE = 2;
           "Number of regions in this CM (excluding front air gap)
ICM_$SYNCMLCE = ICM;      "CM index for this component module
IRSTART_$SYNCMLCE = IR_start_CM(ICM_$SYNCMLCE);
                      "Index of first region in this CM,
                      "set by previous CM or in MAIN if ICM=1
IERR_GEOM(ICM_$SYNCMLCE) = 0; "Geometry-checking flag, 0 if no error detected

" ************************************************************** "

"              STEP TWO : GET SYNCMLCE GEOMETRY INFORMATION
"                         ============================

" ************************************************************** "

" II. NUMBER OF LEAVES"
" ===================="

OUTPUT $MAXLEAF;
(' Input the # of leaf pairs (less than ',I3,')'/
 ' This must be an even no. (usually 40): ', $);
MINPUT ($SYNCMLCE) NUM_LEAF_$SYNCMLCE; (I5);
OUTPUT NUM_LEAF_$SYNCMLCE;(I5/);

IF(NUM_LEAF_$SYNCMLCE>$MAXLEAF) [
    NUM_LEAF_$SYNCMLCE=$MAXLEAF;
    OUTPUT ICM_$SYNCMLCE,NUM_LEAF_$SYNCMLCE;
            (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
             ' # of leaves > max allowed'/
             ' # of leaves reduced to ',I4,' for now'//);
    IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
];

IF(NUM_LEAF_$SYNCMLCE<=0)[
    NUM_LEAF_$SYNCMLCE=2;
    OUTPUT ICM_$SYNCMLCE,NUM_LEAF_$SYNCMLCE;
            (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
             ' # of leaves <= 0'/
             ' # of leaves set to ',I4,' for now'//);
    IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
];

IF(MOD(NUM_LEAF_$SYNCMLCE,2)~=0)[
    OUTPUT ICM_$SYNCMLCE,NUM_LEAF_$SYNCMLCE;
            (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
             ' # of leaves (',I4,') not an even number'/
             ' Reset to 2 for now'//);
    NUM_LEAF_$SYNCMLCE=2;
    IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
]

"ALL PARAMETERS"
"=============="

OUTPUT;('Z position of top MLC, Z Position of bottom MLC = ',$);
MINPUT ($SYNCMLCE) ZMIN_$SYNCMLCE,ZMAX_$SYNCMLCE; (2F15.0);
OUTPUT ZMIN_$SYNCMLCE,ZMAX_$SYNCMLCE;(2F12.5/);

ZMIN_INPUT_$SYNCMLCE=ZMIN_$SYNCMLCE;
ZMAX_INPUT_$SYNCMLCE=ZMAX_$SYNCMLCE;

OUTPUT;('Z position of left step central leaf,'/
        'Z Position of right step central leaf:',$);
MINPUT ($SYNCMLCE) ZSTEPL_$SYNCMLCE,ZSTEPR_$SYNCMLCE; (2F15.0);
OUTPUT ZSTEPL_$SYNCMLCE,ZSTEPR_$SYNCMLCE; (2F12.5/);
IF(ZSTEPL_$SYNCMLCE<ZSTEPR_$SYNCMLCE)[
   OUTPUT ICM_$SYNCMLCE;
    (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
       ' Geometry assumes Z of left step <= Z of right step.'/
       ' Check step Z positons and try again.'//);
       STOP;
]
IF(ZSTEPL_$SYNCMLCE>=ZMAX_$SYNCMLCE)[
   OUTPUT ICM_$SYNCMLCE;
    (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
       ' Z position of left step must be < Z of bottom of MLC.'/
       ' Check geometry and try again.'//);
       STOP;
]
IF(ZSTEPR_$SYNCMLCE<=ZMIN_$SYNCMLCE)[
   OUTPUT ICM_$SYNCMLCE;
    (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
       ' Z position of right step must be > Z of top of MLC.'/
       ' Check geometry and try again.'//);
       STOP;
]

OUTPUT;('Width of step (TGW) :',$);
MINPUT ($SYNCMLCE) TGW_$SYNCMLCE; (F15.0);
OUTPUT TGW_$SYNCMLCE;(F12.5/);

OUTPUT;
('Upper (X3) and lower (X4) right coordinates of central leaf ignoring step'/
 ':',$);
MINPUT ($SYNCMLCE) X3_$SYNCMLCE,X4_$SYNCMLCE; (2F15.0);
OUTPUT X3_$SYNCMLCE,X4_$SYNCMLCE;(2F12.5/);

X1_$SYNCMLCE=-X3_$SYNCMLCE;
X2_$SYNCMLCE=-X4_$SYNCMLCE;

IF(ORIENT_$SYNCMLCE=0)[
   OUTPUT;('Distance between leaf centres in Y direction (SPACE),'/
        'distance from Z=0 where SPACE is defined :',$);
]
ELSE[
   OUTPUT;('Distance between leaf centres in X direction (SPACE),'/
        'distance from Z=0 where SPACE is defined :',$);
]
MINPUT ($SYNCMLCE) SPACE_$SYNCMLCE, SSD_$SYNCMLCE; (2F15.0);
OUTPUT SPACE_$SYNCMLCE, SSD_$SYNCMLCE;(F12.5,F15.5/);

OUTPUT;('Leaf bank rotation angle = ',$);
MINPUT ($SYNCMLCE) LBROT_$SYNCMLCE; (F15.0);
OUTPUT LBROT_$SYNCMLCE;(F12.5/);

XREF(4)=X2_$SYNCMLCE;
XREF(3)=(X2_$SYNCMLCE-X1_$SYNCMLCE)*((ZSTEPL_$SYNCMLCE-ZMIN_$SYNCMLCE)/
        (ZMAX_$SYNCMLCE-ZMIN_$SYNCMLCE)) +X1_$SYNCMLCE;
XREF(2)=XREF(3)+TGW_$SYNCMLCE;
XREF(1)=(X2_$SYNCMLCE-X1_$SYNCMLCE)*((ZMIN_$SYNCMLCE-ZSTEPL_$SYNCMLCE)/
        (ZMAX_$SYNCMLCE-ZMIN_$SYNCMLCE)) +XREF(2);
XREF(8)=X3_$SYNCMLCE;
XREF(7)=(X4_$SYNCMLCE-X3_$SYNCMLCE)*((ZSTEPR_$SYNCMLCE-ZMIN_$SYNCMLCE)/
        (ZMAX_$SYNCMLCE-ZMIN_$SYNCMLCE)) +XREF(8);
XREF(6)=XREF(7)-TGW_$SYNCMLCE;
XREF(5)=(X4_$SYNCMLCE-X3_$SYNCMLCE)*((ZMAX_$SYNCMLCE-ZSTEPL_$SYNCMLCE)/
       (ZMAX_$SYNCMLCE-ZMIN_$SYNCMLCE)) +XREF(6);
"DO J=1,8[
"OUTPUT XREF(J);('XREF = ',F15.5);];
ZREF(1)=ZMIN_$SYNCMLCE;
ZREF(2)=ZSTEPL_$SYNCMLCE;
ZREF(3)=ZSTEPL_$SYNCMLCE;
ZREF(4)=ZMAX_$SYNCMLCE;
ZREF(5)=ZMAX_$SYNCMLCE;
ZREF(6)=ZSTEPR_$SYNCMLCE;
ZREF(7)=ZSTEPR_$SYNCMLCE;
ZREF(8)=ZMIN_$SYNCMLCE;

"VII. TYPE OF LEAF ENDS - ROUNDED VS FLAT DIVERGENT "
"================================================ "

OUTPUT; (/'Input the type of leaf end desired : ',/,
          '   0 --- Rounded leaf end or ',/
          '   1 --- Focused leaf end  ');
OUTPUT; ('Input your choice : ', $);
MINPUT ($SYNCMLCE) ENDTYPE_$SYNCMLCE; (I5);
OUTPUT ENDTYPE_$SYNCMLCE; (I5/);

IF(ENDTYPE_$SYNCMLCE=1) [

   OUTPUT; (' Input the z focus of the leaf ends : ',$);
   MINPUT ($SYNCMLCE) ZFOCUS_$SYNCMLCE; (F15.0);
   OUTPUT ZFOCUS_$SYNCMLCE;(F12.5/);

   IF(ABS(ZFOCUS_$SYNCMLCE-ZMIN_$SYNCMLCE)<1.E-5) [
      ZFOCUS_$SYNCMLCE=ZMIN_$SYNCMLCE-1.E-4;
      OUTPUT ICM_$SYNCMLCE,ZFOCUS_$SYNCMLCE;
          (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
           ' ZFOCUS(2) cannot be equal to ZMIN_$SYNCMLCE'/
           ' ZFOCUS(2) reset to ',F15.5,' cm for now'//);
      IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
    ]
ELSEIF(ZFOCUS_$SYNCMLCE>ZMIN_$SYNCMLCE & ZFOCUS_$SYNCMLCE<ZMAX_$SYNCMLCE)[
       ZFOCUS_$SYNCMLCE=ZMAX_$SYNCMLCE;
       OUTPUT ICM_$SYNCMLCE,ZFOCUS_$SYNCMLCE;
          (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
          ' ZFOCUS(2) is between ZMIN_$SYNCMLCE and ZMAX_$SYNCMLCE'/
          ' This will cause leaf ends to overlap'/
          ' ZFOCUS(2) reset to ',F15.5,' cm for now'//);
       IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
     ];
     LEAFRADIUS_$SYNCMLCE=0.;"used in calculations later"
]
ELSE  [ "Defaults to rounded ends "

   OUTPUT;(' Input the radius of the leaf ends (>3.75 cm),'/
           ' Z at which this radius is defined : ',$);

   MINPUT ($SYNCMLCE) LEAFRADIUS_$SYNCMLCE,CIL_$SYNCMLCE; (2F15.0);
   OUTPUT LEAFRADIUS_$SYNCMLCE,CIL_$SYNCMLCE; (2F15.5/);

   IF((LEAFRADIUS_$SYNCMLCE < 3.75) |
      (LEAFRADIUS_$SYNCMLCE < 0.0)) [

" This is done to ensure that the leaf end is rounded all the
" way from zmin_$varmlc to zmax_$varmlc. Otherwise the curvature
" will fall short."

   LEAFRADIUS_$SYNCMLCE=3.75;
   OUTPUT ICM_$SYNCMLCE,LEAFRADIUS_$SYNCMLCE;
      (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
      ' LEAFRADIUS_$SYNCMLCE is less than minimum acceptable'/
      ' RESET TO ', F15.5, ' cm for now'//);
   IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
   ]
]; " End of checking the leaf end ;

"CALCULATE A AND B : XYL(1)=A*Z+B"
"================================"

DO N=1,NUM_LEAF_$SYNCMLCE/2 [
"  OUTPUT NUM_LEAF_$SYNCMLCE/2,N;('Leaf nr = ',I2,'+',I2);
  TRANSLR(N)=(2*N-1)*(SPACE_$SYNCMLCE/2.)*ZMIN_INPUT_$SYNCMLCE/SSD_$SYNCMLCE;
  TRANSLL(N)=((2*N-1)*(-SPACE_$SYNCMLCE/2.)*ZMIN_INPUT_$SYNCMLCE)/SSD_$SYNCMLCE;
  IF(N=1)[
    TRANSLL1=TRANSLL(1);
    TRANSLR1=TRANSLR(1);
  ]
  IF(XREF(1)+TRANSLR1<XREF(8)+TRANSLL1)[
                             "central leaves overlap"
                             "unlikely that rotation will change this"
    TRANSLR(N)=(2*N-1)*(SPACE_$SYNCMLCE/2.);
    TRANSLL(N)=(2*N-1)*(-SPACE_$SYNCMLCE/2.);
    IF(N=1)[
       OUTPUT ICM_$SYNCMLCE,SPACE_$SYNCMLCE;
       (//' ***WARNING IN CM ',I4,/
          ' Leaves will overlap if translated according to input values of'/
          ' SPACE, SSD and requirement to focus at Z=0.'/
          ' Leaves will simply be translated to be ',F12.5,' cm apart.'//);
    ]
  ]
"  OUTPUT TRANSLR(N);('Translation over = ',F15.5);
  DO J=1,8[
    XTEMPR1(J)=XREF(J)+TRANSLR(N);
"    OUTPUT XTEMPR1(J);('XTEMPR1 = ',F15.5);
  ]
  ROTR=ATAN((2*N-1)*(SPACE_$SYNCMLCE/2.)/SSD_$SYNCMLCE);
"  OUTPUT ROTR;('ROTATION RIGHT = ',F15.5);
  DO J=1,8[
    XTEMPR2(J)=TRANSLR(N)+cos(ROTR)*(XTEMPR1(J)-TRANSLR(N))
             +sin(ROTR)*(ZREF(J)-ZREF(1));
    ZTEMPR2(J)=ZREF(1)-sin(ROTR)*(XTEMPR1(J)-TRANSLR(N))
             +cos(ROTR)*(ZREF(J)-ZREF(1));
  "  OUTPUT XTEMPR2(J);('XTEMPR2 = ',F15.5);
  ]
  DO J=1,8[
    X_$SYNCMLCE(J)=cos(LBROT_$SYNCMLCE)*XTEMPR2(J)+
               sin(LBROT_$SYNCMLCE)*(ZTEMPR2(J)-ZMIN_INPUT_$SYNCMLCE);
    Z_$SYNCMLCE(J)=-sin(LBROT_$SYNCMLCE)*XTEMPR2(J)+
               cos(LBROT_$SYNCMLCE)*(ZTEMPR2(J)-ZMIN_INPUT_$SYNCMLCE)+
               ZMIN_INPUT_$SYNCMLCE;
  "  OUTPUT J,X_$SYNCMLCE(J),Z_$SYNCMLCE(J);
  "  ('Coordinate X',I2,'= ',F15.5,' and Z= ',F15.5);
    IF(Z_$SYNCMLCE(J)<ZMIN_$SYNCMLCE)[
      ZMIN_$SYNCMLCE=Z_$SYNCMLCE(J);];
    IF(Z_$SYNCMLCE(J)>ZMAX_$SYNCMLCE)[
      ZMAX_$SYNCMLCE=Z_$SYNCMLCE(J);];
  ];

  IF(N=NUM_LEAF_$SYNCMLCE/2)[
  TEMP2=ABS(X_$SYNCMLCE(5));
  ];

  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1)=(X_$SYNCMLCE(4)-X_$SYNCMLCE(3))/
  (Z_$SYNCMLCE(4)-Z_$SYNCMLCE(3));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1)=X_$SYNCMLCE(3)-
  (Z_$SYNCMLCE(3)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1));

  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,2)=(X_$SYNCMLCE(2)-X_$SYNCMLCE(1))/
  (Z_$SYNCMLCE(2)-Z_$SYNCMLCE(1));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,2)=X_$SYNCMLCE(1)-
  (Z_$SYNCMLCE(1)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,2));

  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,3)=(X_$SYNCMLCE(6)-X_$SYNCMLCE(5))/
  (Z_$SYNCMLCE(6)-Z_$SYNCMLCE(5));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,3)=X_$SYNCMLCE(5)-
  (Z_$SYNCMLCE(5)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,3));

  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,4)=(X_$SYNCMLCE(8)-X_$SYNCMLCE(7))/
  (Z_$SYNCMLCE(8)-Z_$SYNCMLCE(7));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,4)=X_$SYNCMLCE(7)-
  (Z_$SYNCMLCE(7)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,4));

  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1)=(Z_$SYNCMLCE(8)-Z_$SYNCMLCE(1))/
  (X_$SYNCMLCE(8)-X_$SYNCMLCE(1));
  D_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1)=Z_$SYNCMLCE(1)-
           (X_$SYNCMLCE(1)*C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1));
  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,4)=(Z_$SYNCMLCE(5)-Z_$SYNCMLCE(4))/
  (X_$SYNCMLCE(5)-X_$SYNCMLCE(4));
  D_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,2)=Z_$SYNCMLCE(4)-
           (X_$SYNCMLCE(4)*C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,4));
  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,2)=Z_$SYNCMLCE(7);
  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,3)=Z_$SYNCMLCE(2);

  IF(N>=2)[
    IF(X_$SYNCMLCE(1)<A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N-1,4)*Z_$SYNCMLCE(1)+
                  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N-1,4))[
       "check to see if upper left corner of leaf will overlap"
       "side of previous leaf"
       OUTPUT ICM_$SYNCMLCE;
       (//' ***ERROR IN CM ',I4,/
          ' After translation and rotation, left corner of leaf overlaps'/
          ' side of previous leaf.  Check inputs and try again.'//);
       STOP;
    ]
    IF(XTEMPR_STORE5>A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1)*ZTEMPR_STORE5+
                     B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+N,1))[
       "lower right corner of previous leaf will overlap"
       "side of current leaf"
       OUTPUT ICM_$SYNCMLCE;
       (//' ***ERROR IN CM ',I4,/
          ' After translation and rotation, left side of leaf overlaps'/
     ' lower right corner of previous leaf.  Check inputs and try again.'//);
       STOP;
    ]
  ]
  XTEMPR_STORE5=X_$SYNCMLCE(5);
  ZTEMPR_STORE5=Z_$SYNCMLCE(5);

"now do leaves 1 - NUM_LEAF_$MLC/2"

"  OUTPUT NUM_LEAF_$SYNCMLCE/2+1,N;('Leaf nr = ',I2,'-',I2);
"  OUTPUT TRANSLL(N);('TRANSLATIE LINKS = ',F15.5);
  DO J=1,8[
    XTEMPL1(J)=XREF(J)+TRANSLL(N);
  "  OUTPUT XTEMPL1(J);('XTEMPL1 = ',F15.5);
  ]

  ROTL=ATAN((2*N-1)*(-SPACE_$SYNCMLCE/2.)/SSD_$SYNCMLCE);
"  OUTPUT ROTL;('ROTATIE LINKS = ',F15.5);
  DO J=1,8[
    XTEMPL2(J)=TRANSLL(N)+cos(ROTL)*(XTEMPL1(J)-TRANSLL(N))
             +sin(ROTL)*(ZREF(J)-ZREF(8));
  "  OUTPUT XTEMPL2(J);('XTEMPL2 = ',F15.5);
    ZTEMPL2(J)=ZREF(8)-sin(ROTL)*(XTEMPL1(J)-TRANSLL(N))
             +cos(ROTL)*(ZREF(J)-ZREF(8));
  "  OUTPUT ZTEMPL2(J);('ZTEMPL2 = ',F15.5);
  ]
  DO J=1,8[
    X_$SYNCMLCE(J)=cos(LBROT_$SYNCMLCE)*XTEMPL2(J)+
               sin(LBROT_$SYNCMLCE)*(ZTEMPL2(J)-ZMIN_INPUT_$SYNCMLCE);
    Z_$SYNCMLCE(J)=-sin(LBROT_$SYNCMLCE)*XTEMPL2(J)+
               cos(LBROT_$SYNCMLCE)*(ZTEMPL2(J)-ZMIN_INPUT_$SYNCMLCE)+
               ZMIN_INPUT_$SYNCMLCE;
  "  OUTPUT J,X_$SYNCMLCE(J),Z_$SYNCMLCE(J);
  "    ('Coordinate X',I2,'= ',F15.5,' and Z= ',F15.5);
    IF(Z_$SYNCMLCE(J)<ZMIN_$SYNCMLCE)[
      ZMIN_$SYNCMLCE=Z_$SYNCMLCE(J);];
    IF(Z_$SYNCMLCE(J)>ZMAX_$SYNCMLCE)[
      ZMAX_$SYNCMLCE=Z_$SYNCMLCE(J);];
  ];
  IF(N=NUM_LEAF_$SYNCMLCE/2)[
  TEMP1=ABS(X_$SYNCMLCE(4));
  ];

  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,1)=(X_$SYNCMLCE(4)-X_$SYNCMLCE(3))/
  (Z_$SYNCMLCE(4)-Z_$SYNCMLCE(3));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,1)=X_$SYNCMLCE(3)-
  (Z_$SYNCMLCE(3)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,1));
  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,2)=(X_$SYNCMLCE(2)-X_$SYNCMLCE(1))/
  (Z_$SYNCMLCE(2)-Z_$SYNCMLCE(1));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,2)=X_$SYNCMLCE(1)-
  (Z_$SYNCMLCE(1)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,2));
  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,3)=(X_$SYNCMLCE(6)-X_$SYNCMLCE(5))/
  (Z_$SYNCMLCE(6)-Z_$SYNCMLCE(5));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,3)=X_$SYNCMLCE(5)-
  (Z_$SYNCMLCE(5)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,3));
  A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,4)=(X_$SYNCMLCE(8)-X_$SYNCMLCE(7))/
  (Z_$SYNCMLCE(8)-Z_$SYNCMLCE(7));
  B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,4)=X_$SYNCMLCE(7)-
  (Z_$SYNCMLCE(7)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,4));

  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,1)=(Z_$SYNCMLCE(8)-Z_$SYNCMLCE(1))/
  (X_$SYNCMLCE(8)-X_$SYNCMLCE(1));
  D_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,1)=Z_$SYNCMLCE(1)-
           (X_$SYNCMLCE(1)*C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,1));
  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,4)=(Z_$SYNCMLCE(5)-Z_$SYNCMLCE(4))/
  (X_$SYNCMLCE(5)-X_$SYNCMLCE(4));
  D_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,2)=Z_$SYNCMLCE(4)-
           (X_$SYNCMLCE(4)*C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,4));
  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,2)=Z_$SYNCMLCE(7);
  C_$SYNCMLCE(NUM_LEAF_$SYNCMLCE/2+1-N,3)=Z_$SYNCMLCE(2);
];

IF(ZMIN_$SYNCMLCE ~= ZMIN_INPUT_$SYNCMLCE)[
   OUTPUT ZMIN_INPUT_$SYNCMLCE,ZMIN_$SYNCMLCE;
   (/' Due to leaf rotations, ZMIN in $SYNCMLCE changed from ',F15.8,' cm'/
     ' to ',F15.8,' cm.'/);
]
IF(ZMAX_$SYNCMLCE ~= ZMAX_INPUT_$SYNCMLCE)[
   OUTPUT ZMAX_INPUT_$SYNCMLCE,ZMAX_$SYNCMLCE;
   (/' Due to leaf rotations, ZMAX in $SYNCMLCE changed from ',F15.8,' cm'/
     ' to ',F15.8,' cm.  Be aware of this when specifying downstream CM.'/);
]
IF(ZMIN_$SYNCMLCE<Z_min_CM(ICM_$SYNCMLCE))["cannot have this or else it will"
                                   "interfere with CM above and screw"
                                   "up HOWNEAR calculations"
   OUTPUT ICM_$SYNCMLCE;
      (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
      ' Adjusted ZMIN is < Z_min_CM(ICM_$SYNCMLCE).'/
      ' This will cause errors in HOWFAR and HOWNEAR.'//);
   IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
]
IF(TEMP1>RMAX_CM(ICM_$SYNCMLCE)|TEMP2>RMAX_CM(ICM_$SYNCMLCE)) [
   OUTPUT ICM_$SYNCMLCE;
   (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
      ' After rotation, leaves are not contained within the CM boundaries.'/
      ' Please check ZFOCUS_$SYNCMLCE(1) and or RMAX_CM(ICM_$SYNCMLCE)'//);
   IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
]

"XI. INPUT THE COORDINATES NEG_$SYNCMLCE AND POS_$SYNCMLCE "
"===================================================== "
DO I=1, NUM_LEAF_$SYNCMLCE
[
    LEAFB_$SYNCMLCE(I)=0.0;LEAFA_$SYNCMLCE(I)=0.0;
]
IF(MODE_$SYNCMLCE=1|MODE_$SYNCMLCE=2)["dynamic or step-and-shoot leaf inputs"
 "Added by Julio Lobo and Tony Popescu taken from code from SYNCVMLC"
  OUTPUT;(/' Input full name of file containing leaf opening data:'/);
  READ(i_input,'(A256)')mlc_file;
  OUTPUT mlc_file;(A/);
  call replace_env(mlc_file);
  mlc_unit=egs_get_unit(mlc_unit);
  IF(mlc_unit<1)[
    $egs_fatal(*,
         'MLC leaf opening file: failed to get a free Fortran I/O unit');
  ]
  open(mlc_unit,file=mlc_file,status='old',err=:no-mlc-data-file:);
  read(mlc_unit,'(A80)') MLC_TITLE;
  read(mlc_unit,'(I10)') NFIELDS_$SYNCMLCE;
  OUTPUT NFIELDS_$SYNCMLCE; (I10);

  IF(NFIELDS_$SYNCMLCE>$MAXFIELD_$SYNCMLCE) [
   OUTPUT $MAXFIELD_$SYNCMLCE;
        (/' The number of fields is greater than $MAXFIELD_$SYNCMLCE: ',I10, /
        ' Increase $MAXFIELD_$SYNCMLCE in SYNCMLCE_macros.mortran'/);
   STOP;
  ];

  DO I=1,NFIELDS_$SYNCMLCE[
  "read in non-default leaf positions for each field"
     read(mlc_unit,'(F15.0)')INDEX_$SYNCMLCE(I);
     J=1;"counter for total no. of leaves input so far"
     LOOP[
       read(mlc_unit,'(2F15.0,I5)')NEG_$SYNCMLCE, POS_$SYNCMLCE, NUM_$SYNCMLCE;
       IF(NUM_$SYNCMLCE<=0) NUM_$SYNCMLCE=1;
       DO K=J,J+NUM_$SYNCMLCE-1[
         IF(K>NUM_LEAF_$SYNCMLCE) EXIT;
         LEAFNEG_$SYNCMLCE(K+(I-1)*NUM_LEAF_$SYNCMLCE)=NEG_$SYNCMLCE;
         LEAFPOS_$SYNCMLCE(K+(I-1)*NUM_LEAF_$SYNCMLCE)=POS_$SYNCMLCE;
       ]
       J=K;
     ]WHILE(J<=NUM_LEAF_$SYNCMLCE);
  ]
  CLOSE(UNIT=mlc_unit);

  OUTPUT;('******MLC SEQUENCE FILE READ******');
  IF (MODE_$SYNCMLCE=1) [
      OUTPUT; ('**dynamic delivery**');
  ]
  ELSEIF (MODE_$SYNCMLCE=2) [
      OUTPUT; ('**step and shoot delivery**');
  ]
]
ELSE[
OUTPUT; (' Input for MLC A and B leaf tips '/);
IF(ORIENT_$SYNCMLCE=1)[
    IF(ENDTYPE_$SYNCMLCE=1)[
      OUTPUT;(' Input min. X, max. X of top of opening in leaves,');
    ]
    ELSE[
      OUTPUT;(' Input min. X, max. X of origin of cylindrical leaf ends,');
    ]
]
ELSE[
    IF(ENDTYPE_$SYNCMLCE=1)[
      OUTPUT;(' Input min. Y, max. Y of top of opening in leaves,');
    ]
    ELSE[
      OUTPUT;(' Input min. Y, max. Y of origin of cylindrical leaf ends,');
    ]
]
OUTPUT;(' # of adjacent leaves with these coordinates:');
I=1;
LOOP[
  OUTPUT I;('   For leaf',I4,' :',$)
  MINPUT ($SYNCMLCE) NEG_$SYNCMLCE, POS_$SYNCMLCE, NUM_$SYNCMLCE;
  (2F15.0,I5);
  IF(NUM_$SYNCMLCE<=0) NUM_$SYNCMLCE=1;
  OUTPUT NEG_$SYNCMLCE, POS_$SYNCMLCE, NUM_$SYNCMLCE; (2F15.5,I5);
  IF(NEG_$SYNCMLCE+LEAFRADIUS_$SYNCMLCE > POS_$SYNCMLCE-LEAFRADIUS_$SYNCMLCE)[
     NEG_$SYNCMLCE = POS_$SYNCMLCE-LEAFRADIUS_$SYNCMLCE;
     OUTPUT ICM_$SYNCMLCE,I,I+NUM_$SYNCMLCE-1,NEG_$SYNCMLCE;
      (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
   ' Min. and max. opening coordinates in leaves ',I4,' - ',I4,' overlap'/
   ' Negative coordinate set to ',F15.5,' cm for now'//);
     IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
                               ]

  IF(ABS(NEG_$SYNCMLCE)>RMAX_CM(ICM_$SYNCMLCE)+LEAFRADIUS_$SYNCMLCE|
     ABS(POS_$SYNCMLCE)>RMAX_CM(ICM_$SYNCMLCE)+LEAFRADIUS_$SYNCMLCE) [

     OUTPUT ICM_$SYNCMLCE,I,I+NUM_$SYNCMLCE-1;
      (//' ***ERROR IN CM ',I4,' ($SYNCMLCE)'/
      ' Tip of leaves ',I4,' - ',I4,' are outside CM '//);

     IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
                                            ];
  DO J=I,I+NUM_$SYNCMLCE-1["define opening for all leaves in group"
    IF(J>NUM_LEAF_$SYNCMLCE) EXIT;
    LEAFB_$SYNCMLCE(J)=NEG_$SYNCMLCE;
    LEAFA_$SYNCMLCE(J)=POS_$SYNCMLCE;
  ]
  I=J;
]WHILE(I<=NUM_LEAF_$SYNCMLCE);"End of Coordinate inputs for || direction "

IF(ENDTYPE_$SYNCMLCE=1)[
DO I=1, NUM_LEAF_$SYNCMLCE [

SURPARA2_B_$SYNCMLCE(I)=LEAFB_$SYNCMLCE(I)/
(ZMIN_$SYNCMLCE-ZFOCUS_$SYNCMLCE );

SURPARA2_A_$SYNCMLCE(I)=LEAFA_$SYNCMLCE(I)/
(ZMIN_$SYNCMLCE-ZFOCUS_$SYNCMLCE );

                         ];
                    ];
]

"XII. ESTABLISH TOP OF FIRST CM
"==============================

ZFRONT_$SYNCMLCE = Z_min_CM(ICM_$SYNCMLCE);

"
"XIII. ESTABLISH START OF NEXT CM
"================================

Z_min_CM(ICM_$SYNCMLCE+1) = ZMAX_$SYNCMLCE;

"
"XIV. GET ECUT, PCUT, DOSE SCORING ZONE AND MATERIAL IN EACH REGION
"==================================================================

IRA = IRSTART_$SYNCMLCE-1;
DO IR_$SYNCMLCE = 1,N_$SYNCMLCE
["loop through regions to get information"
   IRA = IRA+1;
   IF (IR_$SYNCMLCE = 1)[
       ;OUTPUT IR_$SYNCMLCE;
        (/' Region',I4,' (MLC opening):'/
          ' ECUT, PCUT (MeV), DOSE ZONE (0=NO DOSE SCORED), IREGION_TO_BIT'/
          ' :',$);
   ]
   ELSE[
      ;OUTPUT IR_$SYNCMLCE;
        (/' Region',I4,' (MLC leaves):'/
         ' ECUT, PCUT (MeV), DOSE ZONE (0=NO DOSE SCORED), IREGION_TO_BIT'/
         ' :',$);
   ]
   ;MINPUT ($SYNCMLCE)
      ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.0,2I5);
   IF(ECUT(IRA) < ECUTIN)[ECUT(IRA)=ECUTIN;]
   IF(PCUT(IRA) < PCUTIN)[PCUT(IRA)=PCUTIN;]
     ;OUTPUT ECUT(IRA),PCUT(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA);
      (2F15.5,2I5);
      OUTPUT IR_$SYNCMLCE;(' material of region ',I3,' ',$);
   ;$MED_INPUT($SYNCMLCE); " inputs character array MED_IN from unit 5, loops
  "through array MEDIA(24,I) to check if medium was previously input.
  "If so, sets MED_INDEX to index of previous medium.  If not,
  "increments NMED and sets MED_INDEX to NMED.
   med(IRA) = MED_INDEX; " medium of the planar slab
] "end of loop over IR_$SYNCMLCE"

"
"XV. SET UP AIR GAP TO PREVIOUS CM IF PRESENT
"  =========================================
"
"  The air gap has the highest region number in the CM, even though its
"  the top of the component module.  This is to allow the assignment of
"  region numbers on input of the parameters of each local region
"  (mainly to assign the medium number of the region).
"  The air gap is then assigned after all of the
"  CM parameters have been input.
"
"note that if this is the first CM (ICM_$mlc=1) then the gap thickness
"Z_gap_THICK(ICM_$varmlc) = 0, which is used as a flag for no air gap

Z_gap_THICK(ICM_$SYNCMLCE) = ZMIN_$SYNCMLCE - Z_min_CM(ICM_$SYNCMLCE);
IF (Z_gap_THICK(ICM_$SYNCMLCE) < = 0.0)
[
   Z_gap_THICK(ICM_$SYNCMLCE) = 0.;
   N_GAP_$SYNCMLCE = 0; "no air gap for this CM
]
ELSE
[
   N_GAP_$SYNCMLCE = 1; "this CM has an air gap
   IRA = IRSTART_$SYNCMLCE+N_$SYNCMLCE; "absolute region number of air gap
   med(IRA) = AIR_INDEX; "medium is air
]

"
"XVI. SET UP REGION NUMBERS
"===========================
"
"  This CM has N_$SYNCMLCE+N_GAP_$mlc regions
"
;
"Index last region
IREND_$SYNCMLCE = (IRSTART_$SYNCMLCE -1) + N_$SYNCMLCE+N_GAP_$SYNCMLCE;
NREG = NREG+N_$SYNCMLCE+N_GAP_$SYNCMLCE;
                            "Total no of regions in full geometry up
                            "to and including this CM
IF (NREG <= $MXREG)
[ IR_start_CM(ICM_$SYNCMLCE+1) = IREND_$SYNCMLCE+1; ]
                       "have not exceeded maximum region number
                       "Index of first region in next CM:"
ELSE
[
      OUTPUT ICM_$SYNCMLCE,NREG,$MXREG;
      (//' ***ERROR IN CM ',I4,' ($SYNCMLCE):'/
         T2,I4,' regions requested, only ',I4,' available'//);
      IERR_GEOM(ICM_$SYNCMLCE)=IERR_GEOM(ICM_$SYNCMLCE)+1;
]

"
"XVII.  ESTABLISH CM BOUNDARY
"============================
"
RMAX_CM_FLAG(ICM_$SYNCMLCE) = 2; "put a square boundary about CM
"
"XVIII. ESTABLISH DOSE SCORING ZONES AND BIT SETTING FOR EACH REGION
"===================================================================
"
IRA = IRSTART_$SYNCMLCE-1; "absolute region number"
DO IR_$SYNCMLCE=1,N_$SYNCMLCE
["loop over local region number
   IRA = IRA+1;
   "dose-scoring zones
   NDOSE_ZONE = MAX(DOSE_ZONE(IRA),NDOSE_ZONE); "Number of dose zones
   MAX_BIT = MAX(IREGION_TO_BIT(IRA),MAX_BIT); " current maxmum
   "charged particle range rejection parameters
   "
   ESAVE(IRA)=ESAVE_GLOBAL; "Particles with total energies below ESAVE are
                            "considered for range rejection
   ECUTRR(IRA)=ECUT(IRA); "Minimum energy on exit from region GXD
   E_min_out(ICM_$SYNCMLCE)=ECUT(IRA); "Minimum energy on exit from CM

] "end of loop over IR_$SYNCMLCE

"XIX. ESTABLISH SUB-REGION IR VALUES
"===================================

DO I=1,3 [
   DO J =1,3 [
      DO K = 1,5  [
    SUBINDEX_$SYNCMLCE(I,J,K)=1;
                  ];
            ];
         ];

DO I=2,3 [
   DO K=2,4 [
   SUBINDEX_$SYNCMLCE(I,2,K)=2;
            ];

   SUBINDEX_$SYNCMLCE(I,1,4)=2;
   SUBINDEX_$SYNCMLCE(I,3,2)=2;
         ];


"   =======================
"
RETURN;

"XX. ERROR MESSAGES
"==================
"
:EOF_$SYNCMLCE:
;OUTPUT ICM;
  (//' *** ERROR *** unexpected end of file reading input for CM',I3);
STOP;

:ERROR_$SYNCMLCE:
;OUTPUT ICM;(//' *** ERROR *** format error on input for CM',I3);
STOP;

:no-mlc-data-file:
;OUTPUT;(//' *** ERROR: MLC leaf data file could not be opened');
STOP;

END;  "End of INPUT_$SYNCMLCE"

%E "SYNCMLCE_cm.mortran  start of subroutine ISUMRY_$SYNCMLCE (SID 1.12)"
"***********************************************************************
"
"                          Subroutine ISUMRY_$SYNCMLCE
"                          ***********************
"
" Summarize input, write graphics file for EGS_Windows, and set parameters
" that require medium information obtained from HATCH call.
"
"***********************************************************************

;SUBROUTINE ISUMRY_$SYNCMLCE;

;IMPLICIT NONE;
;COMIN/ BOUNDS,CMs,CM_$SYNCMLCE,GEOM,IO_INFO,MEDIA,MISC,SCORE,UPHIOT,USER/;
"T>
"T>**********************************
"T>TYPE DECLARATIONS FOR ISUMRY_$SYNCMLCE
"T>**********************************
"T>
INTEGER
"   ID,     already defined gf  T>index of dose scoring zone
   IRA,     "T>absolute region number
   I,J;     "T>DO loop index

$REAL  VOL_$SYNCMLCE(2), "T> region volumes
       TOTALVOL,       "T> Total volume of MLC CM
       VOLLEAF,       "T>volume of a single leaf
       XINT_TOPA,     "intersection of +ve leaf end with ZMIN_INPUT
       XINT_BOTB,     "intersection of -ve leaf end with ZMAX_INPUT
       XINT_TOPB,     "intersection of -ve leaf end with ZMIN_INPUT
       R,            "distance of chord of rounded leaf end from CIL
       CHORD,         "area contained in chords at end of leaves
       OPENINGAREA;   "area of the opening between +ve and -ve leaves



"   Mass of dose zone
"   =================
"
"Need to calculate mass of dose zone here, after call to HATCH, where the
"region density is set if it was allowed to default in INPUT_$mlc.
"This volume calculation is approximate, but close enough
"
TOTALVOL = (ZMAX_$SYNCMLCE-ZMIN_$SYNCMLCE)*4*RMAX_CM(ICM_$SYNCMLCE)**2;
VOL_$SYNCMLCE(1) = 0.;
VOL_$SYNCMLCE(2) = 0.;

"volume of a pair of leaves, ignoring leaf ends/openings"
VOLLEAF=(2*X4_$SYNCMLCE*(ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)-
        (X4_$SYNCMLCE-X3_$SYNCMLCE)*(ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)-
        TGW_$SYNCMLCE*(ZSTEPL_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)-
        TGW_$SYNCMLCE*(ZMAX_INPUT_$SYNCMLCE-ZSTEPR_$SYNCMLCE))*
        2*RMAX_CM(ICM_$SYNCMLCE);

DO J = 1, NUM_LEAF_$SYNCMLCE [

    IF(ENDTYPE_$SYNCMLCE=0)["rounded leaf ends"

      "find out where the circle defining the ends intersects the
      "leaf
      XINT_TOPB=LEAFB_$SYNCMLCE(J)+SQRT(LEAFRADIUS_$SYNCMLCE**2-
                                   (ZMIN_INPUT_$SYNCMLCE-CIL_$SYNCMLCE)**2);
      XINT_BOTB=LEAFB_$SYNCMLCE(J)+SQRT(LEAFRADIUS_$SYNCMLCE**2-
                                   (ZMAX_INPUT_$SYNCMLCE-CIL_$SYNCMLCE)**2);
      XINT_TOPA=LEAFA_$SYNCMLCE(J)-SQRT(LEAFRADIUS_$SYNCMLCE**2-
                                    (ZMIN_INPUT_$SYNCMLCE-CIL_$SYNCMLCE)**2);
      R=SQRT(LEAFRADIUS_$SYNCMLCE**2-
   ((ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)**2+
                            (XINT_TOPB-XINT_BOTB)**2)/4.);
      CHORD=LEAFRADIUS_$SYNCMLCE**2*
              ACOS(R/LEAFRADIUS_$SYNCMLCE)-R*SQRT(LEAFRADIUS_$SYNCMLCE**2-R**2);
      IF(CHORD<0) CHORD=0.; "can happen for large LEAFRADIUS"
      OPENINGAREA=(ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)*
                  (XINT_TOPA-XINT_BOTB)-2*CHORD;
      VOL_$SYNCMLCE(2)=VOL_$SYNCMLCE(2)+VOLLEAF*
                   ((ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)*
                   2*RMAX_CM(ICM_$SYNCMLCE)-OPENINGAREA)/
                   ((ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)*
                    2*RMAX_CM(ICM_$SYNCMLCE));
   ]
   ELSE["focused leaf ends"
      XINT_TOPA=LEAFA_$SYNCMLCE(J);
      XINT_BOTB=(ZMAX_INPUT_$SYNCMLCE-ZFOCUS_$SYNCMLCE)*LEAFB_$SYNCMLCE(J)/
                (ZMIN_INPUT_$SYNCMLCE-ZFOCUS_$SYNCMLCE);
      OPENINGAREA=(ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)*
                  (XINT_TOPA-XINT_BOTB);
      VOL_$SYNCMLCE(2)=VOL_$SYNCMLCE(2)+VOLLEAF*
                  ((ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)*
                   2*RMAX_CM(ICM_$SYNCMLCE)-OPENINGAREA)/
                   ((ZMAX_INPUT_$SYNCMLCE-ZMIN_INPUT_$SYNCMLCE)*
                   2*RMAX_CM(ICM_$SYNCMLCE));
   ]
]

VOL_$SYNCMLCE(1) = TOTALVOL - VOL_$SYNCMLCE(2);

"i.e. Air Volume = Total Volume - Volume of Leaves"

IRA = IRSTART_$SYNCMLCE-1;
DO IR_$SYNCMLCE=1,N_$SYNCMLCE+N_GAP_$SYNCMLCE
[
   IRA = IRA+1;
   IF(DOSE_ZONE(IRA).NE.0)
   [
      ID=DOSE_ZONE(IRA);
      AMASS(ID)=AMASS(ID)+VOL_$SYNCMLCE(IR_$SYNCMLCE)*RHOR(IRA);
   ]
]

"   Summarize geometrical information for this CM in listing file"
"   =============================================================="

WRITE(IOUTLIST,110) ICM_$SYNCMLCE,TITLE_$SYNCMLCE;
WRITE(IOUTLIST,120) Z_min_CM(ICM_$SYNCMLCE), RMAX_CM(ICM_$SYNCMLCE);
IF(N_GAP_$SYNCMLCE~=0)[
          WRITE(IOUTLIST,124) Z_min_CM(ICM_$SYNCMLCE),
                             ZMIN_$SYNCMLCE-Z_min_CM(ICM_$SYNCMLCE);
]
IF(ORIENT_$SYNCMLCE~=0)["leaves parallel to X"
  IF(ENDTYPE_$SYNCMLCE=0) [
    WRITE(IOUTLIST,122)NUM_LEAF_$SYNCMLCE,'X',ZMIN_INPUT_$SYNCMLCE,
                       ZMAX_INPUT_$SYNCMLCE,ZSTEPL_$SYNCMLCE,
                       ZSTEPR_$SYNCMLCE,'Y',
                       TGW_$SYNCMLCE,'Y',X3_$SYNCMLCE,'Y',X4_$SYNCMLCE,
                       SPACE_$SYNCMLCE, SSD_$SYNCMLCE, LBROT_$SYNCMLCE,
                       LEAFRADIUS_$SYNCMLCE,CIL_$SYNCMLCE,
                       VOL_$SYNCMLCE(1),VOL_$SYNCMLCE(2),TOTALVOL;
  ]
  ELSE                   [
    WRITE(IOUTLIST,123)NUM_LEAF_$SYNCMLCE,'X',ZMIN_INPUT_$SYNCMLCE,
                       ZMAX_INPUT_$SYNCMLCE,ZSTEPL_$SYNCMLCE,
                       ZSTEPR_$SYNCMLCE,'Y',
                       TGW_$SYNCMLCE,'Y',X3_$SYNCMLCE,'Y',X4_$SYNCMLCE,
                       SPACE_$SYNCMLCE, SSD_$SYNCMLCE, LBROT_$SYNCMLCE,
                       ZFOCUS_$SYNCMLCE,VOL_$SYNCMLCE(1),
                       VOL_$SYNCMLCE(2),TOTALVOL;
  ]
]
ELSE["leaves parallel to Y"
  IF(ENDTYPE_$SYNCMLCE=0) [
    WRITE(IOUTLIST,122)NUM_LEAF_$SYNCMLCE,'Y',ZMIN_INPUT_$SYNCMLCE,
                       ZMAX_INPUT_$SYNCMLCE,ZSTEPL_$SYNCMLCE,
                       ZSTEPR_$SYNCMLCE,'X',
                       TGW_$SYNCMLCE,'X',X3_$SYNCMLCE,'X',X4_$SYNCMLCE,
                       SPACE_$SYNCMLCE, SSD_$SYNCMLCE, LBROT_$SYNCMLCE,
                       LEAFRADIUS_$SYNCMLCE,CIL_$SYNCMLCE,
                       VOL_$SYNCMLCE(1),VOL_$SYNCMLCE(2),TOTALVOL;
  ]
  ELSE                   [
    WRITE(IOUTLIST,123)NUM_LEAF_$SYNCMLCE,'Y',ZMIN_INPUT_$SYNCMLCE,
                       ZMAX_INPUT_$SYNCMLCE,ZSTEPL_$SYNCMLCE,
                       ZSTEPR_$SYNCMLCE,'X',
                       TGW_$SYNCMLCE,'X',X3_$SYNCMLCE,'X',X4_$SYNCMLCE,
                       SPACE_$SYNCMLCE, SSD_$SYNCMLCE, LBROT_$SYNCMLCE,
                       ZFOCUS_$SYNCMLCE,VOL_$SYNCMLCE(1),
                       VOL_$SYNCMLCE(2),TOTALVOL;
  ]
];
IF(ORIENT_$SYNCMLCE~=0)["leaves parallel to X"
      WRITE(IOUTLIST,126)'X';
]
ELSE["leaves parallel to Y"
      WRITE(IOUTLIST,126)'Y';
]

DO I =1, NUM_LEAF_$SYNCMLCE [

WRITE(IOUTLIST,128)I,LEAFB_$SYNCMLCE(I),LEAFA_$SYNCMLCE(I);

]

WRITE(IOUTLIST,130);
IRA = IRSTART_$SYNCMLCE-1;
DO IR_$SYNCMLCE=1,N_$SYNCMLCE[
   IRA = IRA+1;
   IF(IR_$SYNCMLCE=1)[
      IF (MED(IRA)=0)[
         WRITE(IOUTLIST,140) IR_$SYNCMLCE,'opening',ECUT(IRA),PCUT(IRA),
           ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE[
         WRITE(IOUTLIST,140) IR_$SYNCMLCE,'opening',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
   ELSEIF(IR_$SYNCMLCE=2)[
      IF (MED(IRA)=0)[
         WRITE(IOUTLIST,140) IR_$SYNCMLCE,'leaves',ECUT(IRA),PCUT(IRA),
           ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
           IREGION_TO_BIT(IRA),'V','a','c','u','u','m';
      ]
      ELSE[
         WRITE(IOUTLIST,140) IR_$SYNCMLCE,'leaves',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),
         IREGION_TO_BIT(IRA),(MEDIA(J,MED(IRA)),J=1,9);
      ]
   ]
]

IF(N_GAP_$SYNCMLCE ~=0)[
   IRA=IRSTART_$SYNCMLCE+N_$SYNCMLCE;
      WRITE(IOUTLIST,140) IR_$SYNCMLCE,'airgap',ECUT(IRA),PCUT(IRA),
         ECUTRR(IRA),ESAVE(IRA),DOSE_ZONE(IRA),IREGION_TO_BIT(IRA),
         (MEDIA(J,MED(IRA)),J=1,9);
      WRITE(IOUTLIST,141)'at top';
]

110 FORMAT(/' Component module',I3,' is a multi-leaf collimator (SYNCMLCE)',
            ' (3 regions SID 1.12)',
           /'  -------------------------------------------------',
            '------------------',
           //T5,'Title: ',68A1);
120 FORMAT(/T2,'$SYNCMLCE geometry parameters:',
           /T2,'------------------------',
           /T2,'Distance from front of CM from reference plane = ',T51,
           F15.5,' cm',
           /T2,'Radius of outer boundary of CM = ',T51,F15.5,' cm');
122 FORMAT(T2,'No. of leaf pairs = ',T51,I5,
           /T2,'Leaves open parallel to the ',A1,' axis'
           /T2,'Min. Z of leaf bank as input = ',T51,F15.5,' cm',
           /T2,'Max. Z of leaf bank as input = ',T51,F15.5,' cm',
           /T2,'Z of left step in central leaf = ',T51,F15.5,' cm',
           /T2,'Z of right step in central leaf = ',T51,F15.5,' cm',
           /T2,'Width of steps in the ',A1,' direction = ',T51,
               F15.5,' cm',
           /T2,'Upper right ',A1,' coord. of central leaf = ',T51,F15.5,' cm',
           /T2,'Lower right ',A1,' coord. of central leaf = ',T51,F15.5,' cm',
           /T2,'Space between leaf centres = ',T51,F15.5,' cm',
           /T2,'SSD at which above space is defined = ',T51,F15.5,' cm',
           /T2,'Leaf bank rotation angle = ',T51,F15.5,' rad',
           /T2,'Radius of curvature of rounded leaf ends = ',T51,F15.5,' cm',
           /T2,'Z of origin of curvature = ',T51,F15.5,' cm',
           /T2,'Volume of region between leaves = ',T51,
               F15.5, ' cm**3',
           /T2,'Volume of leaves = ',T51,
               F15.5, ' cm**3',
           /T2,'Volume of Multileaf Collimator Component Module = ',T51,
               F15.5, ' cm**3');
123 FORMAT(T2,'No. of leaf pairs = ',T51,I5,
           /T2,'Leaves open parallel to the ',A1,' axis'
           /T2,'Min. Z of leaf bank as input = ',T51,F15.5,' cm',
           /T2,'Max. Z of leaf bank as input = ',T51,F15.5,' cm',
           /T2,'Z of left step in central leaf = ',T51,F15.5,' cm',
           /T2,'Z of right step in central leaf = ',T51,F15.5,' cm',
           /T2,'Width of steps in the ',A1,' direction = ',T51,
               F15.5,' cm',
           /T2,'Upper right ',A1,' coord. of central leaf = ',T51,F15.5,' cm',
           /T2,'Lower right ',A1,' coord. of central leaf = ',T51,F15.5,' cm',
           /T2,'Space between leaf centres = ',T51,F15.5,' cm',
           /T2,'SSD at which above space is defined = ',T51,F15.5,' cm',
           /T2,'Leaf bank rotation angle = ',T51,F15.5,' rad',
           /T2,'Z focus of straight leaf ends = ',T51,F15.5,' cm',
           /T2,'Volume of region between leaves = ',T51,
               F15.5, ' cm**3',
           /T2,'Volume of leaves = ',T51,
               F15.5, ' cm**3',
           /T2,'Volume of Multileaf Collimator Component Module = ',T51,
               F15.5, ' cm**3');


124 FORMAT(T2,'There is an airgap starting at Z = ',F8.3,' cm with',
              ' thickness ',F8.3,' cm');
126 FORMAT
(/T2,'  Leaf          ',A1,' coordinates of opening',
 /T2,'                  NEG     (cm)        POS');
128 FORMAT(T2,I5,5X,F15.5,5X,F15.5);
130 FORMAT(/T2,'$SYNCMLCE region parameters:',
           /T2,'----------------------',
           /T2,'local  location  electron  photon',
               '  range-rejection   dose  bit  medium'
           /T2,'region            cutoff   cutoff',
               '   level     max    zone  set'
           /T2,'                   (MeV)    (MeV)',
               '   (MeV)    (MeV)');
140 FORMAT(T2,I3,4X,A7,F10.3,F9.3,F8.3,F9.3,I6,I5,3X,9A1);
141 FORMAT(T9,A7);

"   Output representation of this component module to file for EGS_Windows"
"   ======================================================================"

"IF (IWATCH = 4 | IZLAST = 2) ["
"   ;"

"] "

"200 FORMAT(' ',I1,A3,A1,10(F7.2,','));"
;RETURN;
END;

%E "Start of subroutine HOWNEAR_$SYNCMLCE"
"***********************************************************************
"
"                          Subroutine HOWNEAR_$SYNCMLCE
"                          ***********************
"
" Calculates min. distance to nearest region boundary
" Used to be HOWNEAR macro, but is now called from that macro.
"
"***********************************************************************

;SUBROUTINE HOWNEAR_$SYNCMLCE(DIST);

$IMPLICIT-NONE;

COMIN/CM_$SYNCMLCE,STACK,GEOM,USER/;

$REAL DIST, "T> min. distance to nearest region boundary
      XYL1,XYL2,ZBOR(5), "T> X(NP) and Y(NP)
      TMP1,TMP2,TMP3,TMP4,
      TMP5,TMP6,TMP7,TMP8,UPB,DOWN;

$INTEGER I, "T> looping index
         NZ, "T> index of subregion in Z direction
         NY, "T> index of subregion perpendicular to leaf opening direction
         LEAFIS; "T> leaf no. where particle is located

IR_$SYNCMLCE=IR(NP) - IRSTART_$SYNCMLCE + 1;
IF(IR_$SYNCMLCE=3) [ "in the air gap at the top"
  DIST=MIN(Z(NP)-ZFRONT_$SYNCMLCE,ZMIN_$SYNCMLCE-Z(NP));
]
ELSE [
  IF(ORIENT_$SYNCMLCE=1) [ XYL1=Y(NP); XYL2=X(NP); ]
  ELSE [ XYL1=X(NP); XYL2=Y(NP); ]

LEAFIS=0;

DO I=1,NUM_LEAF_$SYNCMLCE [

TMP1=(A_$SYNCMLCE(I,1)*Z(NP))+B_$SYNCMLCE(I,1);
TMP2=(A_$SYNCMLCE(I,4)*Z(NP))+B_$SYNCMLCE(I,4);

IF( (TMP1<=XYL1) & (XYL1<=TMP2)) [

LEAFIS=I; EXIT; ];

];

IF( LEAFIS~=0 )[

  TMP1=(A_$SYNCMLCE(LEAFIS,1)*Z(NP))+B_$SYNCMLCE(LEAFIS,1);
  TMP2=(A_$SYNCMLCE(LEAFIS,4)*Z(NP))+B_$SYNCMLCE(LEAFIS,4);
  IF(XYL1<TMP1)[
    NY=1;
  ]
  ELSEIF(XYL1>TMP2)[
    NY=3;
  ]
  ELSE[

DO I =1,3 [

TMP1=(A_$SYNCMLCE(LEAFIS,I)*Z(NP))+B_$SYNCMLCE(LEAFIS,I);
TMP2=(A_$SYNCMLCE(LEAFIS,I+1)*Z(NP))+B_$SYNCMLCE(LEAFIS,I+1);

IF(TMP1<=XYL1 & XYL1<=TMP2)[

NY=I; EXIT;];

          ];
  ]

ZBORDERS_$SYNCMLCE(1)=(C_$SYNCMLCE(LEAFIS,1)*XYL1)+D_$SYNCMLCE(LEAFIS,1);
ZBORDERS_$SYNCMLCE(2)=C_$SYNCMLCE(LEAFIS,2);
ZBORDERS_$SYNCMLCE(3)=C_$SYNCMLCE(LEAFIS,3);
ZBORDERS_$SYNCMLCE(4)=(C_$SYNCMLCE(LEAFIS,4)*XYL1)+D_$SYNCMLCE(LEAFIS,2);

NZ=0;
DO I=1,4 [
   IF(Z(NP)=<ZBORDERS_$SYNCMLCE(I)) [ NZ=I; EXIT; ];
];
IF(NZ=0 & (Z(NP)<=ZMAX_$SYNCMLCE) )[ NZ=5; ];

"check overlapping leaf"

IF(NY=3 & Z(NP)>=C_$SYNCMLCE(LEAFIS,2) & LEAFIS~=NUM_LEAF_$SYNCMLCE )
[
 IF(XYL1>=(A_$SYNCMLCE(LEAFIS+1,1)*Z(NP))+B_$SYNCMLCE(LEAFIS+1,1))
 [
   LEAFIS=LEAFIS+1;
   NY=1;
   "NZ=4;  this is not necessarily the case,  nick"
   ZBOR(2)=C_$SYNCMLCE(LEAFIS,2);
   ZBOR(3)=C_$SYNCMLCE(LEAFIS,3);
   ZBOR(4)=(C_$SYNCMLCE(LEAFIS,4)*XYL1)+D_$SYNCMLCE(LEAFIS,2);
   NZ=0;
   DO I=2,4 [
    IF(Z(NP)=<ZBOR(I)) [ NZ=I; EXIT; ];
   ];
   IF(NZ=0 & (Z(NP)<=ZMAX_$SYNCMLCE) )[ NZ=5; ];
 ];
];

"initialization of variables"

TMP1=((XYL1*(C_$SYNCMLCE(LEAFIS,1)**2))-(Z(NP)*C_$SYNCMLCE(LEAFIS,1))+
(C_$SYNCMLCE(LEAFIS,1)*D_$SYNCMLCE(LEAFIS,1)))**2;
TMP1=TMP1+(Z(NP)-(XYL1*C_$SYNCMLCE(LEAFIS,1))-D_$SYNCMLCE(LEAFIS,1))**2;
TMP1=(1/(1+C_$SYNCMLCE(LEAFIS,1)**2))*sqrt(TMP1);

TMP2=((XYL1*(C_$SYNCMLCE(LEAFIS,4)**2))-(Z(NP)*C_$SYNCMLCE(LEAFIS,4))+
(C_$SYNCMLCE(LEAFIS,4)*D_$SYNCMLCE(LEAFIS,2)))**2;
TMP2=TMP2+(Z(NP)-(XYL1*C_$SYNCMLCE(LEAFIS,4))-D_$SYNCMLCE(LEAFIS,2))**2;
TMP2=(1/(1+C_$SYNCMLCE(LEAFIS,4)**2))*sqrt(TMP2);

"start check"

    IF(NY=1 & (NZ=1|NZ=2|NZ=3) )[
      DOWN=Z(NP)-ZMIN_$SYNCMLCE;
      UPB=C_$SYNCMLCE(LEAFIS,3)-Z(NP);
      ]
    ELSEIF(NY=1 & NZ=4)[
      DOWN=Z(NP)-C_$SYNCMLCE(LEAFIS,3);
      UPB=TMP2;
      ]
    ELSEIF(NZ=5 & (NY=1|NY=2))[
      DOWN=TMP2;
      UPB=ZMAX_$SYNCMLCE-Z(NP);
      ]
    ELSEIF(NZ=1)[
      DOWN=Z(NP)-ZMIN_$SYNCMLCE;
      UPB=TMP1;
      ]
    ELSEIF(NY=2)[
      DOWN=TMP1;
      UPB=TMP2;
      ]
    ELSEIF(NZ=2)[
      DOWN=TMP1;
      UPB=C_$SYNCMLCE(LEAFIS,2)-Z(NP);
      ]
    ELSEIF(NY=3)[
      DOWN=Z(NP)-C_$SYNCMLCE(LEAFIS,2);
      UPB=ZMAX_$SYNCMLCE-Z(NP);
    " following not necessary as already checke above"
    "  IF(LEAFIS~=NUM_LEAF_$SYNCMLCE & "
    "    (XYL1>((A_$SYNCMLCE(LEAFIS+1,1)*Z(NP))+B_$SYNCMLCE(LEAFIS+1,1))))["
    "     UPB=(C_$SYNCMLCE(LEAFIS+1,3)-Z(NP));]; "
      ];

    DIST=MIN(UPB,DOWN);

TMP1=((A_$SYNCMLCE(LEAFIS,1)*XYL1)-
       (A_$SYNCMLCE(LEAFIS,1)*B_$SYNCMLCE(LEAFIS,1))-
       (Z(NP)*(A_$SYNCMLCE(LEAFIS,1))**2))**2;
TMP1=TMP1+((A_$SYNCMLCE(LEAFIS,1)*Z(NP))+B_$SYNCMLCE(LEAFIS,1)-XYL1)**2;
TMP1=(1/(1+(A_$SYNCMLCE(LEAFIS,1)**2)))*sqrt(TMP1);

TMP2=((A_$SYNCMLCE(LEAFIS,2)*XYL1)-
      (A_$SYNCMLCE(LEAFIS,2)*B_$SYNCMLCE(LEAFIS,2))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS,2)**2)))**2;
TMP2=TMP2+((A_$SYNCMLCE(LEAFIS,2)*Z(NP))+B_$SYNCMLCE(LEAFIS,2)-XYL1)**2;
TMP2=(1/(1+(A_$SYNCMLCE(LEAFIS,2)**2)))*sqrt(TMP2);

TMP3=((A_$SYNCMLCE(LEAFIS,3)*XYL1)-
      (A_$SYNCMLCE(LEAFIS,3)*B_$SYNCMLCE(LEAFIS,3))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS,3)**2)))**2;
TMP3=TMP3+((A_$SYNCMLCE(LEAFIS,3)*Z(NP))+B_$SYNCMLCE(LEAFIS,3)-XYL1)**2;
TMP3=(1/(1+(A_$SYNCMLCE(LEAFIS,3)**2)))*sqrt(TMP3);

TMP4=((A_$SYNCMLCE(LEAFIS,4)*XYL1)-
      (A_$SYNCMLCE(LEAFIS,4)*B_$SYNCMLCE(LEAFIS,4))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS,4)**2)))**2;
TMP4=TMP4+((A_$SYNCMLCE(LEAFIS,4)*Z(NP))+B_$SYNCMLCE(LEAFIS,4)-XYL1)**2;
TMP4=(1/(1+(A_$SYNCMLCE(LEAFIS,4)**2)))*sqrt(TMP4);

IF(LEAFIS~=1)[
TMP5=((A_$SYNCMLCE(LEAFIS-1,3)*XYL1)-
      (A_$SYNCMLCE(LEAFIS-1,3)*B_$SYNCMLCE(LEAFIS-1,3))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS-1,3))**2))**2;
TMP5=TMP5+((A_$SYNCMLCE(LEAFIS-1,3)*Z(NP))+B_$SYNCMLCE(LEAFIS-1,3)-XYL1)**2;
TMP5=(1/(1+(A_$SYNCMLCE(LEAFIS-1,3)**2)))*sqrt(TMP5);

TMP6=((A_$SYNCMLCE(LEAFIS-1,4)*XYL1)-
      (A_$SYNCMLCE(LEAFIS-1,4)*B_$SYNCMLCE(LEAFIS-1,4))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS-1,4))**2))**2;
TMP6=TMP6+((A_$SYNCMLCE(LEAFIS-1,4)*Z(NP))+B_$SYNCMLCE(LEAFIS-1,4)-XYL1)**2;
TMP6=(1/(1+(A_$SYNCMLCE(LEAFIS-1,4)**2)))*sqrt(TMP6);
];

IF(LEAFIS~=NUM_LEAF_$SYNCMLCE)[
TMP7=((A_$SYNCMLCE(LEAFIS+1,1)*XYL1)-
      (A_$SYNCMLCE(LEAFIS+1,1)*B_$SYNCMLCE(LEAFIS+1,1))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS+1,1)**2)))**2;
TMP7=TMP7+((A_$SYNCMLCE(LEAFIS+1,1)*Z(NP))+B_$SYNCMLCE(LEAFIS+1,1)-XYL1)**2;
TMP7=(1/(1+(A_$SYNCMLCE(LEAFIS+1,1)**2)))*sqrt(TMP7);

TMP8=((A_$SYNCMLCE(LEAFIS+1,2)*XYL1)-
      (A_$SYNCMLCE(LEAFIS+1,2)*B_$SYNCMLCE(LEAFIS+1,2))-
      (Z(NP)*(A_$SYNCMLCE(LEAFIS+1,2)**2)))**2;
TMP8=TMP8+((A_$SYNCMLCE(LEAFIS+1,2)*Z(NP))+B_$SYNCMLCE(LEAFIS+1,2)-XYL1)**2;
TMP8=(1/(1+(A_$SYNCMLCE(LEAFIS+1,2)**2)))*sqrt(TMP8);
];

    IF( NZ=2 & (NY=2|NY=3) )[
       DOWN=TMP2; UPB=TMP4;]
    ELSEIF( NZ=3 & NY=2 )[
       DOWN=TMP2; UPB=TMP3;]
    ELSEIF( NZ=4 & (NY=1|NY=2) )[
       DOWN=TMP1; UPB=TMP3;]
    ELSEIF( NZ=1 )[
       IF( LEAFIS=1 )[ DOWN=TMP1;UPB=TMP8;]
       ELSEIF( LEAFIS=NUM_LEAF_$SYNCMLCE )[ DOWN=TMP6;UPB=TMP4;]
       ELSE[ DOWN=TMP6;UPB=TMP8;];
       ]
    ELSEIF( NZ=5 )[
       IF( LEAFIS=1 )[ DOWN=TMP1;UPB=TMP7;]
       ELSEIF( LEAFIS=NUM_LEAF_$SYNCMLCE )[ DOWN=TMP5;UPB=TMP4;]
       ELSE[ DOWN=TMP5;UPB=TMP7;];
       ]
    ELSEIF( NY=1 )[
       UPB=TMP2;
       IF( LEAFIS=1 )[DOWN=TMP1;]
       ELSE[
       DOWN=TMP6;
       IF(Z(NP)>C_$SYNCMLCE(LEAFIS-1,2))[
          DOWN=TMP5;];
       ];
       ]
    ELSEIF( NY=3 )[
       DOWN=TMP3;
       IF( LEAFIS=NUM_LEAF_$SYNCMLCE )[UPB=TMP4;]
       ELSE[
       UPB=TMP7;
       IF(Z(NP)<C_$SYNCMLCE(LEAFIS+1,3))[UPB=TMP8;];
       ];
       ];

    DIST = MIN(DIST,UPB,DOWN);

    IF(ENDTYPE_$SYNCMLCE=1) [

      TMP1=SURPARA2_B_$SYNCMLCE(LEAFIS);
      TMP1=1/SQRT(1+TMP1**2);
      TMP2=SURPARA2_A_$SYNCMLCE(LEAFIS);
      TMP2=1/SQRT(1+TMP2**2);

      DIST=MIN(DIST,
     ABS((SURPARA2_B_$SYNCMLCE(LEAFIS)*(Z(NP)-ZFOCUS_$SYNCMLCE)-XYL2)*TMP1),
     ABS((SURPARA2_A_$SYNCMLCE(LEAFIS)*(Z(NP)-ZFOCUS_$SYNCMLCE)-XYL2)*TMP2));

    ]
    ELSE[

     TMP1=ABS(sqrt((XYL2-LEAFA_$SYNCMLCE(LEAFIS))**2+
     (Z(NP)-CIL_$SYNCMLCE)**2)-LEAFRADIUS_$SYNCMLCE);
     TMP2=ABS(sqrt((Z(NP)-CIL_$SYNCMLCE)**2+
     (XYL2-LEAFB_$SYNCMLCE(LEAFIS))**2)-LEAFRADIUS_$SYNCMLCE);
"     IF(XYL2>LEAFA_$SYNCMLCE(LEAFIS))[ TMP1=1.0E20; ];"
"     IF(XYL2<LEAFB_$SYNCMLCE(LEAFIS))[ TMP2=1.0E20; ];"

     DIST=MIN(DIST,TMP1,TMP2);
    ]
  ]
  ELSE[ "beyond outer edges SYNCMLCE"
    IF(XYL1 <= A_$SYNCMLCE(1,1)*Z(NP)+B_$SYNCMLCE(1,1))[
      TMP1=((A_$SYNCMLCE(1,1)*Z(NP))+B_$SYNCMLCE(1,1)-XYL1)**2;
      TMP1=TMP1+((A_$SYNCMLCE(1,1)*XYL1)-(B_$SYNCMLCE(1,1)*
      A_$SYNCMLCE(1,1))-
      (Z(NP)*A_$SYNCMLCE(1,1)**2))**2;
      TMP1=(1/(1+A_$SYNCMLCE(1,1)**2))*sqrt(TMP1);
    ]
    ELSEIF(XYL1 >= A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*Z(NP)+
                   B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4))[
      TMP1=((A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*Z(NP))+
      B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)-XYL1)**2;
      TMP1=TMP1+((A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*XYL1)-
      (B_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)*
      A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4))-
      (Z(NP)*A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)**2))**2;
      TMP1=(1/(1+A_$SYNCMLCE(NUM_LEAF_$SYNCMLCE,4)**2))*sqrt(TMP1);
    ]
    DIST=MIN(Z(NP)-ZMIN_$SYNCMLCE,ZMAX_$SYNCMLCE-Z(NP),TMP1);

  ]
]
RETURN;
END; "End of subroutine HOWNEAR_$SYNCMLCE
"************************************************************************
"End of SYNCMLCE_cm.mortran (SID 1.12)"




