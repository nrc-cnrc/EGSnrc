%C80
"#############################################################################"
"                                                                             "
"  EGSnrc dosrznrc application                                                "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Authors:         Eric Fox, 1984                                            "
"                   Dave Rogers, 1985                                         "
"                   Alex Bielajew, 1986                                       "
"                                                                             "
"  Contributors:    Charlie Ma                                                "
"                   Aaron Merovitz                                            "
"                   Iwan Kawrakow                                             "
"                   Blake Walters                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally adapted from CAVITY.MOR.V05 by Eric Fox in 1984   "
"  and further developed by Dave Rogers in 1985 and Alex Bielajew in 1986.    "
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code simulates the passage of an electron or photon beam in a finite, "
"  right cylindrical  geometry.                                               "
"                                                                             "
"  It also scores pulse height distributions in an arbitrary volume made up   "
"  of any number of regions. There is a write to unit 2 of the calculated     "
"  spectra/response functions.                                                "
"                                                                             "
"  The energy deposited within various user defined regions is scored and     "
"  analyzed statistically following the simulation.                           "
"                                                                             "
"  Iwan Kawrakow, 2003:                                                       "
"                                                                             "
"  Changes since Revision 1.55 in RCS; work done from March to June 2003      "
"  during the preparation of the EGSnrc MP system:                            "
"                                                                             "
"  - replaced all date and time stuff with calls to the new egsnrc date and   "
"    time routines.                                                           "
"                                                                             "
"  - fixed occurrences of local variables assumed to be static                "
"                                                                             "
"  - implemented a new parallel processing strategy using a lock files to     "
"    control the execution on multiple CPUs                                   "
"                                                                             "
"  - Cleaned up use of Fortran I/O units which are now explicitly opened and  "
"    closed if needed except for unit 1 (the .egslst file) and unit 15 (the   "
"    errors file), which are defined to be automatically opened in egs_init   "
"    in the .io file.                                                         "
"                                                                             "
"  Dave Rogers, 2011:                                                         "
"                                                                             "
"  Fixed up the kerma scoring routines which were seriously wrong. Main thing "
"  was that only first member of pair produced particles was being included   "
"  in the kerma. Also fixed a minor bug in the plotting of the D/K ratio vs   "
"  depth (bins were offset). Added lots of comments as I tried to relearn the "
"  code and made many comments in lower case to make them more readable.      "
"                                                                             "
"  Reid Townson, 2017:                                                        "
"                                                                             "
"  Energy depositions for kerma calculations below the cut-off are now sorted "
"  out using AUSGAB to include only Auger from relaxations, not fluorescence. "
"                                                                             "
"#############################################################################"


%C80
%Q1
%I4
!INDENT F2;
;
REPLACE {$VERSION} WITH {
,' ', }
;
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"******************************************************************************
"
"
"                               ********************
"                               *                  *
"                               * dosrznrc.mortran *
"                               *                  *
"                               ********************
"
"
"       INTRODUCTION:
"       This code simulates the passage of an electron or photon beam in a
"       finite, right cylindrical  geometry.
"
"       It also scores pulse height distributions
"       in an arbitrary volume made up of any number of regions.
"       There is a write to unit 2 of the calculated spectra/response functions
"
"       The energy deposited within various user defined regions is scored and
"       analyzed statistically following the simulation.
;
"       USER CONTROLS:
"       The user 1) defines the geometry of the target via the input of a
"                   number of planar and cylindrical coordinates which
"                   divide the cylinder into a number of regions, each region
"                   composed of a user specified material.
"                2) specifies in which of these regions the dose is to be
"                   scored.
"                3) selects the form and degree of detail of the output.
"                4) selects either the energy if a monoenergetic beam is to be
"                   used or specifies an energy spectrum consisting of
"                   energy points and corresponding probabibities
"                5) selects the source of radiation from amongst parallel and
"                   point sources originating from the side or front,
"                   isotropically radiating sources embedded in regions
"                   in the cylinder and phase space files from BEAM.
"                6) selects the number of histories, time limit and statistical
"                   limit. all histories will be run unless time runs out or
"                   the variance calculated in the peak region drops below
"                   the statistical limit.
"                7) selects transport controls such as the fractional energy
"                   loss per charged particle step, the maximum step size,
"                   particle energy cutoffs, range rejection parameters.
"
"       SIMULATION:
"       Each particle emitted from the source is transported along with all its
"       offspring (with energies greater than the cutoff) using EGS4.
"
"       SCORING:
"       In each of the defined dose scoring regions, the total dose and the
"       dose less that due to stopped/discarded particles is scored. In
"       addition, the dose scored in a region can be broken down into that
"       due to particles which entered via the front wall, back wall, outer
"       wall and inner wall. The total number of charged particle steps
"       taken and the total number taken in the dose scoring region
"       are counted.
"
"       OUTPUT:
"       The first section of the output echos the user input.
"       The second section is is composed of messages and information printed
"       during the simulation as a means of monitoring the simulation.
"       The third section details the total doses accumulated with
"       accompanying statistical uncertainties.
"       The first and third sections may include grid format summaries if
"       requested by the user.
"       Plot files for the xmgr program are also output.
;

"       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
"       ===========================================================
"         Z axis = axis of rotation runs across page shown as .......
"
"
"       --------------------------------------------------------- RCYL(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
"       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
"       --------------------------------------------------------- RCYL(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RCYL(2)
"       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
"       --------------------------------------------------------- RCYL(1)
"..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
;"      ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
"
;
"=============================================================================
"
"                       HISTORY
"
"   This is the work-horse dose scoring code developed and used extensively
"   at NRC.  The major developers were Alex Bielajew and Dave Rogers
"   and undergarduate student assistants along with specific patches
"   and extensions by others at NRC. In particular, it was converted
"   for EGSnrc use by Iwan Kawrakow.
"
"   If using this code, please reference it as the NRCC user-code DOSRZnrc
"   for the EGSnrc system and cite PIRS-702

"*******************************************************************************
"*******************************************************************************
"   Instructons for use of input routines
"
"   Input is via the routine get_inputs which has extensive documentation
"   at the top of its source code.
"
"   Inputs are all in the format: name of value_sought= value
"   where the name of value_sought must match that expected by the
"   program. The = sign must have no blanks on its immediate left and
"   at least one on its immediate right..
"
"   The value_sought must be the first thing on a line but blanks are
"     allowed before it.
"
"   Various inputs are only sought between certain delimeter strings
"     which are defined below (eg :start I/O control: :stop I/O control:)
"     If not specified, the whole file is searched for a requested value_sought.
"     Delimeter strings are enclosed by colons.
"     Note that within delimeter strings, order of inputs does not matter.
"
"   If a requested quantity is not found, this is noted in $input.errors
"     and this file is printed at the end of the log file.
"
"   A semi-colon implies the end of input for this quantity but is
"     not mandatory.  However, this means they cannot be used in titles.
"   A # sign indicated everything else on the line is a comment (and
"     cannot be used in titles.
"   Case is not important in the names of the quantites.
"
"   Commas separate multiple values for a given quantity and a comma
"     at the end of a line implies there is more input on the next line.
"   Values can extend over as many lines as needed. Use commas to imply
"     there are more values on the next line.
"
"   Blank lines and blanks in general are ignored.
"   tabs are NOT allowed when character input is being sought,
"   including tabs used to put # to the right after a character input. Use
"   blanks instead.
"
"   The maximum record length is 256 characters.
"
"   There is a routine morph_dosrz which takes an old format input file
"     and translates it.
"
"   There should be a file morph_template.egs4inp which can be used
"     and which defines most options.
"
"   One drawback of this system is that there is a disconnect between
"     the internal variable name used and the value_sought strings.
"     In the input description variables listed in [ ] braces are
"     the internal variable names associated with this input.
"
"*******************************************************************************
"* (1)  *  Integers between parentheses show the value of the internal         *
"*      *  variable corresponding to this input. These are for reference only. *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value(no ; or #).              *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"*******************************************************************************
"                                TITLE
"                                *****
"*******************************************************************************
"
"       TITLE          (C)  Title of the input file (format= '80A1')
;
"*******************************************************************************
"                       INPUT/OUTPUT CONTROL INPUT
"                       **************************
"*******************************************************************************
"
" I/O DELIMETERS:    :start I/O control:
"                    :stop I/O control:
"
"  IWATCH= off         (0)  for normal output
"        = interactions(1)  output info on every discrete interaction
"        = steps       (2)  output on every electron/photon step as well
"        = deposited   (3)  output when energy is deposited as well
"        = graph       (4)  outputs file for EGS_Windows graphics
"                           [IWATCH]
"
"  STORE INITIAL RANDOM NUMBERS
"        = no          (0)  DO NOT STORE THE INITIAL RANDOM NUMBERS
"        = last        (1)  STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
"        = all         (2)  STORE ALL THE INITIAL RANDOM NUMBERS
"
"  IRESTART
"        = first       (0)  first run for this input file
"        = restart     (1)  restart of a previous run, i.e. add more histories
"        = analyze     (3)  just read in the raw data and do the statistical
"                           analysis( gives no timing - restart 100 histories
"                           to get the same effect and more info)
"        = start-RNS   (4)  read starting random numbers from a filE (e.g. FOR
"                           OUTPUT TO A GRAPHICS PACKAGE)
"        = parallel    (5)  post-process distributed runs (all files
"                           named <filenamebase>_w#)
"                           [IRESTART ]
"
"  OUTPUT OPTIONS
"        = short                      (0)  short output -just dose grid(DG)
"        = dose summary               (1)  output dose summary only (DS)
"        = material summary           (2)  output material summary grid(MG) & DG
"        = material and dose summary  (3)  output MG + DS
"        = long                       (4)  output MG + DS + DG
"                              Note-any time there is a dose summary, there
"                              is also an .egs4dose file, unit 10
"                           [IOOPTN]
"
"  STORE DATA ARRAYS
"        = yes             (0) Store data arrays dor re-use
"        = no              (1) don't store them
"                          [IDAT]
"
"  ELECTRON TRANSPORT
"        = normal          (0) normal electron transport (discrete interactions)
"        = no interactions (1) no discrete interactions (used for CDSA
"                              calculations but note that special data
"                              sets are also needed to do a full CSDA
"                              calculation. All turning off
"                              interactions does is just that. See use
"                              of IUNRST=2,3,4 PEGS4 data sets for real CSDA)
"                           [ ICSDA]
"
"                         For complex geometries you may want to just output
"                         a few regions.  These are defined here. Note that
"                         proper transport is done everywhere and this is
"                         NOT related to range rejection.
"
"  DOSE ZBOUND MIN    (I) Minimum plane # defining dose region (default=1)
"                         [NZDMIN]
"  DOSE ZBOUND MAX    (I) Maximum plane # defining dose region
"                         [NZDMAX]
"  DOSE RBOUND MIN    (I) Minimum cylinder # defining dose region (default=0)
"                         [NRDMIN]
"  DOSE RBOUND MAX    (I) Maximum cylinder # defining dose region
"                         [NRDMAX]
;
"
"*******************************************************************************
"                       MONTE CARLO CONTROL INPUT
"                       *************************
"*******************************************************************************
"
" MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
"                            :stop Monte Carlo inputs:
"
"  NUMBER OF HISTORIES         (I)  # HISTORIES TO RUN
"                                   (MIN:100, DEFAULTS TO 20 000,
"                                   max=1073741824=2^30 max is a compiler
"                                   restriction for 32bit integers
"                                   [NCASE]
"  INITIAL RANDOM NO. SEEDS=  INTGER1, INTEGER2
"                  User-code can use RANLUX or RANMAR, depending on selection
"                  Default is RANLUX
"            RANLUX
"                  INTEGER1 is the luxury level, use 1 to 4, 4 taking longest
"                           default is 1 (set by $DEFAULT-LL in ranlux.macros)
"                  INTEGER2 selects the independent sequence to use, it
"                           can be from 1 to 1073741824 (2**30)
"            RANMAR
"                  INTEGER1 is a seed between 1 and 31328 (0 =>default 1802)
"                  INTEGER2 is a seed between 1 and 30081 (0 =>default 9937)
"                     Selection of unique INTEGER2 values guarantees independent
"                     sequences.
"            Note:
"               After the seeds are first input and used for initialization,
"               the variables IXXIN and JXXIN are just pointers used by the RNG
"
"  MAX CPU HOURS ALLOWED       (I)  max CPU time allowed in hours, default=999
"                                   [TIMMAX]
"
"  IFULL
"         = dose and stoppers         (0) just calculate total dose and that due
"                                         to stoppers and discards.
"         = entrance regions          (1) as well analyze the total dose per
"                                         entrance region.
"         = pulse height distribution (2) score a pulse height distribution in
"                                         the volume specified after the
"                                         material inputs.
"         = scatter fraction          (3) score the scatter fraction instead of
"                                         stoppers.  Only for incident photons.
"                                         Dose after Compton and for fluorescent
"                                         photons if followed.
"
"  STATISTICAL ACCURACY SOUGHT        (R) % statistical accuracy of the total
"                                         dose in the peak region that is sought
"                                         The program executes until this
"                                         accuracy is obtained or the CPU time
"                                         runs out. If 0, no effect.
"
"  SCORE KERMA
"        = no              (0) do not score kerma
"        = yes             (1) score kerma wherever dose scored and estimate
"                              ratio of dose/kerma using correlated uncertainty
"                              estimate.
"                              This only makes sense for photon beams.
"                              [IKERMA]
"
;
"*******************************************************************************
"                       CYLINDRICAL GEOMETRY INPUT
"                       **************************
"*******************************************************************************
"
" GEOMRZ DELIMETERS:    :start geometrical inputs:
"                       :stop geometrical inputs:
"
"  METHOD OF INPUT
"        = Groups         (0)   input groups of slabs of equal thickness
"        = Individual     (1)   detailed input of the geometry and media.
"                               [ITERSE]
"
"-------------------------------------------------------------------------------
"
" Information defining depth boundaries along z axis (all dimensions cm)
"
" Only if  METHOD OF INPUT=  Groups
"
"  Z OF FRONT FACE        (R)   start of first slab (real)
"  NSLAB                  (M)   # planar slabs in a group (integers)
"  SLAB THICKNESS         (M)   thickness of each slab in the group (reals)
"
"
" Only if  METHOD OF INPUT=  Individual
"
"  Z OF FRONT FACE        (R)   start of first slab (real)
"  DEPTH BOUDARIES        (M)   geometrical z-plane coordinates (reals)
"
"-------------------------------------------------------------------------------
"
"  Information defining radial boundaries
"
"  RADII                  (M)   radii of cylinders defining the geometry (reals)
"
"-------------------------------------------------------------------------------
"  MATERIAL INPUT
"  **************
"
"  MEDIA              (M)   material name which must match that in the
"                           pegs4 data set EXACTLY, including case.
"                           24 characters max per medium, ended by , or ;
"
"  Define which media in which regions, numbering in order given above.
"
"  DESCRIPTION BY= Regions(0)   using the geometric region number
"                = Planes (1)   USING THE IX, IZ PLANES
"                               [DESCRIBE]
"
" If DESCRIPTION BY= Regions
"
"  MEDNUM                 (M)   the material number (integers)
"                               (MEDNUM=0 => vacuum)
"  START REGION           (M)   initial geometrical zone(irl) (integers) for
"                               this medium [NREGLO]
"  STOP REGION            (M)   final geometrical zone(irl) (integers) for
"                               this medium.[NREGHI]
"                               ( >NREGLO to input more than one zone)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
"                         These inputs should be thought of as triplets of
"                         MEDNUM,START and STOP REGIONs     which are used
"                         to specify the medium numbers for all regions where
"                         the medium is not the default (medium 1).
"
" If DESCRIPTION BY=  Planes
"
"  MEDNUM                 (M)   the material number (integers)
"                               (MEDNUM=0 => vacuum)
"  START ZSLAB            (M)   initial zslab (iz) (integers)
"  STOP ZSLAB             (M)   final zslab (iz) (integers)
"  START RING             (M)   initial radial ring (ix) (integers)
"  STOP RING              (M)   final radial ring (ix) (integers)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"  One must use one type of input or the other so you must decide
"  which is more convenient for any given case.
"
"
;
"*******************************************************************************
"                       PULSE HEIGHT DISTRIBUTION INPUTS     (ONLY IF IFULL=2)
"                       ********************************
"*******************************************************************************
"
" (ONLY IF IFULL= pulse height distribution)
"
"  PULSE HEIGHT DISTRIBUTION DELIMETERS:
"                      :start pulse height distribution input:
"                      :stop pulse height distribution input:
"
"
"   REGION OF SENSITIVE VOLUME   (M)   Region numbers(IRL) of sensitive volume
"
"
"   SLOTE    (R)   for the pulse height distribution, defines the
"                  output energy bins. for SLOTE > 0.0, use equal size
"                  bins of this width in MeV (this will get increased
"                  by  factors of two until the whole spectrum input
"                  gets covered.
"                  SLOTE < 0.0, flags input additional 'TOPS OF ENERGY BINS'
"
"   DELTAE   (R)   code analyses peak efficiencies using a bin width
"                  of 2*deltae about each peak and two background regions
"                  of width deltae above and below the peak. default
"                  value is 0.005 MeV. (meaningless for electrons and positrons
"
" IF SLOTE < 0.0 Input tops of individual energy bins for pulse height distn.
"
"   TOPS OF ENERGY BINS   (M)  lowest energy first, tops of bins.
"                  [BINTOP]
"
"
"*******************************************************************************
"                            SOURCE INPUT(check latest version of srcrz)
"                            **************
"*******************************************************************************
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"FOR ALL SOURCES
"                                      Charge of the incident beam
"  INCIDENT PARTICLE= electron   (-1)  electrons
"                     photon     (0)   photons
"                     positron   (1)   positrons
"
"  (for SOURCE 21,22,23)  all    (2)  include all of the particles
"                                     in the phase space file
"                                     [IQIN]
"                    charged     (3)  include e+ and e-
"
"  SOURCE NUMBER                 (I)   number of the source
"                                      [ISOURC]
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  0 <<<<<<<<
"
"     PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS) ""toc:
"
"
"  SOURCE OPTIONS            (M4)  RBEAM, UINC, VINC, WINC
"
"               RBEAM          radius of parallel beam in cm
"                              (defaults to max radius of geometry)
"               UINC           incident x-axis direction cosine
"               VINC           incident y-axis direction cosine
"               WINC           incident z-axis direction cosine
"                              NOTE: (UINC,VINC,WINC)
"                              get automatically normalized
"                              defaults to (0.0,0.0,1.0)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  1 <<<<<<<<
"
"     POINT SOURCE ON AXIS INCIDENT FROM THE FRONT    ""toc:
"
"  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, 0, 0
"
"               DISTZ          distance of the point source from the
"                              front of the target in cm (DEFAULT 100.)
"               RBEAM          radius of the beam at the front of the
"                              target in cm (defaults to MAX radius)
"
"------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  2 <<<<<<<<
"
"        BROAD PARALLEL BEAM INCIDENT FROM FRONT (+VE Z-AXIS) ""toc:
"               WITH UNIT AREA BEAM AND LARGE SCORING AREA
"
"  SOURCE OPTIONS          (M4)  0, 0, 0, 0
"
"------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  3 <<<<<<<<
"
"     UNIFORM ISOTROPICALLY RADIATING DISK OF FINITE SIZE   ""toc:
"            (MUST BE ALLOWED FOR IN THE GEOMETRICAL DEFINITIONS)
"
"  SOURCE OPTIONS                (M4)  RMINBM, RBEAM, ZSMIN, ZSMAX
"
"               RMINBM,RBEAM           inner and outer radii of source region
"                                      must be inside geometry
"               ZSMIN,ZSMAX            min and max z values for source
"
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  4 <<<<<<<<
"
"     FOR CENTRAL AXIS FLUENCE VS BEAM RADIUS      ""toc:
"
"  SOURCE OPTIONS            (M4)  RCAXIS, 0, 0, 0
"
"               RCAXIS       radius of central axis scoring zone (cm)
"
"        NOTE: this source option treats the cylindrical radii input
"              above as beam radii. the largest radius must be infinite
"              and the phantom must be homogeneous (at least in each layer)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  10 <<<<<<<<
"
"     PARALLEL BEAM INCIDENT FROM THE SIDE (+VE Y-AXIS)    ""toc:
"
"  SOURCE OPTIONS           (M4)  XBEAM, ZBEAM, 0, 0
"
"               XBEAM             half-width of the rectangular beam in cm
"                                 (defaults to max radius)
"               ZBEAM             half-height of the rectangular beam in cm
"                                 (defaults to max)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  11 <<<<<<<<
"
"     POINT SOURCE INCIDENT FROM THE SIDE     ""toc:
"
"
"  SOURCE OPTIONS                (M4)  DISTRH, XBEAM, ZBEAM, 0
"
"               DISTRH                 distance of the source from the middle
"                                      of the target in cm (defaults to 100.)
"               XBEAM                  half-width of the beam at the center of
"                                      the target in cm (defaults to max radius)
"               ZBEAM                  half-height of the beam at the center of
"                                      the target in cm (defaults to max)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  12 <<<<<<<<
"
"   POINT SOURCE OFF AXIS         ""toc:
"
"  SOURCE OPTIONS                (M4)  DISTRH, DISTZ, 0, 0
"
"               DISTRH                 distance of the point source off the
"                                      Z-axis.
"               DISTZ                  perpendicular distance of the
"                                      point source away from the front face.
"                                      a negative value is permitted.
"
"                                      DISTZ > 0
"                                      point located in front of front face
"
"                                      0 > DISTZ > -(ZPLANE(NPLANE)-ZPLANE(1))
"                                      point located between front and rear face
"
"                                      DISTZ < -(ZPLANE(NPLANE)-ZPLANE(1))
"                                      point located rear of rear plane
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  13 <<<<<<<<
"
"        PARALLEL BEAM FROM ANY ANGLE     ""toc:
"
"  SOURCE OPTIONS                (M4)  UINC, VINC, WINC, 0
"
"               UINC                   incident x-axis direction cosine
"               VINC                   incident y-axis direction cosine
"               WINC                   incident z-axis direction cosine
"
"                 NOTE: (UINC,VINC,WINC) get automatically normalized
"                       default is (0.0,0.0,1.0)
"
"
"------------------------------------------------------------------------------
"                     >>>>>>>> SOURCE  14 <<<<<<<<
"
"   POINT SOURCE ON AXIS INCIDENT FROM THE FRONT WITH ALL   ""toc:
"    EVENTS INSIDE RMINBM NOT FOLLOWED (A FUDGE FOR COLLIMATOR STUDIES)
"
"  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, RMINBM, IGNORED
"
"               DISTZ                  distance of the point source from the
"                                      front of the target in cm
"                                      (defaults to 100.)
"               RBEAM                  radius of the beam at the front of the
"                                      target in cm (defaults to max radius)
"               RMINBM                 below this radius, all histories are
"                                      terminated by the source routines by
"                                      giving them zero weight.
"                                      The howfar routines must check for this.
"
"-------------------------------------------------------------------------------
"
"
"
"                     >>>>>>>> SOURCE  15 <<<<<<<<
"
"  POINT SOURCE OFF AXIS. The same as source 12 but uses an alternative
"  implementation for sampling points on the surface of the RZ-geomtry. The
"  motivation for implementing this source was to check that source 12 is OK
"  and to check the effect of varying weights from the source on the
"  statistical uncertainty (contrary to source 12, source 16 produces
"  essentially  constant weights if the geometry-to-source distance is large
"  compared to the geometry dimension, a typical situation for ion chamber
"  simulations)
"
"  SOURCE OPTIONS                (M4)  DIST, ANGLE, IGNORED, IGNORED
"
"             DIST                     distance of the centre of the geometry
"                                      to the source in cm.
"             ANGLE                    angle of rotation around the x-axis.
"                                      (because of the cylindrical symetry,
"                                      rotations around the x-axis and y-axis
"                                      are indistinguishable). 0 degrees
"                                      corresponds to a source above the front
"                                      face (i.e. the same as source 1), 90
"                                      degrees to a source from the side
"                                      (i.e. the same as source 11).
"                                      The source MUST be outside the geometry,
"                                      otherwise the initialization routine
"                                      will abort execution.
"
"           Note that if you are not actually rotating about the center of the
"           geometry, you must calculate the angle and distance as if you
"           were.
"
"-------------------------------------------------------------------------------
"
"
"
"                     >>>>>>>> SOURCE  16 <<<<<<<<
"
"           EXTENDED (CIRCULAR OR RECTANGULAR)  SOURCE OFF AXIS.
"
"  SOURCE OPTIONS                (M4)  DIST, ANGLE, TMP1, TMP2
"
"            DIST                      distance of geometry centre to source
"                                      centre in cm.
"
"            ANGLE                     angle of rotation around the x-axis
"                                      (see comments/explanations to source 15)
"
"            TMP1, if TMP2 <= 0        radius of the source (i.e., the emitting
"        or  TMP2, if TMP1 <= 0        position is picked uniformly within the
"                                      circle).
"
"            TMP1 and TMP2, if both    half-sizes of the radiating rectangle
"            >= 0                      in x- and y-directions before rotation,
"                                      i.e., initially x and y are picked
"                                      within the rectangle and z is set to
"                                      -DIST + geometry centre. Then a rotation
"                                      around the x-axis is performed.
"       In all cases the source plane is perpendicular to the line joining
"       it to the center of the geometry.   Note that this introduces a
"       slight error if the center of your geometry is not the true point
"       of rotation.
"
"       Note: if TEMP1 <= 0 and TEMP2 <= 0, source 16 becomes a point-source
"             off-axis, i.e. the same as source 12 and 15.
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  20 <<<<<<<<
"
"   RADIAL DISTRIBUTION INPUT      ""toc:
"
"  MODEIN= Local                 (0)   if radial distribution is to be input
"                                      locally through the .egs4inp file
"        = External              (1)   if the distribution is to be input
"                                      via an external file
"
"                        -----------------------------
" ONLY IF MODEIN= Local
"
"  NRDIST                        (I)   # radial bins in distribution histogram
"  RDISTF                        (M)   top of radial bin.
"                                      should be values for 1 to NRDIST.
"  RPDF                          (M)   Probability of initial particle being
"                                      in this bin.
"                                      Probability doesn't need to be normalized
"                                      but it should be in units cm**-2
"                                      Should be values for 1 to NRDIST.
"  RDIST IOUTSP= None            (0)   No distribution data in output summary
"              = Include         (1)   include distribution data output summary
"
"                        -----------------------------
"  ONLY IF MODEIN= External
"
"  RDIST FILENAME                (C)   filename(with ext) contains
"                                      distribution information
"
"  RDIST IOUTSP= None            (0)   No distribution data in output summary
"              = Include         (1)   include distribution data output summary
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  21 <<<<<<<<
"
"    FULL BEAM PHASE-SPACE BEAM DATA, INCIDENT ON FRONT FACE    ""toc:
"
"  SOURCE OPTIONS                (M4)  IMODE, 0, 0, 0
"
"               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
"                                  2=> 8 variables/record: the above + ZLAST
"
"  FILSPC                        (C)   filename (with ext) contains
"                                      phase space information
"                                      (maximum of 80 characters)
"                                      (assigned to unit 42)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  22 <<<<<<<<
"
"    FULL BEAM PHASE-SPACE BEAM DATA FROM ANY ANGLE, INSIDE OR OUTSIDE   ""toc:
"
"    PARTICLES ARE READ IN FROM A BEAM PHASE SPACE and placed on a plane
"    described by the SOURCE OPTIONS inputs (see below). Then it is checked
"    whether they are already inside the geometry. If yes, the region index
"    is determined and the shower intiated. If not, it is checked whether
"    the particle trajectory will intersect the geometry (assuming that the
"    geometry is surrounded by vacuum). If not, the particle is rejected and
"    the next one taken from the phase-space file. If yes, the particle
"    is placed on the entry point and the shower is initiated.
"
"  SOURCE OPTIONS                (M4)  IMODE, DIST, ANGLE, ZOFFSET
"
"               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
"                                  2=> 8 variables/record: the above + ZLAST
"               DIST               Perpendicular distance of the phase-space
"                                  plane to the point of rotation in cm.
"               ANGLE              Angle of rotation in degrees. The rotation
"                                  is performed around an axis that is parallel
"                                  to the x-axis and passes through the point
"                                  (x,y,z)=(0,0,ZOFFSET).
"               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
"                                  the centre of the geometry is taken as
"                                  the point of rotation (but note that
"                                  the maximum value allowed by the input
"                                  routine is 1e6, so that |ZOFFSET| must
"                                  be between 1e4 and 1e6 to use the centre
"                                  of the geometry automatically).
"
"    Examples:
"       - to place a phase-space on the upper z-face of the geometry,
"         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
"         This is the same as source 21
"       - to place a phase space on the lower z-face of the geometry,
"         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
"       - to have a phase file incident from, say, 60 degrees with
"         a distance to the centre of the geometry of 30 cm, use
"         DIST=30, ANGLE=60, ZOFFSET=9999.
"   etc.
"
"  FILSPC                        (C)   filename (with ext) contains
"                                      phase space information
"                                      (maximum of 80 characters)
"                                      (assigned to unit 42)
"
;
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  23 <<<<<<<<
"
"    BEAM TREATMENT HEAD SIMULATION AS SOURCE INCIDENT FROM AND ANGLE,  ""toc:
"    INSIDE OR OUTSIDE PHANTOM                                          ""toc:
"
"    PARTICLES ARE READ DIRECTLY FROM A BEAM SIMULATION COMPILED AS A
"    SHARED LIBRARY.  Particles are read at the scoring plane in
"    the BEAM simulation (although no phase space file is scored) and are
"    tranlated/rotated by the inputs DIST, ANGLE, XOFFSET, YOFFSET, ZOFFSET,
"    described below.  Then it is checked
"    whether they are already inside the geometry. If yes, the region index
"    is determined and the shower intiated. If not, it is checked whether
"    the particle trajectory will intersect the geometry (assuming that the
"    geometry is surrounded by vacuum). If not, the particle is rejected and
"    the next one taken from the BEAM simulation (more histories are run in
"    the BEAM simulation if required).  If yes, the particle
"    is placed on the entry point and the shower is initiated.
"
"  BEAM CODE                     (C)  The name of the accelerator code being
"                                     used as a source including the BEAM_
"                                     prefix (ie BEAM_accelname).  This code
"                                     must have been compiled as a shared
"                                     library (see the BEAM manual for more
"                                     details) and exist as
"                                     libBEAM_accelname.so (for Linux/Unix) or
"                                     libBEAM_accelname.dll (for Windows) in
"                                     directory $EGS_HOME/bin/config.
"
"  INPUT FILE                    (C)  The name of a working input file
"                                     (no .egsinp extension) for
"                                     the BEAM code BEAM_accelname.  This
"                                     input file must specify output of a
"                                     phase space file at one scoring plane.
"                                     Particles that would have been scored
"                                     in the phase space file are extracted
"                                     and used as the incident particles in
"                                     the DOSXYZ simulation instead.  The
"                                     input file must exist in the directory
"                                     $EGS_HOME/BEAM_accelname.
"
"  PEGS FILE                     (C)  The name of the pegs4 data set (no
"                                     .pegs4dat extension) used
"                                     by BEAM_accelname with the input file
"                                     specified by INPUT FILE.  The pegs4
"                                     data set must exist in either
"                                     $HEN_HOUSE/pegs4/data or in
"                                     $EGS_HOME/pegs4/data.
"
"  WEIGHT WINDOW                 (M2)  MIN_WEIGHT_23, MAX_WEIGHT_23
"
"               MIN_WEIGHT_23         Min. weight of particles to use from
"                                     the BEAM simulation (defaults to -1E30)
"               MAX_WEIGHT_23         Max. weight of particles to use from
"                                     the BEAM simulation (defaults to 1E30)
"
"  SOURCE OPTIONS                (M5)  DIST, ANGLE, ZOFFSET, XOFFSET, YOFFSET
"
"               DIST               Perpendicular distance of the phase-space
"                                  plane to the point of rotation in cm.
"               ANGLE              Angle of rotation in degrees. The rotation
"                                  is performed around an axis that is parallel
"                                  to the x-axis and passes through the point
"                                  (x,y,z)=(0,0,ZOFFSET).
"               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
"                                  the centre of the geometry is taken as
"                                  the point of rotation (but note that
"                                  the maximum value allowed by the input
"                                  routine is 1e6, so that |ZOFFSET| must
"                                  be between 1e4 and 1e6 to use the centre
"                                  of the geometry automatically).
"               XOFFSET,YOFFSET    X and Y offset of scoring plane in BEAM
"                                  simulation (cm).  Offsets are applied before
"                                  rotating the source.
"
"    Examples:
"       - to have BEAM simulation incident on the upper z-face of the geometry,
"         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
"         This is the same as source 21
"       - to have BEAM simulation incident on the lower z-face of the geometry,
"         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
"       - to have BEAM simulation incident from, say, 60 degrees with
"         a distance to the centre of the geometry of 30 cm, use
"         DIST=30, ANGLE=60, ZOFFSET=9999.
"
"
;
"*******************************************************************************
"
" Source Energy Inputs (not required if ISOURC=21,22,23 - phase space or BEAM
"                                                         simulation )
"
"  Input from ensrc.mortran
"
" ENSRC DELIMETERS:  :start source inputs:
"                    :stop source inputs:
"
"
"  INCIDENT ENERGY
"        = monoenergetic  (0)  if monoenergetic beam
"        = spectrum       (1)  if energy spectrum to be used
"
"           ---------------------------------------
"
"  If INCIDENT ENERGY= Monoenergetic:
"
"     INCIDENT KINETIC ENERGY(MEV)   (I)
"                                   kinetic energy of the incident beam in MeV
"                                   (defaults to 1.25)
"
"           ---------------------------------------
"
"  If INCIDENT ENERGY= Spectrum:
"
"                   SPEC FILENAME   (C)  filename (with ext)
"                                   contains spectrum information
"
"                                   FILE FORMAT:
"                                   TITLE      spectrum title  (80 char)
"                                   NENSRC, ENMIN, MODE
"                                   NENSRC     # energy bins in spec. histogram
"                                   ENMIN      lower energy of first bin
"                                   MODE       =0, assumes cts/bin
"                                              =1  assumes cts/MeV
"                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
"                                   top of energy bin and probability of
"                                   initial particle being in this bin.
"                                   probability does not need to be normalized
"
"                   SPEC IOUTSP
"                        = none     (0)  no spectrum data in output summary
"                        = include  (1)  include spectrum data in output summary
;
"*******************************************************************************
"
"                       TRANSPORT CONTROL INPUT
"                       ***********************
"
"  BE AWARE!!!!!!!!!!!!!!!!!!!!
"            IK changed this section to make things more flexible.
"            All mc transport parameter are handled in a separate
"            routine, the delimeters are
"                  :start mc transport parameter:
"                  :stop mc transport parameter:
"            Input associated with variance reduction,
"            previously in the transport control section,
"            is to be put between the delimeters
"                  :start variance reduction:
"                  :stop variance reduction:
"
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  Currently, the following options are available (except for a few entries,
"  case does not matter):
"
"       Global ECUT=     Set a global (in all regions) electron transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Set a global (in all regions) photon transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Set a global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions will
"                        be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Set the maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%)
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is Off
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        even in `well conditioned' situations (e.g. depth
"                        dose curves for RTP energy range electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If On, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but signifficant in the keV energy range.
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski or penelope.  If set to On or ik, then
"                        use Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then use the cross-sections of
"                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
"                        Similar for kolbenstvedt, gryzinski and penelope.
"                        This is only of interest in kV X-ray calculations.
"                        Note that the user can supply their own EII
"                        cross-section data as well. The requirement is that
"                        the file eii_suffix.data exists in the $HEN_HOUSE/data
"                        directory, where suffix is the name specified.
"                        Entry is case-sensitive except for Off, On or ik.
"                        [ eii_flag ]
"       Bound Compton scattering=  On, Off, Simple or norej
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impuls approximation. Default is On.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to turn on for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Pair angular sampling= Off, Simple or KM
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.
"                        Default is Simple, make sure you always use Simple or
"                        KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel--the default), epdl (Evaluated Photon
"                        Data Library), xcom and pegs4.  Allows the use of
"                        photon cross-sections other than from the PEGS4 file
"                        unless the pegs4 option is specified.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is Off
"                        [ IPHTER ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering,
"                        even if no Rayleigh data in PEGS4 file.
"                        Default is Off. Should be turned on for low energy
"                        applications. If custom, user must provide media names
"                        and form factor files for each medium.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"       Atomic relaxations= Off, On
"                        Default is Off. The effect of using On is twofold:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross seections
"                        - Shell vacancies created in photo-absorption events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         Make sure to turn this option on for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"                         can also be turned On/Off on a region-by-region
"                         basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                        in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn on in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************
"
"                    VARIANCE REDUCTION
"                    ******************
"
"  Delimeter:       :start variance reduction:
"                   :stop variance reduction:
"
"  BREM SPLITTING
"         = Off            (0)   no bremsstrahlung splitting
"         = On             (1)   there is bremsstrahlung spliting
"
"  NUMBER OF BREMS PER EVENT
"                          (I)   number of brems / event if splitting on
"
"  CHARGED PARTICLE RUSSIAN ROULETTE
"         = Off        (0)  Do not play Russian Roulette with charged particles
"         = On         (1)  Play Russian Roulette with charged particles with
"                           probability of survival=PROB_RR=1/nbr_split.
"                           [I_PLAY_RR]
"
"  ELECTRON RANGE REJECTION
"         = off        (0)  No electron range rejection
"         = on         (1)  Do electron range rejection. All charged
"                           particles without enough range to get out
"                           of their current region have their
"                           history terminated.  This uses EGSnrc internal
"                           range rejection and takes no time to test.
"                           The parameter ESAVEIN also plays a role (see below)
"                           [IREJCT]
"
"      We could/should? reinstitute the old approach by searching all
"      regions outside the region of interest, finding the one with the
"      greatest range and then use that range as a test against the distance
"      to the region of interest.  Some of the coding is left in place.
"      This has been implemented in CAVRZnrc
"
"  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
"                           electron  when E< ESAVEIN and RANGE < CDIST
"                           where CDIST is closest distance to region of
"                           interest specified below. This ignores brem
"                           losses below ESAVEIN.
"                           This parameter must be input even if not used.
"                           ESAVEIN is a total energy.
"
"
"========================================================================
"  FOLLOWING IS NOT USED  - leave in until decide what to do
"========================================================================
"  RANGE REJECTION PARAMETERS
"                 (M5)   CRANGE(1,1),CRANGE(2,1),ERANGE,CRANGE(1,2),CRANGE(2,2)
"
"               Coefficients of a 2-piece logarithmic fit to the electron
"               CSDA range used to discard electrons that cannot reach the
"               range rejection region.
"               The electron residual range is computed in HOWFAR as
"               RANGE=EXP(CRANGE(1,I)+CRANGE(2,I)*ELKE)/RHO
"               where  i=1 for EKE>ERANGE, ELSE I=2.
"               default values for crange,erange are for carbon
"               with ERANGE=200keV FROM B&S '64. The range should always
"               be overestimated with the closest fit being at the energy
"               where most of the electrons are expected to be.
"            NB There is only one medium used and hence it must be the
"               one with the longest range in the problem.
;
"
" If  ELECTRON RANGE REJECTION= on
"
"  RANGE REJECTION MINIMUM PLANE   (I)  min. Z boundary for range rejection
"
"  RANGE REJECTION MAXIMUM PLANE   (I)  max. Z boundary for range rejection
"
"  RANGE REJECTION MINIMUM RADIUS  (I)  min radial boundary for range rejection
"
"  RANGE REJECTION MAXIMUM RADIUS  (I)  max radial boundary for range rejection
"
"               The above boundaries define the ``tracking region'' and if
"               a charged particles range is such that it cannot get to
"               this region, the history is terminated if E<ESAVEIN.
"========================================================================
"========================================================================
"
"
"  RUSSIAN ROULETTE DEPTH      (R)
"                           for russian roulette -
"                           as any photon crosses the Z='RUSSIAN ROULETTE DEPTH'
"                           plane,  russian roulette is played.
"                           [RRZ]
"
"  RUSSIAN ROULETTE FRACTION   (R)
"                           Each time russian roulette is played, RRF IS THE
"                           probability of survival.
"                           weight increases by 1/RRF,  if it survives
"                           [RRCUT]
"
"                    ****** IF BOTH ZERO, NO RUSSIAN ROULETTE IS PLAYED ******
"
"  EXPONENTIAL TRANSFORM C     (R)
"                           Parameter for pathlength biasing <0 FOR SHORTENING
"                           If 0.0, no biasing done.
"                           Review chapter discusses in detail.
"                           [CEXPTR]
;
"
"  PHOTON FORCING
"        = Off         (0)    normal photon transport (no forcing)
"        = On          (1)    force photon interactions explicitly
"                             must set START and STOP FORCING in this case
"                             [IFORCE]
"
"  START FORCING       (I)    number of photon interaction/history at which
"                             to start forcing photon interactions
"                             This input is required even if forcing off
"                             [NFMIN]
"  STOP FORCING AFTER  (I)    number of photon interaction/history after which
"                             to stop forcing photon interactions
"                             [NFMAX]
"                             STOP FORCING AFTER must be >= START FORCING
"                             This input is required even if forcing off
"
"  CS ENHANCEMENT FACTOR  (R)  can scale the photon cross section by this
"                             factor in a specified set of regions.
"                             From 1 to 10,000. with a default of 200 if
"                             it is on at all.
"
"  CS ENHANCEMENT START REGION (M)
"  CS ENHANCEMENT STOP REGION  (M)
"                             Photon cross section scalled in these defined
"                             sets of regions.
"                             From 0 to NREG.  Defaults to region 1 which means
"                             no enhancement since this is outside the geometry.
"
"
;
"*******************************************************************************
"
"                             PLOT CONTROL INPUTS
"                             *******************
"*******************************************************************************
"
"  PLOT CONTROL DELIMETERS:   :start plot control:
"                             :stop plot control:
"
"
"   PLOTTING
"          = Off         (0)   no plots or plot files to be prepared
"          = On          (1)   plotting to be prepared or printed
"
"
"  ONLY IF   PLOTTING= On
"
"   LINE PRINTER OUTPUT
"          = Off         (0)   don't plot in egs4lst file
"          = On          (1)   do plot in egs4lst file
"
" ONLY IF   PLOTTING= On
"
"   EXTERNAL PLOTTER OUTPUT
"          = Off         (0)   don't prepare plot files for xmgr
"          = On          (1)   prepare xmgr input  files
"
" ONLY IF   EXTERNAL PLOTTER OUTPUT= On
"   EXTERNAL PLOT TYPE
"          = Point       (1)   point plot in xmgr file
"          = Histogram   (2)   histogram  plot in xmgr file
"          = Both        (3)   both point plot and histogram
"
"
" ONLY IF   PLOTTING= On
"   PLOT RADIAL REGION IX  (M)  radial regions to plot vs depth
"                               (= 0 for no plots)
"
" ONLY IF   PLOTTING= On
"   PLOT PLANAR REGION IZ  (M)  planar slab numbers to plot vs radius
"                               (= 0 for no plots)
"
"******************************************************************************"
"                          END OF INPUTS
"                          *************
"
"*******************************************************************************
"*******************************************************************************
;
"
"                       USER DEFINED MACROS
"                       *******************
;
REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}

REPLACE {$PLTDIM} WITH {500}     "bins for plotting routine xvgrplot"
REPLACE {$EBIN} WITH {$PLTDIM}   "Max number of bins in pulse height distn     "
"                                 Note if you use large values of EBIN so that "
"                                 2*EBIN > MXDATA (below), then use 2*EBIN     "
REPLACE {$ONE-EPS} WITH {0.9999} "USED TO KEEP THE BEAM INSIDE THE TARGET      "
REPLACE {$NSWTCH} WITH {8}       "# OF NRC SWITCHES FOR CONTROLLING SCATTERING "
REPLACE {$MXMED} WITH {10}       "MAX # OF MEDIA                               "
REPLACE {$NCASEMIN} WITH {100}   "min. no. of histories                        "
REPLACE {$NBATCH} WITH {10}     "# BATCHES FOR OUTPUT                          "
REPLACE {$MXSTACK} WITH {500}    "MAXIMUM STACK                                "
REPLACE {$MAXZREG} WITH {200}     "MAX # OF DOSE SCORING PLANAR ZONES          "
REPLACE {$MAXRADII} WITH {60}    "MAX # OF DOSE SCORING RADIAL ZONES           "
REPLACE {$MAXRZ} WITH {$MAXZREG} "MAX($MAXRADII,$MAXZREG)                      "
REPLACE {$MXRDIST} WITH {100}    "# OF POINTS IN RADIAL DISTRIBUTION FIT       "
REPLACE {$MAXIT} WITH {7}        "MAX # OF DOSE COMPONENTS TO BE SCORED        "
"                                (1) TOTAL DOSE                                "
"                                (2) STOPPERS AND DISCARDS DOSE                "
"                                (3) TOTAL DOSE FROM FRONT WALL                "
"                                (4) TOTAL DOSE FROM SIDE WALL                 "
"                                (5) TOTAL DOSE FROM BACK WALL                 "
"                                (6) TOTAL DOSE FROM INSIDE WALL               "
"                                (7) TOTAL DOSE SCORED IN REGION NSRCRG        "
"                                    DUE TO PARTICLES CREATED IN THE           "
"                                    REGION (ONLY WHEN ISOURC = 3)             "
REPLACE {$MAXCMPTS} WITH {$MAXIT}"MAX # OF COMPONENTS IN SUBROUTINE GRID       "
"COMPUTED MACROS                                                               "
REPLACE {$MAXZPLANE} WITH {{COMPUTE $MAXZREG+1}}
"                                 MAX # OF PLANAR BOUNDARIES                   "
REPLACE {$MAXRADII1} WITH {{COMPUTE $MAXRADII+1}}
"                                 MAX # OF RADIAL DOSE COMPONENTS TO SCORE + 1 "
REPLACE {$MXREG} WITH {{COMPUTE ($MAXRADII*$MAXZREG)+1}}
"                                 # IF REGIONS, +1 IS FOR THE VACUUM           "
REPLACE {$MXDATA} WITH {{COMPUTE $MXREG-1}}
"REPLACE {$MXDATA} WITH {{COMPUTE 2*$EBIN}}"
"                       Use the second version of the above macro IF and ONLY  "
"                       if 2*$EBIN > ($MXREG-1)*$STAT                          "
"                       Note an explicit test/check is implemented below"
"                                 MAXIMUM DATA POINTS FOR ANALYSIS             "
REPLACE {$MAXBRSPLIT} WITH {200} "MAX BREM SPLITTING NUMBER"

REPLACE {$MAX_SC_PLANES} WITH {1};"needed to use phsp macros"
;

%E
"Following macro tells code to use the get_inputs routine for"
"the presta II inputs"

REPLACE {$PRESTA-II-INPUTS;}  WITH { call prestaII_inputs; }



;
"This MACRO changes integers of three digits"
"or less into a character string. It is needed with the get_opts routine."
"In each case 48 must be added to the digit we are"
"converting into ASCII since '0' is ASCII # 48."
"Aaron Merovitz, Jan 1998"

REPLACE {$CONVERT_INT(#)_TO_CHAR(#);} WITH {
;
"{P1} is the integer value < 1000"
"{P2} is the character string returned"
      NEGVAL=.FALSE.;
      IF ({P1} < 0) [
         NEGVAL=.TRUE.;
         {P1} = ABS({P1});
      ]
      IF (({P1} = MOD({P1},1000)))[
            CHECK=1;
            IF ({P1} = MOD({P1},10)) [
                IF (NEGVAL) [{P2}='-'//CHAR({P1}+48);]
                ELSE [{P2}=CHAR({P1}+48);]
                CHECK=0;
            ]
            IF ((CHECK.NE.0).AND.({P1} = MOD({P1},100))) [
                a(1)=CHAR(({P1}/10)+48);
                int=(MOD({P1},10)+48);
                a(2)=CHAR(int);
                IF (NEGVAL) [{P2}='-'//a(1)//a(2);]
                ELSE [{P2}=a(1)//a(2);]
                CHECK=0;
            ]
            IF (CHECK.NE.0) [
                a(1)=CHAR(({P1}/100)+48);
                int=(MOD({P1},100)/10+48);
                a(2)=CHAR(int);
                int=MOD({P1},10)+48;
                a(3)=CHAR(int);
                IF (NEGVAL) [{P2}='-'//a(1)//a(2)//a(3);]
                ELSE [{P2}=a(1)//a(2)//a(3);]
            ]
      ]
      ELSE [{P2}='3max';]
}


REPLACE {;COMIN/BREMPR_addition/;} WITH {
   ;COMMON /BREMPR_addition/IBRSPL;
   $INTEGER IBRSPL;         "flag set to 1 if bremsstrahlung splitting used"
!   COMIN BREMPR_addition is defined in DOSRZnrc.mortran;
}
;APPEND {;COMIN/BREMPR_addition/;} TO {;COMIN/BREMPR/;}

;
"MACRO USED FOR FORCING INTERACTIONS IN THE GEOMETRY"
"USED BY EGSnrc FOR VARIANCE REDUCTION"
"      note WT and GWTOLD were updated in fast step"
"      until April 1991                            "

"In order to use $SELECT-PHOTON-MFP with implicit none, we need
"to define all variables used in $SELECT-PHOTON-MFP in the
"PHOTON routine, IK Jan 5 2000

APPEND {;COMIN/NRCNEW/;} TO {$COMIN-PHOTON;}
;
APPEND
{;
$REAL SPMFP,TEMP,TEMP1,PATHLT;
$REAL DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG;
$INTEGER IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,NRCDUM;
;} TO
{$DEFINE-LOCAL-VARIABLES-PHOTON;}

REPLACE {$SELECT-PHOTON-MFP;} WITH {
"         =================="
NFTIME=NFTIME+1;
$RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;
IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))[
    SPMFP=-LOG(RNNO35);
    IF( (CEXPTR.LT.1.0) .AND.(NFTIME.GE.NFMIN) .AND.(NFTIME.LE.NFMAX)
        .AND.( ((W(NP).GT.0.0).AND.(CEXPTR.GT.0.0)).OR.(CEXPTR.LT.0.0))
        )[
        TEMP=CEXPTR*W(NP);TEMP1=1.0-TEMP;
        SPMFP=SPMFP/TEMP1;WT(NP)=WT(NP)*EXP(-SPMFP*TEMP)/TEMP1;
    ]
    DPMFP=SPMFP;
]
ELSE[
    IF((do_fast_step).AND.(NFTIME.EQ.1).AND.(CEXPTR.EQ.0.0))
        GOTO :FASTSTEP:;
    "IFPB IN COMIN USER-VARIANCE-REDUCTION"
    DUMU=USTEP;
    DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);
    IRODUM=IROLD;IRNDUM=IRNEW;IRDUM=IR(NP);MEDDUM=MEDIUM;
    IDUM=IDISC;
    NRCDUM=NEWNRC;
    PATHL=0.0;MEDTMP=0;
    LOOP[
        USTEP=VACDST;
        IROLD=IR(NP);MEDIUM=MED(IROLD);
        IF(MEDIUM=0)["vacuum"
            DELTAP=0.;
        ]
        ELSE[
            IF(MEDTMP.NE.MEDIUM)[
               MEDTMP=MEDIUM;
               $SET INTERVAL GLE,GE;
               $EVALUATE DELTAP USING GMFP(GLE);
            ]
            IF(IRAYLR(IROLD).EQ.1)[ $EVALUATE COHFAC USING COHE(GLE); ]
            ELSE[ COHFAC=1.0; ]
        ]
        IRNEW=IROLD;
        CALL HOWFAR;
        IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
        "only add to pathl if not going through vacuum"
        IF(IRNEW.EQ.1) EXIT;
        IR(NP)=IRNEW;
        X(NP)=X(NP)+USTEP*U(NP);
        Y(NP)=Y(NP)+USTEP*V(NP);
        Z(NP)=Z(NP)+USTEP*W(NP);
    ]
    USTEP=DUMU;
    X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;
    IROLD=IRODUM;IRNEW=IRNDUM;IR(NP)=IRDUM;MEDIUM=MEDDUM;
    IDISC=IDUM;
    NEWNRC=NRCDUM;
    IF(CEXPTR.EQ.0)[
        IF(PATHL.LE.1.0E-3)[GWAIT=PATHL*(1.-0.5*PATHL);]
        ELSE[GWAIT=1.-EXP(-PATHL);]
    ]
    GWTOLD=WT(NP);
    WT(NP)=GWTOLD*GWAIT;

    :FASTSTEP:;
    IF(CEXPTR.EQ.0)[
        EPSLON=RNNO35*GWAIT;
        IF(EPSLON.LE.1.0E-3)[
            IF(NFTIME.EQ.1)EXPMFP=EPSLON*(1.+EPSLON);
            DPMFP=EPSLON*(1.+0.5*EPSLON);
        ]
        ELSE[
            ARG=1./(1.-EPSLON);
            DPMFP=LOG(ARG);
            IF(NFTIME.EQ.1)EXPMFP=EPSLON*ARG;
        ]
    ]
    ELSE[
        TEMP=CEXPTR*W(NP);TEMP1=1.0-TEMP;
        PATHLT=PATHL*TEMP1;
        IF(ABS(PATHLT).LE.1.0E-3)[
            SPMFP=PATHL*RNNO35*(1.0-0.5*PATHLT*(1.0-RNNO35));
            GWAIT=PATHL*(1.0-0.5*PATHLT)*EXP(-SPMFP*TEMP);
            DPMFP=SPMFP;
        ]
        ELSE[
            GWAIT=1.-EXP(-PATHLT);
            SPMFP=-LOG(1.0-RNNO35*GWAIT)/TEMP1;
            GWAIT=GWAIT*EXP(-SPMFP*TEMP)/TEMP1;
            DPMFP=SPMFP;
        ]
    ]
]
}

" The following macro is used in conjunction with an user
" input cs_enhance and iefl(irl) to increase the photon
" interaction density in regions of interest (where iefl(irl) is set to 1)
" cs_enhance means desired average number of interactions per
" g/cm**2. If cs_enhance*rho(medium) > 1/gmfp (1/gmfp is the the actual
" number of interactions per unit length), cs_enhance*rho(medium) is
" used to sample interaction distances in these regions.
" Scattered and unscattered photon fractions are then killed via Russian
" Roulette (to avoid too many low-weight photons)
"
"       ics_enhance  flag to indicate if both some regions are asked     "
"                    and the enhancement factor is > 1.001               "
"                    ics_enhance = 1 if BOTH conditions fulfilled        "
"       cs_enhance   cross section enhancement factor as input by user   "
"       ienhance     flag indicating whether an interaction in enhanced  "
"                    region occurred                                     "
"       iefl(irl)    set 0 if there is no enhancement, 1 if there is     :

REPLACE {$RAYLEIGH-CORRECTION;} WITH {
     ;IF(IRAYLR(IRL).EQ.1) [
         $EVALUATE COHFAC USING COHE(GLE);
         GMFP=GMFP*COHFAC
     ];
    "enhancement flag to beef up a local cross-section"
   ;IF(iefl(IRL) = 1) ["these are all zero if cs_enhance is 1.0"
       cs_enhance_current = cs_enhance*rho(medium)*gmfp;
       IF( cs_enhance_current > 1 ) [
           GMFP=GMFP/cs_enhance_current;
           ienhance=1;
       ]
       ELSE [
           cs_enhance_current = 1; ienhance = 0;
       ]
    ]"end of block for regions in which enhancement done"
    ELSE [ cs_enhance_current = 1; ienhance=0; ]
}


REPLACE {$SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-BEAM;} WITH
"        =================================================="
{
;
IF((IFPB.EQ.0).AND.(IFORCE.EQ.1))[
    GLE=LOG(EIN);
    DO IX=1,NR[
        PATHL=0.0;
        DO IZ=1,NZ[
            $GET-IRL(IZ,IX);MEDIUM=MED(IRL);
            IF(MEDIUM=0)["vacuum"
                DELTAP=0.;
            ]
            ELSE[
                $SET INTERVAL GLE,GE;
                $EVALUATE DELTAP USING GMFP(GLE);
                IF(IRAYLR(IRL).EQ.1)[
                   $EVALUATE COHFAC USING COHE(GLE);
                ]
                ELSE[
                   COHFAC=1.0;
                ]
            ]
            IF(DELTAP~=0) ["only add to path if not vacuum"
               DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP);
               PATHL=PATHL+DELTAP;
            ]
            IF(PATHL.LE.1.0E-3)[GWATE(IX)=PATHL*(1.-0.5*PATHL);]
            ELSE[GWATE(IX)=1.-EXP(-PATHL);]
            ]
        ]
    ]
}


;
"MACRO THAT GETS GEOMETRICAL (OR DOSE) ZONES FROM THE GEOMETRY (OR NDOSRG+1)
"NUMBER WITH THE INPUT OF NZ (OR NZDOSE)
REPLACE {$GET-IX-IZ(#);} WITH {;IX=({P1}-2)/NZ+1; IZ={P1}-1-NZ*(IX-1);}
"        =============="

;
"MACRO THAT GETS THE GEOMETRY NUMBER FROM THE PLANAR AND RADIAL ZONES
;REPLACE {$GET-IRL(#,#);} WITH {;IRL={P1}+NZ*({P2}-1)+1;}
"         =============="

;
" **** RANGE REJECTION MACRO****"
"$USER-RANGE-DISCARD for local region has been replaced by EGSnrc's"
"$RANGE-DISCARD"

"THE FOLLOWING FIVE MACROS ARE FOR STATISTICAL ANALYSIS.             "
"THEY MAKE USE OF THE SUBROUTINE SIGMA FOUND IN THE NRCCAUX.MOR FILE."
"MODE 0 => IGNORE 0 VALUES IN ANALYSIS                               "
"     1 => INCLUDE 0 VALUES                                          "
"     2 => ANALYSE FOR TOTAL VALUE, NOT AVERAGE VALUE PER BATCH      "
"                                                                    "
"ALL ROUTINES USE THREE ASSOCIATED ARRAYS, OF VARYING DIMENSIONS.    "
"THE DIMENSIONS REFERRED TO ARE THOSE OF THE QUANTITY OF INTEREST.   "
"                                                                    "
"       ARRAYIS   ARRAY OF VALUES IN STATISTICAL BATCHES (INPUT)     "
"       ARRAY     ARRAY OF AVERAGE OR TOTAL VALUES       (OUTPUT)    "
"       ARRAYUN   ARRAY OF UNCERTAINTIES                 (OUTPUT)    "
"                                                                    "
"   UNCERTAINTIES ARE %, AND CAPPED AT 99.9%                         "
"                                                                    "
;

REPLACE {$SCORE(#,#:#)} WITH {;

"Scoring macro used in AUSGAB for quantities other than DOSE and KERMA"
"{P1}{P2}=scoring array (eg SCSTP)"
"{P3}=quantity to be scored (eg 1)"

"If the (primary) history number, NHSTRY, is the same as the history"
"that last scored in this array, {P1}_LAST{P2}, then {P3} is added"
"to a temporary array, {P1}_TMP{P2}.  Otherwise, we add"
"{P1}_TMP{P2} to {P1}{P2}, {P1}_TMP{P2}*{P1}_TMP{P2} to {P1}2{P2},"
"set {P1}_TMP{P2}={P3}, and set {P1}_LAST{P2}=NHSTRY."
"This scoring method allows us to calculate  uncorrelated value"
"of {P1}2{P2} which is then used to calculate the uncertainty"
"in {P1}{P2}.  This macro was copied over from BEAMnrc, but in this"
"code it is only used for scoring no. of steps."

IF(NHSTRY={P1}_LAST{P2})[
  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
]
ELSE[
  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
  {P1}_TMP{P2}={P3};
  {P1}_LAST{P2}=NHSTRY;
]
;
}

REPLACE {$SCOREDK(#,#:#)} WITH {;

"Scoring macro used in AUSGAB for DOSE and KERMA"
"{P1}{P2}=scoring array (eg SCDOSE(IZD,IXD,IT))"
"{P3}=quantity to be scored (eg FTMP)"

"Works similar to $SCORE macro above.  However, if we are scoring"
"KERMA and we have moved on to a new primary history, then the KERMA"
"accumulated over the previous primary history is stored in"
"SCKERMA_TMPOLD{P2} and the previous primary history number is stored"
"in SCKERMA_LASTOLD{P2}.  Then, if we are scoring DOSE and have just moved on"
"to a new primary history, this macro checks to see if the previous"
"primary history that deposited energy = the previous primary history that"
"scored kerma.  If so, then the contents of SCDOSE_TMP{P2} are multiplied by"
"SCKERMA_TMPOLD{P2} and added to SCDOSEtoKERMA2{P2}.  SCDOSEtoKERMA2{P2}"
"is eventually used calculate the covariance DOSE and KERMA to obtain an"
"estimate on the uncertainty on DOSE/KERMA."

IF(NHSTRY={P1}_LAST{P2})[
  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
]
ELSE[
  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
  IF('{P1}'='SCKERMA')[
       SCKERMA_TMPOLD{P2}={P1}_TMP{P2};
       SCKERMA_LASTOLD{P2}={P1}_LAST{P2};
  ]
  ELSEIF('{P1}'='SCDOSE' & IKERMA=1 & {P1}_LAST{P2}=SCKERMA_LASTOLD{P2})[
       SCDOSEtoKERMA2{P2}=SCDOSEtoKERMA2{P2}+{P1}_TMP{P2}*
                          SCKERMA_TMPOLD{P2};
  ]
  {P1}_TMP{P2}={P3};
  {P1}_LAST{P2}=NHSTRY;
]
;
}

REPLACE {$ANALYZE(#,#:#)} WITH {;

"Macro to analyze uncertainty:"
"{P1}{P2}=scoring array (eg SCDOSE(IDZ,IDX,ITDOSE))"
"{P3}=quantity to normalize by (eg incident no. of particles)"

"Calculates the uncertainty on {P1}{P2}/{P3}.  The "
"uncertainty is stored in {P1}2{P2} and is expressed as a percentage of"
"{P1}{P2}/{P3} (max 99.9%).  Note that you must define the REAL*8 variable"
"SCORE_TEMP in any subroutine where this macro is used.  This macro"
"is only used in the analysis of dose and no. of steps."
" IK: various compilers fail to compile the original version of this macro"
"     (using the intrinsic max) because the arguments are sometimes of "
"     different type"

SCORE_TEMP={P1}{P2}/{P3};
{P1}2{P2}={P1}2{P2}/{P3};
{P1}2{P2}=({P1}2{P2}-SCORE_TEMP*SCORE_TEMP)/({P3}-1);
IF({P1}2{P2}>=0.) {P1}2{P2}= SQRT({P1}2{P2});
IF(SCORE_TEMP~=0.)[
    {P1}2{P2} = {P1}2{P2}/SCORE_TEMP*100.;
    IF( {P1}2{P2} > 99.9 ) [ {P1}2{P2} = 99.9; ]
    "{P1}2{P2}= MIN({P1}2{P2}/SCORE_TEMP*100.,99.9);"
]
ELSE[
    {P1}2{P2}=99.9;
]
;
}

%E     "dosrznrc.mortran"
"                       COMMON BLOCK DEFINITIONS
"                       ************************

$IMPLICIT-NONE;

" Declarations for implicit none added by IK, Jan 5 2000"

$LONG_INT ITEMP,NOSCAT,INOMSD;
$INTEGER itmax,IORSTRT,i,ix,iz,it,ib,NBATCH,irl,izd,ixd,j,MEDNUM,
         LGLE,ISUMX,jj,IBATCH,IBTCH,ICASE,ipk,ICUM,
         IDSMAX,NDATA,IERR,I1,I2,I3,NETADJ,ISTAT;
$REAL    DEPTH,VOLUME,RLOW2,
         PATHL,DELTAP,COHFAC,EK0,TIMEB,TIMCPU,BATCHT,
         TDSMAX,TDOS,TDOS2,RATIO,ETIMETOT,
         TEMP1,TEMP2,FMASS,aux;
$INTEGER IRIN,NRCFLG;
$REAL    EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;

;
"CHARACTERS BLANK,*,A,B,C,D,I,M,R,S,T,U,V IN I*4(F4) OR CHARACTER(F77) FORM"
REPLACE {;COMIN/CHARS/;} WITH
"       ================
{;
$TYPE BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,
      TCHAR,UCHAR,VCHAR;
COMMON/CHARS/
BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,TCHAR,UCHAR,VCHAR;
}

;
"GEOMETRICAL INFORMATION"
REPLACE {;COMIN/GEOM/;} WITH
"       ===============          "
{;$TYPE CDSTBL($MXREG),CTRTBL($MXREG),CABSRB($MXREG);
COMMON/GEOM/ZPLANE($MAXZPLANE),RCYL(0:$MAXRADII),
CYRAD2($MAXRADII1),
NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,
NZDMIN,NZDMAX,NRDMIN,NRDMAX,
NTRACK($MXREG),CDSTBL,CTRTBL,CABSRB,IDSTBL($MXREG,2);
$REAL    ZPLANE,RCYL,CYRAD2;
$INTEGER NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDMIN,NRDMAX,
         NTRACK,IDSTBL;
"Added type declaration, IK, Jan 5 2000"
}
"
"CDSTBL(IRL)='D' IF IRL IS A DOSE SCORING REGION
"CTRTBL(IRL)='T' IF IRL IS A RANGE REJECTION TRACKING REGION
"CABSRB(IRL)='A' IF IRL IS A TOTALLY ABSORBING REGION
"ZPLANE(IZ) CONTAINS THE REAL VALUED COORDINATE OF THE IZ'TH PLANE
"RCYL(IX) CONTAINS THE REAL VALUED COORDINATE OF THE IX'TH CYL.
"CYRAD2(IX)=RCYL(IX)**2
"NZ/NR=NUMBER OF PLANAR SLABS/CYLINDRICAL REGIONS DEFINING THE TARGET
"NREG=NZ*NR+1 (+1 FOR THE SURROUNDING VACUUM), NPLANE=NZ+1
"NZDOSE/NRDOSE=NUMBER OF DOSE SCORING SLABS/CYLINDRICAL REGIONS
"NDOSE=NZDOSE*NRDOSE, NUMBER OF DOSE SCORING REGIONS
"NZ/NRDMIN/MAX, MIN/MAX PLANES/CYLINDERS DEFINING THE DOSE REGION
"IDSTBL(IRL,1)=DOSE PLANAR SLAB NUMBER IF IRL IS IN DOSE REGION
"IDSTBL(IRL,2)=DOSE CYLINDRICAL REGION NUMBER IF IRL IS IN DOSE REGION
"NTRACK(IRL)=1 IF DOSE REGION ELSE =0

;
"FOUR COMMONS FOR INPUT AND OUTPUT"
;
REPLACE {;COMIN/IODAT1/;} WITH
"       =================
{;
CHARACTER*1 TITLE(80);  "This replaces an old LOGICAL*1 stmt"
COMMON/IODAT1/TITLE;
}
"
"TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES
"DATEN,TIMEN : MACHINE VARIABLES FOR TIME AND DATE

;
REPLACE {;COMIN/IODAT2/;} WITH
"       ================
{;
COMMON/IODAT2/
NCASE,NCASEO,NCASET,
AMASS($MAXZREG,$MAXRADII),TMCPUO,TIMMAX,STATLM,EIN,EKMAX,
IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,DATCOUNT;
$REAL    AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX;
$INTEGER IDAT,IRESTART,IQIN,NESTEP,NSMAX,
         IXXIN,JXXIN,IVAL,DATCOUNT;
$LONG_INT NCASE,NCASEO,NCASET;
"Added type declaration, IK, Jan 5 2000"
}
"
"AMASS(IZ,IX)  mass of zone with coordinates (IZ,IX)
"TMCPUO        CPU time used in previous sessions
"TIMMAX        maximum allowed CPU hours for a given calculation
"STATLM        target statistics in peak dose region used for an early EXIT
"EIN           kinetic energy of the external beam
"IDAT          = 0 store data arrays for re-use
"              = 1 don't store them
"NCASE         number of histories remaining to be done
"NCASEO        number of histories done in previous sessions
"NCASET        number of histories already done
"IRESTART      = 0 => initial run
"              = 1 => restarted run
"              = 3 => data analysis only
"              = 4 => read random number seeds
"              = 5 => post-process distributed runs
"IQIN          charge of the external beam
"NESTEP        number of regions to alter estepe
"NSMAX         number of regions to alter smax
"IXXIN,JXXIN   input pointers for RNG
"IVAL          counter used with get_inputs
"DATCOUNT      no of parallel runs being recombined

;

"printer controls"
REPLACE {;COMIN/PRINTC/;} WITH {
;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
$INTEGER       ICHPIN,ILPIN,IOUT,IPAGE;
"Added type declaration, IK, Jan 5 2000"
}
"       =================
"ICHPIN  NUMBER OF CHARACTERS PER INCH
"ILPIN   NUMBER OF LINES PER INCH
"IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
"IPAGE   =1 => PAGE THROW

;
"common used for transmitting geometrical info from HOWFAR to AUSGAB
REPLACE {;COMIN/NRCNEW/;} WITH {
;COMMON/NRCNEW/NEWNRC,DECISION;
$INTEGER       NEWNRC,DECISION;
"Added type declaration, IK, Jan 5 2000"
}
"       =================
"NEWNRC = 0 if the particle is about to leave the geometry
"NEWNRC = 10,20,30 or 40 depending on whether the particle in question is
"         about to enter a new region via the front wall, outer wall, back
"         wall or inner wall respectively
"NEWNRC = 50 if the particle is in the source region and never left
"DECISION = 1 if ustep = 0 and region number changes--this ensures that
"           LATCH bit gets set to reflect NEWNRC before dose is deposited

;
"common used for scoring in AUSGAB
REPLACE {;COMIN/SCORE/;} WITH
"       ================
{;
COMMON/SCORE/
SCDOSE($MAXZREG,$MAXRADII,$MAXIT),SCDOSE2($MAXZREG,$MAXRADII,$MAXIT),
SCKERMA($MAXZREG,$MAXRADII,$MAXIT),SCKERMA2($MAXZREG,$MAXRADII,$MAXIT),
SCDOSEtoKERMA2($MAXZREG,$MAXRADII,$MAXIT),SCPDST($EBIN),SCPDST2($EBIN),
SCPCUM($EBIN),SCPCUM2($EBIN),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2,
SCDFBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4),
SCSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP,
SCSTP_LAST, SCDSTP_LAST,SCDOSE_LAST($MAXZREG,$MAXRADII,$MAXIT),
SCKERMA_LAST($MAXZREG,$MAXRADII,$MAXIT),
SCKERMA_LASTOLD($MAXZREG,$MAXRADII,$MAXIT),SCPDST_LAST,
IHSTRY,
DFEN(4,4), PHENER,WT1OLD,BINTOP($EBIN),SLOTE,DELTAE,
SCDOSE_TMP($MAXZREG,$MAXRADII,$MAXIT),
SCKERMA_TMP($MAXZREG,$MAXRADII,$MAXIT),
SCKERMA_TMPOLD($MAXZREG,$MAXRADII,$MAXIT),
SCSTP_TMP,SCDSTP_TMP,
MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP,
IPHR($MXREG),MAXBIN,NCOMPT,BEFORE_PHOTO,BEFORE_EII;
real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDST2,
       SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2,
       SCDFBK,SCDFBK2,SCDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2,
       SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
$LONG_INT SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST,
       SCKERMA_LASTOLD,SCPDST_LAST, IHSTRY;
$REAL DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE,
      SCDOSE_TMP,SCKERMA_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP;
$INTEGER MXNP,IFULL,ISTORE,IKERMA,
          IWATCH,IOOPTN,IOUTSP,
          IPHR,MAXBIN,NCOMPT,BEFORE_PHOTO,BEFORE_EII;
}
"
"SCDOSE(2)       accumulates energy deposited (energy deposited^2),
"                eventually holds dose (uncertainty in dose)
"SCKERMA(2)      accumulates energy of electrons created (energy of electrons
"                created^2), eventually holds kerma (uncertainty in kerma)
"SCDOSEtoKERMA2  accumulates (energy deposited)*(energy of electrons created)
"                summed over all primary histories, eventually holds uncertainty
"                in dose/kerma
"SCPDST(2)       accumulates counts (counts^2) in each energy bin of pulse
"                height sensitive region, eventually holds pulse height distn
"                (uncertainty in pulse height distn)
"SCPCUM(2)       accumulates sum of counts (counts^2) in all bins <= current bin
"                in pulse height region, eventually holds cumulative pulse
"                height distn (uncertainty in cumulative pulse height distn)
"SCPTOT(2)       accumulates all counts (counts^2) in all bins in pulse height
"                region, eventually holds total of all counts (uncertainty on
"                total) and is used to normalize scpdst, scpcum and scdfep
"SCPHEN(2)       accumulates total energy (energy^2) deposited in pulse height
"                region, eventuall holds energy deposited in pulse height region
"                (uncertainty on energy in pulse height region) per incident
"                particle
"SCDFBK(2)       accumulates background counts (counts^2) for each peak in pulse
"                height distribution, will be subtracted from scdfep below
"SCDFEP(2)       accumulates counts (counts^2) in each energy peak in pulse
"                height distribution
"SCDFDIFF(2)     accumulates difference (difference^2) between peak and
"                background counts for each peak in pulse height distribution,
"                gets used to determine covariance between scptot and
"                (SCDFEP-SCDFBK) so we can calculate the uncertainty on the
"                final value of SCDFEP
"SCSTP(2)        accumulates total particle steps (particle steps^2) in phantom,
"                eventually, scstp2 holds uncertainty on this number
"SCDSTP(2)       accumulates total particle steps (particle steps^2) in dose
"                region of phantom, eventually, scdstp2 holds uncertainty on
"                this number
"PIISTP          holds no. of presta-ii steps from previous runs
"SCSTP_LAST      last primary history to score a particle step in phantom
"SCDSTP_LAST     last primary history to score a step in the dose region of the
"                phantom
"SCDOSE_LAST     last primary history to deposit energy in each dose region of
"                the phantom
"SCKERMA_LAST    last primary history to deposit kerma in each region of
"                phantom
"SCKERMA_LASTOLD second last primary history to deposit kerma in each region
"                of phantom.  used to calculate scdose*sckerma for covariance
"                in uncertainty on dose/kerma
"SCPDST_LAST     last primary history to score energy in pulse height region
"SCDOSE_TMP      accumulates energy deposited in each region by current primary
"                history
"SCKERMA_TMP     accumulates energy of electrons created in each region by
"                current primary history
"SCKERMA_TMPOLD  energy of electrons created in each region by last primary
"                history.  used to calculate scdose*sckerma for covariance
"                in uncertainty on dose/kerma
"SCSTP_TMP    accumulates charged particle steps in current primary history
"SCDSTP_TMP   accumulates charged particle steps in dose region in current
"             primary history
"DFEN         energy limits for four peak area and backgrounds
"MXNP         maximum level to which the stack of daughter particles from an
"             incident particle rises (stack may include incident particle)
"IFULL        = 0 just calculate total dose and that due to stoppers
"                 and discards (the default)
"             = 1 above analyse where the dose is coming from
"             = 2 IFULL = 0 scoring plus pulse height distributions
"             = 3 score the scatter fraction instead of stoppers
"ISTORE       = 0 do not store the initial random numbers (the default)
"             = 1 store the initial random number for last history
"             = 2 store initial random numbers for all histories
"IKERMA       = 0 do not score kerma
"             = 1 score kerma
"IWATCH       = 0 for normal output (the default)
"             = 1 output on every discrete interaction
"             = 2 output on every electron/photon step as well
"             = 3 prints out only when energy is deposited
"             = 4 prints out file for graphics
"IHSTRY       counter for total number of histories successfully simulated
"IOOPTN       = 0 short output (the default) -just dose grid(dg)
"             = 1 output dose summary only (ds)
"             = 2 output material summary grid(mg) + dg
"             = 3 output mg + ds
"             = 4 output mg + ds + dg
"IOUTSP       = 0 no energy input spectrum data in output summary
"             = 1 include energy inout spectrum data in output summary
"PHENER       energy deposited in sensitive volume for current history only
"WT1OLD       stores value of WT(1) from last history for scoring phd
"IPHR         flag array for each region, non-zero only if pulse height
"             distribution wanted in this geometric region
"BINTOP       tops of energy bins for pulse height distribution
"MAXBIN       number of energy bins for pulse height distribution
"SLOTE        >0, width of pulse height distribution energy bins
"             else flag to use bintop
"DELTAE       width of energy bins used for peak efficiencies


;

"COMMONS used for non-monoenergetic beam data                             "
"       NOTE MONOEN is passed in user                                     "
"                                                                         "
REPLACE {$NENSRC} WITH {300}     "max # of points in energy distribution  "
"        =======                                                          "
REPLACE {$INVDIM} WITH {1000}    "dimension controls grid size for inverse"
"        =======                                                          "
;
REPLACE {;COMIN/SPECTR/;} WITH
"       ================="
{;
COMMON/SPECTR/
CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
NENSRC;
$INTEGER NENSRC;
$REAL    CDFINV,ENSRCD,SRCPDF,SRCCDF;
"Added type declaration, IK, Jan 5 2000"
}
"CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
"SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
"SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION

;
"common used for russian roulette
REPLACE {;COMIN/RUSROU/;} WITH
"       =================
{;
LOGICAL RUSROU;
COMMON/RUSROU/RRZ,RRCUT,RUSROU;
$REAL         RRZ,RRCUT;
}
"
"RRZ      COORDINATE OF PLANE AT WHICH RUSSIAN ROULETTE IS PLAYED
"RRCUT    SURVIVAL PROBABILITY AFTER CROSSING THE PLANE
"RUSROU   = .FALSE. => RUSSIAN ROULETTE WILL NOT BE PLAYED
"         = .TRUE.  => RUSSIAN ROULETTE WILL BE PLAYED

;
"common used for plotting routine
REPLACE {;COMIN/PLOTC/;} WITH
"       ================
{;
COMMON/PLOTC/
IPLOTR($MAXRADII),IPLOTZ($MAXZREG),IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ;
$INTEGER IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ;
"Added type declaration, IK, Jan 5 2000"
}
"IPLOTR(IX) = 0 NO PLOTS FOR CYLINDRICAL DOSE REGION IX
"           = 1 PLOTS FOR CYLINDRICAL DOSE REGION IX
"IPLOTZ(IX) = 0 NO PLOTS FOR PLANAR DOSE SLAB IZ
"           = 1 PLOTS FOR PLANAR DOSE SLAB IZ
"IOPLOT     = 0  NO PLOTS OR PLOT FILES TO BE PREPARED
"           = 1  PLOTTING TO BE PREPARED OR PRINTED
"IPLTLP     = 0  DON'T PLOT IN EXECUTION OUTPUT
"           = 1  DO PLOT IN EXECUTION OUTPUT
"IPLTPL     = 0  DON'T PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
"           = 1  PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
"IPLPHB     = 1  POINT PLOT ON EXTERNAL PLOTTER
"           = 2  HISTOGRAM ON EXTERNAL PLOTTER
"           = 3  BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
"NPLOTR     NUMBER OF RADIAL PLOTS
"NPLOTZ     NUMBER OF Z-AXIS PLOTS

;
REPLACE {;COMIN/USER/;} WITH
"       =============="
{;
COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR,IREJCT;
$REAL    ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN;
$INTEGER MINZ,MAXZ,MINR,MAXR,IREJCT;
"                                                                            "
"common used for range rejection                                             "
"Z/RMINR/MAX   PLANE/CYLINDER COORDINATES OF THE MIN/MAX PLANES/CYLINDERS    "
"              FOR RANGE REJECTION                                           "
"ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                        "
"MIN/MAX/Z/R   MIN/MAX PLANE/CYLINDER NUMBERS OF RANGE REJECTION REGION      "
"FOR THE REMAINING VARIABLES SEE DOCUMENTATION IN SUBROUTINE INPUTS          "
;
COMMON/USERMI/EXPMFP,GWTOLD,ICSDA;
$INTEGER ICSDA;
$REAL    EXPMFP,GWTOLD;
"                                                                       "
"COMIN/USER-MISC/USERMI  EXTRA USER COMMON FOR DOSRZnrc                 "
"EXPMFP   EXPONENTIAL MEAN-FREE-PATH USED FOR INTERACTION FORCING       "
"GWTOLD   OLD WEIGHT                                                    "
"ICSDA    CSDA CALCULATION ON(1) OR OFF(0)                              "
;

;COMMON/USERVR/
CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,
cs_enhance,cs_enhance_current,ienhance,iefl($MXREG),ics_enhance,
do_fast_step;
$INTEGER ienhance,iefl,ics_enhance,
         IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN;
$REAL    CEXPTR,GWAIT,cs_enhance,cs_enhance_current;
$LOGICAL do_fast_step;

"COMIN/USER-VARIANCE-REDUCTION"
"       CEXPTR       C VARIABLE FOR EXPONENTIAL PATHLENGTH TRANSFORMATION"
"       GWAIT        WEIGHT ADJUSTMENT IN FORCING INTERACTIONS MACRO     "
"       IFORCE       ONLY FORCE PHOTON INTERACTIONS IF THIS IS NON-ZERO  "
"       NFMIN,NFMAX,NFTIME  FOR FORCE PHOTON INTERACTIONS MACRO          "
"       IFPB         FLAGS IF ISOURC = 0,2 OR 4                          "
"       IQINC        INCIDENT CHARGE                                     "
"       MONOEN = 0 IF MONOENERGETIC BEAM, = ELSE IF SOURCE DIST'N INPUT  "
"       ics_enhance  flag to indicate if both some regions are asked     "
"                    and the enhancement factor is > 1.001               "
"       cs_enhance   cross section enhancement factor as input by user   "
"       ienhance     flag indicating whether an interaction in enhanced  "
"                    region occurred                                     "
"       iefl(ir)     flag indicating whether in a specific region        "
"                    enhancing should occur, set to 1 if yes 0 if no     "
"       do_fast_step If iforce is set to 1 and the source is a front     "
"                    parallel beam, the photon forcing macro uses        "
"                    pre-calculated path-lengths and mfp's to sample the "
"                    photon interaction distance for the first forced    "
"                    photon. This is a bug if the incident particle is   "
"                    an electron! To avoid this problem, do_fast_step    "
"                    is set to .false. in this case. IK, April 2000      "

"Added type declaration, IK, Jan 5 2000"

}

"THIS MACRO ALLOW THE USER TO SWITCH ON CSDA CALCULATIONS.             "
"THE MEAN FREE PATH IS SET TO INFINITY AND THE PROPER CSDA STOPPING    "
"POWERS SHOULD BE USED HAVING BEEN CREATED BY PEGS4 VIA IUNRST = N.    "
;
REPLACE {$SELECT-ELECTRON-MFP;} WITH {;
    IF(ICSDA.EQ.0)[
        ;$RANDOMSET RNNE1;IF(RNNE1.EQ.0.0)[RNNE1=1.E-30;]
        DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);
        ]
    ELSE[ DEMFP=VACDST; ]
;}

;

"END OF MACRO DEFINITIONS

"                       DATA DECLARATIONS
"                       *****************
"
REPLACE {$NMAX} WITH {100}  "max number of inputs"
REPLACE {$NVALUE} WITH {100}  "max number of values per input"

INTEGER MAKE_IT_AN_INT,JTEMP;
CHARACTER*80 TEXT;
$LONG_INT JCASE;

$DECLARE_TIMING_VARIABLES;

$REAL
    GWATE($MAXRADII); "PHOTON INTERACTION FORCING WEIGHTING FACTORS FOR
                      "NORMALLY INCIDENT PARALLEL BEAMS

$REAL SCORE_NORM_NUM,
      SCORE_TEMP;    "variables for uncertainty analysis + normalization"

REAL*8 SCORE_TEMP2;


;COMIN/
BOUNDS,CHARS,EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,
MEDIA,MISC,NRCNEW,PHOTIN,PLOTC,PRINTC,RUSROU,SCORE,SOURCE,SPECTR,
STACK,THRESH,UPHIOT,USEFUL,USER,RANDOM,GetInput,BREMPR,EGS-VARIANCE-REDUCTION,
RWPHSP,CH-Steps,EGS-IO/;

external combine_results;

" I/O stuff "
$INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit;

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.

$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;
$REAL   part_dose, part2_dose, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last;
$INTEGER  n_job;
$LOGICAL first_time;
#endif;

$LOGICAL is_finished;

"                       START OF EXECUTABLE CODE
"                       ************************

call egs_init;

;
"INITIALIZE THE CHARACTER ARRAY"
BLANK=' ';     ASTER='*';     ACHAR='A';     BCHAR='B';
CCHAR='C';     DCHAR='D';     ICHAR='I';     MCHAR='M';
RCHAR='R';     SCHAR='S';     TCHAR='T';     UCHAR='U';     VCHAR='V';

$SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"

OUTPUT ' '; (//1x,79('*')/ / 9X,a,$);
call egs_fdate(6);
OUTPUT; (//1x,79('*')/);

" ********** IK: using wrapper for date and time routines.
" Was:
" CALL DATE(DATEN);CALL TIME(TIMEN);
" OUTPUT DATEN,TIMEN; (//1x,79('*')/ / 10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT/
"     / ' ',79('*')/);

OUTPUT  $MAXZREG,$MAXRADII; (
  ' *',T34,'************',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'* DOSRZnrc *',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'************',T80,'*'//
  '   Developed by National Research Council of Canada',/
  '   '$VERSION' on '$MACHINE/
    / ' Number of planar regions      = ',I3/
    ' Number of cylindrical regions = ',I3 /);

JTEMP = 2*$EBIN;
IF (JTEMP > $MXDATA) [ "the user has a huge number of bins in their"
                         "spectrum and needs to enlarge stats array to"
                         "handle it
   OUTPUT $EBIN;(///' *********************************************'/
   ' You have used such a large value of EBIN(=',I6,' ) that you must use'/
   ' the alternative form of the REPLACE {$MXDATA} macro near the top of'/
   ' dosrznrc.mortran and then recompile',
   ///' *********************************************'///);
   STOP;
]
"******************************************************************************
"
"                       *** SECTION 1 ***
"
"------------------------------------------------------------------------------
"
"READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
"
"------------------------------------------------------------------------------

IOUT=1; "OUTPUT FORTRAN UNIT NUMBER"

CALL INPUTS;
IF (ERROR_FLAG=1) [
   GOTO :END:;
]

" Open a file to read/write random numbers, if necessary "
" IK: use explicit file names instead of fort.* "
IF( istore > 0 ) [ "We want to store the rng state in a file"
    rng_unit = egs_open_file(2,0,1,'.egsrns');
]
ELSE IF( irestart = 4 ) [ "We well read RN's from a file"
    rng_unit = egs_open_datfile(2,0,1,'.egsrns');
]

" This is copied directly from below.  Don't know why it needs "
" repeating, but it does.  -- JT "
IF((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))[ITMAX=2;]
ELSE[ITMAX=$MAXIT;]

" THE IRESTART=5 case, post-processing for distributed runs, goes here
" ADDED BY JT, NOV.98
IF(IRESTART.EQ.5)[

    "IK: the egs_combine_runs subroutine checks for files named "
    "    output_file_wiii.egsdat (iii=1,99) in the user code directory "
    "    For each file found, it calls the subroutine combine_results "
    "    with the name of the file as argument. The combine_results
    "    subroutine is essentially a cut-and-paste of what used to be "
    "    in this block, short of the creation of a script that checks "
    "    for existing .egsdat files. The egs_combine_runs subroutine "
    "    is now part of EGSnrc and can be found in egs_utilities.mortran "
    "    The reason for this change is cross-platform portability "
    "    (the script is obviously not going to work under Windows) "

    call egs_combine_runs(combine_results,'.egsdat');

    NBATCH=0; "DON'T WANT IT TO RUN ANY HISTORIES"
    NCASET=NCASEO;
] "end of IRESTART = 5, DISTRIBUTED POST-PROCESSING"
ELSE [
    IF(NCASE/$NBATCH=0)[NCASE=$NBATCH;]
    JCASE=NCASE/$NBATCH; NCASE=JCASE*$NBATCH;"number of histories per batch"
]

DECISION=0; "this is for howfar and ausgab when IFULL=1"
MXNP=0; "reset the maximum stack indicator"
IHSTRY=NCASEO; "reset the number of histories counter"

NHSTRY=0; "start the no. of primary histories counter at zero"

"SET UP THE BROAD PARALLEL BEAM DEFAULTS"
IF (ISOURC.EQ.2)[
    NR=1;RCYL(1)=1000.;NREG=NZ+1;CYRAD2(1)=RCYL(1)**2;
    ]

NDOSE=NZDOSE*NRDOSE;     "NUMBER OF DOSE SCORING REGIONS"

IF(IFULL.EQ.1)[ITMAX=$MAXIT;]ELSE[ITMAX=2;] "# OF DOSE COMPONENTS"

IF(IREJCT = 1)[
    "GET COORDINATES USED BY HOWFAR FOR RANGE REJECTION"
    ZMINR=ZPLANE(MINZ);                              "lesser plane position"
    ZMAXR=ZPLANE(MAXZ);                              "greater plane position"
    IF(MINR.EQ.0)[RMINR=0.0;]ELSE[RMINR=RCYL(MINR);] "inner cylinder radius"
    RMAXR=RCYL(MAXR);                                "outer cylinder radius"
]

;
"Set up tables corresponding to dose and range rejection tracking regions"
"for geometrical region number 'IRL' a dose scoring region then IDSTBL(IRL,1)"
"assigned dose coordinate IZD and IDSTBL(IRL,2) assigned dose coordinate IXD"
"and CDSTBL(IRL) assigned 'D'. If region IRL within tracking region for"
"range rejection then CTRTBL(IRL) assigned 'T'"
"Also set up table NTRACK with entry of 1 for dose scoring zone else 0. This"
"is redundant in view of CDSTBL and is only used in macro 'COUNT-NOSCAT-IN"
"-CAVITY' but is less dangerous than introducing a new array to EGS"
CTRTBL(1)=BLANK;
CDSTBL(1)=BLANK;
DO IZ=1,NZ[
    DO IX=1,NR[
        $GET-IRL(IZ,IX); "DERIVE CORRESPONDING DOSE ZONE NUMBERS"
        IZD=IZ+1-NZDMIN;IXD=IX-NRDMIN;
        IF(
            (IZD.LE.0).OR.
            (IZD.GT.NZDOSE).OR.
            (IXD.LE.0).OR.
            (IXD.GT.NRDOSE))[
            CDSTBL(IRL)=BLANK;
            IDSTBL(IRL,1)=0;
            IDSTBL(IRL,2)=0;
            NTRACK(IRL)=0;
            ]
        ELSE[
            CDSTBL(IRL)=DCHAR;
            IDSTBL(IRL,1)=IZD;
            IDSTBL(IRL,2)=IXD;
            NTRACK(IRL)=1;
            ]
        IF(
            (IZ.LT.MINZ).OR.
            (IZ.GE.MAXZ).OR.
            (IX.LE.MINR).OR.
            (IX.GT.MAXR)
            )[
            CTRTBL(IRL)=BLANK;
            ]
        ELSE[
            CTRTBL(IRL)=TCHAR;
            ]
        ]
    ]

;
"SET UP AUSGAB CALLS"
DO J=1,5[IAUSFL(J)=1;]DO J=6,$MXAUS[IAUSFL(J)=0;] "NORMAL EXECUTION"

IF(IFULL = 1 | IFULL = 3 | IKERMA = 1) [
   "need to call ausgab to set flag after photon interactions"
   "IKERMA=1 means scoring KERMA"
   "for KERMA, rayleigh scatter has no effect"
    iausfl(6) = 1; "after each step"
    iausfl(17) = 1; "after pair"
    iausfl(18) = 1; "before compt"
    iausfl(19) = 1; "after compt"
    iausfl(20) = 1; "before photo"
    iausfl(21) = 1; "after photo"
    iausfl(10) = 1; "after Moller (to count radiative losses due to EII)"
    iausfl(35) = 1; "after sub-threshold Auger"
    iausfl(32) = 1; "before eii"
    iausfl(33) = 1; "after eii"
]

IF(IFULL = 4) [
  iausfl(8)  = 1; "After bremsstrahlung"
  "iausfl(14) = 1;" "A positron has annihilated in-flight"
  "iausfl(15) = 1;" "A positron has annihilated at rest"
]

IF(cs_enhance > 1.0001) [
write(6,*) 'flagged all photon intereaction types';
    iausfl(16) = 1; "Before pair"
    iausfl(18) = 1; "Before Compton"
    iausfl(19) = 1; "After Compton"
    iausfl(20) = 1; "Before photoelectric"
    iausfl(21) = 1; "After photoelectric"
    iausfl(24) = 1; "Before Rayleigh"
    iausfl(25) = 1; "After Rayleigh"
]
ELSE [ DO j=1,$MXREG [ iefl(j) = 0; ] ]


"HATCH CALL PREPARATION AND EXECUTION"
"-------------------------------------

DUNIT=1; "SET LENGTH UNITS TO cm"

OUTPUT; (/' CALL TO HATCH AT  ',$); call egs_time(6); write(6,*);
" ********** IK: using wrapper for date and time routines.
" Was: CALL TIME(TIMEN); " "GET THE TIME OF DAY"
" OUTPUT TIMEN;(/' CALL TO HATCH AT  ',$TIMEN_FORMAT);

CALL HATCH; "INPUT THE PEGS GENERATED DATA"

OUTPUT; (/' HATCH COMPLETED AT ',$); call egs_time(6); write(6,*);
" ********** IK: using wrapper for date and time routines.
" Was: CALL TIME(TIMEN);OUTPUT TIMEN;(/' HATCH COMPLETED AT ',$TIMEN_FORMAT);

IF(MONOEN.EQ.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.NE.23) [
             "MONOENERGETIC INPUT BEAM"
    IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]
    EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
    ]
ELSEIF (MONOEN.EQ.1) [ "ENERGY SPECTRUM"
    CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
    EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
    ]
ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22) ["FULL PHASE-SPACE INFORMATION PROVIDED"
    EKMAX=EKSRCM; "MAXIMUM KINETIC ENERGY IN THE FILE"
    ]

"CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY RANGE REQUIRED"
DO I=1,NMED[
    IF((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))[
        OUTPUT I,EKMAX,UP(I),UE(I);
        (//1X,50('*')//
        ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MeV'/
        ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MeV'/
        '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
        1X,50('*')//);
        GOTO :END-OF-RUN:;
        ]
    ] "END OF LOOP OVER MEDIA"

"CALCULATE THE MASS OF EACH ZONE (AREAL MASS FOR ISOURC=2 OR 4)
DO IZ=1,NZ[
    DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ);
    DO IX=1,NR[
        $GET-IRL(IZ,IX);
        MEDNUM=MED(IRL);
        IF(MEDNUM.NE.0)[
            IF((ISOURC.EQ.2).OR.(ISOURC.EQ.4))[VOLUME=DEPTH;]
            ELSE[
                IF(IX.EQ.1)[RLOW2=0.0;]
                ELSE[RLOW2=CYRAD2(IX-1);]
                VOLUME=PI*DEPTH*(CYRAD2(IX)-RLOW2);
                ]
            AMASS(IZ,IX)=RHOR(IRL)*VOLUME;
            ]
        ELSE[AMASS(IZ,IX)=0.0;]
        ]"END OF IX LOOP"
    ]"END OF IZ LOOP"

"CALCULATE ONE-TIME-ONLY CONSTANTS FOR SOURCE"
CALL SRCOTO(WEIGHT);
IF((IFPB.EQ.0).AND.(IFORCE.NE.0).AND.(IQIN.EQ.0).AND.(MONOEN.EQ.0))[
    OUTPUT;
    (/' ********* Initializing front parallel beam for photons *******'/);
    $SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-BEAM;
    do_fast_step = .true.;
]
ELSE [ do_fast_step = .false.; ]

EK0=EIN;
"For source=21,22 we input EIN in SRCRZ"

CALL ISUMRY; "PRINT THE SUMMARY OF INPUTS"

"******************************************************************************
"
"                       *** SECTION 2 ***
"
"------------------------------------------------------------------------------
"
"LOOP THROUGH THE NUMBER OF HISTORIES. CALCULATE CONSTANTS THAT MAY CHANGE FOR
"EACH HISTORY AND DO THE SIMULATION
"
"------------------------------------------------------------------------------

"WRITE THE HEADER"

write(iout,100) ' '; call egs_fdate(iout); write(iout,*);

" ********** IK: using wrapper for date and time routines.
" Was:
" CALL DATE(DATEN);CALL TIME(TIMEN);WRITE(IOUT,100) TITLE,TIMEN,DATEN;

WRITE(IOUT,200);WRITE(6,200); "PRINT HEADER FOR EXECUTION MESSAGES"

"PRINT EXECUTION MODE"
IF(IRESTART .EQ.0)[WRITE(6,201);WRITE(IOUT,201);]
ELSEIF(IRESTART .EQ.1)[
    WRITE(6,202) NCASE,NCASEO;
    write(6,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(6); write(6,*);
    WRITE(IOUT,202) NCASE,NCASEO;
    write(iout,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(iout); write(iout,*);
]
ELSEIF(IRESTART .EQ.3)[WRITE(6,204);WRITE(IOUT,204);GO TO :END-SIM:;]
ELSEIF(IRESTART.EQ.4)[ WRITE(6,206); WRITE(IOUT,206); ]
ELSEIF(IRESTART.EQ.5)[WRITE(6,205);WRITE(IOUT,205);GO TO :END-SIM:;]

"INITIALIZE IWATCH ROUTINE"
IF(IWATCH.NE.0) CALL WATCH(-99,IWATCH);

"SET CLOCK AT THE BEGINNING OF SIMULATIONS"
$SET_ELAPSED_CPUTIME(CPUT1);
$INITIALIZE_ELAPSED_TOTAL_TIME;
ETIMETOT=0;
TIMEB=0;
NETADJ=0;

" IK: Open a file for data storage, if requested "
"     The egs_open_file function opens a file named output_file.egsdat "
"     in the temporary working directory. The unit 4 (first argument) is"
"     tried first, but if it is already in use, it picks the first Fortran I/O"
"     unit available. The other two integer arguments tell egs_open_file to "
"     open the .egsdat file for formated sequential I/O (the zero) and to "
"     exit with an error message if something goes wrong (the 1)."
"     If the third argument is zero instead, egs_open_file will return with
"     a negative error code and it is up to the user to deal with the error."
"
IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.
#ifdef HAVE_C_COMPILER;
;
n_tot = ncaseo; first_time = .true.; is_finished = .false.;
/part_dose,part2_dose/=0;
"I'm not sure what is a good quantity to put into the job control file =>"
"just use 0 for now"

:start_parallel_loop:;

IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(6,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        goto :END-SIM:;
    ]
    jcase = n_run/$NBATCH;
    IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
    IF( first_time ) [
        first_time = .false.; n_last = n_run;
        write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
]
#endif;


"OUTPUT BATCHES. EXECUTION STOPS IF THE DESIRED STATISTICAL ACCURACY IS"
"OBTAINED OR THERE IS NOT ENOUGH TIME TO DO ANOTHER BATCH."

DO IBATCH=1,$NBATCH[

    IBTCH=IBATCH;
    IF(IBATCH.EQ.1)[
        OUTPUT ' ';
        (/' BATCH #',2X,'time-elapsed',2X,'total cputime',2X,'ratio',2X,
          'time of day',2X,'peak region stats(%)'//
          ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',3X,a,$);
        call egs_time(6);
        " ********** IK: using wrapper for date and time routines.
        " Was:
        " CALL TIME(TIMEN);OUTPUT TIMEN;
        " (/' BATCH #',2X,'time-elapsed',2X,'total cputime',2X,'ratio',2X,
        " 'time of day',2X,'peak region stats(%)'//
        " ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',4X,$TIMEN_FORMAT,$);

        "IK: it is annoing that for batch runs we don't see the progress"
        "    info in the log file until the job is finished. This is because"
        "    Fortran uses buffered I/O. The following flushes unit 6 so that"
        "    we can see the progress of the calculation. "
        $FLUSH_UNIT(6);
    ]
    ELSE[
        $SET_ELAPSED_TOTAL_TIME(TIMEB);
        ETIMETOT=ETIMETOT+TIMEB;
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU=CPUT2-CPUT1;
        OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU;
        (' ',3X,I2,5X,F8.1,7X,F8.1,2X,F8.2,3X,' ',$);
        call egs_time(6);
        " ********** IK: using wrapper for date and time routines.
        " Was:
        " CALL TIME(TIMEN);
        " OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU,TIMEN;
        " (' ',3X,I2,5X,F8.1,7X,F8.1,2X,F8.2,4X,$TIMEN_FORMAT,$);
        "CHECK THERE IS TIME LEFT FOR ANOTHER BATCH"

        "IK: it is annoing that for batch runs we don't see the progress"
        "    info in the log file until the job is finished. This is because"
        "    Fortran uses buffered I/O. The following flushes unit 6 so that"
        "    we can see the progress of the calculation. "
        $FLUSH_UNIT(6);

        BATCHT=TIMCPU/dble(IBATCH-1);"TIME PER BATCH SO FAR"
        IF(TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)[
            "NOT ENOUGH TIME FOR ANOTHER BATCH"
            "PRINT MESSAGE AND EXIT SIMULATION LOOP"
            WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
            WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
            "ADJUST THE INCIDENT FLUENCE"
            "EMH: Must be at the end of all possible exits from the shower loop"
            "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
            GO TO :END-SIM:;
        ]
    ]

    DO ICASE=1,JCASE[

            IF( ISOURC ~= 23 ) IHSTRY=IHSTRY+1; "INCREMENT HISTORY COUNTER"
              " For source 23 ihstry is set in srchst "

            NFTIME=0; "RESET THE PHOTON FORCED INTERACTION COUNTER"

            IF(IRESTART=4) [
               $RETRIEVE RNG STATE FROM UNIT rng_unit;
            ]

            "STORE INITIAL RANDOM #S FOR LAST HISTORY IF REQUESTED"
            IF(ISTORE.EQ.1)[
                $STORE RNG STATE ON UNIT rng_unit;
            ]
            ELSEIF(ISTORE.EQ.2)[
                "STORE THE INITIAL RANDOM NUMBER SEED"
                $PUT RNG STATE ON UNIT rng_unit;
            ]

            "CALCULATE THE SOURCE DEPENDANT VALUES WHICH CHANGE FOR EACH
            "HISTORY THESE INCLUDE :
                "ENTRY POINT INTO TARGET,
                "INITIAL DIRECTION COSINES,
                "STATISTICAL WEIGHT,
                "ENTRY FLAG(NRCFLG)
            CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);

            "CALCULATE THE INITIAL ENERGY IF A DISTRIBUTION IS TO BE USED"
            IF(MONOEN.NE.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.NE.23)[
                "IF EQUAL TO 0, IT IS MONOENERGETIC"
                "IF ISOURC=21 FULL PHASE SPACE DATA IS USED"
                CALL ENSRCH(EIN);   "RETURNS K.E. FROM DISTRIBUTION"
                IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]  "TOTAL ENERGY"
                " THERE WAS A CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY
                "RANGE REQUIRED, THE LOCATION OF IT WILL EVENTUALLY BE IN
                "ESRCIN.MOR
            ]
            ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)[EI=EIN;]

            IF((ISOURC=21 | ISOURC=22 | ISOURC=23) & IFULL=2 & WEIGHT<1.)[
               OUTPUT WEIGHT; (//' ****WARNING****'/
' A particle of weight ',F10.5,' from the phase space source is being used'/
' Pulse height distribution only makes sense if all particles have'/
' weight=1.  Will run simulation with IFULL= dose and stoppers'//);
               WRITE(1,'(//'' ****WARNING****''/
'' A particle of weight '',F10.5,'' from the phase space source is being used''/
'' Pulse height distribution only makes sense if all particles have''/
'' weight=1.  Will run simulation with IFULL= dose and stoppers''//)');
              IFULL=0;
            ]

           "Set photon weights if gamma interactions are to be forced in the
            "target in the frontal parallel beam case if monoenergetic
            IF( do_fast_step )[
                IX=(IRIN-2)/NZ+1;
                GWAIT=GWATE(IX);
                WEIGHT=GWAIT;
            ]
            "For an input energy spectrum, detailed forcing macro is used"

            LATCHI=0;

            "Set initial dose components"
            IF(IFULL.EQ.1)[
                NEWNRC=NRCFLG;
                LATCHI=IBSET(LATCHI,NRCFLG/10);
            ]

            IF((IWATCH ~= 0) & (IWATCH ~= 4))[
                OUTPUT 1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,WEIGHT;
                (/' INITIAL SHOWER VALUES',T36,':',
                I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
            ]

            "all initial shower variables are set, call the SHOWER routine"

            CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);

            "signal the end of a history if watch mode is set"
            IF(IWATCH > 0) CALL WATCH(-1,IWATCH);

    ] "END OF THE ICASE LOOP"

    "SUCCESFUL COMPLETION OF A BATCH. DELETE THE RAW DATA FROM THE LAST BATCH"
    "AND RECORD THE NEW BATCH ONLY IF REQUESTED"
    IF(IDAT.EQ.0)[
        "add unscored portions of _TMP arrays before writing"
        SCSTP=SCSTP+SCSTP_TMP;
        SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
        SCSTP_TMP=0;
        SCDSTP=SCDSTP+SCDSTP_TMP;
        SCDSTP2=SCDSTP2+SCDSTP_TMP*SCDSTP_TMP;
        SCDSTP_TMP=0;
        DO IZ=1,NZDOSE[
           DO IX=1,NRDOSE[
              DO IT=1,ITMAX[
                 SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT);
                 SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
                                                     SCDOSE_TMP(IZ,IX,IT);
                 IF(IKERMA=1)[
                   SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT);
                   SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT)*
                                                        SCKERMA_TMP(IZ,IX,IT);
                   IF(SCDOSE_LAST(IZ,IX,IT)=SCKERMA_LAST(IZ,IX,IT))[
                       "same history being scored, include these in"
                       "uncertainty estimate"
                       SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+
                             SCDOSE_TMP(IZ,IX,IT)*SCKERMA_TMP(IZ,IX,IT);
                   ]
                   SCKERMA_TMP(IZ,IX,IT)=0.;
                 ]
                 SCDOSE_TMP(IZ,IX,IT)=0.;
              ]
           ]
        ]
        "OPEN(UNIT=4,file='fort.4',STATUS='UNKNOWN');"
        "IK: the .egsdat file is opened before the shower loop."
        "    The only reason for opening and closing the I/O unit is to "
        "    overwrite data from previous batches, but we can do this "
        "    by rewinding the unit"
        rewind(data_unit);
        WRITE(data_unit,*)SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP+count_pII_steps;
        WRITE(data_unit,*)
                (((SCDOSE(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
        WRITE(data_unit,*)
                (((SCDOSE2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
        IF(IKERMA=1)[
           WRITE(data_unit,*)
                (((SCKERMA(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
           WRITE(data_unit,*)
                (((SCKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
           WRITE(data_unit,*)
            (((SCDOSEtoKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
        ]
        IF(IFULL=2)[
           IF(PHENER>0.)[
           "FIND WHAT BIN WE ARE IN"
             IF(SLOTE.GT.0.0)[
               "EQUAL ENERGY BINS CASE"
               IB=MIN0(int(PHENER/SLOTE+0.999),$EBIN);
             ]
             ELSE[
                 IB = MAXBIN;
                 UNTIL((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)) [IB=IB-1;]
             ]

     "ACCUMULATE THE PULSE HEIGHT DISTRIBUTION"
             SCPDST(IB)=SCPDST(IB)+WT1OLD;
             SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD;
             "add to cumulative distn"
             DO ICUM=IB,MAXBIN[
               SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD;
               SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD;
             ]

             IF(IWATCH.EQ.3)[
                OUTPUT PHENER,IB,1;
                (' PULSE HEIGHT ENERGY=',
                F10.4,' MeV, IN BIN',I3,' WITH WEIGHT',1PE10.3);
             ]

             "NOW SCORE PROBABILITIES FOR COUNTS IN PEAKS"
             DO IPK=1,4[
                "FOR EACH PEAK, F.E., ESCAPES AND 511"
                IF((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3)))[
                    "IT IS IN THE PEAK"
                    SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD;
                    SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD;
                    SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD;
                    SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD;
                    IF(IWATCH.EQ.3)[
                        OUTPUT IPK;(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/);
                    ]
                ]
                ELSEIF((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2)))[
                    "IT IS IN THE BKGD"
                    SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD;
                    SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD;
                    SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD;
                    SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD;
                ]
             ]"END IPK LOOP"
             PHENER=0;
           ]
           WRITE(data_unit,*)(SCPDST(IB),SCPDST2(IB),IB=1,MAXBIN);
           WRITE(data_unit,*)(SCPCUM(IB),SCPCUM2(IB),IB=1,MAXBIN);
           WRITE(data_unit,*)(SCDFEP(IPK),SCDFEP2(IPK),IPK=1,4);
           WRITE(data_unit,*)(SCDFBK(IPK),SCDFBK2(IPK),IPK=1,4);
           WRITE(data_unit,*)(SCDFDIFF(IPK),SCDFDIFF2(IPK),IPK=1,4);
        ]
    ]"END OF CONDITIONAL DATA STORAGE"

    $SET_ELAPSED_CPUTIME(CPUT2);
    TIMCPU=CPUT2-CPUT1+TMCPUO;
    IF(IDAT.EQ.0)[
        $PUT RNG STATE ON UNIT data_unit;
        WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD;
        write(data_unit,*) SCOMEG,SCOMEG2;
        "IK: don't need to close, see ebove. CLOSE(UNIT=4);"
    ]

    "DO STATISTICAL ANALYSIS ON THE PEAK DOSE REGION TO SEE IF WE QUIT EARLY"
    TDSMAX=0.0;
    DO IRL=2,NREG[
        IF(CDSTBL(IRL).EQ.DCHAR)[
            IZD=IDSTBL(IRL,1);IXD=IDSTBL(IRL,2);
            FMASS=AMASS(IZD+NZDMIN-1,IXD+NRDMIN);
            IF((SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1))/FMASS.GT.TDSMAX)[
                  TDSMAX=(SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1))/FMASS;
                  IDSMAX=IRL;
            ]
         ]
    ]
    "NOW DO STATS ON THE PEAK REGION"
    IF(TDSMAX.GT.0.0)[
        IZD=IDSTBL(IDSMAX,1);IXD=IDSTBL(IDSMAX,2);
        TDOS=SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1);
        TDOS2=SCDOSE2(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1)*SCDOSE_TMP(IZD,IXD,1);
        "normalize by incident no. of primary histories--so far"
        IF(ISOURC=21|ISOURC=22)[
          SCORE_NORM_NUM=
             dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
        ]
        ELSE[
          SCORE_NORM_NUM=dble(IHSTRY);
        ]
        IF(SCORE_NORM_NUM>1.)[
          TDOS=TDOS/SCORE_NORM_NUM;
          TDOS2=TDOS2/SCORE_NORM_NUM;
          TDOS2=(TDOS2-TDOS*TDOS)/(SCORE_NORM_NUM-1);
          IF(TDOS2>=0.) TDOS2=SQRT(TDOS2);
          TDOS2=MIN(TDOS2/TDOS*100.,99.9);

          IF( (TDOS2 <= STATLM) & (STATLM ~= 0.0) )[
        "REACHED OBJECTIVE - PRINT MESSAGE AND JUMP OUT OF SIMULATION LOOP"
             WRITE(6,230)IDSMAX,TDOS2,IBTCH;WRITE(IOUT,230)IDSMAX,TDOS2,IBTCH;
            "EMH: Must be at the end of all possible exits from the shower loop"
             "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET); FIX NORM ON EARLY EXIT"
             GO TO :END-SIM:;
          ]
        ]
    ]
    OUTPUT TDOS2;(' ',9X,F6.3);

] "END OF SIMULATIONS, ie IBATCH loop"

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]

#endif;

"PRINT INSUFFICIENT STATS WARNING"
WRITE(IOUT,240) STATLM,TDOS2,IBTCH;WRITE(6,240) STATLM,TDOS2,IBTCH;

:END-SIM:;

write(6,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(6); write(6,'(a)') '  *********';
write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(iout); write(iout,'(a)') '  *********';

$SET_ELAPSED_TOTAL_TIME(TIMEB);
ETIMETOT=ETIMETOT+TIMEB;
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=CPUT2-CPUT1+TMCPUO;
IF(TMCPUO.EQ.0)[RATIO=ETIMETOT/TIMCPU;]ELSE[RATIO=0.;] "ONLY FOR SINGLE RUN"
IF(IRESTART=3)["just analyzing data--no elapsed time"
  WRITE(IOUT,250)TMCPUO,TMCPUO/3600;
  WRITE(6,250)TMCPUO,TMCPUO/3600;
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRESTART=5)["output time results for parallel runs"
  WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSE[
  IF(RATIO.NE.0.0)["I.E. WE HAVE CORRECT ELAPSED TIME"
      WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
      WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
  ]
  ELSE[
      WRITE(IOUT,270) TIMCPU,TIMCPU/3600.;
      WRITE(6,270) TIMCPU,TIMCPU/3600.;
  ]
  IF((IHSTRY.NE.0).AND.(TIMCPU.NE.0.0))["THIS SHOULD ALWAYS HAPPEN"
      WRITE(IOUT,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
      WRITE(6,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
  ]
]
;
"******************************************************************************
"
"                       *** SECTION 3 ***
"
"------------------------------------------------------------------------------

"STATISTICAL AND OTHER DATA HANDLING AND CALL THE OUTPUT SUMMARY ROUTINE"

"------------------------------------------------------------------------------

:STATS-ANAL:;

IF(ISOURC=21|ISOURC=22)[
    SCORE_NORM_NUM=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/
       dble(NCASE_PHSP)*NINCSRC;
]
ELSE[
    SCORE_NORM_NUM=dble(IHSTRY);
]

$ANALYZE(SCSTP, :SCORE_NORM_NUM);
$ANALYZE(SCDSTP, :SCORE_NORM_NUM);

IF(IDAT=1)["add unscored portions to _TMP arrays"
  DO IT=1,ITMAX[
        DO IX=1,NRDOSE[
             DO IZ=1,NZDOSE[
                 SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT);
                 SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
                                   SCDOSE_TMP(IZ,IX,IT);
                 IF(IKERMA=1)[
                    SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT);
                    SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+
                                        SCKERMA_TMP(IZ,IX,IT)*
                                        SCKERMA_TMP(IZ,IX,IT);
                   IF(SCDOSE_LAST(IZ,IX,IT)=SCKERMA_LAST(IZ,IX,IT))[
                    SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+
                               SCDOSE_TMP(IZ,IX,IT)*SCKERMA_TMP(IZ,IX,IT);
                   ]
                 ]
             ]
        ]
  ]
  IF(IFULL=2)[
     IF(PHENER>0.)[
           "FIND WHAT BIN WE ARE IN"
             IF(SLOTE.GT.0.0)[
               "EQUAL ENERGY BINS CASE"
               IB=MIN0(int(PHENER/SLOTE+0.999),$EBIN);
             ]
             ELSE[
                 IB = MAXBIN;
                 UNTIL((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)) [IB=IB-1;]
             ]

     "ACCUMULATE THE PULSE HEIGHT DISTRIBUTION"
             SCPDST(IB)=SCPDST(IB)+WT1OLD;
             SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD;
             "also add to cumulative distn"
             DO ICUM=IB,MAXBIN[
               SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD;
               SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD;
             ]


             IF(IWATCH.EQ.3)[
                OUTPUT PHENER,IB,1;
                (' PULSE HEIGHT ENERGY=',
                F10.4,' MeV, IN BIN',I3,' WITH WEIGHT',1PE10.3);
             ]
             "NOW SCORE PROBABILITIES FOR COUNTS IN PEAKS"
             DO IPK=1,4[
                 "FOR EACH PEAK, F.E., ESCAPES AND 511"
                 IF((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3)))[
                     "IT IS IN THE PEAK"
                     SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD;
                     SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD;
                     SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD;
                     SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD;
                     IF(IWATCH.EQ.3)[
                         OUTPUT IPK;(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/);
                     ]
                 ]
                 ELSEIF((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2)))[
                     "IT IS IN THE BKGD"
                     SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD;
                     SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD;
                     SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD;
                     SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD;
                 ]
             ]"END IPK LOOP"
             PHENER=0;
     ]
  ]
]

"FOR ISOURC=4 WE NEED THE DATA FOR CIRCLES, NOT RINGS, SO ADD IT UP"
IF((ISOURC.EQ.4).AND.(NR.GT.1))[
        DO IT=1,ITMAX[
            DO IX=2,NRDOSE[
                DO IZ=1,NZDOSE[
                    SCDOSE(IZ,IX,IT)=
                        SCDOSE(IZ,IX,IT)+SCDOSE(IZ,IX-1,IT);
                    SCDOSE2(IZ,IX,IT)=
                        SCDOSE2(IZ,IX,IT)+SCDOSE2(IZ,IX-1,IT);
                    SCKERMA(IZ,IX,IT)=
                        SCKERMA(IZ,IX,IT)+SCKERMA(IZ,IX-1,IT);
                    SCKERMA2(IZ,IX,IT)=
                        SCKERMA2(IZ,IX,IT)+SCKERMA2(IZ,IX-1,IT);
                ]
            ]
        ]
]

"AT THIS POINT, SCDOSE CONTAINS THE ENERGY (IN MeV) DEPOSITED"
"IN EACH MODE. TO GET THE AVERAGE ENERGY DEPOSITED IN THE       "
"PULSE HEIGHT DETECTOR REGION, WE SUM THE IT=1 VALUES FOR ALL         "
"REGIONS IN THE DETECTOR. (FOR IFULL=2 ONLY)                          "
IF(IFULL.EQ.2)[
        DO IX = 1,NRDOSE[
            DO IZ=1,NZDOSE[
                $GET-IRL(IZ,IX);
                IF(IPHR(IRL).NE.0) [
                    "THIS REGION IS IN DETECTOR"
                    SCPHEN=SCPHEN+SCDOSE(IZ,IX,1);
                    SCPHEN2=SCPHEN2+SCDOSE2(IZ,IX,1);
                ] "END TEST FOR INSIDE THE DETECTOR"
            ]
        ] "END LOOPS OVER REGIONS"
] "END OF IFULL = 2 BLOCK"

"STATISTICAL ANALYSES ON THE RAW DATA"

DO IT=1,ITMAX[
      DO IX=1,NRDOSE[
           DO IZ=1,NZDOSE[
               $ANALYZE(SCDOSE,(IZ,IX,IT):SCORE_NORM_NUM);
               IF(IKERMA=1)[
                  $ANALYZE(SCKERMA,(IZ,IX,IT):SCORE_NORM_NUM);
                  "now analyze the uncertainty on the dose/kerma ratio"
                  "first set SCDOSEtoKERMA2(IZ,IX,IT)=cov(dose,kerma)"
                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/
                                           SCORE_NORM_NUM-
                                           SCDOSE(IZ,IX,IT)*
                                           SCKERMA(IZ,IX,IT)/
                                           (SCORE_NORM_NUM**2);
                  "now set SCDOSEtoKERMA2(IZ,IX,IT)=cov(dose,kerma)/"
                  "                                  (dose*kerma)"
                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/
                              (SCDOSE(IZ,IX,IT)*SCKERMA(IZ,IX,IT)/
                               (SCORE_NORM_NUM**2));
                  "now set SCDOSEtoKERMA2(IZ,IX,IT)=cov(dose,kerma)/"
                  "                                 (dose*kerma)/(N-1)"
                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/
                                           (SCORE_NORM_NUM-1);
                  "now estimate the uncertainty on dose/fluence"
                  SCDOSEtoKERMA2(IZ,IX,IT)=(SCDOSE2(IZ,IX,IT)/100.)**2+
                                           (SCKERMA2(IZ,IX,IT)/100.)**2-
                                          2*SCDOSEtoKERMA2(IZ,IX,IT);
                  IF(SCDOSEtoKERMA2(IZ,IX,IT)>0.)[
                     SCDOSEtoKERMA2(IZ,IX,IT)=
                       100*SQRT(SCDOSEtoKERMA2(IZ,IX,IT));
                  ]
                  IF( SCDOSEtoKERMA2(IZ,IX,IT) > 99.9 ) [
                      SCDOSEtoKERMA2(IZ,IX,IT) = 99.9;
                  ]
               ]
           ]
      ]
]

$ANALYZE(SCOMEG, :dble(IHSTRY));
SCOMEG = SCOMEG/dble(IHSTRY);"Corrected, IK May 4 1999"

OUTPUT SCOMEG,SCOMEG2;(/' OMEG =',1PE12.3,'(',0PF5.1,'%)'/);

"ANALYSIS OF THE PULSE HEIGHT DISTRIBUTIONS"
IF(IFULL.EQ.2)[

    DO IB=1,MAXBIN[
       SCPTOT=SCPTOT+SCPDST(IB);
       SCPTOT2=SCPTOT2+SCPDST2(IB);
    ]

    $ANALYZE(SCPTOT, :SCORE_NORM_NUM);
    $ANALYZE(SCPHEN, :SCORE_NORM_NUM);

    DO IPK=1,4[
       $ANALYZE(SCDFEP,(IPK):SCORE_NORM_NUM);
       $ANALYZE(SCDFBK,(IPK):SCORE_NORM_NUM);

       "subtract background from peak"
       SCDFEP(IPK)=SCDFEP(IPK)-SCDFBK(IPK);

       "estimate uncertainty on this subtracted value"
       SCDFEP2(IPK)=(SCDFEP2(IPK)*SCDFEP(IPK)/SCORE_NORM_NUM/100.)**2+
                    (SCDFBK2(IPK)*SCDFBK(IPK)/SCORE_NORM_NUM/100.)**2+
                    2/(SCORE_NORM_NUM**2)*(SCDFEP(IPK)*SCDFBK(IPK))/
                    (SCORE_NORM_NUM-1);
       IF(SCDFEP2(IPK)>0.) [
         SCDFEP2(IPK)=SQRT(SCDFEP2(IPK))/(SCDFEP(IPK)/SCORE_NORM_NUM);
       ]
       IF( SCDFEP2(IPK) > 0.999 ) [ SCDFEP2(IPK) = 0.999; ]

       SCDFEP(IPK)=SCDFEP(IPK)/SCPTOT;

       "now estimate the uncertainty on this quotient"
       SCDFEP2(IPK)=SCDFEP2(IPK)**2+(SCPTOT2/100.)**2-
          2*(SCDFDIFF2(IPK)/SCORE_NORM_NUM - SCDFDIFF(IPK)*SCPTOT/
                                            (SCORE_NORM_NUM)**2)/
          (SCDFDIFF(IPK)*SCPTOT/(SCORE_NORM_NUM)**2)/(SCORE_NORM_NUM-1);
       IF(SCDFEP2(IPK)>0.)SCDFEP2(IPK)=100*SQRT(SCDFEP2(IPK));
       IF(SCDFEP2(IPK)>99.9) SCDFEP2(IPK)=99.9;
    ]
    DO IB=1,MAXBIN[

      "save SCPDST2(IB) since it is also equal to SCPDST(IB)*SCPTOT summed"
      "over all primary histories and will be used later"
      SCORE_TEMP2=SCPDST2(IB);
      $ANALYZE(SCPDST,(IB):SCORE_NORM_NUM);

      "now estimate the uncertainty on scpdst(IB)/scptot"
      SCPDST2(IB)=(SCPDST2(IB)/100.)**2+(SCPTOT2/100.)**2-
         2*(SCORE_TEMP2/SCORE_NORM_NUM-SCPDST(IB)*SCPTOT/(SCORE_NORM_NUM**2))/
         (SCPDST(IB)*SCPTOT/(SCORE_NORM_NUM**2))/(SCORE_NORM_NUM-1);

      IF(SCPDST2(IB)>0.)SCPDST2(IB)=100*SQRT(SCPDST2(IB));
      IF(SCPDST2(IB)>99.9) SCPDST2(IB)=99.9;

      SCPDST(IB)=SCPDST(IB)/SCPTOT;

      "save SCPCUM2(IB) since it is also equal to SCPCUM(IB)*SCPTOT summed"
      "over all primary histories and will be used later"
      SCORE_TEMP2=SCPCUM2(IB);
      $ANALYZE(SCPCUM,(IB):SCORE_NORM_NUM);

      "now estimate the uncertainty on this quotient"
      SCPCUM2(IB)=(SCPCUM2(IB)/100.)**2+(SCPTOT2/100.)**2-
         2*(SCORE_TEMP2/SCORE_NORM_NUM-SCPCUM(IB)*SCPTOT/(SCORE_NORM_NUM**2))/
         (SCPCUM(IB)*SCPTOT/(SCORE_NORM_NUM**2))/(SCORE_NORM_NUM-1);

      IF(SCPCUM2(IB)>0.)SCPCUM2(IB)=100*SQRT(SCPCUM2(IB));
      IF(SCPCUM2(IB)>99.9) SCPCUM2(IB)=99.9;

      SCPCUM(IB)=SCPCUM(IB)/SCPTOT;
    ]

    SCPTOT=SCPTOT/SCORE_NORM_NUM; "NORMALIZE TOTAL TO PER HISTORY"
    SCPHEN=SCPHEN/SCORE_NORM_NUM; "NORMALIZE TO ENERGY PER HISTORY"

] "END IFULL=2 BLOCK"

"CONVERT DOSE FROM MeV PER REGION PER BATCH TO GRAY PER UNIT INCIDENT FLUENCE"
IF(ISOURC=21|ISOURC=22)[
"normalize dose to number of incident particles from primary source
   AINFLU=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
"we estimate the total number of particles from the primary source (original"
"non-phase space source) by taking the ratio of the total number of"
"particles read from the phase source in this simulation to the total number"
"of particles in the phase space source and multiply this by the number of"
"particles from the primary source that were used to obtain this phase space"
"source."
]
ELSEIF(ISOURC=23)[
"have to set AINFLU to no. of primary histories
   AINFLU=dble(IHSTRY);
]
ELSE["EMH: adjust incident fluence to actual number of histories"
   AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);
]

"RECALL 1 MeV = 1.602E-06 erg, 1 rad=100 ergs/g, 1 rad=0.01 Gy"
"THE UNIT OF DOSE IS Gy-cm**2"
DO IT=1,ITMAX[
    DO IX=1,NRDOSE[
        DO IZ=1,NZDOSE[
            IF(SCDOSE(IZ,IX,IT).NE.0.0)[
                FMASS=AMASS(IZ+NZDMIN-1,IX+NRDMIN);
                IF(FMASS.EQ.0.0)FMASS=1.0; "AVOIDS /0 FOR VACUUM"
                SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)*1.602E-10/(FMASS*AINFLU);
                IF(SCKERMA(IZ,IX,IT) ~= 0) [
                  SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)*1.602E-10/(FMASS*AINFLU);
                ]
             ]
        ]
    ]
]

CALL OSUMRY; "PRINT THE OUTPUT SUMRY"

:END-OF-RUN:;
;
"******************************************************************************
"
"                       *** SECTION 4 ***
"
"------------------------------------------------------------------------------
"
"THE CONCLUSION"
"
"------------------------------------------------------------------------------

:END:;

OUTPUT ' '; (/ ' End of run',9X,a,$);
call egs_fdate(6);
OUTPUT; (//1x,79('*')/1x,79('*')/);

" ********** IK: using wrapper for date and time routines.
" Was:
" CALL DATE(DATEN);CALL TIME(TIMEN);
" OUTPUT DATEN,TIMEN; ( / ' End of run',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT/
"     / ' ',79('*')/ ' ',79('*')/);

"Now print the error file at the end of run to draw users attention to it"
"This reports the errors on the input and defaults used etc"
IF (ERROR_FLAG=1) [
   OUTPUT ;(//' **********  ERRORS AND WARNING MESSAGES  ********** '//);
]
rewind (i_errors);
9998 CONTINUE;
     READ (i_errors, END=9999, FMT='(A80)') TEXT;
     WRITE (*,'(A79)') TEXT;
     GOTO 9998;
9999 CONTINUE;
backspace(i_errors);
write(i_errors,'(/a,9x,a,$)') ' '; call egs_fdate(i_errors); write(i_errors,*);
write(iout,'(/a,9x,a,$)') ' ';     call egs_fdate(iout);     write(iout,*);

" ********** IK: using wrapper for date and time routines.
" Was:
" WRITE(15 , 400) DATEN,TIMEN;
" WRITE(IOUT,400) DATEN,TIMEN;

call egs_finish;

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IF( n_job = 0 ) [
        is_finished = .true.;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET;
        CALL SRCOTO(WEIGHT);
        goto :STATS-ANAL:;
    ]
]
#endif;

call SRCEND;

$CALL_EXIT(0);

"FORTRAN FORMAT STATEMENTS. FORMAT STATEMENT N## IS FIRST USED IN SECTION N."
%I0
100  FORMAT(' ',80A1//' CALCULATION USING DOSRZnrc(EGSnrc) '$VERSION' ',
             /'ON '$MACHINE' ',T54,a,$);
" ********** IK: using wrapper for date and time routines.
" Was:
" 100  FORMAT(' ',80A1//' CALCULATION USING DOSRZnrc(EGSnrc) '$VERSION' ',
"              /'ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
200  FORMAT(/' ',79('*')/
            /' ',T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
            /' ',79('*')/
            /' USING DOSRZnrc(EGSnrc) '$VERSION' ');
201  FORMAT(/' ********* NEW INPUT FILE *********'/);
202  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
             ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
             ' ',20X,'NEW RN SEEDS=',$);
204  FORMAT(/' ********* DATA ANALYSIS ONLY *********'/);
205  FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/);
206  FORMAT(/' ********* READING RANDOM NUMBER STATE FROM UNIT 2 ****'/);
210  FORMAT(/' ********* Not enough time to finish within',
     ' limit of',F8.2,' hours *******'/'*********',I5,' batches used********'/
     ' ',I12,' histories run, ',I12,' histories analyzed'//);
220  FORMAT(I12,1X,2I1);
230  FORMAT(/' DESIRED STATISTICAL ACCURACY OBTAINED.'/
            ' STATS IN PEAK DOSE REGION (REGION ',I3,')= ',F6.3,
            ' AFTER ',I2,' BATCHES');
240  FORMAT(/' *********DESIRED STATISTICAL ACCURACY OF ',F6.3,'%',
            ' NOT REACHED*********'/
            ' STATS IN PEAK DOSE REGION= ',F6.3,' % AFTER ',I2,' BATCHES');
250  FORMAT(/' FOR OLD RUN:'/
             ' ----------- '/
             ' Total cputime =',F8.1,'s (=',F5.2,' h)');
255  FORMAT(/' FOR PARALLEL RUNS:'/
             ' ----------------- '/
             ' On ',I5,' machines '/
             ' Total cputime =',F8.1,'s (=',F8.2,' h), cputime/machine =',
              F8.1,'s');
260  FORMAT(/' Finished simulations: elapsed,cputime',
             ',ratio= ',2F8.1,'(=',F5.2,'h)',F8.2);
270  FORMAT(/' Finished simulations: cputime=',F8.1,'(=',F5.2,' h)');
280  FORMAT(/' cputime per history =',F10.5,' sec. number of histories per',
             1x,' hour =',F12.0);
"400  FORMAT(/' End of run',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT);

END; "END OF MAIN ROUTINE-DOSRZ"

%C80
%I4
%Q1
%E     "start of AUSGAB in DOSRZnrc.mortran"

;
"******************************************************************************
"
"
"                               **********
"                               *        *
"                               * AUSGAB *
"                               *        *
"                               **********
"
"
"     AN AUSGAB ROUTINE TO BE USED WITH DOSRZnrc.mortran
"
"     Called with IARG = -1 after each history is over in order to
"     score things for the pulse height distribution when IFULL = 2.
"
"     For IFULL = 2 (passed in COMIN SCORE), the parameter phener keeps
"     track of the energy deposited in the sensitive volume defined by non-
"     zero elements in the array IPHR($MXREG) (passed IN SCORE).
"
"     This routine scores the dose in a finite, azimuthally symmetric
"     cylindrical geometry which the user defines via plane and radial
"     coordinates. The user must specify both the target geometry as well
"     as the planes and radii between which the dose is to be scored. All
"     the geometrical checks for crossing 'geometrical' or 'dose' regions
"     are handled by the subroutine  HOWFAR.
;
"     FOR IT = 1      total dose is scored
"            = 2      dose less stopped/discarded particles is scored
"                     For IFULL = 3 the scattered dose for incident photons
"            = 3      dose due to particles entering the dose region from
"                     the front wall
"            = 4      dose due to particles entering the dose region from
"                     the side wall
"            = 5      dose due to particles entering the dose region from
"                     the back wall
"            = 6      dose due to particles entering the dose region from
"                     the inside wall
"            = 7      dose due to particles originates from within an
"                     isotropically radiating disk buried in the geometry
"                     which have not yet strayed outside the source region
"
"     Some of the logic
"             Bit 6 of latch is set for all photons scattered after Compton
"             Bit 7 of LATCH is set for all photons after photoeffect
"             Bit 8 of LATCH is no longer set. Not clear what it was for
"
"******************************************************************************
;

SUBROUTINE AUSGAB(IARG);

$IMPLICIT-NONE;

$INTEGER  IARG;

REAL*8 FTMP;

;
COMIN/CHARS,EPCONT,GEOM,NRCNEW,RUSROU,SCORE,STACK,USEFUL,USER,RANDOM,
BREMPR,EGS-VARIANCE-REDUCTION,SOURCE,IODAT2/;

$INTEGER  IRL,IZD,IXD,IQL,ip,IX,IZ,IGEOM,IB,IPK,I,II,ICUM;
$REAL     aux1,R1,XSI;

LOGICAL BTEST;
INTEGER IBSET,IBCLR;

"I don't know about the purpose of IGBUG1,2 but they should be declared,"
"make static and initialized to zero as they seem to count bugs, IK"
$INTEGER  IGBUG1,IGBUG2;
save      IGBUG1,IGBUG2;

data      IGBUG1/0/,IGBUG2/0/;

MXNP=MAX(MXNP,NP);"keep track of how deep stack is"
                  "should print out MXNP"

IF (ienhance = 1) [" Option to enhance photon cross section in some region"
"write(6,*) 'in ausgab to recreate photon';"
    IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23) [
        "A pair/Compton/photoelectric/pair event is about to take place"
        np = np + 1; "Boost the stack"
        IF(np > $MXSTACK) [
            OUTPUT $MXSTACK; (
             ' Enhance cs unable to add to stack'/
             '       since exceeding $MXSTACK=',I6/
             ' Stopping.'/ 1x,80('*')/);
            stop;
        ]
        "Create an identical photon"
        $TRANSFER PROPERTIES TO (np) FROM (np - 1);
        e(np)  =  e(np - 1);
        u(np)  =  u(np - 1);
        v(np)  =  v(np - 1);
        w(np)  =  w(np - 1);
        iq(np) = iq(np - 1);
        $RANDOMSET R1;
        aux1 = 1 - 1./cs_enhance_current;
        IF( R1 > aux1 ) [ wt(np-1) = 0; e(np-1) = 0; dnear(np-1) = -1; ]
        wt(np) = wt(np)*1.0/cs_enhance_current;
        "write(6,*) ' Creating an unscattered photon! ',ir(np),wt(np),wt(np-1);
        return;
    ]"end of block after photon events"

    " Play Russian Roulette with scattered photons to avoid transport
    " of many low weight particles.
    " Now there is a stack pointer NPold which points to the particle "
    " before the last discrete interaction. This change was necessary "
    " for the implementation of atomic relaxations. So, check all particles"
    " between NPold and NP for RR"
    IF ( (  iarg = 18               " Compton has occured"
          | iarg = 20               " After photo-absorption "
          | iarg = 24)              " After Rayleigh "
          & ienhance = 1 )
    [
          ienhance=0;
          "write(6,*) ' iarg = ',iarg,' NP NPold: ',NP,NPold;

          DO ip=NPold,NP [
              IF( iq(ip) = 0 ) [
               $RANDOMSET R1;
               IF(R1.LT.1.0/cs_enhance_current)[
                   "PARTICLE SURVIVES"
                    WT(ip)=WT(ip)*cs_enhance_current;
                    "write(6,*) ' iarg = ',iarg,' particle has survived ',
                    "     wt(ip),ip;
               ]
               ELSE [
                    wt(ip) = 0; e(ip) = 0; dnear(ip) = -1;
                    "write(6,*) ' Have killed particle ',ip,
                    " ' after iarg = ',iarg;
               ]
              ]
          ]
          return;
    ]

] "end of ienhance block"


"Check if particle is leaving the transport geometry"
IRL=IR(NP);  "local region number"
IF(IRL = 1)[
    IF(IWATCH > 0) CALL WATCH(IARG,IWATCH); "signal watch routine if active"
    RETURN; "outside the chamber, howfar will discard"
    ]

"obtain frequently used local variables"
IRL=IR(NP);IF(IRL.EQ.1) RETURN; "outside the chamber"
IZD=IDSTBL(IRL,1); IXD=IDSTBL(IRL,2);   "dose zone coordinates"
IQL=IQ(NP); "local variable"
"write(1,*) ' In AUSGAB: iarg iq edep = ',iarg,iql,edep

IF(IARG = 0)["about to transport a particle"
    IF(IQL.NE.0)[
        $SCORE(SCSTP, :1);"count charged particle steps taken"
        IF(CDSTBL(IRL).EQ.DCHAR)[$SCORE(SCDSTP, :1);]
                                 "count steps in dose region"
    ]
    ELSE["photon step - play russian roulette?"
        IF(RUSROU.AND.(W(NP).GT.0.0))["yes, play if crosses RRZ "
            IF((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))["crosses"
                $RANDOMSET XSI;
                    IF(XSI.LT.RRCUT)["it survives" WT(NP)=WT(NP)/RRCUT;]
                    ELSE["discard it on next call to HOWFAR" WT(NP)=0.0;]
                ] "end test if crosses russian roulette plane"
            ] "end test for playing russian roulette"
        ] "end test for photon step"
    ] "end test for IARG = 0"

IF(IWATCH.GT.0) CALL WATCH(IARG,IWATCH); "signal WATCH routine if active"

IF(IFULL = 1)[ "dose components by origin in each voxel"
   "check to see if any electrons created BY PHOTONS"
   "if so, set bit 5 to 1 (ie dose from inside). If e- created by e-"
   "(ie moller, bhaba), just pass latch value on.  This is"
   "our arbitrary definition of where dose comes from."

   IF(IARG=16 | IARG=18 | IARG=20)[" after pair production,compton or p.e event"
     IF(NP>=NPold)[ "needed for p.e. case where russian roulette may have"
                    "eliminated ALL electrons"
       DO II=NPold,NP [
         IF(IQ(II)~=0)[
            "first, clear latch bits 1-5"
            DO I=1,5[LATCH(II)=IBCLR(LATCH(II),I);]
            "now set latch bit 5"
            LATCH(II)=IBSET(LATCH(II),5);
         ]
       ]  "end loop over II"
     ]
   ] "end block after photon event"

   ELSEIF(IQ(NP)=0 & (IARG=1 | IARG=2))[
     "In the rare case that a photon is terminated "
     "because E<PCUT or E<AP.  We also want"
     "this to show as dose originating from"
     "within the volume"
     "first, clear latch bits 1-5"
     DO I=1,5[LATCH(NP)=IBCLR(LATCH(NP),I);]
     "now set latch bit 5"
     LATCH(NP)=IBSET(LATCH(NP),5);
   ]

   ELSEIF(((IARG.EQ.5).AND.(IRNEW.NE.IROLD)).OR.DECISION.EQ.1)[
   "set LATCH for a particle entering a new region during a step"
   "used to be below, but found that bit setting was wrong for particles"
   "ending their track on a region boundary"
        DO I=1,5[LATCH(NP)=IBCLR(LATCH(NP),I);]
        LATCH(NP)=IBSET(LATCH(NP),NEWNRC/10);
        "NEWNRC = 10,20,30 OR 40 depending on if particle in question is"
        "         about to enter a new region via front, outer, back    "
        "         or inner wall respectively                            "
        DECISION=0;
   ]
]
ELSEIF(IFULL = 3)["score scattered dose separately"
   "LATCH currently set as follows:
   "   scattered dose includes:
   "         any dose from compton scattered photons
   "         any dose from fluorescent photon which is re-absorbed
   "
   " This counts as primary any dose after bremsstrahlung  from e- Why???
   "      and dose from fluorescent photons when not transported.
   "
   "Reminder i_survived_RR = 0=> all particles survived RR
   "                       = n=> n particles eliminated by RR in interaction"

   IF( iarg = 18 ) [ "After Compton. With binding effects and subsequent "
                     "atomic relaxations implemented, there may be 0, 1  "
                     "or more additional particles on the stack. NPold   "
                     "is a current addition to STACK. It is set to NP    "
                     "at the beginning of every scattering routine       "

       IF( NP > NPold | i_survived_rr > 0 ) [ " Flag all photons as scattered "
           DO ip=NPold,NP [
               IF( iq(ip) = 0 ) [ latch(ip) = IBSET(latch(ip),6); ]
           ]
       ]
       " NPold = NP & i_survived_rr>0 after Compton means the interaction"
       "      occurred but russian roulette got rid of all electrons but "
       "      the scattered photon is on the stack => flag it            "
       " NPold = NP & i_survived_rr=0 after Compton means the interaction"
       "      was rejected due to binding effects                       "
       "      => emerging photon is not scattered => don't flag it       "
   ]
   ELSE IF( iarg = 20 ) [ "A photo-absorption has occured. "
                          "If NPold = NP, no particles with energies above "
                          "the specified thresholds resulted from the "
                          "relaxation cascade. If NPold < NP, there were "
                          "such particles emitted. Check them and flag all"
                          "fluorescent photons as secondaries"
      IF( NP > NPold | i_survived_rr>0 ) [
          DO ip=NPold,NP ["particle at NPold is photo-electron if not rr'd"
              IF( iq(ip) = 0 ) [ latch(ip) = IBSET(latch(ip),7); ]
          ]
      ]
   ]
] " end IFULL=3 "

"IKERMA=1 option will not work with new photon physics!!!"
"I intend to fix it in the future, IK January 1999"
"July 2011 DR I think I have fixed what was here. Someone had tried to"
"make it work since Iwan made the above comment, but it was buggy!"

IF (IKERMA = 1) ["want to score KERMA"
   "we score kerma for scattered component too if ifull=3"
   "the kerma is part of scattered kerma if latch of initial photon is not zero"

    "Here we keep track of whether we are currently inside a PE/Compton"
    "event, or EII. This lets us use edep_local to account for kerma"
    "contributions below threshold energies depending on the interaction type."
    IF( iarg = 19 | iarg = 17 ) [
        before_photo = 1;
        return;
    ]
    IF( iarg = 20 | iarg = 18 ) [
        before_photo = 0;
    ]
    IF( iarg = 31 ) [
        before_eii = 1;
        return;
    ]
    IF( iarg = 32 ) [
        before_eii = 0;
        return;
    ]

   IF (IARG = 4 & ~BTEST(LATCH(NP),8) & before_eii = 0 & before_photo = 0)[
      "local energy deposition"
      "include deposited energy as kerma"
      " I am not sure why the BTEST was there??? Currently bit 8 is"
      "not set, but was there some reason for it to be there??  DR"
      $SCOREDK(SCKERMA,(IZD,IXD,1):WT(NP)*EDEP);
      IF(IFULL=3 & (BTEST(LATCH(NP),6) | BTEST(LATCH(NP),7)))[
         $SCOREDK(SCKERMA,(IZD,IXD,2):WT(NP)*EDEP);
      ]
   ]

    "depositing sub-threshold energy for PE & Compton"
    "Auger only"
    IF( iarg = 34 ) [
        IF( before_photo = 1 ) [
            $SCOREDK(SCKERMA,(IZD,IXD,1):WT(NP)*edep_local);
            IF(IFULL=3 & (BTEST(LATCH(NP),6) | BTEST(LATCH(NP),7)))[
                $SCOREDK(SCKERMA,(IZD,IXD,2):WT(NP)*edep_local);
            ]
            return;
        ] ELSE [
            return;
        ]
    ]

   IF (IARG = 16)["pair event just occured"
      IF(NP>NPold | i_survived_rr > 0)[
         "i_survived_rr, 0=> all particles survive RR,"
         "               n=> n particles were removed"
         "so the only reason for the i_survived_rr > 0 possibility"
         "  is for the case one particle discarded, NP=NPOLD and there"
         "  is one charged particle to account for"
         "If both eliminated, NP=NPOLD-1 and so nothing done"
         DO IP=NPold,NP[
           IF(IQ(IP)~=0 & ~BTEST(LATCH(IP),8))[
               $SCOREDK(SCKERMA,(IZD,IXD,1):WT(IP)*(E(IP)-PRM));
               IF (IFULL = 3 & (BTEST(LATCH(IP),6) | BTEST(LATCH(IP),7)))[
                  $SCOREDK(SCKERMA,(IZD,IXD,2):WT(IP)*(E(IP)-PRM));
               ]
               "LATCH(IP)=IBSET(LATCH(IP),8);"
               "DR July 2011 I don't understand why the above was here:
               "it caused the other member of the pair to be missed"
               "But do we need it somewhere else? -for the IARG=4 above?"
           ]
         ]
      ]
   ]"end of pair case"

   IF (IARG = 18)["compton event just occured"
      "must score kerma for all resultant electrons"
     IF(NP>NPold)["compton occurred and we have not cleared the stack with"
                  "russian roulette since if we had, NP=NPOLD"
                  "also, if bound compton and rejected NP=NPOLD"
                  "note any relaxation particles are included in NP"
      DO IP=NPold,NP[
        IF(IQ(IP) ~= 0 & ~BTEST(LATCH(IP),8)) ["score kerma for the electron"
          $SCOREDK(SCKERMA,(IZD,IXD,1):WT(IP)*(E(IP) - PRM));
          IF(IFULL=3 & (BTEST(LATCH(IP),6) | BTEST(LATCH(IP),7)))[
             $SCOREDK(SCKERMA,(IZD,IXD,2):WT(IP)*(E(IP)-PRM));
          ] "end IFULL block"
          "LATCH(IP)=IBSET(LATCH(IP),8);  Commented out as above"
        ]"end charged particle block"
      ]"end loop on IP"
     ]"end block with some e- on stack"
   ]"end of compton case"

   IF (IARG = 20)["photoelectric event just occured"
     DO IP=NPold,NP[
        IF(IQ(IP)~=0 & ~BTEST(LATCH(IP),8))[
           $SCOREDK(SCKERMA,(IZD,IXD,1):WT(IP)*(E(IP) - PRM));
           IF(IFULL = 3 & (BTEST(LATCH(IP),6) | BTEST(LATCH(IP),7)))[
              $SCOREDK(SCKERMA,(IZD,IXD,2):WT(IP)*(E(IP)-PRM));
           ]
          "LATCH(IP)=IBSET(LATCH(IP),8);  Commented out as above"
        ]
     ]
   ]"end of photoelectric case"
]"end of IKERMA = 1, kerma scoring block"

"do some basic checks to see if scoring is needed"
IF(IARG.GE.5.OR.EDEP.EQ.0) RETURN;

"score total energy deposited"
"============================="

FTMP=WT(NP)*EDEP;

IF(CDSTBL(IRL).EQ.DCHAR)[ "in a dose scoring region"
    "score total energy deposited"
    $SCOREDK(SCDOSE,(IZD,IXD,1):FTMP);
    IF((IFULL = 3) & (BTEST(LATCH(NP),6) | BTEST(LATCH(NP),7)))[
            "bit 6 and 7 set when photons scatter"
            $SCOREDK(SCDOSE,(IZD,IXD,2):FTMP);
    ]
    IF(IARG.EQ.0)[ "step about to occur but not discard"
        "score total energy deposited less stopped/discarded"
        IF(IFULL.NE.3)[$SCOREDK(SCDOSE,(IZD,IXD,2):FTMP);]
    ]
    IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
        OUTPUT FTMP,IRL,IARG;
        (9x,' ***weighted dose deposition  = ',1PE14.7,
        ' MeV. IRL= ',I3, ' IARG= ',I3);
    ]
]
;
IF(IFULL.EQ.1)[
    "Score total energy into bins according to which wall the particle came"
    "from. Corner shots attributed to planar wall : see assignments in howfar"
    IF(CDSTBL(IRL).EQ.DCHAR)[ "in a dose scoring region"
        $GET-IX-IZ(IRL);
        DO I=1,5[
          IF(BTEST(LATCH(NP),I))[
             IGEOM=I*10;
             EXIT;
          ]
        ]
        IF(IGEOM.EQ.10)[    $SCOREDK(SCDOSE,(IZD,IXD,3):FTMP); "front wall"   ]
        ELSEIF(IGEOM.EQ.20)[$SCOREDK(SCDOSE,(IZD,IXD,4):FTMP); "outside wall" ]
        ELSEIF(IGEOM.EQ.30)[$SCOREDK(SCDOSE,(IZD,IXD,5):FTMP); "back wall"    ]
        ELSEIF(IGEOM.EQ.40)[
            $SCOREDK(SCDOSE,(IZD,IXD,6):FTMP); "inside wall"
            IF(IX.EQ.1)[ "BUG"
                IGBUG2=IGBUG2+1;
                IF(IGBUG2.LE.100)[
                    "OUTPUT IGBUG2,IGE0M; changed 92/11/09"
                    OUTPUT IGBUG2,IGEOM;
                    (' **** INSIDE DOSE???. BUG NO.',I3,' IGEOM=',I3);
                ]
            ]
        ]
        ELSEIF(IGEOM.EQ.50)[$SCOREDK(SCDOSE,(IZD,IXD,7):FTMP); "inside source"]
        ELSE[ "bug"
            IGBUG1=IGBUG1+1;
            IF(IGBUG1.LE.100)[
                "OUTPUT IGBUG1,IGE0M; changed 92/11/09"
                OUTPUT IGBUG1,IGEOM;
                (' **** LOST REGION. BUG NO.',I3,' IGEOM=',I3);
            ]
        ]
   ]

    "recover region orientation flag if particle will be discarded"
   IF((NP.GT.1).AND.(IARG.GE.1).AND.(IARG.LE.3))[
        DO I=1,5[
          IF(BTEST(LATCH(NP-1),I))[
            NEWNRC=I*10;
            EXIT;
          ]
        ]
   ]

] "end of IFULL=1 components by wall"

IF(IFULL=2 & IPHR(IRL)~=0)[
  IF(NHSTRY=SCPDST_LAST)["same primary history"
   "keep adding energy in pulse height sensitive region"
   PHENER=PHENER+EDEP;
   WT1OLD=WT(1);
  ]
  ELSE[
   IF(PHENER>0.)[
   "we either have a new history depositing or are at the end of a batch/run"
   "find appropriate bin for pulse height"
   "distn and add initial particle weight to it"
   "FIND WHAT BIN WE ARE IN"
    IF(SLOTE.GT.0.0)[
        "EQUAL ENERGY BINS CASE"
        IB=MIN0(int(PHENER/SLOTE+0.999),$EBIN);
    ]
    ELSE[
        IB = MAXBIN;
        UNTIL((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)) [IB=IB-1;]
    ]

    "accumulate the pulse height distribution"
    "use WT(1) from history that contributed since we may have forcing"
    "on for a primary source in the case of a phsp source WT(1) must be 1"
    SCPDST(IB)=SCPDST(IB)+WT1OLD;
    SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD;
    "also add this to the cumulative pulse height distn"
    DO ICUM=IB,MAXBIN[
      SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD;
      SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD;
    ]


    IF(IWATCH.EQ.3)[
        OUTPUT PHENER,IB,1;
        (' Pulse height energy=',
        F10.4,' MeV, in bin',I3,' with WEIGHT',1PE10.3);
    ]

    "now score probabilities for counts in peaks"
    DO IPK=1,4[
        "FOR EACH PEAK, F.E., ESCAPES AND 511"
        IF((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3)))[
            "IT IS IN THE PEAK"
            SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD;
            SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD;
            SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD;
            SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD;
            IF(IWATCH.EQ.3)[
                OUTPUT IPK;(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/);
            ]
        ]
        ELSEIF((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2)))[
            "IT IS IN THE BKGD"
            SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD;
            SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD;
            SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD;
            SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD;
        ]
    ]"END IPK LOOP"
   ]
   SCPDST_LAST=NHSTRY;
   PHENER=EDEP;
   WT1OLD=WT(1);
  ]
]

RETURN;

END;  "end of subroutine AUSGAB"
%I4
%C80
%Q1
%E     "start of HOWFAR "

;
"*******************************************************************************
"
"                               **********
"                               *        *
"                               * HOWFAR *
"                               *        *
"                               **********
"
"       A general purpose cylindrical geometry routine for use with the EGSnrc
"       code system adapted for use with DOSRZnrc.
"
"       For particle NP on the STACK in region IR(NP), this routine
"       determines if the particle can go a distance USTEP without changing
"       zones. if USTEP causes a zone crossing, it is reduced to place it on
"       the boundry and IRNEW is set to the zone number on the far side of
"       the boundary. If IR(NP) is 1 then the particle has escaped the region
"       of interest and the history is terminated.(IDISC is set to 1.)
"
"
"       SOME VARIABLES
"       ==============
;
"OUTEND =       .TRUE.  =>      particle may transmit or backscatter out ends
"       =       .FALSE. =>      particle stays within the end boundaries
"OUTSID =       .TRUE.  =>      particle may transmit out the sides
"       =       .FALSE. =>      particle stays within the side boundary
"IRL    =       starting region number the particle is in
"IZ     =       starting planar zone number the particle is in.
"               the particle is between ZPLANE(IZ) and ZPLANE(IZ+1).
"IX     =       starting cylindrical zone number the particle is in.
"               the particle is between RCYL(IX-1) and RCYL(IX).
"
"       COMMON/GEOM/
"               ZPLANE(IZ)      Z values of planes
"                               1<=IZ<=NZ+1
"               RCYL(IRR)       radii of cylinders
"                               1<=IRR<=NR
"               CYRAD2(IRR)     =RCYL(IRR)**2
"               NZ              # planar geometrical zones (NPLANE-1)
"                               ZONE(I) is between ZPLANE(I) and ZPLANE(I+1)
"               NR              # cylindrical geometrical zones
"                               ZONE(I) is between RCYL(I-1) and RCYL(I)
"               NREG            total # geometrical zones =NR*NZ +1
"                                       +1 for vacuum envelope
"               CABSRB(IRL)     absorbing region flags
"                               =' ' non-absorbing
"                               ='A' absorbing
;
%E     "dosrznrc.mortran"
"       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
"       ===========================================================
"               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
"
"
"                                       1
"
"
"       --------------------------------------------------------- RCYL(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
"       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
"       --------------------------------------------------------- RCYL(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RCYL(2)
"       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
"       --------------------------------------------------------- RCYL(1)
"..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
;"      ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
"
"                                       1
"
"
"
"       VERSION 1       ADAPTED FROM CAVITY HOWFAR          06/84  ERIC FOX
"       VERSION 2       THE SUBROUTINE CALLS TO PLANES AND  10/87  AFB
"                       CYLINDER HAVE BEEN REPLACED BY MACROS
"                       TO SPEED THINGS UP
"
"
"******************************************************************************
;
%E     "start of geometry macros"
"THE MACRO REPLACING THE CALL TO CYLNDR
"*****************************************************************************
"
"                               ***********
"                               *         *
"                               * $CYLNDR *
"                               *         *
"                               ***********
"
"MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
"A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
"OF THE STANDARD NRCC DISTRIBUTION
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT CYLINDERS,
"THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A CYLINDER.
"THE CYLINDERS ARE ASSUMED TO BE ALIGNED AND CENTERED ALONG THE Z-AXIS.
"
"       SOME VARIABLES
"       ==============
"
"{P1} = ICYL  = THE NUMBER OF THE OUTER CYLINDER
"{P2} = IHITC = 1 => PARTICLE HITS THE OUTER SURFACE
"             = 0 => PARTICLE MISSES THE SURFACES
"             =-1 => PARTICLE HITS THE INNER SURFACE
"{P3} = TCYL  = DISTANCE TO SURFACE IF IT HITS
"CYRAD2(ICYL) = RADIUS**2 OF THE OUTER CYLINDER
"
"THIS CODE IS OPTIMIZED FOR SPEED, NOT SIZE.
"
"FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
"FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TCYL=0.
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
"
"
"******************************************************************************
"
REPLACE {$CYLNDR(#,#,#);} WITH {
;
U1=U(NP);V1=V(NP);A=U1*U1+V1*V1;
IF(A.EQ.0.0)[{P2}=0;{P3}=1.0E30;]
ELSE[
    X1=X(NP);Y1=Y(NP);B=X1*U1+Y1*V1;B2=B*B;
    COUT=X1*X1+Y1*Y1-CYRAD2({P1});
    IF(COUT.GT.0.0)[
        IF(IWATCH > 0 & IWATCH < 4 )[OUTPUT COUT;(' COUT=',E11.3);]
        COUT=0.0;
    ]
    IF(B.GT.0.0)[{P2}=1;
        IF(COUT/B2.GT.-1.0E-3)[{P3}=-0.5*COUT/B;]
        ELSE[{P3}=-COUT/(SQRT(B2-A*COUT)+B);]
    ]
    ELSEIF(B.LT.0.0)[{P2}=1;
        IF(COUT/B2.GT.-1.0E-3)[{P3}=-2.*B/A*(1.-0.25*A*COUT/B2);]
        ELSE[{P3}=(SQRT(B2-A*COUT)-B)/A;]
        IF({P1}.NE.1)[
            CIN=X1*X1+Y1*Y1-CYRAD2({P1}-1);
            IF(CIN.LT.0.0)[
                IF(IWATCH > 0 & IWATCH < 4 )[OUTPUT CIN;(' CIN=',E11.3);]
                CIN=0.0;
            ]
            RAD=B2-A*CIN;
            IF(RAD.GE.0.0)[
                {P2}=-1;
                IF(CIN/B2.LT.1.0E-3)[{P3}=-0.5*CIN/B;]
                ELSE[{P3}=CIN/(SQRT(RAD)-B);]
            ]
        ]
    ]
    ELSE[
        {P2}=1;
        {P3}=SQRT(-COUT/A);
    ]
]
;
}

"THE MACRO REPLACING THE CALL TO PLANES
"******************************************************************************
"
"                               ***********
"                               *         *
"                               * $PLANES *
"                               *         *
"                               ***********
"
"PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
"A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
"OF THE STANDARD NRCC DISTRIBUTION
"
"FOR A PARTICLE TRAVELLING INSIDE TWO PARALLEL, INFINITE PLANES WITH NORMALS
"ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
"IT MUST GO TO HIT ONE OF THE PLANES
"
"       SOME VARIABLES
"       ==============
"
"{P1}           =       THE NUMBER OF THE INNER PLANE (LESSER Z-COORDINATE)
"                       IT MUST BE .GE. 1
"{P2}           =       THE NUMBER OF THE OUTER PLANE (GREATER Z-COORDINATE)
"                       IT MUST BE .GE. 2
"{P3} = IHITP   =       1  => PARTICLE HITS THE OUTER PLANE
"               =       0  => PARTICLE MISSES BOTH PLANES
"               =       -1 => PARTICLE HITS THE INNER PLANE
"{P4} = TPLANE  =       DISTANCE TO THE PLANE THAT IT HITS
"ZPLANE(IPLANE) =       Z-COORDINATE OF THE OUTER PLANE
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
"
"
"******************************************************************************
"
REPLACE {$PLANES(#,#,#,#);} WITH {
;
WL=W(NP);
IF (WL.GT.0.0) [{P3}=1;{P4}=(ZPLANE({P2})-Z(NP))/WL;]
ELSEIF (WL.LT.0.0) [{P3}=-1;{P4}=(ZPLANE({P1})-Z(NP))/WL;]
ELSE[{P3}=0;{P4}=1.0E30;]
;
}

%E     "dosrznrc.mortran"
%Q0

SUBROUTINE HOWFAR;

$IMPLICIT-NONE;

;
"MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
REPLACE {$SET NEW REGION(#,#);} WITH {
"       ======================"
;
IF({P1}.LE.USTEP)[
    USTEP={P1};IRNEW={P2};IMSOFF=0;NEWNRC=NWNRCL;
    IF(USTEP=0 & IRNEW~=IROLD) DECISION=1;
]
RETURN
;}

;COMIN/CHARS,EPCONT,GEOM,MISC,NRCNEW,SCORE,STACK/;

$LOGICAL OUTEND,OUTSID;
$INTEGER IQL,IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW,NWNRCL,IMSOFF;
$REAL    WL,TPLANE,TCYL,U1,V1,A,X1,Y1,B,B2,C,COUT,CIN,RAD;

"DISCARD ZERO WEIGHT PARTICLES"
IF(WT(NP).EQ.0.0)[IDISC=1;RETURN;]

OUTEND=.FALSE.;OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"
IQL=IQ(NP);IRL=IR(NP); "LOCAL VARIABLES"

"DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY OR OF THE REGION IS TOTALLY"
"ABSORBING"
IF ((IRL.EQ.1).OR.(CABSRB(IRL).EQ.ACHAR))[IDISC=1;RETURN;]

$GET-IX-IZ(IRL); "GET PLANAR AND CYLINDRICAL ZONES NUMBERS"

"CALCULATE DNEAR"
"Note this is same as $CALL-HOWNEAR-FOR-NRCC-CYLINDRICAL-GEOMETRY(DNEAR(NP))"
"It is redundant if PRESTA is being used since DNEAR is calculated on"
"every step anyway"

$PLANES(IZ,IZ+1,IHITP,TPLANE);"GET DISTANCE TO PLANE"
        "IHITP  =  1 => HITS GREATER Z PLANE"
        "       =  0 => MISSES BOTH PLANES"
        "       = -1 => HITS LESSER Z PLANE"

$CYLNDR(IX,IHITC,TCYL);"GET DISTANCE TO CYLINDER"
"       IHITC   =  1 => HITS OUTER CYLINDER"
"               =  0 => MISSES BOTH CYLINDERS"
"               = -1 => HITS INNER CYLINDER"

IZNEW=IZ+IHITP;                                  "GET NEW PLANAR REGION"
IF((IZNEW.LT.1).OR.(IZNEW.GT.NZ)) OUTEND=.TRUE.; "FLAG IF LEAVES BY THE ENDS"

IXNEW=IX+IHITC;                "GET NEW CYLINDRICAL REGION"
IF(IXNEW.GT.NR) OUTSID=.TRUE.; "FLAG IF LEAVES BY THE SIDES"

"DO MOST PROBABLE CASE FIRST WHERE A PLANE AND A CYLINDER CAN BE HIT"
IF((IHITP.NE.0).AND.(IHITC.NE.0))[
    IF(TPLANE.LT.TCYL)["HITS PLANE FIRST"
        IF(OUTEND)[NWNRCL=0;$SET NEW REGION(TPLANE,1);]
        ELSE[NWNRCL=20-10*IHITP;$SET NEW REGION(TPLANE,IRL+IHITP);]
    ]
    ELSEIF(TCYL.LT.TPLANE)["HITS CYLINDER FIRST"
        IF(OUTSID)[NWNRCL=0;$SET NEW REGION(TCYL,1);]
        ELSE[NWNRCL=30+10*IHITC;$SET NEW REGION(TCYL,IRL+NZ*IHITC);]
    ]
    ELSE["ODD CASE TCYL=TPLANE:HITS PLANE AND CYLINDER TOGETHER"
        IF(OUTEND.OR.OUTSID)[NWNRCL=0;$SET NEW REGION(TCYL,1);]
        ELSE[NWNRCL=20-10*IHITP;$SET NEW REGION(TCYL,IRL+IHITP+NZ*IHITC);]
    ]
]

"DO ODD CASE-PARTICLE CAN HIT PLANE BUT NOT CYLINDER"
ELSEIF(IHITP.NE.0)[
    IF(OUTEND)[NWNRCL=0;$SET NEW REGION(TPLANE,1);]
    ELSE[NWNRCL=20-10*IHITP;$SET NEW REGION(TPLANE,IRL+IHITP);]
]

"DO ODD CASE-PARTICLE CAN HIT CYLINDER BUT NOT PLANE"
ELSE[
    IF(OUTSID)[NWNRCL=0;$SET NEW REGION(TCYL,1);]
    ELSE[NWNRCL=30+10*IHITC;$SET NEW REGION(TCYL,IRL+NZ*IHITC);]
]

"AT THIS STAGE ALL GEOMETRICAL POSSIBILITIES HAVE BEEN CHECKED AND CONTROL"
"HAS ALREADY BEEN TRANSFERRED TO EGS"

END; "END OF SUBROUTINE HOWFAR"
%I4
%C80
%Q1
%E     "start of subroutine INPUTS"

"******************************************************************************
"
"
"                               **************
"                               *            *
"                               * INPUTS.MOR *
"                               *            *
"                               **************
"
"
"       AN INPUT FILE USED WITH DOSRZ. THE INPUTS ARE DEFINED AS THEY ARE
"       INPUT. CONSIDERABLE DEFAULTING AND ERROR CHECKING IS DONE.
"
"       VERSION 1       E.F.    7/84            ADAPTED FROM CAVITY
"       VERSION 2       A.M.    4/98            NEW INPUT ROUTINE(GET_INPUTS)
"       VERSION 3       IK      1/00         Deleted unnecessary input
"                                            and changed mc transport parameter
"                                            to be handled in a seprate routine
"                                            (get_transport_parameter)
;
"******************************************************************************
"
SUBROUTINE INPUTS;

$IMPLICIT-NONE;

"DECLERATION OF COMIN BLOCKS
"***************************
;COMIN/BOUNDS,
CHARS,EDGE,ELECIN,GEOM,IODAT1,IODAT2,MEDIA,MISC,PLOTC,
RUSROU,SCORE,SOURCE,SPECTR,USEFUL,USER,RANDOM,GetInput,ET-Control,
COMPTON-DATA,BREMPR,EGS-VARIANCE-REDUCTION,EGS-IO/;

"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"

"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"
$INTEGER INEXT;

$INTEGER MODEIN;                       "source input"
$REAL TEMP1,TEMP2,TEMP3,TEMP4;         "source input"

$INTEGER IFLUOR;                       "transport control"
$INTEGER IZ, IREGLO, IREGHI;           "transport control"
$INTEGER IESTEP;                       "transport control"
$REAL ESTEP, SMAX;                     "transport control"
$REAL FESTEP;                          "transport control"

$REAL ADDING;
$INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM, lux_level;

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
$INTEGER NUM_TITLE,

"I/O Contol"
        NUM_IWATCH,
        NUM_STRAND,
        NUM_IRESTART ,
        NUM_OUTOPTS,
        NUM_STORE,
        NUM_ETRANS,
        NUM_DZMIN,
        NUM_DZMAX,
        NUM_DRMIN,
        NUM_DRMAX,

"M-C Input"
        NUM_HIST,
        NUM_SEEDS,
        NUM_MXTIME,
        NUM_IFULL,
        NUM_STATLM,
        NUM_SCKERMA,
        NUM_BREMDST,

"Pulse height distribution"
        NUM_REGSVOL,
        NUM_SLOTE,
        NUM_DELTAE,
        NUM_TOPEBIN,

"Tranport Control"
        NUM_ESTEPE,
        NUM_SMAX,
        NUM_ECUT,
        NUM_PCUT,
        NUM_RAYLEIGH,
        NUM_IREJCT,
        NUM_HOWFAR,
        NUM_ESAVEIN,
        NUM_IFLUOR,
        NUM_FLUIZ,
        NUM_FREGSTART,
        NUM_FREGSTOP,
        NUM_RRPARAM,
        NUM_RRMINPL,
        NUM_RRMAXPL,
        NUM_RRMINRA,
        NUM_RRMAXRA,
        NUM_RUSROU,
        NUM_RUSFRAC,
        NUM_XTRANSF,
        NUM_FORCE,
        NUM_STRTFRC,
        NUM_STPFRC,
        NUM_NESTEP,
        NUM_NSMAX,
        NUM_ADJEREG,
        NUM_ADJSLREG,
        NUM_ADJUSTED,
        NUM_NENH,
        NUM_NENHLO,
        NUM_NENHHI,
        NUM_FRAKESTEP,
        num_compton,i_bound_compton,
        num_pe_ang,i_pe_ang,num_spin,i_spin,

"variance reduction"
        NUM_BREMSPLIT,
        NUM_BREMPEVEN,
        NUM_I_PLAY_RR;

$REAL   EPHTOP,fsmax;
$INTEGER IPK,JJ,ii,ics_start,ics_stop,ismax,ib,it,itmax,ix;

$INTEGER egs_open_datfile, data_unit; "IK: using explicit file names"

"---------------------------------------------------------------------------"
IVAL=0;  "number of the value_sought"

ERROR_FLAG=0;   "Initialization of bad input flag"

DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"

OUTPUT; (//' DOSRZnrc(EGSnrc) '$VERSION' ON '$MACHINE' '/)

"*********************************************************"
"* set up the VALUES_SOUGHT(IVAL) and echo inputs to screen *"
"*********************************************************"
"*********"
"* TITLE *"
"*********"
IVAL=IVAL+1;
NUM_TITLE=IVAL;
VALUES_SOUGHT(IVAL)='TITLE';
TYPE(IVAL)=2;
NVALUE(IVAL)=1;

DELIMETER='NONE';
$GET_INPUT(NUM_TITLE);

$SKIP-LINE;$SKIP-LINE;
OUTPUT;(' *** INPUT CARD I01 ***');
READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
WRITE (*,:FMT:) (TITLE(I),I=1,79);
:FMT: FORMAT ('TITLE: ',79A1);
$SKIP-LINE;

"********************************************************************"
"* INPUT/OUTPUT CONTROL *"
"************************"

DELIMETER='I/O CONTROL';

IVAL=IVAL+1;
NUM_IWATCH=IVAL;
VALUES_SOUGHT(IVAL)='IWATCH';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='INTERACTIONS';
ALLOWED_INPUTS(IVAL,2)='STEPS';
ALLOWED_INPUTS(IVAL,3)='DEPOSITED';
ALLOWED_INPUTS(IVAL,4)='GRAPH';

IVAL=IVAL+1;
NUM_STRAND=IVAL;
VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='LAST';
ALLOWED_INPUTS(IVAL,2)='ALL';

IVAL=IVAL+1;
NUM_IRESTART =IVAL;
VALUES_SOUGHT(IVAL)='IRESTART';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='FIRST';
ALLOWED_INPUTS(IVAL,1)='RESTART';
ALLOWED_INPUTS(IVAL,3)='ANALYZE';
ALLOWED_INPUTS(IVAL,4)='START-RNS';
ALLOWED_INPUTS(IVAL,5)='PARALLEL';

IVAL=IVAL+1;
NUM_OUTOPTS=IVAL;
VALUES_SOUGHT(IVAL)='OUTPUT OPTIONS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='SHORT';
ALLOWED_INPUTS(IVAL,1)='DOSE SUMMARY';
ALLOWED_INPUTS(IVAL,2)='MATERIAL SUMMARY';
ALLOWED_INPUTS(IVAL,3)='MATERIAL AND DOSE SUMMARY';
ALLOWED_INPUTS(IVAL,4)='LONG';

IVAL=IVAL+1;
NUM_STORE=IVAL;
VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='YES';
ALLOWED_INPUTS(IVAL,1)='NO';

IVAL=IVAL+1;
NUM_ETRANS=IVAL;
VALUES_SOUGHT(IVAL)='ELECTRON TRANSPORT';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NORMAL';
ALLOWED_INPUTS(IVAL,1)='NO INTERACTIONS';

IVAL=IVAL+1;
NUM_DZMIN=IVAL;
VALUES_SOUGHT(IVAL)='DOSE ZBOUND MIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=1;
VALUE_MAX(IVAL)=$MAXZREG;
DEFAULT(IVAL)=1;

IVAL=IVAL+1;
NUM_DZMAX=IVAL;
VALUES_SOUGHT(IVAL)='DOSE ZBOUND MAX';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=2;
VALUE_MAX(IVAL)=$MAXZREG+1;
DEFAULT(IVAL)=$MAXZREG+1;   "Actual default set below GEOMRZ.MORTRAN"

IVAL=IVAL+1;
NUM_DRMIN=IVAL;
VALUES_SOUGHT(IVAL)='DOSE RBOUND MIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=$MAXRADII-1;
DEFAULT(IVAL)=0;

IVAL=IVAL+1;
NUM_DRMAX=IVAL;
VALUES_SOUGHT(IVAL)='DOSE RBOUND MAX';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=1;
VALUE_MAX(IVAL)=$MAXRADII;
DEFAULT(IVAL)=$MAXRADII;    "Actual default set below GEOMRZ.MORTRAN"

"********************************************************************"
DELIMETER='I/O CONTROL';
$GET_INPUTS(NUM_IWATCH,NUM_DRMAX);
"********************************************************************"

OUTPUT;(' *** INPUT CARD IO2 ***');
IWATCH=VALUE(NUM_IWATCH,1);
ISTORE=VALUE(NUM_STRAND,1);
IRESTART =VALUE(NUM_IRESTART ,1);
IOOPTN=VALUE(NUM_OUTOPTS,1);
IDAT=VALUE(NUM_STORE,1);
ICSDA=VALUE(NUM_ETRANS,1);
NZDMIN=VALUE(NUM_DZMIN,1);
NZDMAX=VALUE(NUM_DZMAX,1);
NRDMIN=VALUE(NUM_DRMIN,1);
NRDMAX=VALUE(NUM_DRMAX,1);
NZDOSE=NZDMAX-NZDMIN;
NRDOSE=NRDMAX-NRDMIN;
OUTPUT IWATCH,ISTORE,IRESTART ,IOOPTN,IDAT,ICSDA;
  ( /
' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T72,I4/
' DO NOT STORE(0) OR STORE(1,2) INITIAL RANDOM #s:',T72,I4/
' FIRST RUN(0),RESTARTED(1),ANALYZE(3),start-RNS(4),parallel(5):',
    T72,I4/
' OUTPUT OPTION (1 THRU 4):',T72,I4/
' STORE DATA(0) OR NOT(1):',T72,I4/
' CSDA CALCULATION(1) OR NOT(0)':,T72,I4/);
OUTPUT ;(/' ******DOSE SCORING BOUNDARIES******');
OUTPUT NZDMIN,NZDMAX,NRDMIN,NRDMAX;
(' NZDMIN,NZDMAX,NRDMIN,NRDMAX: ',3(I5,','),I5/);
$SKIP-LINE;

IF(IDAT.EQ.1)[INEXT=0;]ELSE[INEXT=1;]
IF(IRESTART .EQ.4) [
    IDAT=1;   "DO NOT STORE OUTPUT IN THIS CASE TO AVOID BIASING"
    ISTORE=0; "DO NOT STORE THE STARTING RANDOM NUMBERS EITHER"
]

"                       MONTE CARLO CONTROL INPUT
"                       *************************
IVAL=IVAL+1;
NUM_HIST=IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=1;
VALUE_MAX(IVAL)=4.611686e18;; "This is the largest integer handled=2^62"
DEFAULT(IVAL)=20000;

IVAL=IVAL+1;
NUM_MXTIME=IVAL;
VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=1000;
DEFAULT(IVAL)=999.;

IVAL=IVAL+1;
NUM_IFULL=IVAL;
VALUES_SOUGHT(IVAL)='IFULL';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='DOSE AND STOPPERS';
ALLOWED_INPUTS(IVAL,1)='ENTRANCE REGIONS';
ALLOWED_INPUTS(IVAL,2)='PULSE HEIGHT DISTRIBUTION';
ALLOWED_INPUTS(IVAL,3)='SCATTER FRACTION';
ALLOWED_INPUTS(IVAL,4)='OFMET Fricke';  "To score quantities of interest"
                                        "for the OFMET Fricke experiments"
                                        "e.g. brems loss, backscatter loss etc"

IVAL=IVAL+1;
NUM_STATLM=IVAL;
VALUES_SOUGHT(IVAL)='STATISTICAL ACCURACY SOUGHT';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0;
VALUE_MAX(IVAL)=100.0;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_SCKERMA=IVAL;
VALUES_SOUGHT(IVAL)='SCORE KERMA';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='YES';

"********************************************************************"
DELIMETER='MONTE CARLO INPUTS';
$GET_INPUTS(NUM_HIST,NUM_SCKERMA);
"********************************************************************"

$RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',ixxin,jxxin);
IF( i_parallel > 0 ) jxxin = jxxin - 1 + i_parallel;


$INITIALIZE RNG USING ixxin AND jxxin;

"************"
"* CARD MC1 *"
"************"
OUTPUT;(/,' *** INPUT CARD MC1 ***');
NCASE=VALUE(NUM_HIST,1);
TIMMAX=VALUE(NUM_MXTIME,1);
IFULL=VALUE(NUM_IFULL,1);
STATLM=VALUE(NUM_STATLM,1);
IKERMA=VALUE(NUM_SCKERMA,1);
BEFORE_PHOTO=0;
BEFORE_EII=0;

IF(IWATCH=0 & NCASE < $NCASEMIN)[NCASE=$NCASEMIN;]

OUTPUT NCASE,IXXIN,JXXIN,TIMMAX,IFULL,STATLM,IKERMA;
    ( / ' # OF HISTORIES:',T60,I12/
     $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
    ' MAXIMUM CPU TIME ALLOWED:'      ,T60,F10.2,'HRS'/
    ' SCORING OPTION IFULL (0,1,2,3):'  ,T60,I12/
    ' STATISTICAL ACCURACY DESIRED:'  ,T60,F10.4,'%'/
    ' KERMA WILL(1) or WILL NOT(0) be scored:',T60,I2);


IF (ERROR_FLAG=1) [GOTO :FINISHED:;]

"                CYLINDRICAL GEOMETRY AND MATERIAL INPUT
"                ***************************************
"EXECUTED FROM SUBROUTINE GEOMRZ(ERROR_FLAG)"

CALL GEOMRZ;

IF(NMED>$MXMED)[
   OUTPUT $MXMED;(//' *****************ERROR******************'/
                    ' No. of media > max. no. of media allowed (',I4,')'/
                    ' Increase $MXMED in srcrznrc.mortran, recompile'/
                    ' and try again.'//);
   ERROR_FLAG=1;
]

IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMRZ************';
   GOTO :FINISHED:;
]

"Actual defaults for dose boundaries are set here"

"-------------------------------------------------------------"
"- Check for valid minimum scoring plane/cylinder number added"
"- Output values in case they have to  be reset               "

"                                              EMH, 22/03/2002"
"-------------------------------------------------------------"
IF ( NZDMAX > NZ+1 ) [
    NZDMAX=NZ+1;
    OUTPUT NZDMAX;(/'===> MAX. SCORING PLANE # RESET TO: ',I6);
]
IF ( NZDMIN >= NZDMAX ) [
     NZDMIN = NZDMAX -1;
     OUTPUT NZDMIN;(/'===> MIN. SCORING PLANE # RESET TO: ',I6);
]

IF ( NRDMAX > NR ) [
     NRDMAX=NR;
     OUTPUT NRDMAX;(/'===> MAX. SCORING CYLINDER # RESET TO: ',I6);
]
IF ( NRDMIN >= NRDMAX ) [
     NRDMIN = NRDMAX -1;
     OUTPUT NRDMIN;(/'===> MIN. SCORING CYLINDER # RESET TO: ',I6);
]
"-------------------------------------------------------------"
"with the above checks: "
"NZDMIN will never be < 1 since NZDMAX is never < 2"
"NRDMIN will never be < 0 since NRDMAX is never < 1"
"-------------------------------------------------------------"

NZDOSE=NZDMAX-NZDMIN;
NRDOSE=NRDMAX-NRDMIN;

IF (NZDOSE>$PLTDIM)[
   $egs_warning('(a,i5/,a,i5/,a/,a)',
   'INPUTS: Number of dose scoring slab regions NZDOSE =',NZDOSE,
   'is larger than plotting arrays size $PLTDIM = ',$PLTDIM,
   'Setting NZDOSE to $PLTDIM.',
   'You can reset $PLTDIM in dosrznrc.mortran.');
   NZDOSE=$PLTDIM;
]
IF (NRDOSE>$PLTDIM)[
   $egs_warning('(a,i5/,a,i5/,a/,a)',
   'INPUTS: Number of dose scoring cyl. regions NRDOSE =',NRDOSE,
   'is larger than plotting arrays size $PLTDIM = ',$PLTDIM,
   'Setting NZDOSE to $PLTDIM.',
   'You can reset $PLTDIM in dosrznrc.mortran.');
   NRDOSE=$PLTDIM;
]

"                 PULSE HEIGHT DISTRIBUTION INPUT
"                 *******************************
IF(IFULL.EQ.2)[
    OUTPUT;(/' INPUT FOR PULSE HEIGHT DISTRIBUTION'/);
    "INITIALIZE FLAGS TO NO PULSE HEIGHT DISTRIBUTION IN EACH REGION"
    DO J=1,NREG [IPHR(J)=0;]

   "**************************"
   "* CARD PHD1 (IF IFULL=2) *"
   "**************************"
   IVAL=IVAL+1;
   NUM_REGSVOL=IVAL;
   VALUES_SOUGHT(IVAL)='REGION OF SENSITIVE VOLUME';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=1;
   VALUE_MAX(IVAL)=NREG;
   DEFAULT(IVAL)=NREG;

   "*************"
   "* CARD PHD2 *"
   "*************"
   IVAL=IVAL+1;
   NUM_SLOTE=IVAL;
   VALUES_SOUGHT(IVAL)='SLOTE';
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=-10000.0;
   VALUE_MAX(IVAL)=10000.0;
   DEFAULT(IVAL)=1.25;

   IVAL=IVAL+1;
   NUM_DELTAE=IVAL;
   VALUES_SOUGHT(IVAL)='DELTAE';
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=1.e-20;
   VALUE_MAX(IVAL)=100000.0;
   DEFAULT(IVAL)=0.005;

   "********************************************************************"
   DELIMETER='PULSE HEIGHT DISTRIBUTION INPUT';
   $GET_INPUTS(NUM_REGSVOL, NUM_DELTAE);
   "********************************************************************"

   OUTPUT;(/' *** INPUT CARD PHD1 ***'/);
   DO J=1, NVALUE(NUM_REGSVOL) [
      REGNUM=VALUE(NUM_REGSVOL,J);
      IPHR(REGNUM)=1;
      OUTPUT REGNUM,MED(REGNUM); (/T10,' REGION',I4,'  HAS MEDIUM',I3);
   ]
   $SKIP-LINE;

   OUTPUT;(/' *** INPUT CARD PHD2 ***'/);
   SLOTE=VALUE(NUM_SLOTE,1);
   DELTAE=VALUE(NUM_DELTAE,1);
   IF (SLOTE > 0.0) [
        OUTPUT SLOTE,SLOTE*dble($EBIN);
        (/' EQUAL BINS OF',F10.4,' MeV WILL COVER UP TO',F10.3,' MeV');
        "NOTE THAT LATER, WHEN WE KNOW THE MAXIMUM ENERGY IN THE"
        "INPUT SPECTRUM, WE WILL INCREASE SLOTE TO MAKE SURE IT WORKS"
   ]
   ELSE [  "SLOTE <= 0.0 means we input energy bins"
      IVAL=IVAL+1;
      NUM_TOPEBIN=IVAL;
      VALUES_SOUGHT(IVAL)='TOPS OF ENERGY BINS';
      TYPE(IVAL)=1;
      VALUE_MIN(IVAL)=1.e-20;
      VALUE_MAX(IVAL)=100000.0;
      DEFAULT(IVAL)=1.25;
      $GET_INPUT(NUM_TOPEBIN);
      DO J=1, NVALUE(NUM_TOPEBIN) [BINTOP(J)=VALUE(NUM_TOPEBIN,J);]
      MAXBIN = NVALUE(NUM_TOPEBIN);

      IF (NVALUE(NUM_TOPEBIN) > $EBIN+1) [
         OUTPUT $EBIN;
         (/' ****Tried to use more than max number of energy bins ',I5/
         '     Either increase $EBIN or reduce number of bins');
         STOP;
      ]
      OUTPUT NVALUE(NUM_TOPEBIN),(BINTOP(J),J=1,NVALUE(NUM_TOPEBIN));
      (/' READ A TOTAL OF',I4,' ENERGY BINS'/ (5F15.4) );
   ]

    "used to DO SOME CHECKS ON PULSE HEIGHT DISTRIBUTION BINS here"
    "but these failed since didn't know EIN yet!  DR"
] "end of IFULL=2 block"

"                       SOURCE CONFIGURATION INPUT
"                       **************************
"************"
"* CARD SC1 *"
"************"
"EXECUTED FROM SUBROUTINE SRCRZ(ERROR_FLAG)"
CALL SRCRZ;  "Get source data"
CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0);
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************';
   GOTO :FINISHED:;
]


"************
"* CARD TC1 *"
"************"
"EXECUTED FROM SUBROUTINE ENSRC(ERROR_FLAG)"
IF (ISOURC=21.OR.ISOURC=22.OR.ISOURC=23) [MONOEN=0;]
  "no need to input monoen for source 21,22,23"
ELSE [CALL ENSRC;] "Get data re-source energies"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
   GOTO :FINISHED:;
]

$SKIP-LINE;
IF(IFULL = 3 & IQIN ~= 0)[ "only allow option 3 for pure photon beam"
"                           could modify for full phase space if needed"
   OUTPUT;
   (// 1x,70('@')/'  Changed IFULL to 0 from 3 since photon beam not input');
   IFULL = 0;
]

IF(IFULL=2)["for pulse height distribution"
    "DO SOME CHECKS ON PULSE HEIGHT DISTRIBUTION BINS"
    IF(IQIN.EQ.1)[EPHTOP=EIN+1.022;"INCLUDE ANNIHILATION FOR POSITRONS IN"]
    ELSE[EPHTOP=EIN;]
    IF(SLOTE.GT.0.0)[
        UNTIL(SLOTE*dble($EBIN).GT.1.05*EPHTOP)[
            SLOTE=SLOTE*2.;
            OUTPUT SLOTE;
            (/' ***HAVE DOUBLED SLOTE TO',F12.4,
            ' MeV TO REACH MAXIMUM INPUT ENERGY');
            ]
        MAXBIN=int(1.05*EPHTOP/SLOTE+0.999);
        OUTPUT MAXBIN;(/' MAXBIN set to',I5,' to cover spectrum'/);
        ] "end of SLOTE>0 block"
    ELSE[
        IF(BINTOP(MAXBIN).LE.EPHTOP)[
            OUTPUT MAXBIN,EPHTOP;
            (/' ***CHANGED BINTOP(',I3,') TO REACH', F10.3,' MeV***');
            BINTOP(MAXBIN)=EPHTOP;
            ]
        ]"end SLOTE<=0 block"

    "Set up energy bins for peak efficiency calculation"
    "This only makes sense if beam is monoenergetic"
    DFEN(1,2)=EPHTOP-DELTAE;DFEN(2,2)=DFEN(1,2)-PRM;
    DFEN(3,2)=DFEN(1,2)-1.022;DFEN(4,2)=PRM-DELTAE;
    "I.E. WE SET LOWER ENERGIES FOR FULL ENERGY, SINGLE ESCAPE, DOUBLE"
    "ESCAPE AND THE 511 KEV LINE"
    DO IPK = 1,4 [
        DFEN(IPK,1) = DFEN(IPK,2) - DELTAE;
        DFEN(IPK,3) = DFEN(IPK,2) +2*DELTAE;
        DFEN(IPK,4) = DFEN(IPK,3) +DELTAE;
    ]
]"end of pulse height dist'n block"

"
"      Start of inputs for transport control delimeter
"      ===============================================

call get_transport_parameter(6); " This will scan the input file for
                                 " transport parameter input and then
                                 " output all settings to unit 6


"*************************************************************************"
"                variance reduction section                               "
"*************************************************************************"

IVAL = IVAL + 1;
NUM_BREMSPLIT = IVAL;
VALUES_SOUGHT(IVAL)='BREM SPLITTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL = IVAL + 1;
NUM_BREMPEVEN = IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF BREMS PER EVENT';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=$MAXBRSPLIT;
DEFAULT(IVAL)=$MAXBRSPLIT;

IVAL = IVAL + 1;
NUM_I_PLAY_RR = IVAL;
VALUES_SOUGHT(IVAL)='CHARGED PARTICLE RUSSIAN ROULETTE';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_IREJCT=IVAL;
VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';


IVAL=IVAL+1;
NUM_ESAVEIN=IVAL;
VALUES_SOUGHT(IVAL)='ESAVEIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.;
VALUE_MAX(IVAL)=EIN+PRM;  "EIN is max k.e. of particles set in "
                         "srcrz for ISOURC 21,22 and ine ensrc for the others"
DEFAULT(IVAL) =EIN+PRM;  "This means that if a too high number "
                            "is input, it is reduced to the max needed."

"********************************************************************"
DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_BREMSPLIT,NUM_ESAVEIN);
"********************************************************************"

IBRSPL=VALUE(NUM_BREMSPLIT,1);
nbr_split =VALUE(NUM_BREMPEVEN,1);
IF(IBRSPL = 1)["brems splitting requested"
    "default bremsstrahlung splitting to maximum"
    "IF((nbr_split  <= 0) | (nbr_split  > $MAXBRSPLIT)) nbr_split =$MAXBRSPLIT;"
    "Changed to allow brem and annihilation radiation to be turned off"
    IF((nbr_split  > $MAXBRSPLIT)) nbr_split =$MAXBRSPLIT;"
]
ELSE ["no bremsstrahlung splitting" nbr_split = 1;]
"note the above is needed since BREMS only checks nbr_split, not IBRSPL"

I_PLAY_RR=VALUE(NUM_I_PLAY_RR,1);
IF(I_PLAY_RR=1)[PROB_RR=1./dble(nbr_split);]
ELSE[PROB_RR=1.;]

IREJCT=VALUE(NUM_IREJCT,1);  "note IREJCT and ESAVE are defined in USERRR"
ESAVEIN=VALUE(NUM_ESAVEIN,1);
IF(IREJCT = 1 )[ "set parameters for all regions"
   DO ii = 1,$MXREG [
       i_do_rr(ii) = 1;
       e_max_rr(ii) = ESAVEIN;
   ]
]

OUTPUT IBRSPL,nbr_split,I_PLAY_RR,PROB_RR,IREJCT,ESAVEIN;
(
    /
    ' BREMSSTRAHLUNG SPLITTING OFF(0) OR ON(1):'          ,T60,I12/
    ' EACH BREMSSTRAHLUNG SPLIT INTO:'                    ,T60,I12//
    ' CHARGED PARTICLE RUSSIAN ROULETT OFF(0) OR ON(1):'  ,T60,I12/
    ' PROBABILITY OF SURVIVAL:'                           ,T60,F10.4//
    ' WITHOUT(0) OR WITH(1) RANGE REJECTION:'             ,T60,I12/
    ' ESAVEIN CUTOFF VALUE FOR regional RANGE REJECTION :' ,T60,F10.4,' MeV'/

);

IF(IFULL=2 & nbr_split > 1)[ "cannot have this"
   OUTPUT;(//' ****WARNING****'/
            ' You cannot calculate a pulse height distribution with'/
            ' bremsstrahlung splitting on.  Will run simulation with'/
            ' IFULL= dose and stoppers'//);
   WRITE(1,'(//'' ****WARNING****''/
            ''You cannot calculate a pulse height distribution with''/
            '' bremsstrahlung splitting on.  Will run simulation with''/
            '' IFULL= dose and stoppers''//)');
   IFULL=0;
]


IVAL=IVAL+1;
NUM_RUSROU=IVAL;
VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e10;
VALUE_MAX(IVAL)=1.e10;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_RUSFRAC=IVAL;
VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e10;
VALUE_MAX(IVAL)=1.e10;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_XTRANSF=IVAL;
VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e10;
VALUE_MAX(IVAL)=1.e10;
DEFAULT(IVAL)=0.0;

"********************************************************************"
DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_RUSROU,NUM_XTRANSF);
"********************************************************************"

"*************"
"* CARD TC2C *"
"*************"
OUTPUT;(' *** INPUT CARD TC2C ***');
RRZ=VALUE(NUM_RUSROU,1);
RRCUT=VALUE(NUM_RUSFRAC,1);
CEXPTR=VALUE(NUM_XTRANSF,1);
RUSROU=.FALSE.;IF(RRZ+RRCUT.NE.0.0)RUSROU=.TRUE.;
IF(RUSROU)[
    OUTPUT RRZ,RRCUT;
    (/' RUSSIAN ROULETTE WILL BE PLAYED'/
    ' RUSSIAN ROULETTE PLANE:',T30,E14.7/
    ' SURVIVAL PROBABILITY:',T30,E14.7/)
]
ELSE [OUTPUT;(' RUSSIAN ROULETTE WILL NOT BE PLAYED'/);]
IF (CEXPTR.EQ.0) [OUTPUT;(' NO PATHLENGTH BIASING TO BE DONE'/);]
ELSE [OUTPUT CEXPTR;(' CEXPTR PARAMATER:',T30,E14.7/);]

IF(IFULL=2 & RUSROU)[
   OUTPUT;(//' ****WARNING****'/
            ' You cannot calculate a pulse height distribution with'/
            ' Russian Roulette on.  Will run simulation with'/
            ' IFULL= dose and stoppers'//);
   WRITE(1,'(//'' ****WARNING****''/
            '' You cannot calculate a pulse height distribution with''/
            '' Russian Roulette on.  Will run simulation with''/
            '' IFULL= dose and stoppers''//)');
   IFULL=0;
]
IF(IFULL=2 & CEXPTR~=0)[
   OUTPUT;(//' ****WARNING****'/
            ' You cannot calculate a pulse height distribution with'/
            ' pathlength biasing.  Will run simulation with'/
            ' IFULL= dose and stoppers'//);
   WRITE(1,'(//'' ****WARNING****''/
            '' You cannot calculate a pulse height distribution with''/
            '' pathlength biasing.  Will run simulation with''/
            '' IFULL= dose and stoppers''//)');
   IFULL=0;
]

IVAL=IVAL+1;
NUM_FORCE=IVAL;
VALUES_SOUGHT(IVAL)='PHOTON FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
DEFAULT(IVAL)=0;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_STRTFRC=IVAL;
VALUES_SOUGHT(IVAL)='START FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

IVAL=IVAL+1;
NUM_STPFRC=IVAL;
VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(NUM_STPFRC)=0;
VALUE_MAX(NUM_STPFRC)=NREG+1;
DEFAULT(NUM_STPFRC)=1;

"********************************************************************"
DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_FORCE,NUM_STPFRC);
"********************************************************************"

"************"
"* CARD TC3 *"
"************"
OUTPUT;(' *** INPUT CARD TC3 ***');
IFORCE=VALUE(NUM_FORCE,1);
NFMIN=VALUE(NUM_STRTFRC,1);
NFMAX=VALUE(NUM_STPFRC,1);
IF(IFORCE.EQ.0) [
    "NFMIN=0;NFMAX=0;"
    OUTPUT;(/' NO INTERACTION FORCING IS IN EFFECT'/);
]
ELSE [
    IF (NFMAX.LT.NFMIN) NFMAX=NFMIN;
    OUTPUT NFMIN,NFMAX;
    (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
    ' # INTERACTIONS'/);
]

IF(IFULL=2 & (NFMAX>NFMIN | NFMIN>1))[
   OUTPUT;(//' ****WARNING****'/
            ' You cannot calculate a pulse height distribution with'/
            ' more than 1 interaction forced or if the forced interaction'/
            ' is > the first interaction.  Will run simulation with'/
            ' IFULL= dose and stoppers'//);
   WRITE(1,'(//'' ****WARNING****''/
            '' You cannot calculate a pulse height distribution with''/
            '' more than 1 interaction forced or if the forced interaction''/
            '' is > the first interaction.  Will run simulation with''/
            '' IFULL= dose and stoppers''//)');
   IFULL=0;
]

$SKIP-LINE;

IVAL=IVAL+1;
NUM_NENH=IVAL;
VALUES_SOUGHT(IVAL)='CS ENHANCEMENT FACTOR';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=1.0;
VALUE_MAX(IVAL)=10000.0;
DEFAULT(IVAL)=200.0;

IVAL = IVAL + 1;
NUM_NENHLO = IVAL;
VALUES_SOUGHT(IVAL)='CS ENHANCEMENT START REGION';
NVALUE(IVAL)=0;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

IVAL = IVAL + 1;
NUM_NENHHI = IVAL;
VALUES_SOUGHT(IVAL)='CS ENHANCEMENT STOP REGION';
NVALUE(IVAL)=0;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

"********************************************************************"
$GET_INPUTS(NUM_NENH,NUM_NENHHI);
"********************************************************************"

cs_enhance = VALUE(NUM_NENH,1);

DO jj=1,NREG [iefl(jj)=0;]
DO ii=1,NVALUE(NUM_NENHLO) [
 ics_start=VALUE(NUM_NENHLO,ii);
 ics_stop=VALUE(NUM_NENHHI,ii);
 DO jj=ics_start,ics_stop [ iefl(jj)=1;]
]
COUNT=0;
DO jj=2,NREG[COUNT = COUNT + iefl(jj);]
"We don't care about region 1 since outside geometry"
IF(COUNT > 0 & (cs_enhance > 1.0001) ) ["there is enhancement somewhere"
   OUTPUT; ('Cross section enhancement in regions ');
   OUTPUT (iefl(jj),jj=1,NREG); (20 I4);
   OUTPUT cs_enhance;
            ( ' Cross section enhancement factor: ',T60,F6.1/);
   ics_enhance = 1;
]
ELSE [
  OUTPUT; (' No cross section enhancement');
  ics_enhance = 0; ]

IF(IFULL=2 & ics_enhance=1)[
   OUTPUT;(//' ****WARNING****'/
            ' You cannot calculate a pulse height distribution with'/
            ' cross section enhancement.  Will run simulation with'/
            ' IFULL= dose and stoppers'//);
   WRITE(1,'(//'' ****WARNING****''/
            '' You cannot calculate a pulse height distribution with''/
            '' cross section enhancement.  Will run simulation with''/
            '' IFULL= dose and stoppers''//)');
   IFULL=0;
]

"                       PLOTTING CONTROLS
"                       *****************

"INPUT CARDS FOR PLOTTING ROUTINE
CALL PLOTSN;


IF (ERROR_FLAG=1) [GOTO :FINISHED:;]
"
"                        SCORING ARRAY INITIALISATION
"                        ****************************
"

"CALCULATE THE NUMBER OF DOSE COMPONENTS"
IF((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))[ITMAX=2;]
ELSE[ITMAX=$MAXIT;]

NCASEO=0;NCASET=0;TMCPUO=0;

IF(IRESTART.EQ.0.OR.IRESTART.EQ.5)[ "0-FRESH START, SET EVERYTHING TO"
    "ZERO OR 5- INITIALIZE ALL ARRAYS TO 0 FOR PARALLEL POST-PROCESSING"

    NNREAD=0; "have not read any particles from phase space source"

    SCSTP=0; SCSTP2=0; SCSTP_TMP=0; SCSTP_LAST=0;
    SCDSTP=0; SCDSTP2=0; SCDSTP_TMP=0; SCDSTP_LAST=0;
    PIISTP=0;

    DO IT=1,ITMAX[
         DO IX=1,NR[
             DO IZ=1,NZ[
                  SCDOSE(IZ,IX,IT)=0.0;
                  SCDOSE2(IZ,IX,IT)=0.0;
                  SCDOSE_TMP(IZ,IX,IT)=0.0;
                  SCDOSE_LAST(IZ,IX,IT)=0;
                  IF(IKERMA=1)[
                     SCKERMA(IZ,IX,IT)=0.0;
                     SCKERMA2(IZ,IX,IT)=0.0;
                     SCKERMA_TMP(IZ,IX,IT)=0.0;
                     SCKERMA_LAST(IZ,IX,IT)=0;
                     SCDOSEtoKERMA2(IZ,IX,IT)=0.0;
                  ]
             ]
         ]
    ]
    IF(IFULL=2)[
         DO IB=1,MAXBIN[
            SCPDST(IB)=0.0;
            SCPDST2(IB)=0.0;
            SCPCUM(IB)=0.0;
            SCPCUM2(IB)=0.0;
         ]
         DO IPK=1,4[
            SCDFEP(IPK)=0.0;
            SCDFEP2(IPK)=0.0;
            SCDFBK(IPK)=0.0;
            SCDFBK2(IPK)=0.0;
            SCDFDIFF(IPK)=0.0;
            SCDFDIFF2(IPK)=0.0;
         ]
         SCPTOT=0.0;
         SCPTOT2=0.0;
         SCPDST_LAST=0;
    ]
] "END OF IRESTART =0 OR 5"

ELSEIF(IRESTART.EQ.4)[ "retrieve random numbers from .egsrns file"
    OUTPUT;(/' Will READ RANDOM NUMBER PARAMETERS FROM UNIT 2:');
]

ELSE[
    "RESTART OR STATS ANALYSIS ONLY, READ OLD DATA FROM UNIT 4"
    "OPEN UNIT 4 AS AN OLD FILE"
    OUTPUT;(/' ***START READING DATA FILE from PREVIOUS RUN***'/);
    "IK: we don't wont ro rely upon a symbolic link to the .egsdat file "
    "    to have been made for us before running dosrznrc. "
    "    We therefore open the .egsdat file using a file name. "
    "    The egs_open_datfile function opens the file named output_file.egsdat"
    "    (or input_file.egsdat) where output_file and input_file are the "
    "    command line arguments to the -o and -i options."
    "OPEN(UNIT=4,file='fort.4',STATUS='OLD');"
    data_unit = egs_open_datfile(4,0,1,'.egsdat');
    READ(data_unit,*,END=:EOFA:)SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
    READ(data_unit,*,END=:EOFA:)
                (((SCDOSE(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
    READ(data_unit,*,END=:EOFA:)
                (((SCDOSE2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
    IF(IKERMA=1)[
           READ(data_unit,*,END=:EOFA:)
                (((SCKERMA(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
           READ(data_unit,*,END=:EOFA:)
                (((SCKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
           READ(data_unit,*,END=:EOFA:)
            (((SCDOSEtoKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
    ]
    IF(IFULL=2)[
           READ(data_unit,*,END=:EOFA:)(SCPDST(IB),SCPDST2(IB),IB=1,MAXBIN);
           READ(data_unit,*,END=:EOFA:)(SCPCUM(IB),SCPCUM2(IB),IB=1,MAXBIN);
           READ(data_unit,*,END=:EOFA:)(SCDFEP(IPK),SCDFEP2(IPK),IPK=1,4);
           READ(data_unit,*,END=:EOFA:)(SCDFBK(IPK),SCDFBK2(IPK),IPK=1,4);
           READ(data_unit,*,END=:EOFA:)(SCDFDIFF(IPK),SCDFDIFF2(IPK),IPK=1,4);
    ]
    $RETRIEVE RNG STATE FROM UNIT data_unit;
    READ(data_unit,*,END=:EOFA:)NCASEO,TMCPUO,NNREAD;
    " Read solid angle information as well, IK May 4 1999"
    READ(data_unit,*,END=:OMEGA-NOT-THERE:) SCOMEG,SCOMEG2;
    goto :OMEGA-THERE:;
:OMEGA-NOT-THERE:
    OUTPUT;('  Warning: Solid angle information not in data file');
    OUTPUT;('           This may cause errors in absolute normalizations!');
:OMEGA-THERE:
    CLOSE(data_unit);
]

IF(IRESTART .EQ.3)[NCASE=0;]

NCASET=NCASE+NCASEO;

:FINISHED: CONTINUE;
"************************"
"* Check for any errors *"
"************************"
IF(ERROR_FLAG.EQ.0) [
   OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   DO J=1,5[$SKIP-LINE;]

   RETURN; "NORMAL RETURN"
]

IF (ERROR_FLAG=1) [
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   WRITE(15,*) '************************************************';
   WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********';
   WRITE(15,*) '************************************************';
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   OUTPUT;(/' ERROR_FLAG=1 => INPUT DATA IS NOT CORRECT! see error file');
   RETURN; "ERROR RETURN"
]

"BAD DATA FILE, STOP AND PRINT MESSAGE
:EOFA:OUTPUT;(/' End of egsdat file from previous run encountered before',
   ' it was all read in - have to quit ');
ERROR_FLAG=1;
RETURN; "END OF DAT FILE RETURN"

END; "END OF SUBROUTINE INPUTS

%E     "start of subroutine ISUMRY"

"***************************************************************************
"
SUBROUTINE ISUMRY;
"
"           AFB       10/88     MACHINE-INDEPENDENT VARIABLE FORMAT CODED
"
"*************************************************************************

$IMPLICIT-NONE;

;
COMIN/
BOUNDS,EDGE,ELECIN,ET-Control,GEOM,IODAT1,IODAT2,
MEDIA,MISC,RUSROU,SCORE,SOURCE,SPECTR,
THRESH,USEFUL,USER,RANDOM,BREMPR,EGS-VARIANCE-REDUCTION/;
;

$INTEGER   IOUT,j,isumx,jj,i,ii;
$REAL      EK0;

$LOGICAL   start_fluor;
$INTEGER   i_start,i_stop;

IOUT=1;    "OUTPUT ON FORTRAN UNIT 1"
WRITE (IOUT, *) '\f'; "page break"

"WRITE THE HEADER"

write(iout,100) title;
100 FORMAT(
  ' ',80A1,/1X,79('*')/ ' *',T80, '*'/
  ' *',T80, '*'/
  ' *',T34,'************',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'* DOSRZnrc *',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'************',T80,'*'/
  ' *',T80, '*'/
  ' *           Cylindrical-geometry dose-scoring EGSnrc user-code ', T80,'*'/
  ' *',T80, '*'/
  ' *   DOSRZnrc was developed by the National Research Council of Canada',
                                                                      T80,'*'/
  ' *',T80, '*'/
  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
                                                                      T80,'*'/
  ' *             running on '$MACHINE' ',T80,'*'/
  ' *',T80, '*'/
  ' *',  T54,' ',$);
call egs_fdate(iout);
write(iout,'(" *",/1X,79("*"))');

" ********** IK: using wrapper for date and time routines.
" Was:
" CALL DATE(DATEN);CALL TIME(TIMEN);
" WRITE(IOUT,100) TITLE,TIMEN,DATEN;
" 100  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
"   ' *',T80, '*'/
"   ' *',T34,'************',T80,'*'/
"   ' *',T34,'*          *',T80,'*'/
"   ' *',T34,'* DOSRZnrc *',T80,'*'/
"   ' *',T34,'*          *',T80,'*'/
"   ' *',T34,'************',T80,'*'/
"   ' *',T80, '*'/
"   ' *           Cylindrical-geometry dose-scoring EGSnrc user-code ', T80,'*'/
"   ' *',T80, '*'/
"   ' *   DOSRZnrc was developed by the National Research Council of Canada',
"                                                                       T80,'*'/
"   ' *',T80, '*'/
"   ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
"   ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
"                                                                       T80,'*'/
"   ' *             running on '$MACHINE' ',T80,'*'/
"   ' *',T80, '*'/
"   ' *',  T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT,T80,'*'/1X,79('*'));

call show_transport_parameter(iout); " print the transport parameter settings"
                                     " settings on unit IOUT"

"MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS"
WRITE(IOUT,200) NCASE,NCASET,IQIN;
IF(MONOEN.EQ.0.AND.(ISOURC.LT.21.OR.ISOURC.GT.23))[WRITE(IOUT,201) EIN;]
ELSEIF(MONOEN.EQ.1)[CALL ENSRCO;]
ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22)[WRITE(IOUT,202) EKSRCM;]
"IF(estepe.EQ.0.0)[WRITE(IOUT,210);]ELSE[WRITE(IOUT,211)estepe;]
"WRITE(IOUT,220) smaxir($MXREG),ECUTIN,PCUTIN;"
"Now we check to see if ECUT(i) is the same for all regions"
"If so, we print the value"
"Note that this is a fudge for the RZ codes so that even if we "
"SET ECUT(1) = 0.0 to avoid warning messages, there is still a fixed ECUT"
DO I=2,NREG [ IF( (ECUT(I) ~= ECUT(2)) |(PCUT(I) ~= PCUT(2)) ) [
     "we failed at least one test, so this means there really are"
     "varying ECUTs and these will be printed in the grid if we want them"
     "print the first 10 ECUT & PCUT just to be sure"
     jj = MIN(12,NREG);
     WRITE(IOUT,'( ''First ECUTs:''/(6(F12.3)))') (ECUT(ii),ii=2,jj);
     WRITE(IOUT,'( ''First PCUTs:''/(6(F12.3)))') (PCUT(ii),ii=2,jj);
     GO TO :past:]]
"if we get here, they were all the same"
WRITE(IOUT,220) ECUT(2),PCUT(2);
:past:

IF(IFORCE.NE.0)[WRITE(IOUT,230)NFMIN,NFMAX;]ELSE[WRITE(IOUT,231);]

IF(ics_enhance = 1)[ WRITE(IOUT,235) cs_enhance,(j,iefl(j),j=2,NREG);]
ELSE [WRITE(IOUT,236);]
IF(IREJCT.EQ.0)[ WRITE(IOUT,243); ]
ELSE[ WRITE(IOUT,242) ESAVEIN; ]
DO I=1,NREG[
   IF(IRAYLR(I)=1)[
     WRITE(IOUT,244);
     EXIT;
   ]
]
WRITE(IOUT,260) TIMMAX,STATLM,IXXIN,JXXIN;

IF(IBRSPL = 0)[WRITE(IOUT,312);]
ELSE[WRITE(IOUT,313) nbr_split;]

IF(I_PLAY_RR = 0)[WRITE(IOUT,314);]
ELSE[WRITE(IOUT,315) PROB_RR;]

IF(RUSROU) WRITE(IOUT,265)RRZ,RRCUT;
IF(CEXPTR.NE.0) WRITE(IOUT,266)CEXPTR;
IF(ESAVEIN > 0.0) WRITE(IOUT,267)ESAVEIN;
IF(NESTEP.EQ.0)[       WRITE(IOUT,282);      ]
ELSEIF(NESTEP.EQ.NREG)[WRITE(IOUT,283);      ]
ELSE[                  WRITE(IOUT,284)NESTEP;]
IF(NSMAX.EQ.0)[        WRITE(IOUT,285);      ]
ELSEIF(NSMAX.EQ.NREG)[ WRITE(IOUT,286);      ]
ELSE[                  WRITE(IOUT,287)NSMAX; ]
IF(ICSDA.EQ.0)[WRITE(IOUT,289);]ELSE[WRITE(IOUT,290);]

"PATCH FOR FLUORESCENT X-RAYS"
ISUMX=0;
DO JJ=1,NREG[ISUMX=ISUMX+IEDGFL(JJ);"NON-ZERO IF X-RAYS ANYWHERE"]
IF(ISUMX.EQ.0)[WRITE(IOUT,307);]

ELSE[

  WRITE(IOUT,306);

start_fluor = .false.;
DO jj=1,NREG [
    IF( IEDGFL(JJ) > 0 & IEDGFL(JJ) <= $MXELEMENT ) [
        IF( ~start_fluor ) [
            start_fluor = .true.; i_start = jj;
        ]
        ELSE [ i_stop = jj; ]
    ]
    ELSE [
        IF( start_fluor ) [
            write(iout,'(24x,i5,a,i5)') i_start,' -- ',i_stop;
            start_fluor = .false.;
        ]
    ]
]
IF( start_fluor ) write(iout,'(24x,i5,a,i5)') i_start,' -- ',i_stop;

]

EK0=EIN;
$PRESTA-INPUT-SUMMARY; "OUTPUT THE PRESTA INPUT VARIABLES"

"MATERIAL INPUT SUMMARY"
"====================="

WRITE(IOUT,300) NMED;
DO I=1,NMED[
    WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP(I);
]

CALL GEOMRZ_ISUMRY(IOUT);

CALL SRCOUT;

IF(IOOPTN.GE.2)[ "PRINT A GRID OF THE ZONE DEPENDENT VARIABLES"
CABSRB(1)='0';
CALL MATERIALGRID(NR, NZ, AMASS, 1, ECUT, PCUT,
                  RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB);
]   "END OF CONDITIONAL MATERIAL GRID OUTPUT"

"SUMMARY OF REGIONS IN SENSITIVE VOLUME"
IF(IFULL.EQ.2)[
    OUTPUT (I,IPHR(I),I=1,NREG);
    (///' PULSE HEIGHT DISTRIBUTION IS SCORED IN ',
    'THOSE REGIONS DENOTED WITH A 1'/(10(I3,'(',I1,'), ')));
    WRITE(IOUT,311)(I,IPHR(I),I=1,NREG);
] "END IFULL=2 BLOCK"

WRITE (IOUT, *) '\f'; "page break"

RETURN;
%I0
"FORMATS"
200  FORMAT (
    ' ',T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/ / ' ',79('*')//
    ' ',T20,'MAX # OF HISTORIES TO RUN',T53,I12/
    ' ',T20,'MAX # OF HISTORIES TO ANALYZE',T53,I12/
    ' ',T20,'INCIDENT CHARGE',T63,I2);
201  FORMAT(' ',T20,'INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)');
202  FORMAT(' ',T20,'MAXIMUM INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)');
210  FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,'DEFAULT');
211  FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,F5.3);
220  FORMAT(' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF',
                     T56,0PF9.3,' (MeV)'/
             ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF',
                     T56,F9.3,' (MeV)');
230  FORMAT(' ',T20,'MIN/MAX PHOTON STEP FORCED',T60,I6,'/',I6);
231  FORMAT(' ',T20,'PHOTON FORCE INTERACTION SWITCH',T60,'OFF');
235  FORMAT(T20,'Cross section enhancement factor of',T56,F8.1/
            T20,'In regions with a 1:'/
            (T10, 10('(',I3,',',I1,')')));
236  FORMAT(T20,'No cross section enhancement used');
242  FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'ON'/
                T20,'  Range rejection for energy  <',T56,F9.3,' (MeV)'/
                T20,'  Ranges determined internally from stopping powers');
243  FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'OFF');
244  FORMAT(' ',T20,'RAYLEIGH SCATTERING INCLUDED');
"250  FORMAT(' ',T20,'RANGE REJECTION PARAMETERS:'/
"             ' ',T12,F9.3,' (MeV) TO ',F9.3,' (MeV)',T51,E14.7,'/',E14.7/
"             ' ',T12,F9.3,' (MeV) TO ',F9.3,' (MeV)',T51,E14.7,'/',E14.7);
"255  FORMAT(T20,'DISCARDS E- EXTERIOR TO PLANES',I3,' AND',I3/
"            T30,'AND CYLINDERS',I2,' AND',I3,' for E<',F7.3,' MeV');
260  FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (HRS)'/
            ' ',T20,'STATS IN PEAK REGION OBJECTIVE',T59,F6.2,' %'/
            ' ',T20,'1ST INITIAL RANDOM NUMBER SEED',T57,I12/
            ' ',T20,'2ND INITIAL RANDOM NUMBER SEED',T57,I12);
265  FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'/
                T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4);
266  FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/
                T25,'VARIABLE FOR FORWARD GOING PHOTNS: ',T60,F10.3);
267  FORMAT(' ',T20,'DISCARD ALL ELECTRONS BELOW:',T60,F7.3/
                T25,'IF TOO FAR FROM CLOSEST BOUNDRY');
270  FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'NONE');
271  FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'ALL');
272  FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,I2);
273  FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'NONE');
274  FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'ALL');
275  FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,I2);
276  FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'NONE');
277  FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'ALL');
278  FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,I2);
279  FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'NONE');
280  FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'ALL');
281  FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,I2);
282  FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'NONE');
283  FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'ALL');
284  FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,I2);
285  FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'NONE');
286  FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'ALL');
287  FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,I2);
289  FORMAT(' ',T20,'NORMAL ELECTRON TRANSPORT WITH DISCRETE INTERACTIONS');
290  FORMAT( /
    ' ',T20,'NO DISCRETE ELECTRON INTERACTIONS SAMPLED'/
    ' ',T20,'========================================='/);
300 FORMAT( ' ',79('*')/ /
    ' ',T20,'MATERIAL SUMMARY   ',I1,' MATERIALS USED'/ / ' ',79('*')//
    ' # MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',4X,'AP(MeV)',
          9X,'UE(MeV)',4X,'UP(MeV)'/
    ' - --------  ----------------',6X,'-------',4X,'-------',
          9X,'-------',4X,'-------');
305  FORMAT(T22,' REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3);
306  FORMAT(T20,' The following regions have atomic relaxations on: ');
307  FORMAT(T20,' Atomic relaxations are off');
310  FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3));
311  FORMAT(///' PULSE HEIGHT DISTRIBUTION IS SCORED IN THOSE REGIONS',
             ' DENOTED WITH A 1'/(10(I3,'(',I1,'), ')));
312   FORMAT(T20,'Bremsstrahlung splitting',T60,'OFF');
313   FORMAT(T20,'Bremsstrahlung splitting',T60,'ON'/T20,
     'Initially, each bremsstrahlung photon split into ',I3,' photons');
314  FORMAT(T20,'Charged particle Russian Roulette',T60,'OFF');
315  FORMAT(T20,'Charged particle Russian Roulette',T60,'ON'/T20,
                'With probability of survival =',T60,F9.3);
END; "LAST LINE OF SUBROUTINE ISUMRY"


%E     "start of subroue OSUMRY"

"*************************************************************************
"
SUBROUTINE OSUMRY;
"
"           AFB       10/88     MACHINE-INDEPENDENT VARIABLE FORMAT CODED
"
"************************************************************************

$IMPLICIT-NONE;

;
REPLACE {$IRL} WITH {IZD+NZDMIN+NZDOSE*(IXD+NRDMIN-1)}

;
"for the grid output"
$INTEGER NCOMP;
$REAL RESULTS($MAXZREG, $MAXRADII, $MAXCMPTS),
     UNCRTY($MAXZREG, $MAXRADII, $MAXCMPTS),
     RADIAL_BINS($MAXRADII),DEPTH_BINS($MAXZPLANE);
CHARACTER*60 EXPLANATIONS($MAXCMPTS);
CHARACTER*4 LABELS($MAXCMPTS);

$REAL FRACS($MAXZREG,$MAXRADII,3:6);
$INTEGER IXD,IZD,IT,IZ,IX,IRL,I,IR;
$REAL    TEMP;

;COMIN/CHARS,GEOM,IODAT1,IODAT2,PRINTC,PLOTC,SCORE,SOURCE,USER,
BREMPR,EGS-VARIANCE-REDUCTION,CH-Steps/;

$INTEGER egs_open_file, dose_unit;

IF(IFULL.EQ.2)[
    "PULSE HEIGHT DISTRIBUTION OUTPUT"
    "IF(MAXBIN.LT.45)[CALL PRNTER(13,6,1,1);]ELSE[CALL PRNTER(13,8,1,1);]"
    write(1,'(a)') '\f';
    write(iout,101) title; call egs_fdate(iout);
    write(iout,104);

" ********** IK: using wrapper for date and time routines.
" Was:
"    WRITE(IOUT,101) TITLE, DATEN,TIMEN;

    CALL PLOTPH(TITLE,SCPDST,SCPDST2,SCPCUM,SCPCUM2,
        SCPTOT,SCPTOT2,SCDFEP,SCDFEP2,MAXBIN,SLOTE,BINTOP,
        IHSTRY,SCOMEG,SCOMEG2,SCPHEN,SCPHEN2);
]"END OF IFULL= 2 BLOCK"

"CALL PRNTER(12,6,IOUT,1); SET UP THE PRINTER AND PAGE THROW"
write(1,'(a)') '\f';

write(iout,100) title; call egs_fdate(iout); write(iout,105);

" ********** IK: using wrapper for date and time routines.
" Was:
" WRITE(IOUT,100)TITLE,DATEN,TIMEN;" "HEADER"

"Print out final bremsstrahlung splitting number"
IF(IBRSPL = 1)[WRITE(IOUT,90) nbr_split;]

"PRINT # CHARGED PARTICLE STEPS"
IF(ISOURC=21|ISOURC=22)[
  WRITE(IOUT,200) SCSTP,SCSTP2,
        SCSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC),
                  SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
]
ELSE[
  WRITE(IOUT,200) SCSTP,SCSTP2,SCSTP/dble(IHSTRY),
                  SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
]

"PRINT # CHARGED PARTICLE STEPS IN DOSE REGION"
IF(ISOURC=21|ISOURC=22)[
  WRITE(IOUT,210) SCDSTP,SCDSTP2,
       SCDSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC),
                  SCDSTP2,(count_pII_steps+PIISTP)/SCDSTP,SCDSTP2;
]
ELSE[
  WRITE(IOUT,210) SCDSTP,SCDSTP2,
                  SCDSTP/dble(IHSTRY),
                  SCDSTP2,(count_pII_steps+PIISTP)/SCDSTP,SCDSTP2;
]

"SCALE DOSE FRACTIONS"
IF(IFULL.EQ.1)[
    DO IXD=1,NRDOSE[
        DO IZD=1,NZDOSE[
            TEMP=SCDOSE(IZD,IXD,1);
            IF(TEMP.EQ.0)[DO IT=3,6[FRACS(IZD,IXD,IT)=0.0;]]
            ELSE[DO IT=3,6[FRACS(IZD,IXD,IT)=100.*SCDOSE(IZD,IXD,IT)/TEMP;]]
        ]
    ]
]

"PRINT A SUMMARY OF THE DOSE REGION RESULTS"
IF((IOOPTN.EQ.1).OR.(IOOPTN.GT.2))[

    "A COMPACT VERSION IF ONLY ONE DOSE REGION ZONE"
    IF(NDOSE.EQ.1)[
        IZ=NZDMIN;IX=NRDMAX;
        $GET-IRL(IZ,IX);
        IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
           WRITE(IOUT,299) IRL,IZ,IX,(SCDOSE(1,1,IT),SCDOSE2(1,1,IT),IT=1,2);
        ]
        ELSE[
           WRITE(IOUT,300) IRL,IZ,IX,(SCDOSE(1,1,IT),SCDOSE2(1,1,IT),IT=1,2);
        ]
        IF(IFULL.EQ.1)[
            WRITE(IOUT,302)
                (SCDOSE(1,1,IT),SCDOSE2(1,1,IT),FRACS(1,1,IT),IT=3,6);
            IF(ISOURC.EQ.3)[
                IF(IRL.EQ.NSRCRG)[
                    WRITE(IOUT,303)SCDOSE(1,1,7),SCDOSE2(1,1,7);
                ]
            ]
        ]
    ]
    ELSE[ "OUTPUT FOR MORE THAN 1 SCORING ZONE"
        WRITE(IOUT,400);
        IF(IFULL.NE.3)[
            IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[WRITE(IOUT,399);]
            ELSE[WRITE(IOUT,401);]
        ]
        IF(IFULL.EQ.1)["dose per entrance region"
            WRITE(IOUT,410);
            ICHPIN=12;IPAGE=0;
            "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);  SET UP THE PRINTER"
            WRITE(IOUT,411);
            DO IXD=1,NRDOSE[
                DO IZD=1,NZDOSE[
                    IZ=IZD-1+NZDMIN;IX=IXD+NRDMIN;
                    $GET-IRL(IZ,IX);
                    WRITE(IOUT,412) IRL,IZ,IX,
                        (SCDOSE(IZD,IXD,IT),IT=1,$MAXIT-1),
                        (SCDOSE2(IZ,IX,IT),IT=1,$MAXIT-1),
                        (FRACS(IZ,IX,IT),IT=3,6);
                ]
            ]
            IF(ISOURC.EQ.3)[
                IF(CDSTBL(NSRCRG).EQ.DCHAR)[
                    $GET-IX-IZ(NSRCRG);IZD=IZ-NZDMIN+1;IXD=IX-NRDMIN;
                    WRITE(IOUT,304)NSRCRG,IZ,IX,
                        SCDOSE(IZD,IXD,7),SCDOSE2(IZD,IXD,7);
                ]
            ]
        ]
        ELSE["no dose per entrance region"
            IF(IFULL.EQ.3)[
               IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[WRITE(IOUT,:F399B:);]
               ELSE[WRITE(IOUT,:F401B:);]
               WRITE(IOUT,:F402B:);
            ]
            ELSE [WRITE(IOUT,402);]
            "Now output the results"
            DO IXD=1,NRDOSE[
                DO IZD=1,NZDOSE[
                    IZ=IZD-1+NZDMIN;IX=IXD+NRDMIN;
                    $GET-IRL(IZ,IX);
                    WRITE(IOUT,403)
                    IRL,IZ,IX,(SCDOSE(IZD,IXD,IT),SCDOSE2(IZD,IXD,IT),IT=1,2);
                ]
            ]
            "Here we output a brief summary to unit 10 for a database"
            dose_unit = egs_open_file(10,0,1,'.egsdose');
            WRITE(dose_unit,'(80A1)') TITLE;
            WRITE(dose_unit,
              '('' There are'',I5,'' radial zones, midpoints:'')')NR;
            WRITE(dose_unit,'( 8(F9.4,'',''))')((RCYL(I-1)+RCYL(I))/2., I=1,NR);
            WRITE(dose_unit,'('' There are '',I5,'' depth regions'')') NZ;
            DO IZ = 1,NZ[
              WRITE(dose_unit,'('' Depth centered at: '',F12.3)')
                   (ZPLANE(IZ)+ZPLANE(IZ+1))/2.;
              WRITE(dose_unit,'( 4(1PE10.3,''+/-'',0PF5.2,''% ''))')
                   (SCDOSE(IZ,IR,1),SCDOSE2(IZ,IR,1), IR=1,NR);
            ]
            close(dose_unit);
        ]
    ] "END OF DOSE SUMMARY"
] "END OF CONDITIONAL SUMMARY OF DOSE"

IF((IOOPTN.EQ.0).OR.(IOOPTN.EQ.2).OR.(IOOPTN.EQ.4))[
   " OUTPUT GRID ONLY IF REQUESTED"
   "Grid routine by Aaron Merovitz, 1998"

   "1) Set up the arrays"
   DO IXD=1, NRDOSE [
       DO IZD=1, NZDOSE [
           RESULTS(IZD,IXD,1)=SCDOSE(IZD,IXD,1);
           RESULTS(IZD,IXD,2)=SCDOSE(IZD,IXD,2);
           RESULTS(IZD,IXD,3)=SCKERMA(IZD,IXD,1);
           RESULTS(IZD,IXD,4)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1);
           UNCRTY(IZD,IXD,1)=SCDOSE2(IZD,IXD,1);
           UNCRTY(IZD,IXD,2)=SCDOSE2(IZD,IXD,2);
           UNCRTY(IZD,IXD,3)=SCKERMA2(IZD,IXD,1);
           UNCRTY(IZD,IXD,4)=SCDOSEtoKERMA2(IZD,IXD,1);
           IF ((IFULL=1)&(IKERMA=0)) [
              DO IT=3, 6 [
                 RESULTS(IZD,IXD,IT-1)=FRACS(IZD,IXD,IT);
                 UNCRTY(IZD,IXD,IT-1)=SCDOSE2(IZD,IXD,IT);
              ]
           ]
           IF ((IFULL=1)&(IKERMA=1)) [
              RESULTS(IZD,IXD,2)=SCKERMA(IZD,IXD,1);
              RESULTS(IZD,IXD,3)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1);
              UNCRTY(IZD,IXD,2)=SCKERMA2(IZD,IXD,1);
              UNCRTY(IZD,IXD,3)=SCDOSEtoKERMA2(IZD,IXD,1);
              DO IT=4, 7 [
                 RESULTS(IZD,IXD,IT)=FRACS(IZD,IXD,IT-1);
                 UNCRTY(IZD,IXD,IT)=SCDOSE2(IZD,IXD,IT-1);
              ]
           ]
           IF (IFULL=3) [
              RESULTS(IZD,IXD,4)=SCKERMA(IZD,IXD,2);
              RESULTS(IZD,IXD,5)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1);
              RESULTS(IZD,IXD,6)=SCDOSE(IZD,IXD,2)/SCKERMA(IZD,IXD,2);
              UNCRTY(IZD,IXD,4)=SCKERMA2(IZD,IXD,2);
              UNCRTY(IZD,IXD,5)=SCDOSEtoKERMA2(IZD,IXD,1);
              UNCRTY(IZD,IXD,6)=SCDOSEtoKERMA2(IZD,IXD,2);
           ]
       ]
   ]
   "2) Determine the number of components"
   IF (IKERMA=1) [
      IF (IFULL=0) [NCOMP=4;]
      IF (IFULL=1) [NCOMP=7;]
      IF (IFULL=2) [NCOMP=4;]
      IF (IFULL=3) [NCOMP=6;]
   ]
   IF (IKERMA=0) [
      IF (IFULL=1) [NCOMP=5;]
      ELSE [NCOMP=2;]
   ]

   "3) Set up the bin indicators"
   DO IX=1,NRDOSE+1 [RADIAL_BINS(IX)=RCYL(IX+NRDMIN-1);]
   DO IZ=1,NZDOSE+1 [DEPTH_BINS(IZ)=ZPLANE(IZ+NZDMIN-1);]

   "4) Set up the labels and the explanations"
   IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
     EXPLANATIONS(1)='Total dose (Gray/incident particle)';
   ]
   ELSE[
     EXPLANATIONS(1)='Total dose (Gray/incident fluence)';
   ]
   LABELS(1)='T  :';
   IF (IFULL=3) [
      EXPLANATIONS(2)='Scatter dose (after Compton or fluorecent reabsorbed)';
      LABELS(2)='Sca:';
   ]
   ELSE [EXPLANATIONS(2)='Total dose minus stoppers';LABELS(2)='T-S:';]
   EXPLANATIONS(3)='Kerma';LABELS(3)='K  :';
   IF (IFULL~=3) [EXPLANATIONS(4)='Dose to kerma';LABELS(4)='D/K:';]
   ELSE [EXPLANATIONS(4)='Kerma scatter';LABELS(4)='Ksc:';
         EXPLANATIONS(5)='Dose to kerma';lABELS(5)='D/K:';
         EXPLANATIONS(6)='Dose to kerma scatter';LABELS(6)='DsKs';
   ]
   IF (IFULL=1)&(IKERMA=0) [
      EXPLANATIONS(2)='% dose from front wall (error is % OF %)';
                         LABELS(2)='FT :';
      EXPLANATIONS(3)='% dose from outer wall';LABELS(3)='OUT:';
      EXPLANATIONS(4)='% dose from back wall';LABELS(4)='BK :';
      EXPLANATIONS(5)='% dose from inner wall';LABELS(5)='IN :';
   ]
   IF (IFULL=1)&(IKERMA=1) [
      EXPLANATIONS(2)='Total kerma';LABELS(2)='K  :';
      EXPLANATIONS(3)='Total dose to kerma';LABELS(3)='D/K:';
      EXPLANATIONS(4)='% dose from front wall (error is % of %)';
                       LABELS(4)='FT :';
      EXPLANATIONS(5)='% dose from outer wall';LABELS(5)='OUT:';
      EXPLANATIONS(6)='% dose from back wall';LABELS(6)='BK :';
      EXPLANATIONS(7)='% dose from inner wall';LABELS(7)='IN :';
   ]

   "5) Make the grid"
   CALL ZONEGRID(NRDOSE, NZDOSE, NRDMIN, NZDMIN, NZ, RESULTS,
                 UNCRTY, NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS);
] "end IF IOOPTN=0, 2 or 4"

IF(ILPIN.NE.6)[ write(iout,'(a)') '\f'; "CALL PRNTER(13,6,IOUT,1);"]
IF(IOPLOT.EQ.1)CALL PLOTEN;
"CALL PRNTER(13,6,IOUT,0);"

RETURN;
%I0
"FORMATS"

90    FORMAT(/' Final bremsstrahlung photons split into ',I3,' photons'/);
100  FORMAT(' ',80A1/' ',T59,$);
105  FORMAT(///T30,'SUMMARY OF DOSE REGION RESULTS'/
             ' ',T30,'******************************');
101  FORMAT(' ',80A1/' ',T55,$);
104  FORMAT(/// T30,'Summary of pulse height distribution'/
                T30,'************************************');

" ********** IK: using wrapper for date and time routines.
" Was:
" 100  FORMAT(' ',80A1/' ',T59,$DATEN_FORMAT,1X,$TIMEN_FORMAT//
"        T30,'SUMMARY OF DOSE REGION RESULTS'/
"              ' ',T30,'******************************');
" 101  FORMAT(' ',80A1/' ',T59,$DATEN_FORMAT,1X,$TIMEN_FORMAT//
"        T30,'Summary of pulse height distribution'/
"        T30,'************************************');

200  FORMAT(/' ',T26,'Total # charged particle steps',T58,
             1PE10.3,' +/-',0PF6.3,'%'/
             ' ',T13,'# of charged particle steps/initial history',T58,
             1PE10.3,' +/-',0PF6.3,'%'/
             ' ','# of presta-II steps/total # of charged particle steps',
                 T61,F7.3,' +/-',0PF6.3,'%');
210  FORMAT(/' ',T19,'# charged particle steps in dose reg.'
             ,T58,1PE10.3,' +/-',0PF6.3,'%'/
             ' ',T17,'# of steps in dose reg./initial history'
             ,T58,1PE10.3,' +/-',0PF6.3,'%'/
             ' ',T12,'# of presta-II steps/# of steps in dose reg.',
              T61,F7.3,' +/-',0PF6.3,'%');
299  FORMAT(/' Geometrical zone number:',T53,I10/
             ' Planar zone number:',T53,I10/
             ' Cylndrical zone number:',T53,I10//
             ' Total dose (Gray/(source particle)):',
                     T50,1PE11.4,' +/- ',0PF6.3,'%'/
             ' Total dose minus stoppers:',
                     T50,1PE11.4,' +/- ',0PF6.3,'%');
300  FORMAT(/' Geometrical zone number:',T53,I10/
             ' Planar zone number:',T53,I10/
             ' Cylndrical zone number:',T53,I10//
             ' Total dose (Gray/(incident fluence)):',
                     T50,1PE11.4,' +/- ',0PF6.3,'%'/
             ' Total dose minus stoppers:',
                     T50,1PE11.4,' +/- ',0PF6.3,'%');
302  FORMAT( ' Total dose from front planar wall:',
                     T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/
             ' Total dose from outside curved wall:',
                     T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/
             ' Total dose from back planar wall:',
                     T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/
             ' Total dose from inner curved wall:',
                     T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)');
303  FORMAT(' Total dose deposited by particles emergent ',
             'from the dose/source region:',
             T50,1PE11.4,' +/- ',0PF6.3,'%');
304  FORMAT(/' ','Dose scored in source region due to emergent ',
            'particles : Z# P# C#    Dose    uncertainty'/' ',
            57X,I2,I3,I3,E11.3,E12.3);
400  FORMAT(/' ',T20,'Z# : Geometrical zone number'/
             ' ',T20,'P# : Planar zone number'/
             ' ',T20,'C# : Cylndrical zone number');
399  FORMAT(' ',T20,'T  : Total dose (Gray/(source particle))'/
             ' ',T20,'T-S: Total dose minus stoppers');
:F399B:  FORMAT(' ',T20,'T  : Total dose (Gray/(source particle))'/
             ' ',T20,
             'Sca: Scatter dose (after Compton or fluorecent  reabsorbed ');
401  FORMAT(' ',T20,'T  : Total dose (Gray/(incident fluence))'/
             ' ',T20,'T-S: Total dose minus stoppers');
:F401B:  FORMAT(' ',T20,'T  : Total dose (Gray/(incident fluence))'/
             ' ',T20,
             'Sca: Scatter dose (after Compton or fluorecent  reabsorbed ');
402  FORMAT(/'  Z# P# C#          T                  T-S'/
             ' --- -- -- ------------------- -------------------');
:F402B:  FORMAT(/'  Z# P# C#          T                  Sca'/
             ' --- -- -- ------------------- -------------------');
403  FORMAT(' ',I3,2(1X,I2),1X,2(1PE11.4,' +/-',0PF6.3,'% '));
410  FORMAT(' ',T20,'F  : TOTAL DOSE FROM FRONT PLANAR WALL'/
             ' ',T20,'O  : TOTAL DOSE FROM OUTSIDE CURVED WALL'/
             ' ',T20,'B  : TOTAL DOSE FROM BACK PLANAR WALL'/
             ' ',T20,'I  : TOTAL DOSE FROM INNER CURVED WALL');
411  FORMAT(/'  Z# P# C# ',
             '     T         T-S         F          O     ',
             '     B          I'/
             ' --- -- -- ',
             '---------- ---------- ---------- ---------- ',
             '---------- ----------');
412  FORMAT(' ',I3,2(1X,I2),1X,1PE11.4,5(1X,E10.3)/
             '   %ERROR=',
             6(3X,0PF6.3,4X)/
             '    %DOSE=',21X,4(2X,0PF7.3,2X));
%I4
END; "END OF SUBROUTINE OSUMRY"
%Q1
%E     "dosrznrc.mortran"

"THIS FUNCTION COMPRESSES NON-HOLLERITH STRINGS"
CHARACTER*(*) FUNCTION CMPRES(UNCOMP);
$IMPLICIT-NONE;
CHARACTER*(*) UNCOMP;
$LOGICAL HOLRTH;
$INTEGER INDX,NARG,I,NRES;
HOLRTH=.FALSE.;
INDX=1;
NARG=LEN(UNCOMP);
DO I=1,NARG[
    IF(UNCOMP(I:I).EQ.'''') HOLRTH=.NOT.HOLRTH; "HOLLERITH DETECTION"
    IF(HOLRTH)["STRING IS HOLLERITH, WRITE ALL CHARACTERS"
        CMPRES(INDX:INDX)=UNCOMP(I:I);INDX=INDX+1;
        ]
    ELSE["STRING IS NON-HOLLERITH, TRANSCRIBE ONLY NON-BLANKS"
        IF(UNCOMP(I:I).NE.' ')[CMPRES(INDX:INDX)=UNCOMP(I:I);INDX=INDX+1;]
        ]
    ]
"FILL WITH BLANKS"
NRES=LEN(CMPRES);
IF(INDX.LE.NRES)[DO I=INDX,NRES[CMPRES(I:I)=' ';]]
RETURN;
END; "END OF FUNCTION CMPRES"
%Q1
%E     "dosrznrc.mortran"

;
"***************************************************************************
"
"                               PLOTPH"
"                               ======
"
SUBROUTINE PLOTPH(TITLE,PDST,PDSTUN,PCUM,PCUMUN,PTOT,PTOTUN,DFEP,DFEPUN,
                  MAXBIN,SLOTE,BINTOP,IHSTRY,OMEG,OMEGUN,PHEN,PHENUN);
"
"       ROUTINE PLOTS SPECTRUM ON LINEPRINTER AND CREATES A DISK FILE
"       MAXBIN IS NUMBER OF BINS IN SPECTRUM
"       BINTOP IS USED ONLY IF SLOTE IS NON-ZERO
"       SPECTRUM IS NORMALIZED TO PEAK OF UNITY FOR PLOTTING
"
"       OUTPUT FILE ON UNIT 9.
"       FORMAT FOR EACH CALL:
"           TITLE
"           NUMBER OF ENERGY BINS (I5)
"           TOP OF ENERGY BIN, FRACTION OF SPECTRUM IN THIS BIN,UNCERTAINTY
"              ABOVE LINE LOOPED FOR EACH BIN 3(E12.4)
"           HEADER LINE
"           FULL ENRGY PEAK EFFICIENCY PER COUNT IN SPECTRUM, UNCERTAINTY
"           SAME FOR SINGLE ESCAPE, DOUBLE ESCAPE AND 511 KEV PEAKS 2(E12.4)
"
"***************************************************************************

;
$IMPLICIT-NONE;

CHARACTER SPACE,BAR,LINE(61),SYMBOL(6);
REAL*8 PDST($EBIN),PDSTUN($EBIN),PTOT,PTOTUN,DFEP(4),DFEPUN(4),
       PCUM($EBIN),PCUMUN($EBIN),omeg,omegun,phen,phenun;
$REAL BINTOP($EBIN),xplot($EBIN),yplot($EBIN),
     errplot($EBIN),SLOTE;
$LONG_INT ihstry;
$INTEGER maxbin;
COMIN/IODAT2/;
character*1 TITLE(80);
character*60 xtitle,ytitle,subtitle,seriestitle,plottitle;
character*80 graphtitle;

$INTEGER  NHIST,IOUT,IB,j,ilev,ipk,iunit,icurvenum,iplttype,iaxistype;
$REAL     HIST,sfac,eb,sum,uncert,binw,histmin;
$INTEGER  egs_open_file;
DATA SPACE/' '/,BAR/'|'/,SYMBOL/$S'*+$-#@'/;
DATA NHIST/61/,HIST/61./,IOUT/1/;

"GET PEAK IN SPECTRUM"
sfac=0;
"********* IK: on many compilers, arguments to the MAX intrinsic MUST be
"              of the same type. "
"DO IB=1,MAXBIN[SFAC = MAX(PDST(IB),SFAC);]"
DO IB=1,MAXBIN [
    IF( PDST(IB) > sfac ) [ sfac = PDST(IB); ]
]

WRITE(IOUT,4) IHSTRY;
WRITE(IOUT,5);  "HEADER FOR PLOT"

DO IB=1,MAXBIN[
    IF(SLOTE.GT.0.0)[EB=IB*SLOTE;]ELSE[EB=BINTOP(IB);]
    DO J=1,NHIST[LINE(J)=SPACE;"BLANK ENTIRE LINE EACH TIME"]
    ILEV=0;
    IF(PDST(IB).GT.0.0)[
        ILEV=HIST+DLOG10(PDST(IB)/SFAC)*20.+0.5;
        "RUNS FROM 1 TO 61 FOR 0.0 TO 1.0"
        ]
    IF((ILEV.GT.0).AND.(ILEV.LE.NHIST))[LINE(ILEV)=SYMBOL(1);]
    "ADD REFERENCE BARS"
    DO J=1,4[
        ILEV=20*J-19;
        IF(LINE(ILEV).EQ.SPACE) LINE(ILEV)=BAR;
        ]
    WRITE(IOUT,10) LINE,EB,PDST(IB),PDSTUN(IB),PCUM(IB),PCUMUN(IB);
    ]"END OF IB LOOP"

WRITE(IOUT,30);
SUM=0.0; DO IPK=1,4[SUM=SUM+DFEP(IPK);]
IF(SUM.GE.0.00005 )[
    "THERE ARE SOME COUNTS IN THE PEAKS"
    WRITE(IOUT,40) (DFEP(IPK),DFEPUN(IPK),IPK=1,4);
    ]
IF(OMEG.EQ.0.0)[
    "THIS IS A PARALLEL EXTERNAL BEAM OR INTERNAL SOURCE CASE"
    WRITE(IOUT,50) PTOT,PTOTUN;
    ]
ELSE[
    "EXTERNAL POINT SOURCE GEOMETRY"
    UNCERT=SQRT(PTOTUN**2 + OMEGUN**2); "UNCERTAINTY ON RATIO"
    WRITE(IOUT,60) OMEG,OMEGUN,PTOT/(4.*3.141593),PTOTUN,PTOT/OMEG,UNCERT;
    ]
WRITE(IOUT,70) PHEN,PHENUN;

"
"  OUTPUT RESULTS TO DISK FILE ON UNIT 9
"
"IUNIT=9;"
"OPEN(UNIT=9,file='fort.9',STATUS='UNKNOWN'); "
                          "needed by absoft compiler for some reason"

"IK: open the plot file using a file name instead of fort.9 "
iunit = egs_open_file(9,0,1,'.egseff');

WRITE(IUNIT,75) TITLE;
WRITE(IUNIT,80)MAXBIN;
"Feb 1992 corrected to output cts/MeV in bin and get file right"
"Jan 99 changed uncertainties to be absolute so plotxvgr can handle"
DO IB=1,MAXBIN[
    IF(SLOTE.GT.0.0)[EB=IB*SLOTE;BINW=SLOTE;]
    ELSE[
     EB=BINTOP(IB);IF(IB=1)[BINW=BINTOP(1);]ELSE[BINW=EB-BINTOP(IB-1);]
    ]"end block for SLOTE"
    IF(BINW=0.0)[BINW = 1E-9;]
    xplot(IB) = EB;
    yplot(IB) = PDST(IB)/BINW;
    IF (PDST(IB) ~= 0.0) [errplot(IB)=PDSTUN(IB)*PDST(IB)/(BINW*100.);]
    ELSE [errplot(IB) = 0.0;]
    WRITE(IUNIT,90) EB,PDST(IB)/BINW,errplot(IB);
]
WRITE(IUNIT,100) (DFEP(IPK),DFEPUN(IPK),IPK=1,4),PTOT,PTOTUN;
close(iunit);

"Now setup to create a proper xvgr plot of the spectrum on unit 22"
iunit = egs_open_file(22,0,1,'.plotphd');

DO J=1,80[graphtitle(j:j)=title(j);]

xtitle='energy/MeV';
ytitle='cts/MeV';
subtitle='pulse height distribution from dosrznrc';
icurvenum=0;
iplttype=1; "histogram=1, XY-plot=0"
histmin=0.0;
iaxistype = 0; "no logs"
seriestitle=' ';
call xvgrplot(xplot,yplot,errplot,MAXBIN,icurvenum,seriestitle,
xtitle,ytitle,graphtitle,subtitle,iunit,iplttype,histmin,iaxistype);
      "iaxistype is not set, is this intended??? "
close(iunit);

"FORMATS"
4    FORMAT(/I12,' HISTORIES ANALYSED'/);
5    FORMAT(/65X,'EBIN'/' 3',19X,'2',19X,'1',7X,
             '-LOG',8X,'0    TOP',9X,'PDST              CUMULATIVE');
10   FORMAT(1X,61A1,F8.4,1X,2(0PF11.4,' (',F6.3,'%)'));
20   FORMAT(/62X,'TOTALS',2X,6(I4,3X));
30   FORMAT(/' PLOT NORMALIZED TO PEAK OF ONE, ',
            'PDST IS NORMALIZED TO UNIT AREA'/);
40   FORMAT(' PEAK EFFICIENCIES PER COUNT IN SPECTRUM'//
           ' FULL ENERGY PEAK',T30,F10.4,'(+-',F6.3,'%)'/
           ' SINGLE ESCAPE PK',T30,F10.4,'(+-',F6.3,'%)'/
           ' DOUBLE ESCAPE PK',T30,F10.4,'(+-',F6.3,'%)'/
           ' 511 KEV PK'      ,T30,F10.4,'(+-',F6.3,'%)'/);
50   FORMAT(/'  FRACTION OF INITIAL PARTICLES (HITTING DETECTOR HOUSING ',
          '(if parallel beam) WHICH CAUSE PULSE = ',0PF14.4,'(',F6.3,'%)');
60   FORMAT(/' SOLID ANGLE SUBTENDED BY DETECTOR HOUSING =                    ',
                  1PE13.3,'(',0PF5.1,'%)'/
            /' FRACTION OF PARTICLES INTO 4-PI WHICH CAUSE A PULSE =          ',
                  1PE13.3,'(',0PF5.1,'%)'/
            /' FRACTION OF PARTICLES INCIDENT ON HOUSING WHICH CAUSE A PULSE =',
                  1PE13.3,'(',0PF5.1,'%)');
70   FORMAT(/'  ENERGY DEPOSITED IN DETECTOR PER INITIAL PARTICLE:',
             0PF14.5,' MeV (+-',F6.3,'%)');
75   FORMAT(1X,80A1);
80   FORMAT(I5,T40,'# energy bins to follow, bin top,cts/MeV,uncertainty(abs)');
90   FORMAT(3(E12.4,','));
100  FORMAT( 1X,'NOW INDIVIDUAL PEAK AND TOTAL EFFICIENCIES'/ (2E12.4));

RETURN;END;

%E     "dosrznrc.mortran"
"******************************************************************************
"
"                       PLOTSN
"
"       THIS ROUTINE WILL PREPARE A PLOT AND/OR FILE OF DATA POINTS OF
"       DOSE VS. DEPTH CORRESPONDING TO A NUMBER OF CHOSEN RADIAL AND
"       PLANAR ZONES
"
"
"  PLOT CONTROL DELIMETERS:   :start plot control:
"                             :stop plot control:
"
"*******************************************************************************
"                             PLOT CONTROL INPUTS
"                             *******************
"*******************************************************************************
"
"CARD PL1
"
"   PLOTTING
"          = Off         (0)   NO PLOTS OR PLOT FILES TO BE PREPARED
"          = On          (1)   PLOTTING TO BE PREPARED OR PRINTED
"
"
"CARD PL2       (ONLY IF   PLOTTING= On)
"
"   LINE PRINTER OUTPUT
"          = Off         (0)   DON'T PLOT IN EXECUTION OUTPUT
"          = On          (1)   DO PLOT IN EXECUTION OUTPUT
"
"
"CARD PL3       (ONLY IF   PLOTTING= On)
"
"   EXTERNAL PLOTTER OUTPUT
"          = Off         (0)   DON'T PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
"          = On          (1)   PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
"
"
"CARD PL4       (ONLY IF   EXTERNAL PLOTTER OUTPUT= On)
"
"   EXTERNAL PLOT TYPE
"          = Point       (1)   POINT PLOT ON EXTERNAL PLOTTER
"          = Histogram   (2)   HISTOGRAM ON EXTERNAL PLOTTER
"          = Both        (3)   BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
"
"
"CARD PL5       (ONLY IF   PLOTTING= On)
"
"   PLOT RADIAL REGION IX  (M)  RADIAL PLANE NUMBERS TO PLOT
"                               (= 0 FOR NO PLOTS)
"
"
"CARD PL6       (ONLY IF   PLOTTING= On)
"
"   PLOT PLANAR REGION IZ  (M)  PLANAR SLAB NUMBERS TO PLOT
"                               (= 0 FOR NO PLOTS)
"
"
"       VERSION 01      ADAPTED FROM DOSRZ                           6/84  E.F.
"       VERSION 02      MACHINE-INDEPENDENT VARIABLE FORMAT CODED   10/88  AFB
"       VERSION 03      NEW INPUT ROUTINE (GET_INPUTS)              04/25 AM/DR
"
"
"*******************************************************************************
;SUBROUTINE PLOTSN;

$IMPLICIT-NONE;

COMIN/GetInput/;

"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
INTEGER NUM_IOPLOT,
        NUM_IPLTLP,
        NUM_IPLTPL,
        NUM_IPLPHB,
        NUM_IPLTRAD,
        NUM_IPLTPLN;
"--------------------------------------------------------------------------"
;
INTEGER I;
INTEGER ICOL1, ICOL2, NPTS, PLTYPE, IAXISTYPE, UNITNUM, CURVENUM, CHECK;
integer int;
INTEGER IX2CHAR, IZ2CHAR;
LOGICAL NEGVAL;
CHARACTER*103 FMT120;
CHARACTER*103 FMT121;
CHARACTER*4 CH_IX, CH_IZ;
CHARACTER*1 a(3);
CHARACTER*60 SERIESTITLE, XTITLE, YTITLE, SUBTITLE;
CHARACTER*80 GRAPHTITLE;
"CHARACTER*103 CMPRES,FMT;"
CHARACTER CMPRES*103,FMT*103;
$REAL XCOORD($PLTDIM), YCOORD($PLTDIM), UNCERT($PLTDIM);
$TYPE HCHAR,PCHAR;
$TYPE DIGITS(10);
COMIN/GEOM,IODAT1,IODAT2,PRINTC,PLOTC,SCORE,USER/;

" Added declarations for implicit none, IK Jan 5 2000"
$INTEGER IPLTUNX,IPLTUN,J,IZD,IXD,NPPAGE,IX,ICOUNT,IXR,IZ,IZZ;
$REAL    TDSMAX,HISTXMIN;

$INTEGER egs_open_file;

DATA DIGITS /'0','1','2','3','4','5','6','7','8','9'/;
DATA HCHAR/'H'/,PCHAR/'P'/;

" IK: "
" With the new EGSnrc version we can not any longer rely on variables "
" being static. I'm too lazy to figure out which variables need to be "
" static here => save them all"
save NUM_IOPLOT,NUM_IPLTLP,NUM_IPLTPL,NUM_IPLPHB,NUM_IPLTRAD,NUM_IPLTPLN,
     I,ICOL1, ICOL2, NPTS, PLTYPE, IAXISTYPE, UNITNUM, CURVENUM, CHECK,
     IX2CHAR, IZ2CHAR, NEGVAL, FMT120, FMT121, CH_IX, CH_IZ, a,
     SERIESTITLE, XTITLE, YTITLE, SUBTITLE, FMT,
     XCOORD,YCOORD,UNCERT,HCHAR,PCHAR,DIGITS,
     IPLTUNX,IPLTUN,J,IZD,IXD,NPPAGE,IX,ICOUNT,IXR,IZ,IZZ,
     TDSMAX,HISTXMIN,int;

"CHARACTER ARRAYS REQUIRED FOR RUN-TIME FORMATTING"
;

"THE <> SYNTAX IS VALID VAX-ENTENDED FORTRAN AND MAY BE USED DIRECTLY."
"FOR STANDARD FORTRAN, THE <> STRUCTURES ARE REPLACED DURING EXECUTION."
;
%F
      DATA FMT120/
     *'(1X,F7.3,T10,''|'',T35,''|'',T59,''|'',T83,''|'',T107,
     *''|'',T131,''|'',T<ICOL2+10>,''S'',T<ICOL1+10>,''T'')'/
      DATA FMT121/
     *'(1X,F7.3,T10,''+'',T35,''+'',T59,''+'',T83,''+'',T107,
     *''+'',T131,''+'',T<ICOL2+10>,''S'',T<ICOL1+10>,''T'')'/
%M
;

DELIMETER='PLOT CONTROL';

IVAL=0;
IVAL=IVAL+1;
NUM_IOPLOT=IVAL;
VALUES_SOUGHT(IVAL)='PLOTTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';
$GET_INPUT(NUM_IOPLOT);
IOPLOT=VALUE(NUM_IOPLOT,1);

OUTPUT;(/' *** INPUT for plotting ***');
IF (IOPLOT.EQ.1) [OUTPUT;(/'PLOTTING WILL BE DONE');]

IF(IOPLOT.EQ.0)[
    OUTPUT;(/' NO PLOTTING OR PLOT PREPARATION WILL BE DONE');
]
ELSE [
   OUTPUT;(//' *** INPUT which types of plots ***');

   IVAL=IVAL+1;
   NUM_IPLTLP=IVAL;
   VALUES_SOUGHT(IVAL)='LINE PRINTER OUTPUT';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=3;
   ALLOWED_INPUTS(IVAL,0)='OFF';
   ALLOWED_INPUTS(IVAL,1)='ON';

   $GET_INPUT(NUM_IPLTLP);
   IPLTLP=VALUE(NUM_IPLTLP,1);

   IF(IPLTLP=0) [OUTPUT;(/' NO LINEPRINTER PLOTS WILL BE DRAWN');]
   ELSE [OUTPUT;(/' LINEPRINTER PLOTS WILL BE DRAWN');]

   IVAL=IVAL+1;
   NUM_IPLTPL=IVAL;
   VALUES_SOUGHT(IVAL)='EXTERNAL PLOTTER OUTPUT';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=3;
   ALLOWED_INPUTS(IVAL,0)='OFF';
   ALLOWED_INPUTS(IVAL,1)='ON';

   $GET_INPUT(NUM_IPLTPL);
   IPLTPL=VALUE(NUM_IPLTPL,1);

   IF (IPLTPL=0) [OUTPUT;(/' No plotter files will be prepared');]
   ELSE [
      OUTPUT;(/' Files will be prepared for external plotter');
      IPLTUNX=23; "xvgr plot file"
      IPLTUN=3; "OUTPUT TO UNIT 3 FOR PLOTTER"
      OUTPUT;(/' *** INPUT type of plot ***');

      IVAL=IVAL+1;
      NUM_IPLPHB=IVAL;
      VALUES_SOUGHT(IVAL)='EXTERNAL PLOT TYPE';
      NVALUE(IVAL)=1;
      TYPE(IVAL)=3;
      ALLOWED_INPUTS(IVAL,1)='POINT';
      ALLOWED_INPUTS(IVAL,2)='HISTOGRAM';
      ALLOWED_INPUTS(IVAL,3)='BOTH';

      $GET_INPUT(NUM_IPLPHB);
      IPLPHB=VALUE(NUM_IPLPHB,1);

      OUTPUT IPLPHB;
      (/' POINT PLOT(1)/HISTOGRAM(2)/BOTH(3) WILL BE PREPARED:',I2);
   ]

   OUTPUT;(/' *** INPUT which plots to do ***');

   IVAL=IVAL+1;
   NUM_IPLTRAD=IVAL;
   VALUES_SOUGHT(IVAL)='PLOT RADIAL REGION IX';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NR;
   DEFAULT(IVAL)=NR;
   NVALUE(IVAL)=0;

   $GET_INPUT(NUM_IPLTRAD);
   NPLOTR=NVALUE(NUM_IPLTRAD);
   IF (VALUE(NUM_IPLTRAD,1) > 0) [
      DO J=1, NPLOTR [
         IPLOTR(J)=VALUE(NUM_IPLTRAD,J);
         IF (IPLOTR(J).LT.NRDMIN+1.OR.IPLOTR(J).GT.NRDMAX) [
            OUTPUT IPLOTR(J);(
            ' ******************************************************'/
            ' ** WARNING: DOSE IS NOT SCORED IN RADIAL REGION ',I3,' **'/
            ' **          DOSE WILL NOT BE PLOTTED FOR THIS REGION *'/
            ' ******************************************************'/)
            IPLOTR(J)=0;
         ]
         ELSE[
            OUTPUT IPLOTR(J);('PLOTTING RADIAL ZONE ', I3);
            IPLOTR(J)=IPLOTR(J)-NRDMIN;
         ]

      ]
      $SKIP-LINE;
   ]
   ELSE [NPLOTR=0;]

   IVAL=IVAL+1;
   NUM_IPLTPLN=IVAL;
   VALUES_SOUGHT(IVAL)='PLOT PLANAR REGION IZ';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NZ;
   DEFAULT(IVAL)=NZ;
   NVALUE(IVAL)=0;

   $GET_INPUT(NUM_IPLTPLN);
   NPLOTZ=NVALUE(NUM_IPLTPLN);
   IF (VALUE(NUM_IPLTPLN,1) > 0) [
      DO J=1, NPLOTZ [
         IPLOTZ(J)=VALUE(NUM_IPLTPLN,J);
         IF (IPLOTZ(J).LT.NZDMIN.OR.IPLOTZ(J).GE.NZDMAX) [
            OUTPUT IPLOTZ(J);(
            ' ******************************************************'/
            ' ** WARNING: DOSE IS NOT SCORED IN PLANAR REGION ',I3,' **'/
            ' **          DOSE WILL NOT BE PLOTTED IN THIS REGION **'/
            ' ******************************************************'/)
            IPLOTZ(J)=0;
         ]
         ELSE[
            OUTPUT IPLOTZ(J);('PLOTTING PLANAR ZONE ', I3);
            IPLOTZ(J)=IPLOTZ(J)-NZDMIN+1;
         ]

      ]
      $SKIP-LINE;
   ]
   ELSE [NPLOTZ=0;]
]  "END IOPLOT = 1"

RETURN;

ENTRY PLOTEN;
"============"

"CALL PRNTER(16,6,IOUT,0);"

TDSMAX=0.0;
DO IZD=1,NZDOSE[
    DO IXD=1,NRDOSE[
        "GET GLOBAL MAXIMUM"
        IF(TDSMAX.LT.SCDOSE(IZD,IXD,1))[TDSMAX=SCDOSE(IZD,IXD,1);]
    ]
]

IF(IPLTLP.EQ.1)[ "Do lineprinter plots"
    IF(NPLOTR.NE.0)[
        "PLOT DEPTH-DOSE"
        write(iout,100) title; call egs_fdate(iout); write(iout,106) tdsmax;

        " ********** IK: using wrapper for date and time routines.
        " Was:
        " WRITE(IOUT,100)TITLE,TIMEN,DATEN,TDSMAX;

        IF(TDSMAX.EQ.0.0)[WRITE(IOUT,130);RETURN; "NO DATA TO PLOT"]
        NPPAGE=(66-3-2)/(4+NZDOSE);
        IX=1;ICOUNT=0;
        DO IXR=1,NPLOTR[
          IX=IPLOTR(IXR);
          IF(IX>0)[
            IF(ICOUNT.GE.NPPAGE)[
                ICOUNT=0;
                write(iout,100); call egs_fdate(iout); write(iout,106) tdsmax;
                " ********** IK: using wrapper for date and time routines.
                " Was:
                " WRITE(IOUT,100)TITLE,TIMEN,DATEN,TDSMAX;
            ]
            ICOUNT=ICOUNT+1;
            IF((ISOURC.EQ.2).OR.(ISOURC.EQ.4))[WRITE(IOUT,110) RCYL(IX+NRDMIN);]
            ELSE[WRITE(IOUT,102)IX+NRDMIN,RCYL(IX+NRDMIN);]
            DO IZ=1,NZDOSE[
                ICOL1=IDINT(SCDOSE(IZ,IX,1)/TDSMAX*120.+.999);
                ICOL2=IDINT(SCDOSE(IZ,IX,2)/TDSMAX*120.+.999);
                IF(MOD(IZ,5).NE.0)[
                 WRITE(FMT120(72:81),'(I10)')ICOL2+10;
                 WRITE(FMT120(88:97),'(I10)')ICOL1+10;
                    FMT=CMPRES(FMT120);
                    WRITE(IOUT,FMT)ZPLANE(IZ+NZDMIN);
                    ]
                ELSE[
                 WRITE(FMT121(72:81),'(I10)')ICOL2+10;
                 WRITE(FMT121(88:97),'(I10)')ICOL1+10;

                    FMT=CMPRES(FMT121);
                    WRITE(IOUT,FMT)ZPLANE(IZ+NZDMIN);
                    ]
                ]
            ]
          ]
        ]

    "PLOT RADIUS-DOSE"

    IF(NPLOTZ.NE.0)[
        write(iout,100); call egs_fdate(iout); write(iout,106) tdsmax;
        " ********** IK: using wrapper for date and time routines.
        " Was: WRITE(IOUT,100) TITLE,TIMEN,DATEN,TDSMAX;
        NPPAGE=(66-3-2)/(4+NRDOSE);
        IZ=1;ICOUNT=0;
        DO IZZ=1,NPLOTZ[
          IZ=IPLOTZ(IZZ);
          IF(IZ>0)[
            IF(ICOUNT.GE.NPPAGE)[
                ICOUNT=0;
                write(iout,100); call egs_fdate(iout); write(iout,106) tdsmax;
                " ********** IK: using wrapper for date and time routines.
                " Was: WRITE(IOUT,100)TITLE,TIMEN,DATEN,TDSMAX;
            ]
            ICOUNT=ICOUNT+1;
            WRITE(IOUT,103)IZ+NZDMIN-1,ZPLANE(IZ+NZDMIN-1),ZPLANE(IZ+NZDMIN);
            DO IX=1,NRDOSE[
                ICOL1=IDINT(SCDOSE(IZ,IX,1)/TDSMAX*120.+.999);
                ICOL2=IDINT(SCDOSE(IZ,IX,2)/TDSMAX*120.+.999);
                IF(MOD(IX,5).NE.0)[
                 WRITE(FMT120(72:81),'(I10)')ICOL2+10;
                 WRITE(FMT120(88:97),'(I10)')ICOL1+10;

                    FMT=CMPRES(FMT120);
                    WRITE(IOUT,FMT)RCYL(IX+NRDMIN);
                    ]
                ELSE[
                 WRITE(FMT121(72:81),'(I10)')ICOL2+10;
                 WRITE(FMT121(88:97),'(I10)')ICOL1+10;

                    FMT=CMPRES(FMT121);
                    WRITE(IOUT,FMT)RCYL(IX+NRDMIN);
                    ]
                ]
            ]
          ]
        ]
] "end of lineprinter plots"

"IPLPHB     = 1  point plot on external plotter
"           = 2  histogram on external plotter
"           = 3  do both

IF(IPLTPL.EQ.1) [ "plots for external plotter (0 if none)"

    DO I=1,80[GRAPHTITLE(I:I)=TITLE(I);]

    J=0; "J keeps track of which plot we are on"
    CURVENUM=0;  "counter for the curve # of the graph"
    IF(NPLOTR > 0) [ "there are depth-dose plots on plotter"
        IPLTUNX = egs_open_file(23,0,1,'_dd.plotdat');
        "write to unit IPLTUNX "
        DO IXR=1,NPLOTR [
          IX=IPLOTR(IXR);
          IF(IX>0)[

            " For point plots "

            IF((IPLPHB.EQ.1).OR.(IPLPHB.EQ.3)) [ "do point plot"
                "Put out a data set to be read by xvgr: AM Jan 98"
                DO IZ = 1, NZDOSE [
                    XCOORD(IZ) = (ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;
                    YCOORD(IZ) = SCDOSE(IZ,IX,1);
                    UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
                ]

                "Convert radial zone number(IX) to a character string"
                IX2CHAR=IX+NRDMIN; $CONVERT_INT(IX2CHAR)_TO_CHAR(CH_IX);

                "For complete summary of the following variables see"
                "xvgrplot.mortran"

                NPTS=NZDOSE;            "number of points per graph"
                SERIESTITLE='dose at r # ' // CH_IX;
                XTITLE='depth/cm';
                IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
                  YTITLE='dose per incident particle/Gy';
                ]
                ELSE[
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N';
                ]
                " --------------------------> "
                call egs_get_fdate(SUBTITLE);
                SUBTITLE='dose vs. depth on '//SUBTITLE(1:24);
                UNITNUM=IPLTUNX;        "Output file"
                PLTYPE=0;               "histogram=1, XY-plot=0"
                HISTXMIN=ZPLANE(1);     "value of lower X-bin (histograms only)"
                IAXISTYPE=0;            "0 for no logs"

                "plot XY-graph"
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                CURVENUM=CURVENUM+1;

                IF(IKERMA = 1)["scored kerma so plot it too"

                   "set up the arrays that are to be passed to XVGR"
                   DO IZ=1, NZDOSE [
                        XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;
                        YCOORD(IZ)=SCKERMA(IZ,IX,1);
                        UNCERT(IZ)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
                    ]

                    NPTS=NZDOSE;
                    SERIESTITLE='kerma at r # ' // CH_IX;

                    "plot XY-graph"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                    DO IZ=1, NZDOSE [
                        XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;
                        IF(SCKERMA(IZ,IX,1)~=0.0)[
                          YCOORD(IZ)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
                          UNCERT(IZ)=SCDOSEtoKERMA2(IZ,IX,1)*
                                   (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
                        ]
                        ELSE[
                          YCOORD(IZ)=0.;
                          UNCERT(IZ)=0.;
                        ]
                    ]

                    NPTS=NZDOSE;
                    SERIESTITLE='dose/kerma at r # ' // CH_IX;

                    "plot XY-graph"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                ] "end IKERMA = 1 block within point plots"

            ] "end of IPLPHB=1 OR 3 i.e. end of point plots

            "Now plot histograms if requested"

            IF((IPLPHB.EQ.2).OR.(IPLPHB.EQ.3)) ["do histograms"
                "Put out a data set to be read by xvgr  AM Jan 98"
                DO IZ = 1, NZDOSE [
                    XCOORD(IZ) = ZPLANE(IZ+NZDMIN);
                    YCOORD(IZ) = SCDOSE(IZ,IX,1);
                    UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
                    "absolute uncertainty needed for plotting"
                ]

                "Convert radial zone number(IX) to a character string"
                IX2CHAR=IX+NRDMIN; $CONVERT_INT(IX2CHAR)_TO_CHAR(CH_IX);

                "For complete summary of the following variables see"
                "xvgrplot.mortran"

                NPTS=NZDOSE;            "number of points per graph"
                SERIESTITLE='dose at r # ' // CH_IX;
                XTITLE='depth/cm';
                IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
                  YTITLE='dose per incident particle/Gy';
                ]
                ELSE[
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N';
                ]
                " ----------------------- >
                call egs_get_fdate(SUBTITLE);
                SUBTITLE='dose vs. depth on '//SUBTITLE(1:24);
                UNITNUM=IPLTUNX;        "Output file"
                PLTYPE=1;               "histogram=1, XY-plot=0"
                HISTXMIN=ZPLANE(1);     "value of lower X-bin(for HIST. only)"
                IAXISTYPE=0;            "0 for no logs"

                "plot histogram"
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                CURVENUM=CURVENUM+1;

                IF(IKERMA = 1)[  "plot kerma results too if there"
                    "set up the arrays that are to be passed to XVGR"
                    DO IZ=1, NZDOSE [
                        XCOORD(IZ)=ZPLANE(IZ+NZDMIN);
                        YCOORD(IZ)=SCKERMA(IZ,IX,1);
                        UNCERT(IZ)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
                    ]

                    NPTS=NZDOSE;
                    SERIESTITLE='kerma at r # ' // CH_IX;

                    "plot histogram"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                    "now plot ratio of D on K "

                    DO IZ=1, NZDOSE [
                        "XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;"
                        XCOORD(IZ)=ZPLANE(IZ+NZDMIN);  "fixed July 2011 DWOR"
                        IF(SCKERMA(IZ,IX,1)~=0.)[
                           YCOORD(IZ)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
                           UNCERT(IZ)=SCDOSEtoKERMA2(IZ,IX,1)*
                                   (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
                        ]
                        ELSE[ "kerma = 0 case" YCOORD(IZ)=0.;UNCERT(IZ)=0.;]
                    ]

                    NPTS=NZDOSE;
                    SERIESTITLE='dose/kerma at r # ' // CH_IX;

                    "plot histogram"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                ]"end of kerma output"
           ] "END OF IPLPHB=2 OR 3"
         ] "END OF IF IX>0"
       ] "END OF IXR LOOP"
       close(23);
    ] "end of NPLOTR.NE.0"

    CURVENUM=0;
    IF(NPLOTZ > 0) [ "RADIAL PLOTS FOR PLOTTER"
        IPLTUNX = egs_open_file(23,0,1,'_rad.plotdat');
        DO IZZ=1,NPLOTZ [
          IZ=IPLOTZ(IZZ);
          IF(IZ>0)[
            IF((IPLPHB.EQ.1).OR.(IPLPHB.EQ.3)) [
                "POINT PLOTS"
                "Put out a data set to be read by xvgr  AM Jan 98"
                "OPEN(UNIT=IPLTUNX, file='fort.23', STATUS='UNKNOWN');"

                "set up the arrays that are to be passed to XVGR"
                DO IX = 1, NRDOSE ["recall NRDMIN default is 0 check?"
                    "rcyl(0) is handled below as HISTXMIN"
                    "this is for point plots"
                    XCOORD(IX) = (RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;
                    YCOORD(IX) = SCDOSE(IZ,IX,1);
                    UNCERT(IX) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
                ]

                "Convert planar zone number(IZ) to a character string"
                IZ2CHAR=IZ+NZDMIN-1; $CONVERT_INT(IZ2CHAR)_TO_CHAR(CH_IZ);

                "For complete summary of the following variables see"
                "XVGRPLOT.MORTRAN"

                NPTS=NRDOSE;            "number of points per graph"
                SERIESTITLE='dose at z # ' // CH_IZ;
                XTITLE='radius/cm';
                IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
                  YTITLE='dose per incident particle/Gy';
                ]
                ELSE[
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N';
                ]
                " -------------------------- >
                call egs_get_fdate(SUBTITLE);
                SUBTITLE='dose vs. radius on '//SUBTITLE(1:24);
                UNITNUM=IPLTUNX;        "Output file"
                PLTYPE=0;                 "histogram=1, XY-plot=0"
                HISTXMIN=RCYL(NRDMIN);       "value of lower X-bin(HIST only)"
                IAXISTYPE=0;             "0 for no logs"

                "plot XY-graph"
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                CURVENUM=CURVENUM+1;

                IF(IKERMA = 1)[
                   "set up the arrays that are to be passed to XVGR"
                   "we are doing point plots"
                   DO IX=1, NRDOSE [
                        XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;
                        YCOORD(IX)=SCKERMA(IZ,IX,1);
                        UNCERT(IX)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
                    ]

                    SERIESTITLE='kerma at z # ' // CH_IZ;

                    "plot kerma plot"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                    "now plot dose/kerma"
                    DO IX=1, NRDOSE [
		        "following redundant since use same values as just above"
                        "XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;"
                        IF(SCKERMA(IZ,IX,1)~=0.)[
                          YCOORD(IX)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
                          UNCERT(IX)=SCDOSEtoKERMA2(IZ,IX,1)*
                                     (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
                                     "SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)*100.;
                        ]
                        ELSE[ YCOORD(IX)=0.; UNCERT(IX)=0.; ]
                    ]

                    SERIESTITLE='dose/kerma at z # ' // CH_IZ;

                    "plot dose/kerma graph"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                ]"end of kerma plot"
            ] "END OF IPLPHB=1 OR 3 LOOP for point plots"

            IF((IPLPHB.EQ.2).OR.(IPLPHB.EQ.3)) [ "now do histogram plots"
                "Put out a data set to be read by xvgr  AM Jan 98"
                DO IX = 1, NRDOSE [
                    XCOORD(IX) = RCYL(NRDMIN+IX);
                    YCOORD(IX) = SCDOSE(IZ,IX,1);
                    UNCERT(IX) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
                ]

                "Convert planar zone number(IZ) to a character string"
                IZ2CHAR=IZ+NZDMIN-1; $CONVERT_INT(IZ2CHAR)_TO_CHAR(CH_IZ);

                "For complete summary of the following variables see"
                "XVGRPLOT.MORTRAN"

                NPTS=NRDOSE;            "number of points per graph"
                SERIESTITLE='dose at z # ' // CH_IZ;
                XTITLE='radius/cm';
                IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
                  YTITLE='dose per incident particle/Gy';
                ]
                ELSE[
                  YTITLE='dose per incident fluence/Gy cm\\S2\\N';
                ]
                " ------------------------- >
                call egs_get_fdate(SUBTITLE);
                SUBTITLE='dose vs radius on '//SUBTITLE(1:24);
                UNITNUM=IPLTUNX;        "Output file"
                PLTYPE=1;                 "histogram=1, XY-plot=0"
                HISTXMIN=RCYL(NRDMIN);       "value of lower X-bin"
                IAXISTYPE=0;             "0 for no logs"
                "plot histogram"
                CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                CURVENUM=CURVENUM+1;

                IF(IKERMA = 1)[
                   "set up the arrays that are to be passed to XVGR"
                   "this is the histogram block"
                   DO IX=1, NRDOSE [
                        XCOORD(IX) = RCYL(NRDMIN+IX);
                        "XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;"
                        YCOORD(IX)=SCKERMA(IZ,IX,1);
                        UNCERT(IX)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
                    ]

                    SERIESTITLE='kerma at z # ' // CH_IZ;

                    "plot kerma histogram"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                    "now plot kerma/dose histograms"
                    DO IX=1, NRDOSE [
                        "following wrong and redundant -use value just above"
                        "XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;"
                        IF(SCKERMA(IZ,IX,1)~=0.)[
                          YCOORD(IX)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
                          UNCERT(IX)=SCDOSEtoKERMA2(IZ,IX,1)*
                                     (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
                                     "SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)*100.;
                        ]
                        ELSE[
                          YCOORD(IX)=0.;
                          UNCERT(IX)=0.;
                        ]
                    ]

                    SERIESTITLE='dose/kerma at z # ' // CH_IZ;

                    "plot histogram"
                    CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                               NPTS, CURVENUM, SERIESTITLE,
                               XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                               UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);

                    CURVENUM=CURVENUM+1;

                ]"end of kerma plot"
            ] "END OF IPLPHB=2 OR 3"
          ] "END OF IF IZ>0"
        ] "END OF IZZ LOOP"
        close(23)
    ] "END CONDITIONAL BLOCK FOR RADIAL PLOTS"

] "END OF IPLTPL=1"

RETURN;
%I0
100   FORMAT(' ',80A1/
        /' NRC CALCULATION USING DOSRZnrc '$VERSION' ',40X, $);
106   FORMAT(///' ',T60,'SCALED TO A MAX OF',1PE11.4,' Gy.cm**2');

" ********** IK: using wrapper for date and time routines.
" Was:
" 100   FORMAT(' ',80A1/
"              /' NRC CALCULATION USING DOSRZnrc '$VERSION' ',40X,
"                  $TIMEN_FORMAT,1X,$DATEN_FORMAT/
"              /' ',T60,'SCALED TO A MAX OF',1PE11.4,' Gy.cm**2');

102   FORMAT(' '///
             ' ',11X,' DEPTH/DOSE PLOT FOR RADIAL DOSE ZONE #',I2
                ,' TO RADIUS',F10.3);
103   FORMAT(' '///
             ' ',11X,' RADIUS/DOSE PLOT FOR PLANAR DOSE REGION #',I2,
                ' FROM',F10.3,' TO',F10.3,' cm');
110   FORMAT(////
             ' ',14X,'CENTRAL AXIS DEPTH-DOSE FOR BEAM RADIUS',F12.3,' cm');
130   FORMAT(' MAXIMUM DOSE = 0.000, NO PLOTTING WILL BE DONE');

END;  "LAST LINE OF SUBROUTINE PLOTSN"

"The following is the $CALL-HOWNEAR macro for PRESTA-II
REPLACE {$CALL-HOWNEAR(#);} WITH
{
    call hownear({P1},x(np),y(np),z(np),ir(np));
}

subroutine hownear(tperp,x,y,z,ir);

$IMPLICIT-NONE;

COMIN/GEOM/;

"Subroutine arguments
$REAL
    tperp, "nearest distance to any boundary (output)
    x,     "x-position of the particle (input)
    y,     "y-position of the particle (input)
    z      "z-position of the particle (input)
;
$INTEGER
    ir     "region number of the particle
;

"Local variables

$REAL
    r "cylindrical radius
;
$INTEGER
    ix, "current cylindrical radius number
    iz  "current planar slab number
;
r = sqrt(x**2 + y**2);
ix = (ir - 2)/nz + 1;
iz = ir - 1 - nz*(ix - 1);
tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r);
IF(ix ~= 1)
[
    tperp = min(tperp,r - rcyl(ix - 1));
]

return;
end;

subroutine combine_results(file_name);
implicit none;
character*(*) file_name;
;COMIN/SCORE,RANDOM,IODAT2,GEOM,SOURCE/;

$INTEGER egs_get_unit,lnblnk1;
$INTEGER ix,iz,it,ib,iorstrt,ipk,iout,itmax;
REAL*8 TEMPSCSTP, TEMPSCSTP2, TEMPSCDSTP, TEMPSCDSTP2,
       TEMPSCR8($MAXZREG,$MAXRADII,$MAXIT),TEMPSCPDST($EBIN),
       TEMPSCPDST2($EBIN),TEMPSCPCUM($EBIN),TEMPSCPCUM2($EBIN),
       TEMPSCOMEG, TEMPSCOMEG2, TEMPSCPK(4), TEMPSCPK2(4),
       TEMPPIISTP;
$REAL TEMPNCASE,TEMPTMCPU;
$LONG_INT TEMPNNREAD;

$LOGICAL first_time;
data first_time/.true./;
save first_time;


iout = 1;
IF((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))[ITMAX=2;]
ELSE[ITMAX=$MAXIT;]

IF( first_time ) [

    first_time = .false.;

    OUTPUT ;(/1X,'Summing the following .egsdat files');
    OUTPUT ; (1X,'------------------------------------'/);
    WRITE(IOUT,'(/1X,''Summing .egsdat files'')');
    WRITE(IOUT,'(1X,''---------------------''/)');

    /SCSTP,SCSTP2,PIISTP,SCDSTP,SCDSTP2/=0;
    /TMCPUO,NCASEO,NNREAD,SCOMEG,SCOMEG2/=0;

    DO iz=1,nzdose [ DO ix = 1,nrdose [ DO it = 1,itmax [
        /SCDOSE(IZ,IX,IT),SCDOSE2(IZ,IX,IT)/=0;
        /SCKERMA(IZ,IX,IT),SCKERMA2(IZ,IX,IT)/=0;
        SCDOSEtoKERMA2(IZ,IX,IT)=0;
    ] ] ]
    DO ib=1,MAXBIN [ /SCPDST(IB),SCPDST2(IB)/=0; ]
    DO ipk=1,4 [
        /SCDFEP(IPK),SCDFEP2(IPK),SCDFBK(IPK),SCDFBK2(IPK)/=0;
        /SCDFDIFF(IPK),SCDFDIFF2(IPK)/=0;
    ]
    DATCOUNT=0;
]

IORSTRT = egs_get_unit(4);
WRITE(IOUT,'(A)') $cstring(file_name);
WRITE(6,'(A)') $cstring(file_name);
open(IORSTRT,file=file_name,status='old',err=:EOF_RS1:);

DATCOUNT=DATCOUNT+1;

READ(IORSTRT,*)TEMPSCSTP,TEMPSCSTP2,TEMPSCDSTP,TEMPSCDSTP2,TEMPPIISTP;
SCSTP=SCSTP+TEMPSCSTP; SCSTP2=SCSTP2+TEMPSCSTP2; PIISTP=PIISTP+TEMPPIISTP;
SCDSTP=SCDSTP+TEMPSCDSTP; SCDSTP2=SCDSTP2+TEMPSCDSTP2;

READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
    DO IT=1,ITMAX[ SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT); ]
] ]
READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
    DO IT=1,ITMAX[ SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT); ]
] ]
IF(IKERMA=1)[
    READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
    DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
        DO IT=1,ITMAX[ SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT); ]
    ] ]
    READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
    DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
        DO IT=1,ITMAX[
            SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT);
        ]
    ] ]
    READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
    DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
        DO IT=1,ITMAX[
            SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+
                                          TEMPSCR8(IZ,IX,IT);
        ]
    ] ]
]
IF(IFULL=2)[
    READ(IORSTRT,*)(TEMPSCPDST(IB),TEMPSCPDST2(IB),IB=1,MAXBIN);
    READ(IORSTRT,*)(TEMPSCPCUM(IB),TEMPSCPCUM2(IB),IB=1,MAXBIN);
    DO IB=1,MAXBIN[
        SCPDST(IB)=SCPDST(IB)+TEMPSCPDST(IB);
        SCPDST2(IB)=SCPDST2(IB)+TEMPSCPDST2(IB);
        SCPCUM(IB)=SCPCUM(IB)+TEMPSCPCUM(IB);
        SCPCUM2(IB)=SCPCUM2(IB)+TEMPSCPCUM2(IB);
    ]
    READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4);
    DO IPK=1,4[
        SCDFEP(IPK)=SCDFEP(IPK)+TEMPSCPK(IPK);
        SCDFEP2(IPK)=SCDFEP2(IPK)+TEMPSCPK2(IPK);
    ]
    READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4);
    DO IPK=1,4[
        SCDFBK(IPK)=SCDFBK(IPK)+TEMPSCPK(IPK);
        SCDFBK2(IPK)=SCDFBK2(IPK)+TEMPSCPK2(IPK);
    ]
    READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4);
    DO IPK=1,4[
        SCDFDIFF(IPK)=SCDFDIFF(IPK)+TEMPSCPK(IPK);
        SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+TEMPSCPK2(IPK);
    ]
]
$RETRIEVE RNG STATE FROM UNIT IORSTRT;
READ(IORSTRT,*) TEMPNCASE,TEMPTMCPU,TEMPNNREAD;
TMCPUO=TMCPUO+TEMPTMCPU;
NCASEO=NCASEO+TEMPNCASE;
NNREAD=NNREAD+TEMPNNREAD;
write(6,*) '  ncase = ',TEMPNCASE,' cpu = ',TEMPTMCPU,' total cpu = ',
  TMCPUO;
write(iout,*) '  ncase = ',TEMPNCASE,' cpu = ',TEMPTMCPU,' total cpu = ',
  TMCPUO;
READ(IORSTRT,*,END=:OMEGA-NOT-THERE1:) TEMPSCOMEG,TEMPSCOMEG2;
SCOMEG=SCOMEG+TEMPSCOMEG;
SCOMEG2=SCOMEG2+TEMPSCOMEG2;
goto :OMEGA-THERE1:;
:OMEGA-NOT-THERE1:
OUTPUT;('  Warning: Solid angle information not in data file');
OUTPUT;('           This may cause errors in absolute normalizations!');
:OMEGA-THERE1:
CLOSE(UNIT=IORSTRT);
return;
:EOF_RS1:;
WRITE(6,*) 'Error opening file', $cstring(file_name);
return; end;
