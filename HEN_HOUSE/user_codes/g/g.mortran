%C80
"#############################################################################"
"                                                                             "
"  EGSnrc g application                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2000                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Ernesto Mainegra-Hing                                     "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  An EGSnrc application to calculate the energy fraction lost to radiation   "
"  when electrons slow down (if the incident beam is photons, or the          "
"  radiative yield (if the incident beam is electrons). Calculates quantities "
"  such as mu_tr, mu_en and g-bar (the average fraction of energy lost to     "
"  radiation needed for the calculation of mu_en).                            "
"                                                                             "
"  Implemented a type=1 calculation that can run until a prescribed accuracy  "
"  is reached at any stage during the calculation. In a type=1 calculation    "
"  mu_tr is calculated first, then mu_en is obtained from mu_en = mu_tr*(1-g),"
"  where g is the fraction lost to radiation from slowing down electrons. The "
"  advantage is that when g is small, mu_en converges much faster to the      "
"  desired accuracy compared to a type=0 calculation.                         "
"                                                                             "
"#############################################################################"


%L
%E
!INDENT M 4;    "indent each mortran nesting level by 4"
!INDENT F 2;    "indent each fortran nesting level by 2"

"This line is 80 characters long, use it to set up the screen width"
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789"

"*********************************************************************"
"                                                                     "
"                     **********************                          "
"                     *                    *                          "
"                     *     g.mortran      *                          "
"                     *                    *                          "
"                     **********************                          "
"                                                                     "
" An EGSnrc user code. It calculates the energy fraction lost to      "
" radiation when electrons slow down, if the incident beam is photons,"
" or the radiative yield, if the incident beam is electrons.          "
" For photons, the code also calculates mu_tr and mu_en.              "
"                                                                     "
" Version 1.0  I. Kawrakow, January 2000                              "
" Version 1.1  I. Kawrakow, March 2002 (added E*mu_tr and E*mu_en)    "
" Version 1.2  D. Rogers, June 2002 (get mu_tr and mu_en )            "
" Version 1.3  D. Rogers, Aug 2002 (account for fluorescent phtons in "
"                                  g and mu_tr correctly )            "
" Version 1.4  R. Townson, December 2016                              "
"  Energy depositions for kerma calculations below the cut-off are    "
"  now sorted out using AUSGAB to include only Auger from relaxations,"
"  not fluorescence.                                                  "
"                                                                     "
"*********************************************************************"

"Variables definitions
"
"g              e_brem/e_tot  and e_rad/e_tot
"               from NIST web page:the average fraction of the kinetic energy
"               of secondary charged particles (produced in all the types of
"               interactions) that is subsequently lost in radiative (photon-
"               emitting) energy-loss processes as the particles slow to rest
"               in the medium.
"               http://physics.nist.gov/PhysRefData/XrayMassCoef/chap3.html
"e_brem         average energy lost to bremsstrahlung
"ebrem_tmp
"e_rad          average energy lost to bremsstrahlung & kinetic energy
"               transferred in annihilation radiation (ie only annihilation
"               in flight. Note this used to include fluorescent photons, but
"               they should be excluded from e_tot as well.
"erad_tmp
"etot_tmp       includes subthreshold energy (iarg=4)
"
"e_tot          average energy released per particle
"e_radc = sum (etot_tmp*erad_tmp)
"e_bremc= sum (etot_tmp*ebrem_tmp)
"anorm
"npgi
"npei
"E_ave
"factor     1.602176462E-13 J/MeV *1000 g/kg =160.2176E-12 Gy cm^2
"           to convert e_mutr and e_muen scored as MeV cm^2/g
"de_pulsei
"e_mutr
"e_muen
"mutr
"muen
"Eave    average energy of incident spectrum: either actual or sampled

"---------------------------------------------------------------------"
"STEP 1:  USER-OVERRIDE-OF-EGSnrc-MACROS                              "
"---------------------------------------------------------------------"
REPLACE {$MXMED} WITH {1}    "we need just one medium                 "
REPLACE {$MXREG} WITH {1}    "and just one geo0metrical region         "
REPLACE {$MXSTACK} WITH {50} "this should be enough for any purposes  "

REPLACE {$DEBUGIT} WITH {.false.} "that can be used for debugging purposes"

REPLACE {$MXGE} WITH {2000}

"Replace the $CALL-HOWNEAR macro for an infinite homogeneous geometry"
REPLACE {$CALL-HOWNEAR(#);} WITH {;
  {P1} = 1e10;
}

"Don't need any calls to howfar"
REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;}
REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
  IF( wt(np) <= 0 ) idisc = 1;
};

"Define a common for scoring"
REPLACE {;COMIN/SCORE/;} WITH {;
  common/score/ e_tot,e_tot2,e_brem,e_brem2,e_bremc,e_rad,e_rad2,e_radc,
                etot_tmp,ebrem_tmp,erad_tmp,my_gle,accu,ncase,calc_type,
                during_pe_compt,during_eii;
                "It is always a good idea to score in double precision!"
  real*8        e_tot,e_tot2,e_brem,e_brem2,e_rad,e_rad2,
                etot_tmp,ebrem_tmp,erad_tmp,e_radc,e_bremc;
  $REAL         my_gle,accu;
  $INTEGER      ncase,calc_type,during_pe_compt,during_eii;
};

REPLACE {$MXENE} WITH {200};  "maximum number of energies to be looped over"

"Define a common for energies"
REPLACE {;COMIN/ENERGIES/;} WITH {;
  common/energies/ eis,neis;
  $REAL     eis($MXENE);
  $INTEGER  neis;
};

" Don't need any photon transport "
REPLACE {$SELECT-PHOTON-MFP;} WITH { dpmfp = 0; };

" A convenience macro for statistical analysis "
REPLACE {$ANALYZE#(#);} WITH {;
  {P1} = {P1}/{P2}; {P1}2 = {P1}2/{P2};
  {P1}2 = {P1}2 - {P1}*{P1};
  IF( {P1}2 > 0 ) [ {P1}2 = sqrt({P1}2/({P2}-1)); ]
};

"---------------------------------------------------------------------"
" Step 1a: begin of executable code and variable declarations         "
"---------------------------------------------------------------------"

program calculate_g;

$IMPLICIT-NONE;

;COMIN/THRESH,          "for threshold energies"
       BOUNDS,          "for ECUT,PCUT"
       MEDIA,           "to be able to print medium name"
       USEFUL,          "to get electron rest energy"
       SCORE,           "the results of the shower simulation, to be used"
                        "in step 8"
       PHOTIN,          "so that gmfp can be calculated"
       STACK,
       RANDOM,
       EPCONT,
       ENERGIES
      /;

$INTEGER nbatch,        "$INTEGER and $REAL are defined in egsnrc.macros"
         nperbatch,     "they can be used (if employed consistently throughout"
         ibatch,        "the user code) e.g. to switch to double precision"
         i,j;

$INTEGER itimes, ntimes;"loop through different energies"
real*8   aux,aux2,total,anorm,sum,sum2,xtest,xtest2;
real*4   cpu,etime,time_array(2);
character*80 datfile(50);
$INTEGER     datcount;
$INTEGER     ncasei,npgi,npei,nspliti,nbini;
$REAL        de_pulsei, Eave, err_Eave,factor;

$REAL        gmfp;
$INTEGER     lmy_gle;
real*8       e_mutr, e_mutr2, e_muen, e_muen2, mutr, mutr2, muen, muen2;
real*8       ert, ert2, ett, ett2;

"For interacting with the source routine and shower"
$INTEGER       iqin,irin,icase,ip;
$REAL          ein,uin,vin,win,wtin,xin,yin,zin,ecut_ask,pcut_ask;
$REAL          gbr1,gbr2,rnno,err_frac;
$LONG_INT      nmutr,nmuen;

"---------------------------------------------------------------------"
" Steps 2 (pre-hatch initializations),                                "
"       4 (initializations for howfar and hownear)                    "
"       5 (initializations for ausgab)                                "
"       6 (determination of incident particle parameters)             "
" are done in subroutine inputs                                       "
"---------------------------------------------------------------------"

call egs_init;

call inputs;

ecut_ask = ecut(1);
pcut_ask = pcut(1);

"---------------------------------------------------------------------"
"deferred STEP 3   HATCH-CALL                                         "
"---------------------------------------------------------------------"

OUTPUT; (' CALL HATCH to get cross-section data'/);
CALL HATCH;

;OUTPUT;('\f Start g value calculation: Version 1.14 '//);
OUTPUT (media(j,1),j=1,24);(/'          MEDIUM is: ',24A1/);
;OUTPUT AE(1)-PRM, AP(1);
(' knock-on electrons can be created and any electron followed down to'
/T40,F8.3,' MeV kinetic energy'/
'   brem photons can be created and any photon followed down to      ',
/T40,F8.3,' MeV ');
"Compton events can create electrons and photons below these cutoffs"
;OUTPUT UE(1)-rm, UP(1);
  (' electron and photon upper kinetic energies are:',F8.3,F11.3,
   ' MeV respectively');

"a common problem has been to ask for a lower ecut or pcut than the
"data set covers.  Prevent this by exiting if it occurs.  The
"user is then forced to fix the data set or the asked for cut-offs.

IF(ecut_ask < ae(1)   | pcut_ask < ap(1) )[
   OUTPUT ecut_ask, AE(1), pcut_ask, AP(1);
   (//'**************************************************************'/
      'There is a mismatch between asked for and available cut-offs  '/
      'Asked for ECUT of', F10.4,' MeV and have AE of',F10.4,' MeV'/
      'Asked for PCUT of', F10.4,' MeV and have AP of',F10.4,' MeV'/
      'Exiting until there is a match'/
      '**************************************************************'/);
   STOP;
]


"---------------------------------------------------------------------"
"STEP 7   SHOWER-CALL                                                 "
"---------------------------------------------------------------------"

"call test_brems;
"call test_compton;

"initiate the shower ncase times"
cpu = etime(time_array);
write(6,'(a,f9.2)') ' CPU time so far: ',cpu;
;OUTPUT;(/' Starting shower simulation ...');
nbatch = 10; nperbatch = ncase/nbatch;
IF(nperbatch = 0) nperbatch = 1;
      "Note that nbatch and nperbatch are not used for statistical analysis"
      "They are merely for printing information about the progress of the"
      "simulation"

call source_sumry(6);

write(6,*) 'Number of histories to simulate = ',ncase;

IF( accu > 0 & calc_type = 1) [
  write(6,*) 'Will interrupt any calculation loop when accuracy better than '
             ,accu;
]



factor = 160.2176462;  "e_mutr and e_muen scored as MeV cm^2/g"
                    "*1.602176462E-13 J/MeV *1000 g/kg =160.2176E-12 Gy cm^2"
                    "Note, this is used elsewhere too"

IF (neis>1)[
  ntimes = neis;
  write(6,'(//A)')    '=====================================';
  write(6,'(A,I4,A)') 'Will loop through ',ntimes,' energies';
  write(6,'(A//)')    '=====================================';
]
ELSE       [ntimes = 1;]

DO itimes=1,ntimes[ "start of loop over different initial energies"

"following two were only done in subroutine inputs before"
/e_tot,e_tot2,e_rad,e_rad2,e_brem,e_brem2,e_bremc,e_radc/ = 0;
/during_pe_compt,during_eii/ = 0;
/e_mutr,e_mutr2,e_muen,e_muen2,mutr,mutr2,muen,muen2/ = 0.0;
/nmutr,nmuen/ = 0;

call source_switch_energy(itimes);
"above gets initial energy from those we loop over"
"returns ei"

IF( calc_type = 1 ) [  "will seek a given accuracy -- default does not do this"

    write(6,*); write(6,*) '=> First calculating mutr only'; write(6,*);
    /x(1),y(1),z(1)/=0; wt(1)=1; ir(1)=1; medium=1;
    DO icase=1,ncase [
        call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
        IF( iqin ~= 0 ) [
            write(6,*) 'type=1 calculation only works for photons!';
            $CALL_EXIT(1);
        ]
        my_gle = log(ein); gle = my_gle;
        $SET INTERVAL my_gle,ge;
        $EVALUATE gmfp USING gmfp(my_gle);
        $EVALUATE gbr1 USING gbr1(my_gle);
        $EVALUATE gbr2 USING gbr2(my_gle);
        np = 1; e(np) = ein; u(np)=0; v(np)=0; w(np)=1; iq(np) = 0;
        $RANDOMSET rnno; edep = 0;
        IF( rnno < gbr1 & ein > rmt2 )      [ call pair;  ]
        ELSE IF( rnno < gbr2 )              [ call compt; ]
        ELSE                                [ call photo; ]
        DO ip=1,np [
            IF( iq(ip) ~= 0 ) edep = edep + e(ip)-prm;
        ]
        nmutr = nmutr + 1;
        aux = edep/gmfp/rho(1);
        e_mutr = e_mutr + aux; e_mutr2 = e_mutr2 + aux*aux;
        IF( mod(icase,10000) = 0 & accu > 0 ) [
            xtest = e_mutr; xtest2 = e_mutr2;
            $ANALYZE xtest(nmutr);
            "write(6,*) icase,xtest2/xtest;"
            IF( xtest2/xtest < accu ) EXIT;
        ]
    ] "end of icase loop for calc_type=1 seeking a given accuracy"

    xtest = e_mutr; xtest2 = e_mutr2; $ANALYZE xtest(nmutr);
    IF( accu > 0 & xtest2/xtest < accu ) [
        write(6,*) 'mu_tr converged after ',nmutr,' histories'; write(6,*);
    ]
    write(6,*) ' <E*mu_tr/rho>     = ',factor*xtest,' 10^-12 Gy cm^2  +/- ',
               100*xtest2/xtest,'%';
    write(6,*);

    write(6,*); write(6,*) '=> Now calculating g and muen'; write(6,*);

    "we are in the calc_type = 1 block photons only"
    "     -quits when accuracy reached"
    DO icase=1,ncase [
        call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
        /ebrem_tmp,erad_tmp,etot_tmp/ = 0.0;
        call shower(iqin,ein,xin,yin,zin,uin,vin,win,irin,wtin);
        $SET INTERVAL my_gle,ge;
        $EVALUATE gmfp USING gmfp(my_gle);
        aux = etot_tmp/gmfp/rho(1);
        e_mutr = e_mutr + aux; e_mutr2 = e_mutr2 + aux*aux;
        nmutr = nmutr+1; nmuen = nmuen + 1;
        e_tot = e_tot + etot_tmp;
        e_tot2 = e_tot2 + etot_tmp*etot_tmp;
        e_brem = e_brem + ebrem_tmp;
        e_brem2 = e_brem2 + ebrem_tmp*ebrem_tmp;
        e_rad = e_rad + erad_tmp;
        e_rad2 = e_rad2 + erad_tmp*erad_tmp;
        e_radc = e_radc + etot_tmp*erad_tmp;
        IF( mod(icase,10000) = 0 & accu > 0 ) [
            IF( e_rad > 0 ) [
                ert = e_rad; ert2 = e_rad2; $ANALYZE ert(nmuen);
                ett = e_tot; ett2 = e_tot2; $ANALYZE ett(nmuen);
                ert2 = ert*sqrt((ert2/ert)**2+(ett2/ett)**2)/(ett-ert);
                IF( ert2 < accu/2 ) EXIT;
            ]
            ELSE [
                IF( icase > 100000 ) [
                    ert2 = 0; EXIT;
                ]
            ]
        ]
    ] " end of icase loop"
    IF( accu > 0 & ert2 < accu ) [
        write(6,*) '1-g converged after ',nmuen,' histories'; write(6,*);
    ]

    $ANALYZE e_mutr(nmutr); $ANALYZE e_tot(nmuen); $ANALYZE e_rad(nmuen);
    IF( e_rad < 1e-15*e_tot ) e_rad = 1e-15*e_tot;
    write(6,*) 'Final:';
    write(6,*)' <E*mu_tr/rho> i.e., K   =',factor*e_mutr,' 10^-12 Gy cm^2 +/- ',
               100*e_mutr2/e_mutr,'%';
    e_rad2 = e_rad*sqrt((e_rad2/e_rad)**2+(e_tot2/e_tot)**2)/(e_tot-e_rad);
    write(6,*) ' <E*mu_en/rho> i.e., Kcol=',factor*e_mutr*(1-e_rad/e_tot),
       ' 10^-12 Gy cm^2  +/- ',100*sqrt((e_mutr2/e_mutr)**2+e_rad2**2),'%';
    write(6,*) ' g                 = ',e_rad/e_tot,' +/- ',
        100*e_rad2*(e_tot/e_rad-1),'%';
    write(6,*);

    goto :the_end:;

]  "end of calc_type = 1 block seeking a specified accuracy"

$FLUSH_UNIT(6);

"############################################################################
"	start calc_type = 0, fixed number of histories
"############################################################################

DO icase=1,ncase [

  call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
  IF( $DEBUGIT ) [
    write(18,*) ' ******* new shower, e = ',ein,' iq = ',iqin;
  ]
  ebrem_tmp = 0.0;           "keeps track of ke of charged particeles lost"
                             "to brem and annihilation events"
  erad_tmp = 0.0;            "loses just to annihilation"
  "initialize etot_tmp differently for photons and electrons"
  IF( iqin .ne. 0 ) [ etot_tmp = (ein - rm); ]
  ELSE [ etot_tmp = 0; ]
"============================================================================"

  call shower(iqin,ein,xin,yin,zin,uin,vin,win,irin,wtin);

"============================================================================"
  IF( $DEBUGIT ) [
    write(18,*) ' energy released: ',etot_tmp,' lost to brems: ',ebrem_tmp,
     ' erad: ',erad_tmp;
  ]
  IF( iqin = 0 ) [
      my_gle = log(ein);
      $SET INTERVAL my_gle,ge;
      $EVALUATE gmfp USING gmfp(my_gle);  "mfp in cm"
      "when doing bound compton, the above is not the correct cross-section"
      "but we also throw out the uncollided photons, so it works out"
      aux = (etot_tmp/gmfp)/rho(1);  "energy per g/cm^2"
      e_mutr = e_mutr + aux; e_mutr2 = e_mutr2 + aux*aux;
      "mutr = mutr + aux/ein; mutr2   = mutr2 +aux*aux/(ein**2);
      aux = ((etot_tmp - erad_tmp)/gmfp)/rho(1);
      e_muen = e_muen + aux; e_muen2 = e_muen2 + aux*aux;
      "muen = muen + aux/ein; muen2   = muen2 +aux*aux/(ein**2);
  ] "end of photon only block"

  e_tot = e_tot + etot_tmp;
  e_tot2 = e_tot2 + etot_tmp*etot_tmp;
  e_brem = e_brem + ebrem_tmp;
  e_brem2 = e_brem2 + ebrem_tmp*ebrem_tmp;
  e_rad = e_rad + erad_tmp;
  e_rad2 = e_rad2 + erad_tmp*erad_tmp;
  e_radc = e_radc + etot_tmp*erad_tmp;
  e_bremc = e_bremc + etot_tmp*ebrem_tmp;
  ibatch = icase/nperbatch;
  IF( ibatch*nperbatch = icase ) [
    write(6,'(a,i2,a,i2,a,f9.2,a)')
     '+ Finished part ',ibatch,' out of ',nbatch,
     ', cpu time = ',etime(time_array)-cpu,' sec.';
     $FLUSH_UNIT(6);  "so the log file is updated each time"
  ]
] "end of loop over number of histories = ncase times"

;OUTPUT;(/' Finished shower simulation ');

"-----------------------------------------------------------------"
"STEP 8   OUTPUT-OF-RESULTS                                       "
"-----------------------------------------------------------------"

call source_get_eave(Eave);
write(6,*);
write(6,'('' Average spectrum energy: '',1PE10.4, '' MeV'')') Eave;
call source_get_samplede(Eave,err_Eave);
err_Eave = max(0.0, err_Eave);   "to take care of -ve errors from roundoff"
write(6,'('' Average sampled energy: '',1PE10.4, '' +/-'',1PE10.2,
      ''  MeV'')') Eave,err_Eave;

"The correct definition of mu/rho for a spectrum is that given by"
"Attix = int[psi mu/rho dE]/int[psi dE]  This is equivalent to the"
"ICRU60 defn as long as one sums the total energy transferred from"
"the spectrum and then divides by the average energy incident"
"For a while we scored <mu/rho> directly, but this can differ"
"substantially from the correct results and amounts to averaging"
"over the fluence, not the energy fluence"
"These incorrect values are now commented out"
$ANALYZE e_tot(ncase);
$ANALYZE e_brem(ncase);
$ANALYZE e_rad(ncase);
factor = 160.2176462;  "e_mutr and e_muen scored as MeV cm^2/g"
                    "*1.602176462E-13 J/MeV *1000 g/kg =160.2176E-12 Gy cm^2"
                    "Note, this is used elsewhere too"

"Currently in calc_type=0"

IF( e_mutr > 0 ) [
    write(6,'(/)');
    $ANALYZE e_mutr(ncase);
    write(6,800)factor*e_mutr, 100*e_mutr2/e_mutr;
800 format(' <E*mu_tr/rho> i.e., K   =',1PE12.4,'    10^-12 Gy cm^2 +/-',
            0PF7.3,' %');
    write(6,801)e_mutr/Eave;
801  format(' <E*mu_tr/rho>/Eave      =',1PE12.4,'    cm^2/g');

    write(6,*) 'The above is the spectrum averaged coefficient';
    "write(6,*) ' difference        = ',(e_mutr/Eave - mutr)/mutr*100.,'%';
]
IF( e_muen > 0 ) [
    $ANALYZE e_muen(ncase);
    write(6,*);
    write(6,'('' <E*mu_en/rho> i.e., Kcol='',1PE12.4,''    10^-12 Gy cm^2 +/-'',
       0PF7.3,'' %'')') factor*e_muen, 100*e_muen2/e_muen;
    write(6,'('' <E*mu_en/rho>/Eave      = '',1PE12.4,''    cm^2/g'')')
         e_muen/Eave;
    write(6,*) 'The above is the spectrum averaged coefficient';
    "write(6,*) ' difference        = ',(e_muen/Eave - muen)/muen*100.,'%';
    write(6,'(/)');
]

OUTPUT e_tot,e_tot2, 100*e_tot2/e_tot;
  (' Ave energy released per particle:  ',1PE12.4, ' MeV +/-', 1PE10.3,
  ' =', 0PF7.3,' %');
OUTPUT e_brem,e_brem2, 100*e_brem2/e_tot;
  (' Ave energy lost to bremsstrahlung: ',1PE12.4, ' MeV +/-', 1PE10.3,
  ' =', 0PF7.3,' %');
OUTPUT e_rad,e_rad2, 100*e_rad2/e_tot;
  (' Ave energy lost to all radiation:  ',1PE12.4, ' MeV +/-', 1PE10.3,
  ' =', 0PF7.3,' %');

err_frac = sqrt((e_brem2/e_brem)**2+(e_tot2/e_tot)**2);
OUTPUT e_brem/e_tot, err_frac*(e_brem/e_tot), 100.*err_frac;
   (/'fractions   g(brem) = ',F8.4,' +/-',F8.4,' =',F6.3,' %');
err_frac = sqrt((e_rad2/e_rad)**2+(e_tot2/e_tot)**2);
OUTPUT e_rad/e_tot,err_frac*(e_rad/e_tot),100*err_frac;
   ( '         g(all rad) = ',F8.4,' +/-',F8.4,' =',F6.3,' %'/);

write(6,*) 'The above fraction error estimates are made ignoring correlations';
write(6,*) ' between energy released and energy lost to radiation ';

e_radc = e_radc/ncase;       e_bremc = e_bremc/ncase;
IF( e_rad > 0 )  [ e_radc = (e_radc/e_tot/e_rad-1)/(ncase-1); ]
IF( e_brem > 0 ) [ e_bremc = (e_bremc/e_tot/e_brem-1)/(ncase-1); ]
e_radc = (e_rad2/e_rad)**2+(e_tot2/e_tot)**2-2*e_radc;
IF( e_radc > 0 ) [ e_radc = sqrt(e_radc); ]
e_bremc = (e_brem2/e_brem)**2+(e_tot2/e_tot)**2-2*e_bremc;
IF( e_bremc > 0 ) [ e_bremc = sqrt(e_bremc); ]
write(6,*) ' Fractional uncertainties with correlations are: ';
OUTPUT 100*e_bremc; ('   brems:          ',F8.4,' %');
OUTPUT 100*e_radc;  ('   all radiative:  ',F8.4,' %');

$FLUSH_UNIT(6);

:the_end:;

]"end of itimes loop"


call egs_finish;

end;

%E
;
"**********************************************************************"
"                                                                      "
  subroutine inputs;
"                                                                      "
"**********************************************************************"

"The following are two simple and useful macros for calling the"
"get_input routine                                             "

REPLACE {$GET_INPUT(#);} WITH  "Used to get only one input"
{
"{P1}=Array index of the value_sought"
NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT;
}
;
REPLACE {$GET_INPUTS(#,#);} WITH  "Used to get many inputs"
{
NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT;
}
;

$IMPLICIT-NONE;

"The following are EGSnrc internal (privat) common blocks"
"They are included in order to get access to various switches, "
"material array, cut-off energies, etc."

;COMIN/EPCONT,       "to get access to iausfl"
       GetInput,     "for interaction with the get_input routine"
       MEDIA,        "to get access to nmed and media"
       MISC,         "to get access to the array med"
       UPHIOT,       "to get PI (for the incident angle conversion)"
       USEFUL,       "to get electron rest energy RM"
       RANDOM,       "to be able to set the initial rng seeds"
       BREMPR,       "to be able to turn off brems angle selection"
       "                                             "
       " The following are user-defined common blocks"
       "                                             "
       SCORE,
       USER
      /;

character*60 medium_name;

$INTEGER i,j,ispin,jrn1,jrn2;
$INTEGER ival;
$REAL    emax;
integer*4 lnblnk;

call get_transport_parameter(6); "read transport parameter settings and"

accu = -1;
calc_type = 0;
                                 "print a summary on unit 6"
ival = 0;
delimeter = 'NONE';

" Media input "
"============="

ival                   = ival + 1;
values_sought(ival)    = 'MEDIA';
type(ival)             = 2;  "i.e.  character input"
nvalue(ival)           = 0;
$GET_INPUT(IVAL);
IF( error_flag > 0 ) stop;
nmed = nvalue(ival);
IF( nmed > $MXMED ) [
    write(6,*) ' Just ',$MXMED,' allowed!';
    stop;
]
DO i=1,nmed [
  DO j=1,24 [ media(j,i) = ' '; ]
  read(char_value(ival,i),'(24a1)') (media(j,i),j=1,lnblnk(char_value(ival,i)));
]

"Set medium 1 everywhere"
DO i=1,$MXREG [ med(i) = 1; ]

dunit = 1;  "i.e. we work in cm"

"---------------------------------------------------------------------"
"STEP 5  INITIALIZATION-FOR-AUSGAB                                    "
"---------------------------------------------------------------------"

ival                   = ival + 1;
values_sought(ival)    = 'INITIAL RANDOM NO. SEEDS';
type(ival)             = 0;
nvalue(ival)           = 2;
value_min(ival)        = 0;
value_max(ival)        = 9999999;
default(ival)          = 0;
$GET_INPUT(IVAL);
jrn1 = value(ival,1);
jrn2 = value(ival,2);
$INITIALIZE RNG USING jrn1 AND jrn2;

ival                   = ival + 1;
values_sought(ival)    = 'NUMBER OF HISTORIES';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = 2;
value_max(ival)        = 2147483647;
default(ival)          = 10000;
$GET_INPUT(IVAL);
ncase = value(ival,1);

ival                   = ival + 1;
values_sought(ival)    = 'TURN OFF BREMS ANGLES';
type(ival)             = 3;
nvalue(ival)           = 1;
allowed_inputs(ival,0) = 'NO';
allowed_inputs(ival,1) = 'YES';
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [
    IF( value(ival,1) > 0 ) ibrdst=-1;
]

"----------------------------------------------------------------------"
"accuracy sought and calculation type                                  "
"----------------------------------------------------------------------"
ival                   = ival + 1;
values_sought(ival)    = 'ACCURACY';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = -1e30;
value_max(ival)        = 0.1;
default(ival)          = -1;
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [ accu = value(ival,1); ]
ELSE                 [ error_flag = 0; ]

ival                   = ival + 1;
values_sought(ival)    = 'CALCULATION TYPE';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = 0;
value_max(ival)        = 1;
default(ival)          = 0;
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [ calc_type = value(ival,1); ]
ELSE                 [ error_flag = 0; ]

"---------------------------------------------------------------------"
"STEP 6   DETERMINATION-OF-INICIDENT-PARTICLE-PARAMETERS              "
"---------------------------------------------------------------------"

" Source inputs "
" ============= "

" now executed from a separate routine "

call source;

DO j=1,33 [ iausfl(j) = 0; ]
iausfl( 5) = 1; "in order to score sub-threshold energy after relaxations"
iausfl( 8) = 1; "after brems"
iausfl(10) = 1; "after Moller (to count radiative losses due to EII)"
iausfl(12) = 1; "after Bhabha (to count radiative losses due to EII if"
                "added some day)"
iausfl(14) = 1; "after annih"
iausfl(15) = 1; "after annih at rest"
iausfl(17) = 1; "after pair"
iausfl(18) = 1; "before compt"
iausfl(19) = 1; "after compt"
iausfl(20) = 1; "before photo"
iausfl(21) = 1; "after photo"
iausfl(34) = 1; "after sub-threshold fluorescence"
iausfl(35) = 1; "after sub-threshold Auger"
iausfl(32) = 1; "before eii"
iausfl(33) = 1; "after eii"

return;
end;    "of subroutine inputs"

"************************************************************************""
subroutine howfar;
"************************************************************************""
;COMIN/STACK/;

IF( wt(np) <= 0 ) idisc = 1;
return;
end;

"************************************************************************""

subroutine ausgab(iarg);

"Note that once impact ionization is included in EGSnrc, we need
"to change this since, g (e_rad) needs to include fluorescence emission
"as a result of electron- and positron-impact ionization,
"************************************************************************""
$IMPLICIT-NONE;
$INTEGER iarg,irl,iql,jp;
real*8   aux;
$REAL    usave,vsave,wsave,wtsave,eesave,rnno,ee;
$INTEGER isplit,ip;

;COMIN/SCORE,   "to get the scoring arrays and iscore"
       EPCONT,  "to get EDEP"
       STACK,   "to get the region number"
       USEFUL
      /;

IF( iarg = 19 | iarg = 17 ) ["before and during photoeffect or compton"
    "this flag stays set during these interactions until cleared"
    during_pe_compt = 1;
    return;
]
IF( iarg = 20 | iarg = 18 ) ["after photoeffect clear the flag"
    "do we know for sure this comes after the eii calls"
    during_pe_compt = 0;
]
IF( iarg = 31 ) ["before and during eii"
    during_eii = 1;
    return;
]
IF( iarg = 32 ) ["after eii"
    during_eii = 0;
    return;
]

"depositing sub-threshold energy for everything but eii and PE/Compton"
IF( iarg = 4 & during_eii = 0 & during_pe_compt = 0 ) [
    "  during_eii = 0 & during_pe_compt = 0  => after either of these"
    IF( $DEBUGIT ) [ write(19,*) ' Depositing iarg 4 ',edep; ]
    etot_tmp = etot_tmp + edep;
    return;
]
"skip the remaining iarg=4 calls"
IF( iarg = 4 &  ( during_eii = 1 | during_pe_compt = 1 ) ) [
    return;
]

"depositing sub-threshold energy for PE/Compton"
"Auger only"
IF( iarg = 34 ) ["after sub-threshold Auger"
    IF( during_pe_compt = 1 ) ["it is during PE/Compton"
        IF( $DEBUGIT ) [ write(19,*) ' Depositing photo iarg 27 ',edep_local; ]
        etot_tmp = etot_tmp + edep_local;
        return;
    ]
    ELSE [ "it was caused by an e interaction => not in kerma" return; ]
]

"depositing sub-threshold energy for eii"
"fluorescence only"
IF( iarg = 33 ) ["after sub-threshold fluorescence"
    IF( during_eii = 1 ) [ "during an eii event"
        IF( $DEBUGIT ) [ write(19,*) ' Depositing eii iarg 25 ',edep_local; ]
        erad_tmp = erad_tmp + edep_local;
        return;
    ] ELSE ["if it is from other relaxation, it is not an e radiative loss"
        return;
    ]
] "end iarg 33 block"


IF( iarg = 16 | iarg = 18 | iarg = 20 ) ["after a photon interaction"
    IF( $DEBUGIT ) [ write(18,*) ' iarg = ',iarg,' np = ',np; ]


    DO ip = NPold, NP ["loop over all particles on stack after interaction"
        IF( $DEBUGIT ) [ write(18,*) '    ',ip,iq(ip),wt(ip),e(ip); ]
        IF( iq(ip) ~= 0 ) [ etot_tmp = etot_tmp + e(ip) - prm; ]
        ELSE [ "photon"
            wt(ip) = 0; e(ip) = 0;  "terminate the history-no more transport"
            "note, even a rejected bound Compton event is terminated"
        ]
    ]"end block over particles on stack after interaction"
    return;
]"end photon interaction block"

IF( iarg = 7 ) [ "after a call to brems - add up the energy of the photon"
                 "and then discard the photon"
    "It is assumed that nbr_split = 1, ie no splitting"
    IF( iq(np) = 0 ) [ "photon is top of stack"
                       ebrem_tmp = ebrem_tmp + e(np);
                       erad_tmp = erad_tmp + e(np);
                       IF( $DEBUGIT ) [ write(18,*) ' brems: ',e(np),wt(np); ]
                       wt(np) = 0; e(np) = 0
                     ]
    ELSE             [ "electron was top of stack=> photon is np-1"
                       ebrem_tmp = ebrem_tmp + e(np-1);
                       erad_tmp = erad_tmp + e(np-1);
                     IF( $DEBUGIT ) [ write(18,*) ' brems: ',e(np-1),wt(np-1); ]
                       wt(np-1) = 0; e(np-1) = 0
                     ]
    return;
] "end of brems block"

IF( iarg = 13 | iarg = 14 ) ["after annihilation at rest or in flight"
    IF( $DEBUGIT ) [ write(18,*) ' annihilation '; ]
    IF( iarg = 13 ) ["in flight - we only want to score any k.e."
                     "transferred to photons"
      erad_tmp = erad_tmp + e(np) + e(np-1) - 2*prm;
    ]
    e(np) = 0; wt(np) = 0;
    e(np-1) = 0; wt(np-1) = 0;
    return;
]

IF( iarg = 9 | iarg = 11 ) [ "after moller or bhabha"
    IF( $DEBUGIT ) [ write(18,*) ' Moller or Bhabha '; ]
    "pick up any fluorescent photons from eii"
    "Note that the inclusion of Bhabha is not needed since there is"
    "    no eii in Bhabha yet. But in case it is added in future."
    DO ip=npold,np [
        IF( iq(ip) = 0 ) [
            erad_tmp = erad_tmp + e(ip); wt(ip) = 0; e(ip) = 0;
        ]
    ] "end of loop on ip"
    return;
] "end iarg = 9|11 block"

OUTPUT;('We should not get here!!!!');
write(6,*) 'IARG = ',iarg;
return;
end;

"************************************************************************"

subroutine source;

"************************************************************************""
$IMPLICIT-NONE;

;COMIN/GetInput,USEFUL,UPHIOT,RANDOM, ENERGIES/;

$INTEGER ival;

REPLACE {$NENSRC} WITH {250};

$INTEGER mono;
$INTEGER nensrc,mode,iqi,source_type;
$REAL    ensrcd(0:$NENSRC),srcpdf($NENSRC),srcpdf_at($NENSRC);
$INTEGER srcbin_at($NENSRC);
$INTEGER i;
$REAL    ei,eave,sum,ui,vi,wi,angle,rbeam,distance;
real*8   esum,esum2,ecount,aux,aux2;

$INTEGER ounit;
$REAL    emax,e,es,des,eik;

$INTEGER iqin,irin;
         "note iqin is also passed in comin score but it is not in this"
         "subroutine"
$REAL    ein,xin,yin,zin,uin,vin,win,wtin;
$REAL    r,phi,alias_sample;

$REAL    bwidth;
$REAL    e_min, e_max;

$INTEGER itimes;

save     mono,nensrc,mode,ensrcd,srcpdf,srcpdf_at,srcbin_at,eave,sum,
         esum,esum2,ecount,ei,iqi,ui,vi,wi,angle,rbeam,distance,
         source_type,eik;

character*80 spec_file;

ival = 0;

/esum,esum2,ecount/ = 0;

ival                   = ival + 1;
values_sought(ival)    = 'INCIDENT SPECTRUM';
type(ival)             = 3;
allowed_inputs(ival,0) = 'MONO-ENERGY';
allowed_inputs(ival,1) = 'SPECTRUM';
allowed_inputs(ival,2) = 'MONO-ENERGY-LIN-RANGE';
allowed_inputs(ival,3) = 'MONO-ENERGY-LOG-RANGE';
nvalue(ival)           = 1;
delimeter = 'SOURCE INPUT';
$GET_INPUT(ival);
mono = value(ival,1);

ival                   = ival + 1;
values_sought(ival)    = 'INCIDENT CHARGE';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = -1;
value_max(ival)        = 1;
default(ival)          = -1;
$GET_INPUT(ival);
iqi = value(ival,1);

IF( mono = 0 ) ["one or more individual energy values"

    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT KINETIC ENERGY';
    type(ival)             = 0;
    nvalue(ival)           = 0;
    value_min(ival)        = 0;
    value_max(ival)        = 1e10;
    default(ival)          = 1;
    $GET_INPUT(ival);
    ei = value(ival,1); eik = ei;
    IF( iqi ~= 0 ) [ ei = ei + rm; ]
    neis = nvalue(ival);
    IF(neis>$MXENE)[
     write(6,*) '!!!!!!!!!    ERROR  !!!!!!!!!!!!!!!!!!!!!!!!';
     write(6,*) 'too many energies requested, increase MXENE.';
     write(6,*) 'MXENE =',$MXENE,'neis = ',neis;
     stop;
    ]
    write(6,*) 'number of energies = ', neis;
    DO i=1,neis[ "convert incident k.e. to total energies"
     eis(i)=value(ival,i)+rm*abs(iqi);
     write(6,'(A,I2,A,f8.5)') 'E(',i,')=', value(ival,i);
    ]
]
ELSE IF (mono = 2)["lin grid, reading: Emin, emax, bwidth"
    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT KINETIC ENERGY';
    type(ival)             = 0;
    nvalue(ival)           = 3;
    value_min(ival)        = 0;
    value_max(ival)        = 1e10;
    default(ival)          = 1;
    $GET_INPUT(ival);
    ei = value(ival,1); eik = ei;
    IF( iqi ~= 0 ) [ ei = ei + rm; ]

    bwidth = value(ival,3);
    neis = abs(value(ival,2)-value(ival,1))/bwidth+1;

    IF(neis>$MXENE)[
     write(6,*) '!!!!!!!!!    ERROR  !!!!!!!!!!!!!!!!!!!!!!!!';
     write(6,*) 'too many energies requested, increase MXENE.';
     write(6,*) 'MXENE =',$MXENE,' neis = ',neis;
     stop;
    ]

    write(6,*) 'Linear energy grid ';
    write(6,*) '========================';
    write(6,*) 'Emin = ', value(ival,1),' Emax = ', value(ival,2);
    write(6,*) 'bwidth = ', bwidth;
    write(6,*) 'number of energies = (Emax-Emin)/bwidth+1= ', neis;
    write(6,*);

    DO i=0,neis-1[
     eis(i+1)=value(ival,1)+i*bwidth+rm*abs(iqi);
     write(6,'(A,I3,A,f8.5)')'E(',i+1,')=', eis(i+1);
    ]
]
ELSE IF (mono = 3)["log grid, reading: Emin, Emax, npoints"
    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT KINETIC ENERGY';
    type(ival)             = 0;
    nvalue(ival)           = 3;
    value_min(ival)        = 0;
    value_max(ival)        = 1e10;
    default(ival)          = 1;
    $GET_INPUT(ival);
    ei = value(ival,1); eik = ei;
    IF( iqi ~= 0 ) [ ei = ei + rm; ]

    e_min = value(ival,1) + abs(iqi)*rm;
    e_max = value(ival,2) + abs(iqi)*rm;

    neis = int(value(ival,3));
    bwidth = log(e_max/e_min)/(neis-1);

    IF(neis>$MXENE)[
     write(6,*) '!!!!!!!!!    ERROR  !!!!!!!!!!!!!!!!!!!!!!!!';
     write(6,*) 'too many energies requested, increase MXENE.';
     write(6,*) 'MXENE =',$MXENE,' neis = ',neis;
     stop;
    ]

    write(6,*) 'Logarithmic energy grid ';
    write(6,*) '========================';
    write(6,*) 'Emin = ', value(ival,1),' Emax = ', value(ival,2);
    write(6,*) 'number of energies = ', neis;
    write(6,*) 'bwidth = log(Emax/Emin)/n = ', bwidth;write(6,*);

    DO i=0,neis-1[
     eis(i+1)=exp(log(e_min)+i*bwidth);
     write(6,'(A,I3,A,f8.5)')'E(',i+1,')=', eis(i+1);
    ]
]
ELSE [

    neis = 0;

    ival                   = ival + 1;
    values_sought(ival)    = 'SPECTRUM FILE';
    type(ival)             = 2;
    nvalue(ival)           = 1;
    $GET_INPUT(ival);
    read(char_value(ival,1),'(a)') spec_file;
    open(9,file=spec_file,status='old');
    read(9,*); "i.e. ignore the title"
    read(9,*) nensrc,ensrcd(0),mode;
    IF( nensrc > $NENSRC ) [
        write(6,*) ' Too many bins in spectrum!';
        stop;
    ]
    read(9,*) (ensrcd(i),srcpdf(i),i=1,nensrc);
    close(9);
    IF( mode = 1 ) [
        DO i=1,nensrc [ srcpdf(i) = srcpdf(i)*(ensrcd(i)-ensrcd(i-1)); ]
    ]
    eave = 0; sum = 0;
    DO i=1,nensrc [
        sum = sum + srcpdf(i);
        eave = eave + 0.5*srcpdf(i)*(ensrcd(i)+ensrcd(i-1));
    ]
    eave = eave/sum;
    call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at);

]

ival                   = ival + 1;
values_sought(ival)    = 'SOURCE TYPE';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = 0;
value_max(ival)        = 1;
default(ival)          = 0;
$GET_INPUT(ival);
source_type = value(ival,1);

IF( source_type = 0 ) [

    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT ANGLE';
    type(ival)             = 0;
    nvalue(ival)           = 1;
    value_min(ival)        = 0;
    value_max(ival)        = 90;
    default(ival)          = 0;
    $GET_INPUT(ival);
    angle = value(ival,1);
    wi = angle/180*PI; wi = cos(wi);
    ui = sqrt((1-wi)*(1+wi)); vi = 0;
    write(6,*) ' ui vi wi = ',ui,vi,wi;

]
ELSE IF( source_type = 1 ) [

    ival                   = ival + 1;
    values_sought(ival)    = 'SOURCE RBEAM';
    type(ival)             = 0;
    value_min(ival)        = 0;
    value_max(ival)        = 1e8;
    default(ival)          = 1;
    $GET_INPUT(ival);
    rbeam = value(ival,1);

    ival                   = ival + 1;
    values_sought(ival)    = 'SOURCE DISTANCE';
    type(ival)             = 0;
    value_min(ival)        = 0;
    value_max(ival)        = 1e8;
    default(ival)          = 100;
    $GET_INPUT(ival);
    distance = value(ival,1);

]
ELSE [
    write(6,*) ' Unknown source type!';
    stop;
]

return;

entry source_sumry(ounit);
"========================="

write(ounit,'(/a)')
 '                        Source                                  ';
write(ounit,'(a)')
 '================================================================';

write(ounit,'(a,$)')
  ' Incident charge              : ';
IF( iqi = -1 )     [ write(ounit,'(a)') 'Electron'; ]
ELSE IF( iqi = 0 ) [ write(ounit,'(a)') 'Photon'; ]
ELSE               [ write(ounit,'(a)') 'Positron'; ]
write(ounit,'(a,i2)')
  ' Incident spectrum            : ',mono;
IF( mono ~= 1 ) [
 IF (neis = 1)[
  write(ounit,'(a,$)')
  ' Incident kinetic energy (MeV): ';
  write(ounit,'(f15.8)') ei-rm*abs(iqi);
 ]
]
ELSE [
write(ounit,'(a,f10.5)')
 ' Average spectrum energy       : ',eave;
write(ounit,'(a,f10.5)')
 ' Maximum spectrum energy       : ',ensrcd(nensrc);
] "end of spectrum block"
write(ounit,'(a,i2)')
 ' Source type                  : ',source_type;
IF( source_type = 0 ) [
write(ounit,'(a,f7.4)')
  ' Incident angle               : ',angle;
]
ELSE [
write(ounit,'(a,f7.4)')
  ' Beam size on front face      : ',rbeam;
write(ounit,'(a,f7.4)')
  ' Source-face distance         : ',distance;
]
write(ounit,'(//)');

return;

entry source_get_emax(emax);
"=========================="

IF( mono = 0 | mono = 2  | mono = 3 ) [
    IF( iqi = 0 ) [ emax = ei; ]
    ELSE          [ emax = ei-rm; ]
]
ELSE [
    emax = ensrcd(nensrc);
]
return;

entry source_get_eave(e);
"========================"

IF( mono = 0 | mono = 2  | mono = 3 ) [
    IF( iqi = 0 ) [ e = ei; ]
    ELSE          [ e = ei-rm; ]
]
ELSE [
    e = eave;
]
return;

entry source_get_samplede(es,des);
"================================="

IF( ecount <= 2 ) return;
aux = esum/ecount;
aux2 = esum2/ecount;
aux2 = (aux2 - aux*aux)/(ecount-1);
IF( aux2 > 0 ) [ aux2 = sqrt(aux2); ]
es = aux; des = aux2;
return;

entry source_set_energy(ein);
ei = ein;
return;

entry source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
"=============================================================="

iqin = iqi;
irin = 1;
IF( mono = 0 | mono = 2 | mono = 3 ) [ ein = ei; wtin = 1; ]
ELSE [
    ein = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at);
    wtin = 1; eik = ein;
    IF( iqin ~= 0 ) [ ein = ein + rm; ]
]
ecount = ecount + 1;
esum = esum + eik;
esum2 = esum2 + eik*eik;

IF( source_type = 0 ) [
    xin = 0; uin = 0; zin = 0;
    uin = ui; vin = vi; win = wi;
]
ELSE [
    $RANDOMSET r; r = rbeam*sqrt(r);
    $RANDOMSET phi; phi = 2*phi*PI;
    xin = r*cos(phi); yin = r*sin(phi);
    aux = 1/sqrt(xin*xin + yin*yin + distance*distance);
    uin = xin*aux; vin = yin*aux; win = distance*aux;
    zin = 0;
]

return;

entry source_switch_energy(itimes);
"========================="
IF (mono =1) [return;]
ei=eis(itimes); eik = ei;
ecount = 0; esum = 0; esum2 = 0;
IF (neis > 1)[
  write(6,'(a,$)')
  '===> Incident kinetic energy (MeV): ';
  write(6,'(f15.8,10x,a)') ei-abs(iqi)*rm, '      ********************';
]
return;

end;  "of subroutine source"

"************************************************************************""
subroutine test_brems;
"************************************************************************""
implicit none;
;COMIN/ELECIN,EPCONT,SCORE,STACK,USEFUL/;

$INTEGER  icase,iqin,irin,ip,lelke;
$REAL     ein, xin,yin,zin, uin,vin,win,wtin;
$REAL     dedx,ebr1,sig,sig_brem,eb;
real*8    sum,sum2;

call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
np=1; e(np)=ein; iq(np)=-1; ir(np)=1; wt(np)=1;
/x(np),y(np),z(np)/=0; u(np)=0; v(np)=0; w(np)=1;
elke = log(ein-prm); medium=1;
$SET INTERVAL elke,eke;
$EVALUATE dedx USING ededx(elke);
$EVALUATE ebr1 USING ebr1(elke);
$EVALUATE sig USING esig(elke);
sig_brem = sig*ebr1;
write(6,*) ' Incident energy: ',ein-prm,elke;
write(6,*) ' dedx: ',dedx;
write(6,*) ' sig:  ',sig;
write(6,*) ' ebr1: ',ebr1;
write(6,*) ' Brems cross section: ',sig_brem;

DO icase=1,ncase [

  np=1; e(np)=ein;
  call brems; eb=0;
  DO ip=1,np [
      IF(iq(ip) = 0) [ eb = eb + e(ip); ]
  ]
  sum = sum + eb; sum2 = sum2 + eb*eb;
]

sum = sum/ncase; sum2 = sum2/ncase; sum2 = sum2 - sum*sum;
IF( sum2 > 0 ) [ sum2 = sqrt(sum2/(ncase-1)); ]
write(6,*) ' Average energy per brem: ',sum,' +/- ',sum2;
write(6,*) ' Rad. stopping power: ',sum*sig_brem,' +/- ',sum2*sig_brem;
stop; "return;
end;

"************************************************************************""
subroutine test_compton;
"************************************************************************""

REPLACE {$ANALYZE1#;} WITH {;
  sum{P1} = sum{P1}/ncase; sum{P1}2 = sum{P1}2/ncase;
  sum{P1}2 = sum{P1}2 - sum{P1}*sum{P1};
  IF( sum{P1}2 > 0 ) [ sum{P1}2 = sqrt(sum{P1}2/(ncase-1)); ]
};

implicit none;
;COMIN/PHOTIN,EPCONT,MEDIA,SCORE,STACK,USEFUL/;

$INTEGER  icase,iqin,irin,ip,lgle;
$REAL     ein, xin,yin,zin, uin,vin,win,wtin;
$REAL     gmfp,gbr1,gbr2;
real*8    sumr,sumr2,sume,sume2,sumtr,sumtr2;
$REAL     es,des,ee,factor;

medium = 1;
DO icase=1,ncase [
  call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
  IF( iqin ~= 0 ) [
    write(6,*) ' test_compton: only works for photons!';
    stop;
  ]
  gle = log(ein);
  $SET INTERVAL gle,ge;
  $EVALUATE gmfp USING gmfp(gle);
  $EVALUATE gbr1 USING GBR1(GLE);
  $EVALUATE GBR2 USING GBR2(GLE);
  np=1; e(np)=ein; iq(np)=0; ir(np)=1; wt(np)=1;
  /x(np),y(np),z(np)/=0; u(np)=0; v(np)=0; w(np)=1;
  call compt;
  IF( np > 1 ) [
    IF( iq(1) = 0 ) [ ee = ein - e(1); ]
    ELSE [ ee = ein - e(2); ]
    sume = sume + ee; sume2 = sume2 + ee*ee;
    ee = ee*(gbr2-gbr1) + (1-gbr2)*ein;
    IF( ein > 2*prm & gbr1 > 0 ) [ ee = ee + gbr1*(ein-2*prm); ]
    ee = ee/gmfp/rho(medium);
    sumtr = sumtr + ee; sumtr2 = sumtr2 + ee*ee;
  ]
  ELSE [ sumr = sumr + 1; sumr2 = sumr2 + 1; ]
]

$ANALYZE1 r; $ANALYZE1 e; $ANALYZE1 tr;
call source_get_samplede(es,des);
write(6,*) ' Average sampled energy:   ',es,' +/- ',des;
write(6,*) ' Average number of Compton rejections: ',sumr,' +/- ',sumr2;
write(6,*) ' Average energy released in Compton events: ',sume,' +/- ',sume2;
factor = 160.2176462;  "e_mutr and e_muen scored as MeV cm^2/g"
                    "*1.602176462E-13 J/MeV *1000 g/kg =160.2176462E-12 Gy cm^2"
                    "Note, this is used elsewhere too"
write(6,*) ' mutr: ',factor*sumtr,' +/- ',factor*sumtr2;
stop;
return;
end;
