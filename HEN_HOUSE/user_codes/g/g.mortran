%C80
"#############################################################################"
"                                                                             "
"  EGSnrc g application                                                       "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Iwan Kawrakow, 2000                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Ernesto Mainegra-Hing                                     "
"                   Reid Townson                                              "
"                   Marc Chamberland                                          "
"                   Blake Walters                                             "
"                                                                             "
"#############################################################################"
%L
%E
!INDENT M 4;    "indent each mortran nesting level by 4"
!INDENT F 2;    "indent each fortran nesting level by 2"

"This line is 80 characters long, use it to set up the screen width"
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789"

"*********************************************************************"
"                                                                     "
"                     **********************                          "
"                     *                    *                          "
"                     *     g.mortran      *                          "
"                     *                    *                          "
"                     **********************                          "
"                                                                     "
" An EGSnrc user code. It calculates the energy fraction lost to      "
" radiation when electrons slow down, if the incident beam is photons,"
" or the radiative yield, if the incident beam is electrons.          "
" For photons, the code also calculates mu_tr and mu_en.              "
"                                                                     "
" Version 1.0  I. Kawrakow, January 2000                              "
" Version 1.1  I. Kawrakow, March 2002 (added E*mu_tr and E*mu_en)    "
" Version 1.2  D. Rogers, June 2002 (get mu_tr and mu_en )            "
" Version 1.3  D. Rogers, Aug 2002 (account for fluorescent photons   "
"                                  in g and mu_tr correctly )         "
" Version 1.4  R. Townson, December 2016                              "
"  Energy depositions for kerma calculations below the cut-off are    "
"  now sorted out using AUSGAB to include only Auger from relaxations,"
"  not fluorescence.                                                  "
"                                                                     "
" Version 1.5  E. Mainegra-Hing, January 2020                         "
"  The g calculation for spectra was missing a factor mu/rho for both "
"  calculation types. This factor is now included when scoring e_tot  "
"  and e_rad. Bug reported by D. Rogers. The output has been made more"
"  informative and a verbose option added for the type 1 calculation. "
"  Code has been extensively documented and a doxygen based user's    "
"  manual created.                                                    "
"                                                                     "
" Version 1.6  E. Mainegra-Hing, August 2020                          "
"  Adjust original algorithm to ensure a desired precision in muen.   "
"  Option to speed up calculation type 1 in MeV range added. It has   "
"  been made independent of NCASE and precision defaults to 1%.       "
"  Improved calculation progress messages for type 1 calculations.    "
"                                                                     "
"*********************************************************************"
!COMMENTS;
%F
C> @file g.f
C> @brief Application for radiative energy loss calculations
C>
C>  EGSnrc application to calculate \f$\mathrm{\overline{g}}\f$,
C>  the average fraction of kinetic
C>  energy transferred to charged particles by photons lost to radiation when
C>  electrons slow down, or the radiative yield Y for electron beams.
C>  For photons, quantities such as kerma, collision kerma,
C>  \f$\left<\mu_\mathrm{tr}/\rho\right>_\psi\f$ and
C>  \f$\left<\mu_\mathrm{en}/\rho\right>_\psi\f$ are also calculated.
C>
C>  Implemented a type=1 calculation that can run until a prescribed precision
C>  is reached at any stage during the calculation. In a type=1 calculation
C>  \f$\mu_\mathrm{tr}/\rho\f$ is calculated first,
C>  then \f$\mu_\mathrm{en}/\rho\f$ is obtained as
C>  \f$\mu_\mathrm{tr}/\rho\cdot\left(1-\mathrm{\overline{g}}\right)\f$,
C>  where \f$\mathrm{\overline{g}}\f$ is the fraction lost to radiation from
C>  slowing down electrons. The advantage is that when
C>  \f$\mathrm{\overline{g}}\f$ is small, \f$\mu_\mathrm{en}/\rho\f$
C>  converges much faster to the desired precision compared to a type=0
C>  calculation.
C>
C>  Revision History
C>
C>  Version 1.0 (I. Kawrakow, January 2000): Initial version.
C>
C>  Version 1.1 (I. Kawrakow, March 2002):
C>  Added \f$E\cdot\mu_\mathrm{tr}/\rho\f$ and \f$E\cdot\mu_\mathrm{en}\f$.
C>
C>  Version 1.2 (D. Rogers, June 2002):
C>  Get \f$\mu_\mathrm{tr}/\rho\f$ and \f$\mu_\mathrm{en}/\rho\f$.
C>
C>  Version 1.3 (D. Rogers, Aug 2002):
C>  Account for fluorescent photons in \f$\mathrm{\overline{g}}\f$ and
C>  \f$\mu_\mathrm{tr}/\rho\f$ correctly.
C>
C>  Version 1.4 (R. Townson, December 2016):
C>  Energy depositions for kerma calculations below the cut-off are
C>  now sorted out using AUSGAB to include only Auger from relaxations,
C>  not fluorescence.
C>
C>  Version 1.5 (E. Mainegra-Hing, January 2020):
C>  The @g calculation for spectra was missing a
C>  factor \f$\mu/\rho\f$ for both calculation types. This factor is now
C>  included when scoring \f$\mathrm{e_{tot}}\f$ and \f$\mathrm{e_{rad}}\f$.
C>  Bug reported by D. Rogers.
C>  The output has been made more informative and a verbose option added
C>  for type 1 calculation.
C>  Code has been extensively documented and a doxygen based user's
C>  manual created.
C>
C>  Version 1.6 (E. Mainegra-Hing, August 2020):
C>  Calculation type 1 has been made independent of NCASE and the target
C>  precision now defaults to 1%. Algorithm now ensures @muen_rho
C>  is calculated to the  user-requested precision @accu by computing @mutr_rho
C>  down to @accu/\f$\sqrt{4/3}\f$ and 1-@g to @accu/2.
C>  For calculations in the megavoltage range (for Ir-192, Co-60)
C>  one can modify the target precision of mutr and 1-g to save substantial
C>  time in the fairly time consuming calculations above 1 MeV. To this end
C>  the uncertainty in @mutr_rho and 1-@g can be modified so that the
C>  \muen_rho value has an precision \accu according to:
C>
C>  \f$\sigma(\mu_\mathrm{tr}) = \frac{\sigma}{\sqrt{m}} \qquad \textrm{and}
C>  \qquad \sigma(1-\overline{g})  = \frac{\sigma}{\sqrt{m/(m-1)}}\f$
C>
C>  where m can be 2, 3, 4, etc. A value of m =1 indicates the original
C>  implementation should be used. For megavoltage
C>  energies around 1 MeV, m = 2 is recommended.
C>  Calculation progress messages during a type 1 calculation
C>  have been made clearer and the code has been further documented.
C>  The documentation has been also updated to reflect these changes.
C>
C>  @IK
C>  @date 2000
C>  @copyright National Research Council Canada
%M
!NOCOMMENTS;

"Variables definitions
"
!COMMENTS;
%F
C> @param[out] g average fraction of the kinetic energy of secondary charged
C>             particles (produced in all the types of interactions) that is
C>             subsequently lost in radiative (photon-emitting) energy-loss
C>             processes as the particles slow to rest in the medium.
C> (Taken from the
C> <a href="http://physics.nist.gov/PhysRefData/XrayMassCoef/chap3.html">
C> NIST web page</a>)
C> @param e_brem    Average energy lost to bremsstrahlung
C> @param ebrem_tmp As above for the current history
C> @param e_rad  Average energy lost to bremsstrahlung & kinetic energy
C>               transferred in annihilation radiation (ie only annihilation
C>               in flight. Note this used to include fluorescent photons, but
C>               they should be excluded from e_tot as well.
C> @param erad_tmp As above for the current history
C> @param e_tot  average energy released per particle
C>               includes subthreshold energy (iarg=4)
C> @param etot_tmp  As above for the current history
C> @param e_radc  = sum (etot_tmp*erad_tmp)
C> @param e_bremc = sum (etot_tmp*ebrem_tmp)
C> @param[out] e_brem/e_tot the average fraction of the kinetic energy
C>             subsequently lost in bremsstrahlung (photon-emitting) events
C> @param[out] e_rad/e_tot same as g above
C> @param anorm
C> @param npgi
C> @param npei
C> @param E_ave   Average spectrum energy
C> @param factor  Converts e_mutr and e_muen scored as
C>                \f$\mathrm{MeV}\,\mathrm{cm}^2/\mathrm{g}\f$
C>                to \f$\mathrm{Gy}\,\mathrm{cm}^2\f$
C> @param de_pulsei
C> @param mutr The correct definition for a spectrum is that given by Attix
C>             of an energy fluence weighted average mass transfer coefficient
C>  \f[
C>    \left<\mu_\mathrm{tr}/\rho\right>_{\psi} =
C>     \int \psi(E) \mu_\mathrm{tr}(E)/\rho dE/\int \psi(E) dE
C>  \f]
C>  This is equivalent to the ICRU60/ICRU85 definition as long as one sums
C>  the total energy transferred from the spectrum and then divides by the
C>  average energy incident.
C>  For a while we scored <mu_tr/rho> directly, but this can differ
C>  substantially from the correct results and amounts to averaging
C>  over the fluence, not the energy fluence
C> @param muen Similarly, the energy fluence weighted average mass
C>             absorption coefficient is given by
C>  \f[
C>    \left<\mu_\mathrm{en}/\rho\right>_{\psi} =
C>    \int \psi(E) \mu_\mathrm{en}(E)/\rho dE/\int \psi(E) dE =
C>    \left<\mu_\mathrm{tr}/\rho\right>\,\left(1-\overline{g}\right)
C>  \f]
C> @param e_mutr Fluence averaged product
C>        \f$\left<E\,\mu_\mathrm{tr}/\rho\right>_{\phi}\f$
C> @param e_muen Fluence averaged product
C>       \f$\left<E\,\mu_\mathrm{en}/\rho\right>_{\phi}\f$
C> @param Eave  average energy of incident spectrum: either actual or sampled
%M
!NOCOMMENTS;

REPLACE {$VERSION} WITH {'1.6'}
"---------------------------------------------------------------------"
"STEP 1:  USER-OVERRIDE-OF-EGSnrc-MACROS                              "
"---------------------------------------------------------------------"
REPLACE {$MXMED} WITH {1}    "we need just one medium                 "
REPLACE {$MXREG} WITH {1}    "and just one geometrical region         "
REPLACE {$MXSTACK} WITH {50} "this should be enough for any purposes  "
REPLACE {$MXSAMPLE} WITH {1000000} "Max. failed attempts to sample photon"
                                   "energy above AP(medium)"

REPLACE {$DEBUGIT} WITH {.false.} "that can be used for debugging purposes"

REPLACE {$MXGE} WITH {2000}
REPLACE {$MXCHUNK} WITH {10000}

"Round-off errors produce wrong results for a 1 keV energy value."
"The quick fix is to add an epsilon equal to or larger than 1.0D-12 eV."
"Using here a slightly larger epsilon of 1.0D-4 eV to account for "
"machine precision differences. This should still be negligible in "
"the keV energy range."
REPLACE {$E_THRESHOLD} WITH {1.0D-3}; "Minimum energy in EGSnrc"
REPLACE {$E_EPS}       WITH {1.0D-10};"Shifted by small epsilon"

"Replace the $CALL-HOWNEAR macro for an infinite homogeneous geometry"
REPLACE {$CALL-HOWNEAR(#);} WITH {;
  {P1} = 1e10;
}

"Don't need any calls to howfar"
REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;}
REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
  IF( wt(np) <= 0 ) idisc = 1;
};

"Define a common for scoring"
REPLACE {;COMIN/SCORE/;} WITH {;
  common/score/ e_tot,e_tot2,e_brem,e_brem2,e_bremc,e_rad,e_rad2,e_radc,
                etot_tmp,ebrem_tmp,erad_tmp,my_gle,accu,ncase,calc_type,
                during_pe_compt,during_eii,verbose,m_balance;
                "It is always a good idea to score in double precision!"
  real*8        e_tot,e_tot2,e_brem,e_brem2,e_rad,e_rad2,
                etot_tmp,ebrem_tmp,erad_tmp,e_radc,e_bremc;
  $LONG_INT     ncase;
  $REAL         my_gle,accu;
  $INTEGER      calc_type,during_pe_compt,during_eii,m_balance;
  $LOGICAL      verbose;
};

REPLACE {$MXENE} WITH {2000};  "maximum number of energies to be looped over"

"Define a common for energies"
REPLACE {;COMIN/ENERGIES/;} WITH {;
  common/energies/ eis,neis;
  $REAL     eis($MXENE);
  $INTEGER  neis;
};

" Don't need any photon transport "
REPLACE {$SELECT-PHOTON-MFP;} WITH { dpmfp = 0; };

" A convenience macro for statistical analysis "
REPLACE {$ANALYZE#(#);} WITH {;
  {P1} = {P1}/{P2}; {P1}2 = {P1}2/{P2};
  {P1}2 = {P1}2 - {P1}*{P1};
  IF( {P1}2 > 0 ) [ {P1}2 = sqrt({P1}2/({P2}-1)); ]
};

"---------------------------------------------------------------------"
" Step 1a: begin of executable code and variable declarations         "
"---------------------------------------------------------------------"

program calculate_g;

$IMPLICIT-NONE;

;COMIN/THRESH,          "for threshold energies"
       BOUNDS,          "for ECUT,PCUT"
       MEDIA,           "to be able to print medium name"
       USEFUL,          "to get electron rest energy"
       SCORE,           "the results of the shower simulation, to be used"
                        "in step 8"
       PHOTIN,          "so that gmfp can be calculated"
       STACK,
       RANDOM,
       EPCONT,
       ENERGIES
      /;

character*80 datfile(50);
real*8       aux,aux2,total,anorm,sum,sum2,xtest,xtest2;
!COMMENTS;
%F
C> The correct definition of mu_tr/rho for a spectrum is that given by
C> Attix = int[psi mu_tr/rho dE]/int[psi dE]  This is equivalent to the
C> ICRU60 defn as long as one sums the total energy transferred from
C> the spectrum and then divides by the average energy incident
C> For a while we scored <mu_tr/rho> directly, but this can differ
C> substantially from the correct results and amounts to averaging
C> over the fluence, not the energy fluence
%M
!NOCOMMENTS;
real*8       e_mutr, e_mutr2, e_muen, e_muen2, mutr, mutr2, muen, muen2;
real*8       ert, ert2, ett, ett2, g, g_rel_err;
real*8       accu0, m;
$REAL        weight,weight2,cov,covt,rel_e;
$LONG_INT    nperbatch,ncasei,icase,nmutr,nmuen;
$REAL        de_pulsei, Eave, err_Eave,factor,gmfp;
$REAL        t_mutr, t_muen;
"For interacting with the source routine and shower"
$REAL        ein,uin,vin,win,wtin,xin,yin,zin,ecut_ask,pcut_ask;
$REAL        gbr1,gbr2,rnno,err_frac;
$INTEGER     iqin,irin,ip;
$INTEGER     itimes, ntimes;"loop through different energies"
real*4       cpu,etime,time_array(2);
$INTEGER     datcount;
$INTEGER     npgi,npei,nspliti,nbini,lmy_gle;
$INTEGER     nbatch, "$INTEGER and $REAL are defined in egsnrc.macros"
             ibatch, "they can be used (if employed consistently throughout"
             i,j,i_log;    "the user code) e.g. to switch to double precision"
$INTEGER ifailed;    "Number of failed attempts to sample energy above AP"
$REAL ekmax;

"---------------------------------------------------------------------"
" Steps 2 (pre-hatch initializations),                                "
"       4 (initializations for howfar and hownear)                    "
"       5 (initializations for ausgab)                                "
"       6 (determination of incident particle parameters)             "
" are done in subroutine inputs                                       "
"---------------------------------------------------------------------"

i_log = 6;

call egs_init;

call inputs;

ecut_ask = ecut(1);
pcut_ask = pcut(1);

"---------------------------------------------------------------------"
"deferred STEP 3   HATCH-CALL                                         "
"---------------------------------------------------------------------"

OUTPUT; (' CALL HATCH to get cross-section data'/);
CALL HATCH;

write(*,'(//)');
write(*,*) '************************************';
write(*,*) '* Start g calculation: Version '//$VERSION//' *';
write(*,*) '************************************';
OUTPUT (media(j,1),j=1,24);(/'          MEDIUM is: ',24A1/);
;OUTPUT AE(1)-PRM, AP(1);
(' knock-on electrons can be created and any electron followed down to'
/T40,F8.3,' MeV kinetic energy'/
'   brem photons can be created and any photon followed down to      ',
/T40,F8.3,' MeV ');
"Compton events can create electrons and photons below these cutoffs"
;OUTPUT UE(1)-rm, UP(1);
  (' electron and photon upper kinetic energies are:',F8.3,F11.3,
   ' MeV respectively');

"a common problem has been to ask for a lower ecut or pcut than the "
"data set covers.  Prevent this by exiting if it occurs.  The user  "
"is then forced to fix the data set or the asked for cut-offs. "

IF(ecut_ask < ae(1)   | pcut_ask < ap(1) )[
   OUTPUT ecut_ask, AE(1), pcut_ask, AP(1);
   (//'**************************************************************'/
      'There is a mismatch between asked for and available cut-offs  '/
      'Asked for ECUT of', F10.4,' MeV and have AE of',F10.4,' MeV'/
      'Asked for PCUT of', F10.4,' MeV and have AP of',F10.4,' MeV'/
      'Exiting until there is a match'/
      '**************************************************************'/);
   STOP;
]

"Also, check that max. energy of particle source is not > ue, up"
call source_get_emax(iqin,ekmax);
IF((iqin~=0 & ekmax+rm > ue(1)) | (iqin=0 & ekmax > up(1)))[
   OUTPUT ekmax+abs(iqin)*rm;
   (//'**************************************************************'/
'The max. total energy of source particles exceeds that of cross-section data '/
'Max. E of source particles = ',F10.4,' MeV');
   IF(iqin ~=0)[
      OUTPUT ue(1);('UE = ',F10.4,' MeV');
   ]
   ELSE[
      OUTPUT up(1);('UP = ',F10.4,' MeV');
   ]
   OUTPUT;('**************************************************************'/);
   STOP;
]

"Increase minimum energy by small epsilon to prevent round-off errors"
"at 1 keV and below"
call source_check_emin();

"---------------------------------------------------------------------"
"STEP 7   SHOWER-CALL                                                 "
"---------------------------------------------------------------------"

"call test_brems;
"call test_compton;

"initiate the shower ncase times"
cpu = etime(time_array);
write(6,'(a,f9.2)') ' CPU time so far: ',cpu;
;OUTPUT;(/' Starting shower simulation ...');
nbatch = 10; nperbatch = ncase/nbatch;
IF(nperbatch = 0) nperbatch = 1;
      "Note that nbatch and nperbatch are not used for statistical analysis"
      "They are merely for printing information about the progress of the"
      "simulation"

call source_sumry(6);

IF( calc_type = 1) [
  write(*,*)
  '-------------------';
  write(6,'(a,0Pf7.4,a)')
  ' Calculation type 1: Calculation interrupted when muen precision <= ',
  accu*100.,'%.';
  IF (m_balance = 1)[
     write(*,*) '-------------------';
  ]
  ELSE[
     write(*,'(a,i0)')
     '-------------------  Precision balance factor m = ',m_balance;
  ]
]
ELSE[
  write(*,*);
  write(6,'(a,i0)') 'Number of histories to simulate = ',ncase;
]

factor = 160.2176462;"e_mutr and e_muen scored as MeV cm^2/g"
                     "*1.602176462E-13 J/MeV *1000 g/kg =160.2176E-12 Gy cm^2"
                     "Note, this is used elsewhere too"

ifailed = 0;

IF (neis>1)[
  ntimes = neis;
  write(6,'(//A)')    '=====================================';
  write(6,'(A,I4,A)') 'Will loop through ',ntimes,' energies';
  write(6,'(A//)')    '=====================================';
]
ELSE       [ntimes = 1;]

DO itimes=1,ntimes[ "start of loop over different initial energies"

"following two were only done in subroutine inputs before"
/e_tot,e_tot2,e_rad,e_rad2,e_brem,e_brem2,e_bremc,e_radc/ = 0;
/during_pe_compt,during_eii/ = 0;
/e_mutr,e_mutr2,e_muen,e_muen2,mutr,mutr2,muen,muen2/ = 0.0;
/nmutr,nmuen/ = 0;

call source_get_eave(Eave);

call source_switch_energy(itimes);
"above gets initial energy from those we loop over"
"returns ei"

IF( calc_type = 1 ) [  "will seek a given precision -- default does not do this"

   /*********************************************************************
       Precision balancing can be used to speed up calculations
       for energies above 1 MeV. Most times the kerma approximation
       is used for energies under 100 keV where the original
       implementation is more efficient. An exception would be Ir-192.
    **********************************************************************/
    IF (itimes = 1) ["Only do this on 1st energy"
       accu0 = accu; m = m_balance;
    ]"end itimes = 1 block"

    "Update for each energy since accu "
    "changes in the 1-g calculation block"
    IF (m > 1)[
       accu = accu0/sqrt(m);
    ]
    ELSE[
       accu = accu0/sqrt(4./3.);
    ]
    write(6,*);
    write(6,'(a,0Pf7.4,a)') '=> First calculating mutr to <= ',accu*100.,
                             '% statistical precision';
    write(6,*);
    /x(1),y(1),z(1)/=0; wt(1) = 1; ir(1) = 1; medium = 1;
    ibatch = 1; icase = 1;
    "initiate mutr timer"
    t_mutr = etime(time_array);
    "DO icase=1,ncase ["
    LOOP [
        icase += 1;
        call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
        IF( iqin ~= 0 ) [
            write(6,*) 'type=1 calculation only works for photons!';
            $CALL_EXIT(1);
        ]
        IF( ein < ap(1))[
            OUTPUT ein, pcut_ask;
            (/' -> Photon energy of ' , f10.5,' MeV '/
              '    below cut-off AP = ',f10.5,' MeV.'/
              '    Discard and resample source.');
            ifailed += 1;
            IF (ifailed > $MXSAMPLE)[
             $egs_fatal('(/,a,i9)',
             'Too many failed attempts sampling a valid photon energy:',
             ifailed);
            ]
            ELSE[
             $egs_warning('(a,i9)',
             'Failed attempts sampling a valid photon energy:',
             ifailed);
             NEXT;"i.e. go to the next icase in the loop"
            ]
        ]
        my_gle = log(ein); gle = my_gle;
        $SET INTERVAL my_gle,ge;
        $EVALUATE gmfp USING gmfp(my_gle);
        $EVALUATE gbr1 USING gbr1(my_gle);
        $EVALUATE gbr2 USING gbr2(my_gle);
        np = 1; e(np) = ein; u(np)=0; v(np)=0; w(np)=1; iq(np) = 0;
        $RANDOMSET rnno; edep = 0;
        IF( rnno < gbr1 & ein > rmt2 )[
                 call pair;
        ]
        ELSE IF( rnno < gbr2 )        [
                 call compt;
        ]
        ELSE [
                 call photo;
        ]
        /****************************************************
          Collects photons' kinetic energy transferred to e-
          above the threshold. Sub-threshold energy transfer
          is added directly to edep for Compton, photoeffect
          and atomic relaxations. Since only total energy
          transfer is of interest in this block, there is no need
          for further classification.
        *******************************************************/
        DO ip=1,np [
           IF( iq(ip) ~= 0 ) edep = edep + e(ip)-prm;
        ]
        nmutr = nmutr + 1;
        IF(gmfp > 0) [
            aux = edep/gmfp/rho(1);
        ] ELSE [
            aux = 0;
        ]
        e_mutr = e_mutr + aux; e_mutr2 = e_mutr2 + aux*aux;
        /*********************************************
         Only check after certain number of histories,
         this number is arbitrarily set to $MXCHUNK.
        **********************************************/
        IF( mod(icase,$MXCHUNK) = 0 ) [
            xtest = e_mutr; xtest2 = e_mutr2;
            $ANALYZE xtest(nmutr);
            "write(6,*) icase,xtest2/xtest;"
            IF( xtest2/xtest < accu ) EXIT;
            /*****************************************************************
             Display calculation progress starting at 10X the target precision
             reporting the time it takes to get 10X, 9X,..the target precision.
             Since this check is done after an arbitrary number of histories,
             the progress will show a statistical precision that is at or below
             a multiple of the target.
            *****************************************************************/
            IF( xtest2/xtest/(nbatch-ibatch+1) < accu) [
              write(6,'(a,i2,a,a,f8.2,a,f11.8,a,f8.4,a)')
              '+ Reached ',nbatch-ibatch+1,'X target precision ',
              ', cpu time = ',etime(time_array)-cpu,
              ' sec. <mu_tr/rho> = ', xtest/Eave,' cm^2/g [',
              100*xtest2/xtest,'%]';
              $FLUSH_UNIT(6);  "so the log file is updated each time"
              ibatch +=1;
            ]
        ]
    ] REPEAT; "end of icase loop for calc_type=1 seeking a given precision"
    $FLUSH_UNIT(6);  "so the log file is updated each time"
    xtest = e_mutr; xtest2 = e_mutr2; $ANALYZE xtest(nmutr);
    IF( xtest2/xtest < accu ) [
        write(6,'(a,f8.2,a,f11.8,a,f8.4,a)')
            '+ Reached     target precision , cpu time = ',
            etime(time_array)-cpu,
            ' sec. <mu_tr/rho> = ', xtest/Eave,' cm^2/g [',
            100*xtest2/xtest,'%]';
        write(6,*);
        write(6,'(a,i0,a)')
        ' mu_tr attained desired precision after ',nmutr,' histories';
        write(6,*);
    ]
    ELSE[
        write(6,*);
        write(6,'(a,i0,a)')
       ' mu_tr did not reach target precision after ',
       nmutr,' histories';
        write(6,*);
    ]
    write(6,:KERMAFORMAT:) ' <E*mu_tr/rho>     = ',factor*xtest,
               ' 10^-12 Gy cm^2  +/- ',
               100*xtest2/xtest,'%';
    write(6,*);

    IF (m > 1)[
       accu = accu0/sqrt(m/(m-1.));
    ]
    ELSE["Original implementation"
       accu = accu0/2.;
    ]

    write(6,*);
    write(6,'(a,0Pf7.4,a)') '=> Now calculating 1-g to <= ',accu*100.,
                             '% statistical precision';
    write(6,*);
    $FLUSH_UNIT(6);  "so the log file is updated each time"

    "we are in the calc_type = 1 block photons only"
    "     -quits when precision reached"
    ibatch = 1; icase = 0;
    "initiate muen timer"
    t_muen = etime(time_array);
    "DO icase=1,ncase ["
    LOOP [
        icase += 1;
        call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
        IF( iqin ~= 0 ) [
            write(6,*) 'type=1 calculation only works for photons!';
            $CALL_EXIT(1);
        ]

        IF( ein < ap(1))[
            OUTPUT ein, pcut_ask;
            (/' -> Photon energy of ' , f10.5,' MeV '/
              '    below cut-off AP = ',f10.5,' MeV.'/
              '    Discard and resample source.');
            ifailed += 1;
            IF (ifailed > $MXSAMPLE)[
             $egs_fatal('(/,a,i9)',
             'Too many failed attempts sampling a valid photon energy:',
             ifailed);
            ]
            ELSE[
             $egs_warning('(a,i9)',
             'Failed attempts sampling a valid photon energy:',
             ifailed);
             NEXT;"i.e. go to the next icase in the loop"
            ]
        ]

        /ebrem_tmp,erad_tmp,etot_tmp/ = 0.0;

        call shower(iqin,ein,xin,yin,zin,uin,vin,win,irin,wtin);

        my_gle = log(ein); gle = my_gle;
        $SET INTERVAL my_gle,ge;
        $EVALUATE gmfp USING gmfp(my_gle);
        weight = 0.0; weight2 = 0.0; aux = 0.0;
        "Score mass-energy transfer"
        IF(gmfp > 0) [
            weight  = 1./gmfp/rho(1);
            weight2 = weight*weight;
            aux = etot_tmp*weight;
        ]
        e_mutr = e_mutr + aux; e_mutr2 = e_mutr2 + aux*aux;
        "Score mass-energy absorption"
        IF(gmfp > 0) [
          aux = (etot_tmp - erad_tmp)*weight;
        ]
        ELSE [
          aux = 0;
        ]
        e_muen = e_muen + aux; e_muen2 = e_muen2 + aux*aux;

        nmutr = nmutr+1; nmuen = nmuen + 1;
        e_tot = e_tot + etot_tmp*weight;
        e_tot2 = e_tot2 + etot_tmp*etot_tmp*weight2;
        e_rad = e_rad + erad_tmp*weight;
        e_rad2 = e_rad2 + erad_tmp*erad_tmp*weight2;
        e_radc = e_radc + etot_tmp*erad_tmp*weight2;
        /*********************************************
         Only check after certain number of histories,
         this number is arbitrarily set to $MXCHUNK.
        **********************************************/
        IF( mod(icase,$MXCHUNK) = 0 & accu > 0 ) [
        "IF( mod(icase,100) = 0 ) ["
            IF( e_rad > 0 ) [
                ert = e_rad; ert2 = e_rad2; $ANALYZE ert(nmuen);
                ett = e_tot; ett2 = e_tot2; $ANALYZE ett(nmuen);
                /***********************************************
                   Covariance includes a division by nmuen since
                   the uncertainties provided by $ANALYZE are
                   std dev of the mean not the sample std dev
                 **********************************************/
                cov = (e_radc/nmuen-ert*ett)/nmuen;"Covariance"
                covt= 2*(e_radc/nmuen/ert/ett-1)/nmuen;"Covariance term"
                rel_e = ert*sqrt((ert2/ert)**2+(ett2/ett)**2-covt)/(ett-ert);
                IF( rel_e < accu ) EXIT;
            ]
            ELSE [
                IF( icase > 100000 ) [
                    rel_e = 0; EXIT;
                ]
            ]
            /*****************************************************************
             Display calculation progress starting at 10X the target precision
             reporting the time it takes to get 10X, 9X,..the target precision.
             Since this check is done after an arbitrary number of histories,
             the progress will show a statistical precision that is at or below
             a multiple of the target.
            *****************************************************************/
            IF( rel_e/(nbatch-ibatch+1) < accu) [
              IF (verbose & ert2 > 0 & ett2 > 0)[
                 write(6,'(a,i2,a,a,f8.2,a,f11.8,a,f8.4,a,a,f8.4)')
                 '+ Reached ',nbatch-ibatch+1,'X target precision ',
                 ', cpu time = ',etime(time_array)-cpu,' sec. 1-g = ',
                 1-e_rad/e_tot,' [',100*rel_e,'%]',
                 ' Corr = Cov/s_rad/s_tot =',cov/ert2/ett2;
              ]
              ELSE[
                 write(6,'(a,i2,a,a,f8.2,a,f11.8,a,f8.4,a)')
                 '+ Reached ',nbatch-ibatch+1,'X target precision ',
                 ', cpu time = ',etime(time_array)-cpu,' sec. 1-g = ',
                 1-e_rad/e_tot,' [',100*rel_e,'%]';
              ]
              $FLUSH_UNIT(6);  "so the log file is updated each time"
              ibatch += 1;
            ]
        ]

    ] REPEAT; " end of icase loop"

    $FLUSH_UNIT(6);  "so the log file is updated each time"

    t_mutr = etime(time_array)-t_mutr;
    t_muen = etime(time_array)-t_muen;

    IF( ert2 < accu ) [
        IF (verbose & ert2 > 0 & ett2 > 0)[
            write(6,'(a,f8.2,a,f11.8,a,f8.4,a,a,f8.4)')
            '+ Reached     target precision , cpu time = ',
            etime(time_array)-cpu,' sec. 1-g = ',
            1-e_rad/e_tot,' [',100*rel_e,'%]',
            ' Corr = Cov/s_rad/s_tot =',cov/ert2/ett2;
        ]
        ELSE[
            write(6,'(a,f8.2,a,f11.8,a,f8.4,a)')
            '+ Reached     target precision , cpu time = ',
            etime(time_array)-cpu,' sec. 1-g = ',
            1-e_rad/e_tot,' [',100*rel_e,'%]';
        ]
        write(6,*);
        write(6,'(a,i0,a)') ' 1-g attained desired precision after ',
                   nmuen,' histories';
        write(6,*);
        write(6,*);
    ]
    ELSE[
        write(6,*);
        write(6,'(a,i0,a)')
       ' 1-g did not reach target precision after ',
       nmuen,' histories';
        write(6,*);
    ]

    $ANALYZE e_mutr(nmutr); $ANALYZE e_muen(nmuen);
    $ANALYZE e_tot(nmuen);  $ANALYZE e_rad(nmuen);
    IF( e_rad < 1e-15*e_tot ) e_rad = 1e-15*e_tot;

    write(6,'(a)')  '-----------------------------';
    write(6,'(a)')  'Final results (calc. type 1):';
    write(6,'(a/)') '-----------------------------';

    call source_get_eave(Eave);
    write(6,'(a,f10.5,a)') ' Average spectrum energy: ',Eave,' MeV';
    call source_get_samplede(Eave,err_Eave);
    err_Eave = err_Eave/Eave;
    write(6,'(a,f10.5,a,f8.4,a/)') ' Average sampled energy : ',
          Eave,' MeV [',100*err_Eave,'%]';

    write(6,:KERMAFORMAT:) ' K/phi    = <E*mu_tr/rho>         = ',
               factor*e_mutr,
               ' 10^-12 Gy cm^2 [',100*e_mutr2/e_mutr,'%]';

    /***********************************************
       Covariance includes a division by nmuen since
       the uncertainties provided by $ANALYZE are
       std dev of the mean not the sample std dev
     **********************************************/
    covt = 2*(e_radc/nmuen/e_rad/e_tot-1)/nmuen;"Covariance term"
    g_rel_err = sqrt((e_rad2/e_rad)**2+(e_tot2/e_tot)**2-covt);
    g = e_rad/e_tot;
    e_rad2=e_rad*g_rel_err/(e_tot-e_rad);
    "e_rad2=e_rad*sqrt((e_rad2/e_rad)**2+(e_tot2/e_tot)**2)/(e_tot-e_rad);"

    write(6,:KERMAFORMAT:) ' Kcol/phi = <E*mu_tr/rho>*(1-<g>) = ',
              factor*e_mutr*(1-e_rad/e_tot), ' 10^-12 Gy cm^2 [',
              100*sqrt((e_mutr2/e_mutr)**2+e_rad2**2),'%]';
    write(6,*);

    write(6,'(a,1PE12.4,a,0PF8.4,a)')
      ' <g>                              = ',
         g,' [',100*g_rel_err,'%]';
    write(6,'(a,F12.6,a,0PF8.4,a)')
      ' 1-<g>                            = ',
        1-e_rad/e_tot,' [',100*e_rad2,'%]';
    write(6,*);

    write(6,:KERMAFORMAT:) '<mu_tr/rho> = <E*mu_tr/rho>/Eave         = ',
               e_mutr/Eave,'   cm^2/g [',
               100*sqrt((e_mutr2/e_mutr)**2+err_Eave**2),'%]';
    write(6,:KERMAFORMAT:) '<mu_en/rho> = <E*mu_tr/rho>*(1-<g>)/Eave = ',
               e_mutr*(1-e_rad/e_tot)/Eave,'   cm^2/g [',
               100*sqrt((e_mutr2/e_mutr)**2+e_rad2**2+err_Eave**2),'%]';
    write(6,'(a,1PE12.6,a)') '<E*mu_en/rho>                            = ',
             e_mutr*(1-e_rad/e_tot),'   MeV cm^2/g';

    IF (verbose)[

        write(*,*) ;
        write(*,*) '--------------------------';
        write(*,*) 'Calculation type 0 results:';
        write(*,*) '--------------------------';
        write(*,*) ;

        write(6,:KERMAFORMAT:) ' Kcol/phi   = <E*mu_en/rho>      = ',
                  factor*e_muen,' 10^-12 Gy cm^2       [',
                  100*e_muen2/e_muen,'%]';

        write(6,:KERMAFORMAT:) '<mu_en/rho> = <E*mu_en/rho>/Eave = ',
              e_muen/Eave,'   cm^2/g             [',
              100*sqrt((e_muen2/e_muen)**2+err_Eave**2),'%]';

        write(*,'(/a,f12.1,a/)')
        '-> Efficiency gain over calculation type 0: ',
        ((e_muen2/e_muen)**2+err_Eave**2)*t_muen/
        ((e_mutr2/e_mutr)**2+e_rad2**2+err_Eave**2)/t_mutr,
        ' times';
        write(*,*) '--------------------------';
    ]

goto :the_end:;

:KERMAFORMAT: FORMAT(a,1PE12.6,a,0PF7.4,a);

]  "end of calc_type = 1 block seeking a specified precision"

$FLUSH_UNIT(6);

"############################################################################"
"   start calc_type = 0, fixed number of histories                           "
"############################################################################"

write(6,*);
write(6,*) '-------------------------------------------------';
write(6,*) '=> Fixed number of histories (calculation type 0)';
write(6,*) '-------------------------------------------------';
write(6,*);
"Initialize weight to 1 so that's not undefined for charged particles"
weight = 1.0; weight2 = 1.0;
DO icase=1,ncase [

  call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
  IF( $DEBUGIT ) [
    write(18,*) ' ******* new shower, e = ',ein,' iq = ',iqin;
  ]
  ebrem_tmp = 0.0;           "keeps track of ke of charged particles lost"
                             "to brem and annihilation events"
  erad_tmp = 0.0;            "loses just to annihilation"
  "initialize etot_tmp differently for photons and electrons"
  IF( iqin .ne. 0 ) [ etot_tmp = (ein - rm); ]
  ELSE [ etot_tmp = 0; ]
"============================================================================"

  call shower(iqin,ein,xin,yin,zin,uin,vin,win,irin,wtin);

"============================================================================"
  IF( $DEBUGIT ) [
    write(18,*) ' energy released: ',etot_tmp,' lost to brems: ',ebrem_tmp,
     ' erad: ',erad_tmp;
  ]
  IF( iqin = 0 ) [
      my_gle = log(ein);
      $SET INTERVAL my_gle,ge;
      $EVALUATE gmfp USING gmfp(my_gle);  "mfp in cm"
      "when doing bound compton, the above is not the correct cross-section"
      "but we also throw out the uncollided photons, so it works out"

      weight = 0.0; weight2 = 0.0; aux = 0.0;
      IF(gmfp > 0) [
          weight  = 1./gmfp/rho(1);
          weight2 = weight*weight;
          aux = etot_tmp*weight; "energy per g/cm^2"
      ]
      e_mutr = e_mutr + aux; e_mutr2 = e_mutr2 + aux*aux;
      "mutr = mutr + aux/ein; mutr2   = mutr2 +aux*aux/(ein**2);"
      IF(gmfp > 0) [
          aux = (etot_tmp - erad_tmp)*weight;
      ] ELSE [
          aux = 0;
      ]
      e_muen = e_muen + aux; e_muen2 = e_muen2 + aux*aux;
      "muen = muen + aux/ein; muen2   = muen2 +aux*aux/(ein**2);"
  ] "end of photon only block"

  e_tot = e_tot + etot_tmp*weight;
  e_tot2 = e_tot2 + etot_tmp*etot_tmp*weight2;
  e_brem = e_brem + ebrem_tmp*weight;
  e_brem2 = e_brem2 + ebrem_tmp*ebrem_tmp*weight2;
  e_rad = e_rad + erad_tmp*weight;
  e_rad2 = e_rad2 + erad_tmp*erad_tmp*weight2;
  e_radc = e_radc + etot_tmp*erad_tmp*weight2;
  e_bremc = e_bremc + etot_tmp*ebrem_tmp*weight2;
  ibatch = icase/nperbatch;
  IF( ibatch*nperbatch = icase ) [
    write(6,'(a,i2,a,i2,a,f9.2,a)')
     '+ Finished part ',ibatch,' out of ',nbatch,
     ', cpu time = ',etime(time_array)-cpu,' sec.';
     $FLUSH_UNIT(6);  "so the log file is updated each time"
  ]
] "end of loop over number of histories = ncase times"

;OUTPUT;(/' Finished shower simulation ');

"-----------------------------------------------------------------"
"STEP 8   OUTPUT-OF-RESULTS                                       "
"-----------------------------------------------------------------"

write(*,*);
write(6,'(a)')  '-----------------------------';
write(6,'(a)')  'Final results (calc. type 0):';
write(6,'(a/)') '-----------------------------';

call source_get_eave(Eave);
write(6,*);
write(6,'('' Average spectrum energy: '',1PE10.4, '' MeV'')') Eave;
call source_get_samplede(Eave,err_Eave);
err_Eave = max(0.0, err_Eave);   "to take care of -ve errors from roundoff"
write(6,'('' Average sampled energy: '',1PE10.4, '' +/-'',1PE10.2,
      ''  MeV'')') Eave,err_Eave;

"Incorrect values (averaging over fluence, not energy fluence) commented out"
$ANALYZE e_tot(ncase);
$ANALYZE e_brem(ncase);
$ANALYZE e_rad(ncase);
factor = 160.2176462;  "e_mutr and e_muen scored as MeV cm^2/g"
                    "*1.602176462E-13 J/MeV *1000 g/kg =160.2176E-12 Gy cm^2"
                    "Note, this is used elsewhere too"

"Currently in calc_type=0"

IF( e_mutr > 0 ) [
    write(6,'(/)');
    $ANALYZE e_mutr(ncase);
    write(6,800)factor*e_mutr, 100*e_mutr2/e_mutr;
800 format(' <E*mu_tr/rho> i.e., K/phi =',1PE12.4,'    10^-12 Gy cm^2 +/-',
            0PF7.3,' %');
    write(6,801)e_mutr/Eave;
801  format(' <E*mu_tr/rho>/Eave        =',1PE12.4,'    cm^2/g');

    write(6,*) 'The above is the spectrum averaged coefficient';
    "write(6,*) ' difference        = ',(e_mutr/Eave - mutr)/mutr*100.,'%';"
]
IF( e_muen > 0 ) [
    $ANALYZE e_muen(ncase);
    write(6,*);
    write(6,'('' <E*mu_en/rho> i.e., Kcol/phi ='',
       1PE12.4,''    10^-12 Gy cm^2 +/-'',
       0PF7.3,'' %'')') factor*e_muen, 100*e_muen2/e_muen;
    write(6,'('' <E*mu_en/rho>/Eave           ='',1PE12.4,''    cm^2/g'')')
         e_muen/Eave;
    write(6,*) 'The above is the spectrum averaged coefficient';
    "write(6,*) ' difference        = ',(e_muen/Eave - muen)/muen*100.,'%';"
    write(6,'(/)');
]

OUTPUT e_tot,e_tot2, 100*e_tot2/e_tot;
  (' Ave energy released per particle:  ',1PE12.4, ' MeV +/-', 1PE10.3,
  ' [', 0PF7.3,' %]');
OUTPUT e_brem,e_brem2, 100*e_brem2/e_brem;
  (' Ave energy lost to bremsstrahlung: ',1PE12.4, ' MeV +/-', 1PE10.3,
  ' [', 0PF7.3,' %]');
OUTPUT e_rad,e_rad2, 100*e_rad2/e_rad;
  (' Ave energy lost to all radiation:  ',1PE12.4, ' MeV +/-', 1PE10.3,
  ' [', 0PF7.3,' %]');

err_frac = sqrt((e_brem2/e_brem)**2+(e_tot2/e_tot)**2);
OUTPUT e_brem/e_tot, err_frac*(e_brem/e_tot), 100.*err_frac;
   (/'fractions   g(brem) = ',1PE12.4,' +/-',1PE12.4,' [',0PF7.3,' %]');
err_frac = sqrt((e_rad2/e_rad)**2+(e_tot2/e_tot)**2);
OUTPUT e_rad/e_tot,err_frac*(e_rad/e_tot),100*err_frac;
   ( '         g(all rad) = ',1PE12.4,' +/-',1PE12.4,' [',0PF7.3,' %]'/);

write(6,*) 'The above fraction error estimates are made ignoring correlations';
write(6,*) ' between energy released and energy lost to radiation ';

e_radc = e_radc/ncase;       e_bremc = e_bremc/ncase;
IF( e_rad > 0 )  [ e_radc = (e_radc/e_tot/e_rad-1)/(ncase-1); ]
IF( e_brem > 0 ) [ e_bremc = (e_bremc/e_tot/e_brem-1)/(ncase-1); ]
e_radc = (e_rad2/e_rad)**2+(e_tot2/e_tot)**2-2*e_radc;
IF( e_radc > 0 ) [ e_radc = sqrt(e_radc); ]
e_bremc = (e_brem2/e_brem)**2+(e_tot2/e_tot)**2-2*e_bremc;
IF( e_bremc > 0 ) [ e_bremc = sqrt(e_bremc); ]
write(6,*) ' Fractional uncertainties with correlations are: ';
OUTPUT 100*e_bremc; ('   brems:          ',F8.4,' %');
OUTPUT 100*e_radc;  ('   all radiative:  ',F8.4,' %');

$FLUSH_UNIT(6);

:the_end:;

]"end of itimes loop"


call egs_finish;

end;

%E
;
"**********************************************************************"
"                                                                      "
!COMMENTS;
%F
C> Subroutine to read user inputs and transport parameters
%M
!NOCOMMENTS;
  subroutine inputs;
"                                                                      "
"**********************************************************************"

"The following are two simple and useful macros for calling the"
"get_input routine                                             "

REPLACE {$GET_INPUT(#);} WITH  "Used to get only one input"
{
"{P1}=Array index of the value_sought"
NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT;
}
;
REPLACE {$GET_INPUTS(#,#);} WITH  "Used to get many inputs"
{
NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT;
}
;

$IMPLICIT-NONE;

"The following are EGSnrc internal (privat) common blocks"
"They are included in order to get access to various switches, "
"material array, cut-off energies, etc."

;COMIN/EPCONT,       "to get access to iausfl"
       GetInput,     "for interaction with the get_input routine"
       MEDIA,        "to get access to nmed and media"
       MISC,         "to get access to the array med"
       UPHIOT,       "to get PI (for the incident angle conversion)"
       USEFUL,       "to get electron rest energy RM"
       RANDOM,       "to be able to set the initial rng seeds"
       BREMPR,       "to be able to turn off brems angle selection"
       "                                             "
       " The following are user-defined common blocks"
       "                                             "
       SCORE,
       USER
      /;

character*60 medium_name;

$INTEGER i,j,ispin,jrn1,jrn2;
$INTEGER ival;
$REAL    emax;
integer*4 lnblnk;

call get_transport_parameter(6); "read transport parameter settings and"

accu = 0.01;
m_balance = 1;
calc_type = 0;"Defaults to allow photon/electron calculations"
verbose = .false.;
                                 "print a summary on unit 6"
ival = 0;
delimeter = 'NONE';

" Media input "
"============="

ival                   = ival + 1;
values_sought(ival)    = 'MEDIA';
type(ival)             = 2;  "i.e.  character input"
nvalue(ival)           = 0;
$GET_INPUT(IVAL);
IF( error_flag > 0 ) stop;
nmed = nvalue(ival);
IF( nmed > $MXMED ) [
    write(6,*) ' Just ',$MXMED,' allowed!';
    stop;
]
DO i=1,nmed [
  DO j=1,24 [ media(j,i) = ' '; ]
  read(char_value(ival,i),'(24a1)') (media(j,i),j=1,lnblnk(char_value(ival,i)));
]

"Set medium 1 everywhere"
DO i=1,$MXREG [ med(i) = 1; ]

dunit = 1;  "i.e. we work in cm"

"---------------------------------------------------------------------"
"STEP 5  INITIALIZATION-FOR-AUSGAB                                    "
"---------------------------------------------------------------------"

ival                   = ival + 1;
values_sought(ival)    = 'INITIAL RANDOM NO. SEEDS';
type(ival)             = 0;
nvalue(ival)           = 2;
value_min(ival)        = 0;
value_max(ival)        = 9999999;
default(ival)          = 0;
$GET_INPUT(IVAL);
jrn1 = value(ival,1);
jrn2 = value(ival,2);
$INITIALIZE RNG USING jrn1 AND jrn2;

ival                   = ival + 1;
values_sought(ival)    = 'NUMBER OF HISTORIES';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = 2;
"value_max(ival)        = 2147483647;
default(ival)          = 10000;
$GET_INPUT(IVAL);
ncase = value(ival,1);

ival                   = ival + 1;
values_sought(ival)    = 'TURN OFF BREMS ANGLES';
type(ival)             = 3;
nvalue(ival)           = 1;
allowed_inputs(ival,0) = 'NO';
allowed_inputs(ival,1) = 'YES';
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [
    IF( value(ival,1) > 0 ) ibrdst=-1;
]
ELSE                 [ error_flag = 0; ]

"----------------------------------------------------------------------"
" precision sought and calculation type                                 "
"----------------------------------------------------------------------"
ival                   = ival + 1;
values_sought(ival)    = 'PRECISION';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = -1e30;
value_max(ival)        = 1.0;
default(ival)          = 0.01;
$GET_INPUT(IVAL);
IF( error_flag = 0 )    [ accu = value(ival,1); ]
ELSE["Backwards compatible"
   values_sought(ival) = 'ACCURACY';
   $GET_INPUT(IVAL);
   IF( error_flag = 0 ) [ accu = value(ival,1); ]
   ELSE                 [ error_flag = 0; ]
]

ival                   = ival + 1;
values_sought(ival)    = 'PRECISION BALANCE';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = 1;
value_max(ival)        = 100;
default(ival)          = 1;
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [ m_balance  = value(ival,1); ]
ELSE                 [ error_flag = 0; ]

ival                   = ival + 1;
values_sought(ival)    = 'CALCULATION TYPE';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = 0;
value_max(ival)        = 1;
default(ival)          = 0;
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [ calc_type = value(ival,1); ]
ELSE                 [ error_flag = 0; ]

"-------------------------------------------------"
"       verbose output?                           "
"-------------------------------------------------"
ival                = ival + 1;
values_sought(ival) = 'VERBOSE';
nvalue(ival)        = 1;
type(ival)          = 3;
allowed_inputs(ival,0) = 'NO';
allowed_inputs(ival,1) = 'YES';
$GET_INPUT(IVAL);
IF( error_flag = 0 ) [
    IF( value(ival,1) = 1 )[
      verbose = .true.;
    ]
]
ELSE                 [ error_flag = 0; ]

"---------------------------------------------------------------------"
"STEP 6   DETERMINATION-OF-INICIDENT-PARTICLE-PARAMETERS              "
"---------------------------------------------------------------------"

" Source inputs "
" ============= "

" now executed from a separate routine "

call source;

DO j=1,33 [ iausfl(j) = 0; ]
iausfl( 5) = 1; "in order to score sub-threshold energy after relaxations"
iausfl( 8) = 1; "after brems"
iausfl(10) = 1; "after Moller (to count radiative losses due to EII)"
iausfl(12) = 1; "after Bhabha (to count radiative losses due to EII if"
                "added some day)"
iausfl(14) = 1; "after annih"
iausfl(15) = 1; "after annih at rest"
iausfl(17) = 1; "after pair"
iausfl(18) = 1; "before compt"
iausfl(19) = 1; "after compt"
iausfl(20) = 1; "before photo"
iausfl(21) = 1; "after photo"
/*iausfl(25) = 1; "after Rayleigh"*/
iausfl(34) = 1; "after sub-threshold fluorescence"
iausfl(35) = 1; "after sub-threshold Auger"
iausfl(32) = 1; "before eii"
iausfl(33) = 1; "after eii"

return;
end;    "of subroutine inputs"

"************************************************************************""
subroutine howfar;
"************************************************************************""
;COMIN/STACK/;

IF( wt(np) <= 0 ) idisc = 1;
return;
end;

"************************************************************************""

subroutine ausgab(iarg);

"Note that once impact ionization is included in EGSnrc, we need
"to change this since, g (e_rad) needs to include fluorescence emission
"as a result of electron- and positron-impact ionization,
"************************************************************************""
$IMPLICIT-NONE;
$INTEGER iarg,irl,iql,jp;
real*8   aux;
$REAL    usave,vsave,wsave,wtsave,eesave,rnno,ee;
$INTEGER isplit,ip;

;COMIN/SCORE,   "to get the scoring arrays and iscore"
       EPCONT,  "to get EDEP"
       STACK,   "to get the region number"
       USEFUL
      /;

IF( iarg = 19 | iarg = 17 ) ["before and during photoeffect or compton"
    "this flag stays set during these interactions until cleared"
    during_pe_compt = 1;
    return;
]
IF( iarg = 20 | iarg = 18 ) ["after photoeffect clear the flag"
    "do we know for sure this comes after the eii calls"
    during_pe_compt = 0;
]
IF( iarg = 31 ) ["before and during eii"
    during_eii = 1;
    return;
]
IF( iarg = 32 ) ["after eii"
    during_eii = 0;
    return;
]

"depositing sub-threshold energy for everything but eii and PE/Compton"
IF( iarg = 4 & during_eii = 0 & during_pe_compt = 0 ) [
    "  during_eii = 0 & during_pe_compt = 0  => after either of these"
    IF( $DEBUGIT ) [ write(19,*) ' Depositing iarg 4 ',edep; ]
    etot_tmp = etot_tmp + edep;
    return;
]
"skip the remaining iarg=4 calls"
IF( iarg = 4 &  ( during_eii = 1 | during_pe_compt = 1 ) ) [
    return;
]

"depositing sub-threshold energy for PE/Compton"
"Auger only"
IF( iarg = 34 ) ["after sub-threshold Auger"
    IF( during_pe_compt = 1 ) ["it is during PE/Compton"
        IF( $DEBUGIT ) [ write(19,*) ' Depositing photo iarg 27 ',edep_local; ]
        etot_tmp = etot_tmp + edep_local;
        return;
    ]
    ELSE [ "it was caused by an e interaction => not in kerma" return; ]
]

"depositing sub-threshold energy for eii"
"fluorescence only"
IF( iarg = 33 ) ["after sub-threshold fluorescence"
    IF( during_eii = 1 ) [ "during an eii event"
        IF( $DEBUGIT ) [ write(19,*) ' Depositing eii iarg 25 ',edep_local; ]
        erad_tmp = erad_tmp + edep_local;
        return;
    ] ELSE ["if it is from other relaxation, it is not an e radiative loss"
        return;
    ]
] "end iarg 33 block"


/*IF( iarg = 16 | iarg = 18 | iarg = 20 | iarg = 24)
  ["after a photon interaction"*/
IF( iarg = 16 | iarg = 18 | iarg = 20 ) ["after a photon interaction"
    IF( $DEBUGIT ) [ write(18,*) ' iarg = ',iarg,' np = ',np; ]


    DO ip = NPold, NP ["loop over all particles on stack after interaction"
        IF( $DEBUGIT ) [ write(18,*) '    ',ip,iq(ip),wt(ip),e(ip); ]
        IF( iq(ip) ~= 0 ) [ etot_tmp = etot_tmp + e(ip) - prm; ]
        ELSE [ "photon"
            wt(ip) = 0; e(ip) = 0;  "terminate the history-no more transport"
            "note, even a rejected bound Compton event is terminated"
        ]
    ]"end block over particles on stack after interaction"
    return;
]"end photon interaction block"

IF( iarg = 7 ) [ "after a call to brems - add up the energy of the photon"
                 "and then discard the photon"
    "It is assumed that nbr_split = 1, ie no splitting"
    IF( iq(np) = 0 ) [ "photon is top of stack"
                       ebrem_tmp = ebrem_tmp + e(np);
                       erad_tmp = erad_tmp + e(np);
                       IF( $DEBUGIT ) [ write(18,*) ' brems: ',e(np),wt(np); ]
                       wt(np) = 0; e(np) = 0
                     ]
    ELSE             [ "electron was top of stack=> photon is np-1"
                       ebrem_tmp = ebrem_tmp + e(np-1);
                       erad_tmp = erad_tmp + e(np-1);
                     IF( $DEBUGIT ) [ write(18,*) ' brems: ',e(np-1),wt(np-1); ]
                       wt(np-1) = 0; e(np-1) = 0
                     ]
    return;
] "end of brems block"

IF( iarg = 13 | iarg = 14 ) ["after annihilation at rest or in flight"
    IF( $DEBUGIT ) [ write(18,*) ' annihilation '; ]
    IF( iarg = 13 ) ["in flight - we only want to score any k.e."
                     "transferred to photons"
      erad_tmp = erad_tmp + e(np) + e(np-1) - 2*prm;
    ]
    e(np) = 0; wt(np) = 0;
    e(np-1) = 0; wt(np-1) = 0;
    return;
]

IF( iarg = 9 | iarg = 11 ) [ "after moller or bhabha"
    IF( $DEBUGIT ) [ write(18,*) ' Moller or Bhabha '; ]
    "pick up any fluorescent photons from eii"
    "Note that the inclusion of Bhabha is not needed since there is"
    "    no eii in Bhabha yet. But in case it is added in future."
    DO ip=npold,np [
        IF( iq(ip) = 0 ) [
            erad_tmp = erad_tmp + e(ip); wt(ip) = 0; e(ip) = 0;
        ]
    ] "end of loop on ip"
    return;
] "end iarg = 9|11 block"

OUTPUT;('We should not get here!!!!');
write(6,*) 'IARG = ',iarg;
return;
end;

"************************************************************************"

subroutine source;

"************************************************************************""
$IMPLICIT-NONE;

;COMIN/GetInput,USEFUL,UPHIOT,RANDOM, ENERGIES/;

$INTEGER ival;

REPLACE {$NENSRC} WITH {1000};

$INTEGER mono;
$INTEGER nensrc,mode,iqi;
$REAL    ensrcd(0:$NENSRC),srcpdf($NENSRC),srcpdf_at($NENSRC);
$INTEGER srcbin_at($NENSRC);
$INTEGER i,j;
$REAL    ei,eave,sum,ui,vi,wi;
real*8   esum,esum2,ecount,aux,aux2;

$INTEGER ounit;
$REAL    emax,e,es,des,eik;

$INTEGER iqin,irin;
         "note iqin is also passed in comin score but it is not in this"
         "subroutine"
$REAL    ein,xin,yin,zin,uin,vin,win,wtin;
$REAL    r,phi,alias_sample;

$REAL    bwidth;
$REAL    e_min, e_max;

$INTEGER itimes;

save     mono,nensrc,mode,ensrcd,srcpdf,srcpdf_at,srcbin_at,eave,sum,
         esum,esum2,ecount,ei,iqi,ui,vi,wi,eik;

character*256 spec_file;

ival = 0;

/esum,esum2,ecount/ = 0;

ival                   = ival + 1;
values_sought(ival)    = 'INCIDENT SPECTRUM';
type(ival)             = 3;
allowed_inputs(ival,0) = 'MONO-ENERGY';
allowed_inputs(ival,1) = 'SPECTRUM';
allowed_inputs(ival,2) = 'MONO-ENERGY-LIN-RANGE';
allowed_inputs(ival,3) = 'MONO-ENERGY-LOG-RANGE';
nvalue(ival)           = 1;
delimeter = 'SOURCE INPUT';
$GET_INPUT(ival);
mono = value(ival,1);

ival                   = ival + 1;
values_sought(ival)    = 'INCIDENT CHARGE';
type(ival)             = 0;
nvalue(ival)           = 1;
value_min(ival)        = -1;
value_max(ival)        = 1;
default(ival)          = -1;
$GET_INPUT(ival);
iqi = value(ival,1);

IF( mono = 0 ) ["one or more individual energy values"

    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT KINETIC ENERGY';
    type(ival)             = 0;
    nvalue(ival)           = 0;
    value_min(ival)        = 0;
    value_max(ival)        = 1e10;
    default(ival)          = 1;
    $GET_INPUT(ival);
    ei = value(ival,1); eik = ei;
    IF( iqi ~= 0 ) [ ei = ei + rm; ]
    neis = nvalue(ival);
    IF(neis>$MXENE)[
     write(6,*) '!!!!!!!!!    ERROR  !!!!!!!!!!!!!!!!!!!!!!!!';
     write(6,*) 'too many energies requested, increase MXENE.';
     write(6,*) 'MXENE =',$MXENE,'neis = ',neis;
     stop;
    ]
    write(6,*) 'number of energies = ', neis;
    DO i=1,neis[ "convert incident k.e. to total energies"
     eis(i)=value(ival,i)+rm*abs(iqi);
     write(6,'(A,I5,A,f8.5)') 'E(',i,')=', value(ival,i);
    ]
]
ELSE IF (mono = 2)["lin grid, reading: Emin, emax, bwidth"
    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT KINETIC ENERGY';
    type(ival)             = 0;
    nvalue(ival)           = 3;
    value_min(ival)        = 0;
    value_max(ival)        = 1e10;
    default(ival)          = 1;
    $GET_INPUT(ival);
    ei = value(ival,1); eik = ei;
    IF( iqi ~= 0 ) [ ei = ei + rm; ]

    bwidth = value(ival,3);
    neis = abs(value(ival,2)-value(ival,1))/bwidth+1;

    IF(neis>$MXENE)[
     write(6,*) '!!!!!!!!!    ERROR  !!!!!!!!!!!!!!!!!!!!!!!!';
     write(6,*) 'too many energies requested, increase MXENE.';
     write(6,*) 'MXENE =',$MXENE,' neis = ',neis;
     stop;
    ]

    write(6,*) 'Linear energy grid ';
    write(6,*) '========================';
    write(6,*) 'Emin = ', value(ival,1),' Emax = ', value(ival,2);
    write(6,*) 'bwidth = ', bwidth;
    write(6,*) 'number of energies = (Emax-Emin)/bwidth+1= ', neis;
    write(6,*);

    DO i=0,neis-1[
     eis(i+1)=value(ival,1)+i*bwidth+rm*abs(iqi);
     write(6,'(A,I5,A,f8.5)')'E(',i+1,')=', eis(i+1);
    ]
]
ELSE IF (mono = 3)["log grid, reading: Emin, Emax, npoints"
    ival                   = ival + 1;
    values_sought(ival)    = 'INCIDENT KINETIC ENERGY';
    type(ival)             = 0;
    nvalue(ival)           = 3;
    value_min(ival)        = 0;
    value_max(ival)        = 1e10;
    default(ival)          = 1;
    $GET_INPUT(ival);
    ei = value(ival,1); eik = ei;
    IF( iqi ~= 0 ) [ ei = ei + rm; ]

    e_min = value(ival,1) + abs(iqi)*rm;
    e_max = value(ival,2) + abs(iqi)*rm;

    neis = int(value(ival,3));
    bwidth = log(e_max/e_min)/(neis-1);

    IF(neis>$MXENE)[
     write(6,*) '!!!!!!!!!    ERROR  !!!!!!!!!!!!!!!!!!!!!!!!';
     write(6,*) 'too many energies requested, increase MXENE.';
     write(6,*) 'MXENE =',$MXENE,' neis = ',neis;
     stop;
    ]

    write(6,*) 'Logarithmic energy grid ';
    write(6,*) '========================';
    write(6,*) 'Emin = ', value(ival,1),' Emax = ', value(ival,2);
    write(6,*) 'number of energies = ', neis;
    write(6,*) 'bwidth = log(Emax/Emin)/n = ', bwidth;write(6,*);

    DO i=0,neis-1[
     eis(i+1)=exp(log(e_min)+i*bwidth);
     write(6,'(A,I5,A,f15.8)')'E(',i+1,')=', eis(i+1);
    ]
]
ELSE [

    neis = 0;

    ival                   = ival + 1;
    values_sought(ival)    = 'SPECTRUM FILE';
    type(ival)             = 2;
    nvalue(ival)           = 1;
    $GET_INPUT(ival);
    read(char_value(ival,1),'(a)') spec_file;
    call replace_env(spec_file);
    open(9,file=spec_file,status='old');
    read(9,*); "i.e. ignore the title"
    read(9,*) nensrc,ensrcd(0),mode;
    IF( nensrc > $NENSRC ) [
        write(6,*) ' Too many bins in spectrum!';
        stop;
    ]
    read(9,*) (ensrcd(i),srcpdf(i),i=1,nensrc);
    close(9);
    IF( mode = 1 ) [
        DO i=1,nensrc [ srcpdf(i) = srcpdf(i)*(ensrcd(i)-ensrcd(i-1)); ]
    ]
    eave = 0; sum = 0;
    DO i=1,nensrc [
        sum = sum + srcpdf(i);
        eave = eave + 0.5*srcpdf(i)*(ensrcd(i)+ensrcd(i-1));
    ]
    eave = eave/sum;
    call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at);

]

return;

entry source_sumry(ounit);
"========================="

write(ounit,'(/a)')
 '                        Source                                  ';
write(ounit,'(a)')
 '================================================================';

write(ounit,'(a,$)')
  ' Incident charge              : ';
IF( iqi = -1 )     [ write(ounit,'(a)') 'Electron'; ]
ELSE IF( iqi = 0 ) [ write(ounit,'(a)') 'Photon'; ]
ELSE               [ write(ounit,'(a)') 'Positron'; ]
IF( mono ~= 1 ) [
 write(ounit,'(a)')
  ' Incident beam                : monoenergetic';
 IF (neis = 1)[
  write(ounit,'(a,$)')
  ' Incident kinetic energy (MeV): ';
  write(ounit,'(f0.8)') ei-rm*abs(iqi);
 ]
]
ELSE [
 write(ounit,'(a)')
  ' Incident beam                : spectrum';
 write(ounit,'(a,f10.5)')
 ' Average energy (MeV): ',eave;
 write(ounit,'(a,f10.5)')
 ' Maximum energy (MeV): ',ensrcd(nensrc);
] "end of spectrum block"

write(ounit,'(//)');

return;

entry source_get_emax(iqin,emax);
"=========================="
"Note: emax = max. KE"
iqin = iqi;
IF( mono = 0 ) [
    emax = eis(1);
    DO i=2,neis[
       IF( eis(i) > emax ) [
         emax = eis(i);
       ]
    ]
    emax = emax - abs(iqi)*rm;
]
ELSE IF( mono = 2 | mono = 3 ) [
    emax = eis(neis) - abs(iqi)*rm;
]
ELSE [
    emax = ensrcd(nensrc);
]
return;

entry source_check_emin();
"=========================="
"Set to 1 keV plus a small epsilon"
"if minimum energy is 1 keV or less"
IF( mono = 0 ) [
  j = 1;
  DO i=2,neis[
     IF( eis(i) < eis(j) ) [
       j = i;
     ]
  ]
  IF ( eis(j) - abs(iqi)*rm <= $E_THRESHOLD)[
       eis(j) = $E_THRESHOLD + $E_EPS + abs(iqi)*rm;
  ]
]
ELSE IF( mono = 2 | mono = 3 ) [
  IF ( eis(1) - abs(iqi)*rm <= $E_THRESHOLD)[
       eis(1) = $E_THRESHOLD + $E_EPS + abs(iqi)*rm;
  ]
]
ELSE [
  IF ( ensrcd(0) - abs(iqi)*rm <= $E_THRESHOLD)[
       ensrcd(0) = $E_THRESHOLD + $E_EPS + abs(iqi)*rm;
  ]
]
return;

entry source_get_eave(e);
"========================"

IF( mono = 0 | mono = 2  | mono = 3 ) [
    IF( iqi = 0 ) [ e = ei; ]
    ELSE          [ e = ei-rm; ]
]
ELSE [
    e = eave;
]
return;

entry source_get_samplede(es,des);
"================================="

IF( ecount <= 2 ) return;
aux = esum/ecount;
aux2 = esum2/ecount;
aux2 = (aux2 - aux*aux)/(ecount-1);
IF( aux2 > 0 ) [ aux2 = sqrt(aux2); ]
es = aux; des = aux2;
return;

entry source_set_energy(ein);
ei = ein;
return;

entry source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
"=============================================================="

iqin = iqi;
irin = 1;
IF( mono = 0 | mono = 2 | mono = 3 ) [ ein = ei; wtin = 1; ]
ELSE [
    ein = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at);
    wtin = 1; eik = ein;
    IF( iqin ~= 0 ) [ ein = ein + rm; ]
]
ecount = ecount + 1;
esum = esum + eik;
esum2 = esum2 + eik*eik;

"The position and direction doesn't matter in an infinite space"
xin = 0; uin = 0; zin = 0;
uin = 0; vin = 0; win = 1;

return;

entry source_switch_energy(itimes);
"========================="
IF (mono =1) [return;]
ei=eis(itimes); eik = ei;
ecount = 0; esum = 0; esum2 = 0;
IF (neis > 1)[
  write(6,'(a,$)')
  '===> Incident kinetic energy (MeV): ';
  write(6,'(f15.8,10x,a)') ei-abs(iqi)*rm, '      ********************';
]
return;

end;  "of subroutine source"

"************************************************************************""
subroutine test_brems;
"************************************************************************""
implicit none;
;COMIN/ELECIN,EPCONT,SCORE,STACK,USEFUL/;

$INTEGER  icase,iqin,irin,ip,lelke;
$REAL     ein, xin,yin,zin, uin,vin,win,wtin;
$REAL     dedx,ebr1,sig,sig_brem,eb;
real*8    sum,sum2;

call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
np=1; e(np)=ein; iq(np)=-1; ir(np)=1; wt(np)=1;
/x(np),y(np),z(np)/=0; u(np)=0; v(np)=0; w(np)=1;
elke = log(ein-prm); medium=1;
$SET INTERVAL elke,eke;
$EVALUATE dedx USING ededx(elke);
$EVALUATE ebr1 USING ebr1(elke);
$EVALUATE sig USING esig(elke);
sig_brem = sig*ebr1;
write(6,*) ' Incident energy: ',ein-prm,elke;
write(6,*) ' dedx: ',dedx;
write(6,*) ' sig:  ',sig;
write(6,*) ' ebr1: ',ebr1;
write(6,*) ' Brems cross section: ',sig_brem;

DO icase=1,ncase [

  np=1; e(np)=ein;
  call brems; eb=0;
  DO ip=1,np [
      IF(iq(ip) = 0) [ eb = eb + e(ip); ]
  ]
  sum = sum + eb; sum2 = sum2 + eb*eb;
]

sum = sum/ncase; sum2 = sum2/ncase; sum2 = sum2 - sum*sum;
IF( sum2 > 0 ) [ sum2 = sqrt(sum2/(ncase-1)); ]
write(6,*) ' Average energy per brem: ',sum,' +/- ',sum2;
write(6,*) ' Rad. stopping power: ',sum*sig_brem,' +/- ',sum2*sig_brem;
stop; "return;
end;

"************************************************************************""
subroutine test_compton;
"************************************************************************""

REPLACE {$ANALYZE1#;} WITH {;
  sum{P1} = sum{P1}/ncase; sum{P1}2 = sum{P1}2/ncase;
  sum{P1}2 = sum{P1}2 - sum{P1}*sum{P1};
  IF( sum{P1}2 > 0 ) [ sum{P1}2 = sqrt(sum{P1}2/(ncase-1)); ]
};

implicit none;
;COMIN/PHOTIN,EPCONT,MEDIA,SCORE,STACK,USEFUL/;

$INTEGER  icase,iqin,irin,ip,lgle;
$REAL     ein, xin,yin,zin, uin,vin,win,wtin;
$REAL     gmfp,gbr1,gbr2;
real*8    sumr,sumr2,sume,sume2,sumtr,sumtr2;
$REAL     es,des,ee,factor;

medium = 1;
DO icase=1,ncase [
  call source_sample(iqin,irin,ein,xin,yin,zin,uin,vin,win,wtin);
  IF( iqin ~= 0 ) [
    write(6,*) ' test_compton: only works for photons!';
    stop;
  ]
  gle = log(ein);
  $SET INTERVAL gle,ge;
  $EVALUATE gmfp USING gmfp(gle);
  $EVALUATE gbr1 USING GBR1(GLE);
  $EVALUATE GBR2 USING GBR2(GLE);
  np=1; e(np)=ein; iq(np)=0; ir(np)=1; wt(np)=1;
  /x(np),y(np),z(np)/=0; u(np)=0; v(np)=0; w(np)=1;
  call compt;
  IF( np > 1 ) [
    IF( iq(1) = 0 ) [ ee = ein - e(1); ]
    ELSE [ ee = ein - e(2); ]
    sume = sume + ee; sume2 = sume2 + ee*ee;
    ee = ee*(gbr2-gbr1) + (1-gbr2)*ein;
    IF( ein > 2*prm & gbr1 > 0 ) [ ee = ee + gbr1*(ein-2*prm); ]
    IF(gmfp > 0) [
       ee = ee/gmfp/rho(medium);
    ] ELSE [
       ee = 0;
    ]
    sumtr = sumtr + ee; sumtr2 = sumtr2 + ee*ee;
  ]
  ELSE [ sumr = sumr + 1; sumr2 = sumr2 + 1; ]
]

$ANALYZE1 r; $ANALYZE1 e; $ANALYZE1 tr;
call source_get_samplede(es,des);
write(6,*) ' Average sampled energy:   ',es,' +/- ',des;
write(6,*) ' Average number of Compton rejections: ',sumr,' +/- ',sumr2;
write(6,*) ' Average energy released in Compton events: ',sume,' +/- ',sume2;
factor = 160.2176462;  "e_mutr and e_muen scored as MeV cm^2/g"
                    "*1.602176462E-13 J/MeV *1000 g/kg =160.2176462E-12 Gy cm^2"
                    "Note, this is used elsewhere too"
write(6,*) ' mutr: ',factor*sumtr,' +/- ',factor*sumtr2;
stop;
return;
end;
"####################################################"
" Skip rest of Fortran source from doxygen processing"
"####################################################"
!COMMENTS;
%F
C> @cond
%M
!NOCOMMENTS;
"####################################################"
