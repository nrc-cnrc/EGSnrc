%C80
"#############################################################################"
"                                                                             "
"  EGSnrc cavrznrc application                                                "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Alex Bielajew, 1987                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Jan Seuntjens                                             "
"                   Aaron Merovitz                                            "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Leslie Buckley                                            "
"                   Blake Walters                                             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally adapted from DOSRZ (EGS4) and CAVITY (EGS3) by    "
"  Alex Bielajew in 1987.                                                     "
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The cavrznrc application simulates the passage of an electron or photon    "
"  beam in a finite, right cylindrical geometry. It is intended for use in    "
"  calculating quantities of interest for thick-walled ion chambers exposed   "
"  to photon beams although it may be used simply to score dose in a          "
"  cylindrical geometry.                                                      "
"                                                                             "
"#############################################################################"


%L TURN ON LISTING IN CASE IT WAS OFF FOR EGS
%I4
!INDENT F2;
%C80
%Q1
%E     "cavrznrc.mortran"
;
REPLACE {$VERSION} WITH {
,'V1(Rev 1.60 last edit  2003-03-12 11:46:57-05)', }


REPLACE {$MXMDSH} WITH {200}


"This line is 80 characters long, use it to set up the screen width
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"******************************************************************************
"
"
"                               ********************
"                               *                  *
"                               * cavrznrc.mortran *
"                               *                  *
"                               ********************
"
"
"       INTRODUCTION:
"       THIS CODE SIMULATES THE PASSAGE OF AN ELECTRON OR PHOTON BEAM IN A
"       FINITE, RIGHT CYLINDRICAL GEOMETRY.
"       IT IS INTENDED FOR USE IN CALCULATING QUANTITIES OF INTEREST FOR
"       THICK-WALLED ION CHAMBERS EXPOSED TO PHOTON BEAMS ALTHOUGH IT MAY
"       BE USED SIMPLY TO SCORE DOSE IN A CYLINDRICAL GEOMETRY. IN ADDITION
"       TO SCORING DOSE, THE FOLLOWING QUANTITIES MAY ALSO BE SCORED:
"
"          1)THE Aatt  CORRECTION FACTOR    (attenuation of primary beam),
"          2)THE Ascat CORRECTION FACTOR    (photon scatter),
"          3)THE Apn   CORRECTION FACTOR    (for point-source beams, obtained
"                                             by correlated sampling),
"          4)THE Afl   CORRECTION FACTOR    (obtained by correlated sampling),
"          5)<s>g,w STOPPING POWER RATIO    (obtained by correlated sampling)
"
"       FOR A DERIVATION OF THE ABOVE FACTORS, CONSULT
"       `Correction factors for thick-walled ionisation chambers in
"        point source photon beams' by AF Bielajew PMB 35(1990)501-516.
"
"  **************************
"
"       VERSION 0.01    ALEX BIELAJEW   87/10/27/1
"                                       ADAPTED FROM DOSRZ(EGS4) AND
"                                       CAVITY(EGS3)
"       VERSION 0.02    ALEX BIELAJEW   87/11/12/1
"                                       NEW <R**2> BASED ON ENERGY DEPOSITION
"                                       RATHER THAN POINT OF CREATION
"       VERSION 0.03    ALEX BIELAJEW   87/11/13/1
"                                       RANGE REJECTION FIXED, PUT IN MACRO
"                                       TO AVOID CONFLICT WITH PRESTA
"       VERSION 0.04    ALEX BIELAJEW   87/11/16/1
"                                       FIXED PREMATURE EXIT FROM ELECTR
"                                       INTRODUCED IN V0.03
"       VERSION 0.05    ALEX BIELAJEW   87/11/19/1
"                                       INITIAL CODING OF THE CORRELATION
"                                       SAMPLING, <Sg,w> and Afl.
"       VERSION 0.06    ALEX BIELAJEW   87/12/04/1
"                                       INITIAL CODING THAT PRODUCES VAX
"                                       AND IBM COMPATIBLE FORTRAN.
"       VERSION 0.07    ALEX BIELAJEW   87/12/11/1
"                                       INITIAL CODING OF SUBROUTINE ISUMRY
"                                       FOR VAX AND IBM COMPATIBILITY.
"       VERSION 0.08    ALEX BIELAJEW   88/01/28/1
"                                       PUT IN CORRELATED STATS FOR THE
"                                       Afl DIVISIONS.
"       VERSION 0.09    ALEX BIELAJEW   88/02/01/1
"                                       PUT IN NEW ARRAYS FOR
"                                       CALCULATING D/A'S
"       VERSION 0.10    ALEX BIELAJEW   88/06/22/1
"               EXTENDED RANGE REJECTION TO APPLY TO THE CAVITY ON
"               THE SECOND PASS FOR CORRELATION SCORING. NOTE THAT
"               FOR HIGH Z MATERIALS, THE STOPPING POWER RATIO HAS
"               BEEN OBSERVED TO CHANGE.
"               MADE IT AN OPTION WITH IREJCT=2
"       VERSION 0.11    ALEX BIELAJEW   88/12/07/1
"               FIXED THE BUG RELATED TO THE VERSION 10 UPDATE
"       VERSION 0.12    ALEX BIELAJEW   89/03/14/1
"               FIXED BUG WHERE FORCING DID NOT WORK PROPERLY WITH RAYLEIGH.
"       VERSION 0.13    ALEX BIELAJEW   89/03/16/1
"               PUT IN SWITCH TO ALLOW PHOTOELECTRIC SAMPLING TO BE SELECTED.
"       VERSION 0.14    ALEX BIELAJEW   89/03/20/1
"               IN CORRELATION SCORING, CHANGED MEDIUM SWITCHING TO THE
"               ENTIRE CHAMBER.
"       VERSION 0.15    ALEX BIELAJEW   89/03/20/2
"               FIXED BUG IN PHOTON TRACK END PART OF STOPPING POWER RATIO
"       VERSION 1.00    ALEX BIELAJEW   89/10/25/1
"               MAJOR UPGRADE TO USING THE NEW TECHNIQUE FOR CALCULATING Apn
"       VERSION 1.01   ALEX BIELAJEW    90/03/26/1
"               Added fluorescence sampling as in DOSRZ
"       VERSION 1.02   ALEX BIELAJEW    90/03/30/1
"               Fixed forcing, added IQINC
"       VERSION 1.03   ALEX BIELAJEW    91/07/09/1
"               Fixed bug that did not update AINFLU after early exit
"               due to good stats or time expiry
"       Version 2 corrects PRESTA  bug   DWOR  Dec 17 1990
"               3  both 1.03 and 2 together   dr
"       Version 3.01   JAN SEUNTJENS    Oct, 1995
"               A number of bugs fixed related to correlated scoring and
"               photon forcing for Afl calc in point and parallel sources
"               Note that now IFULL=3 and ISOURCE=0 or 2 will do a
"               proper A_fl calculation, and A_pn is set to 1 (the A_pn pass
"               will not be executed; it is therefore not neccesary to select
"               a point source to do the A_fl calculation.)
"       Version 3.02a   JAN SEUNTJENS&IWAN KAWRAKOW
"                                       March-Oct, 1996
"               have put in BREMLOSS common block
"               allowed for fano regeneration calculation (ifano)
"               made some modifications for g77 (Linux) compilation
"               we use this version for calc. with IK Leipzig macros
"       Version 4       Jan Seuntjens&Iwan Kawrakow (Sept 97)
"               cavrz version with PrestaII + small changes
"       Version 4.1     J.S. version with separated srcrz +
"                                    get_inputs (A.M.)
"       Version 4.2     I.K. version with modified get_inputs,
"                            improved range rejection
"       Version 4.3     I.K. Bound Compton scattering, atomic relaxations.
"                       For some unknown reasons dose from fluorescent X-rays
"                       is counted as primary. Should this be changed ????
"
"                       Have put in Joanne's parallelization and corrected a
"                       small normalization bug that occured when some of
"                       the parallel jobs were not finished.
"
"       Version 4.4     I.K. Have put in calls to AUSGAB after coherent
"                       scattering and photo-absorption and added
"                       corresponding addition
"                       to AUSGAB for Awall calculations (dose from fluorescent
"                       x-rays and coherently scattered photons is counted
"                       as scattered).
"       Version 5.0     As released with EGSnrc  March 2000
"
"
"  Started from /usr/people/egsnrc/cavrznrc/RCS/cavrznrc.mortran,v
"  Revision 1.60 last edited  2003-03-12 11:46:57-05
"  cavrznrc.mortran(1.1 under RCS started from SID 1.48 last edited 00/10/11)
"  SID 1.1 was working version with relaxation Jan 21, 99
"  Changes from Revision 1.60 in RCS:
"    - replaced all date/time stuff with calls to the new egsnrc date
"      and time routines.
"    - fixed occurences of local variables assumed to be static
"    - implemented a new parallel processing strategy using a lock
"      file to control the execution on multiple CPU's
"    - Made a few minor optimizations to the geometry routines.
"    - Cleaned up use of Fortran I/O units which are now explicitly
"      opened/closed if needed except for unit 1 (the .egslst file)
"      and unit 15 (the .errors file), which are defined to be
"      automatically opened in egs_init in the .io file.
"   Iwan Kawrakow, June 2003. Work done March - June 2003 during
"   preparation of the EGSnrc MP system.
"
;
"******************************************************************************
"******************************************************************************
"*******************************************************************************
"*  LEGEND       LEGEND        LEGEND       LEGEND        LEGEND       LEGEND  *
"*******************************************************************************
"* (1)  *  Integers between parentheses indicate the numerical value of        *
"*      *  the input allowed input at hand.  These are for reference only,     *
"*      *  and should never be used in an actual input file.                   *
"*      *  E.g.:  ITERSE= Groups                                               *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *                                                                      *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS=  1, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value.                         *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"*******************************************************************************
"                                TITLE
"                                *****
"*******************************************************************************
"
"CARD TI1
"
"       TITLE          (C)  TITLE OF THE INPUT FILE (FORMAT= '80A1')
;
"*******************************************************************************
"
" I/O DELIMETERS:    :start I/O control:
"                    :stop I/O control:
"
"*******************************************************************************
"                       INPUT/OUTPUT CONTROL INPUT
"                       **************************
"*******************************************************************************
"
"CARD IO1
"
"  IWATCH= off         (0)  FOR NORMAL OUTPUT
"        = interactions(1)  OUTPUT ON EVERY DISCRETE INTERACTION
"        = steps       (2)  OUTPUT ON EVERY ELECTRON/PHOTON STEP AS WELL
"        = deposited   (3)  PRINTS OUT ONLY WHEN ENERGY IS DEPOSITED
"        = graph       (4)  PRINTS OUT FILE FOR GRAPHICS
"
"  STORE INITIAL RANDOM NUMBERS
"        = no          (0)  DO NOT STORE THE INITIAL RANDOM NUMBERS
"        = last        (1)  STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
"        = all deposited (2)STORE THE INITIAL RANDOM NUMBER FOR ALL
"                           THAT DEPOSIT ENERGY IN THE CAVITY
"        = all         (3)  STORE ALL THE INITIAL RANDOM NUMBERS
"
"  IRESTART
"        = first       (0)  first run for this data set
"        = restart     (1)  restart of a previous run
"        = analyze     (3)  just read in the raw data and do the statistical
"                           analysis
"        = start-RNS   (4)  read starting random numbers from a file
"        = parallel    (5)  Combine results from previous parallel runs
"
"  OUTPUT OPTIONS
"        = short              (0)  SHORT OUTPUT -JUST THE CAVITY SUMMARY
"                                  AND THE DOSE GRID.
"        = cavity details     (1)  ABOVE PLUS DETAILS FOR EACH CAVITY ZONE
"
"  STORE DATA ARRAYS
"        = yes             (0) Store data arrays for re-use
"        = no              (1) don't store them
;
"*******************************************************************************
"
" MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
"                            :stop Monte Carlo inputs:
"
"*******************************************************************************
"                       MONTE CARLO CONTROL INPUT
"                       *************************
"*******************************************************************************
"
"CARD MC1
"
"  NUMBER OF HISTORIES         (I)  # HISTORIES TO RUN
"                                   (MIN:100, DEFAULTS TO 20 000)
"
"  INITIAL RANDOM NO. SEEDS=  INTGER1, INTEGER2
"                  User-code can use RANLUX or RANMAR, depending on selection
"                  Default is RANLUX
"            RANLUX
"                  INTEGER1 is the luxury level, use 1 to 4, 4 taking longest
"                           default is 1 (set by $DEFAULT-LL in ranlux.macros)
"                  INTEGER2 selects the independent sequence to use, it
"                           can be from 1 to 1073741824 (2**30)
"            RANMAR
"                  INTEGER1 is a seed between 1 and 31328 (0 =>default 1802)
"                  INTEGER2 is a seed between 1 and 30081 (0 =>default 9937)
"                    Selection of unique INTEGER2 values guarantees independent
"                    sequences.
"            Note:
"                After the seeds are first input and used for initialization,
"                the variables jrng1 and jrng2 are just pointers used by the RNG
"     Note that the parameter sought does not change if the generator used
"     is changed.  This is so we don't need to change the input files
"     although it makes the meaning less clear!
"
"  MAX CPU HOURS ALLOWED       (I)  MAX CPU TIME ALLOWED IN HOURS, DEFAULT=999hr
"
"  IFULL
"         = dose and stoppers         (0) just calculate total dose and that due
"                                         to stoppers and discards.
"         = Aatt and Ascat            (1) Above plus Aatt, Ascat
"
"  STATISTICAL ACCURACY SOUGHT        (R) % statistical accuracy of the total
"                                         dose in the peak region that is sought
"                                         The program executes until this
"                                         accuracy is obtained ot the CPU time
"                                         runs out.
"
"  PHOTON REGENERATION
"         = yes (ifano = 1) the calculation is performed with regeneration
"                           of the parent photon after they have interacted. A
"                           typical setting when FANO conditions are examined.
"         = no (ifano = 0)  a normal calculation.
"         = no electrons from wall (ifano = 2) secondary electrons from
"                           interactions in the cavity wall are immediately
"                           eliminated.  Photons are not regenerated.
"
"*******************************************************************************
"*******************************************************************************
"
" GEOMRZ DELIMETERS:    :start geometrical inputs:
"                       :stop geometrical inputs:
"
"*******************************************************************************
"                  CYLINDRICAL GEOMETRY & MATERIAL INPUT
"                  *************************************
"
" EXTRA INPUT FOR CAVRZnrc:    METHOD OF INPUT= Cavity information
"
"                                JUST INPUT THE WALL THICKNESS, CAVITY AND
"                                ELECTRODE DIMENSIONS AND MATERIALS. THE
"                                GEOMETRY IS THEN SET UP AUTOMATICALLY.
"                                (USEFUL FOR SIMPLE,SYMMETRIC GEOMETRIES).
"                                3 PLANAR ZONES ARE ASSUMED AND THE CAVITY
"                                MATERIAL IS ASSUMED TO BE GAS.
"
"CARD CGM1
"
"  METHOD OF INPUT
"        = Groups              (0)   INPUT GROUPS OF SLABS OF EQUAL THICKNESS
"        = Individual          (1)   VERBOSE INPUT OF THE GEOMETRY AND MEDIA.
"        = Cavity information  (2)   SEE ABOVE
"
"*******************************************************************************
"
"CARD CGM2A (ONLY IF METHOD OF INPUT= Groups)
"
"  Z OF FRONT FACE        (R)   START OF FIRST SLAB (REAL)
"  NSLAB                  (M)   # PLANAR SLABS IN A GROUP (INTEGERS)
"  SLAB THICKNESS         (M)   THICKNESS OF EACH SLAB IN THE GROUP (REALS)
"
"*******************************************************************************
"
"CARD CGM2B (ONLY IF METHOD OF INPUT= Individual)
"
"  Z OF FRONT FACE        (R)   START OF FIRST SLAB (REAL)
"  DEPTH BOUDARIES        (M)   GEOMETRICAL Z-PLANE COORDINATES (REALS)
"
"*******************************************************************************
"
"CARD CGM3
"
"  RADII                  (M)   RADII OF CYLINDERS DEFINING THE GEOMETRY (REALS)
"
"*******************************************************************************
"                                MATERIAL INPUT
"                                **************
"*******************************************************************************
"
"CARD M1
"
"  MEDIA                  (M)   TYPE OF MATERIAL (FMT='24A1')
"                               BY CONVENTION THE PRIMARY WALL
"                               MATERIAL IS FIRST, THE CAVITY MATERIAL
"                               IS SECOND AND THE REST FOLLOWS
"
"*******************************************************************************
"
"CARD M2
"
"  DESCRIPTION BY= Regions(0)   USING THE IRL REGION NUMBER
"                = Planes (1)   USING THE IX, IZ PLANES
"
"*******************************************************************************
"
"CARD M3-A  (CHOICE OF CARD M3-A AND CARD M3-B)
"
"  MEDNUM                 (M)   THE MATERIAL NUMBER (INEGERS)
"                               (MEDNUM=0 TO SKIP)
"  START REGION           (M)   INITIAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"  STOP REGION            (M)   FINAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
"*******************************************************************************
"
"CARD M3-B  (CHOICE OF CARD M3-A AND CARD M3-B)
"
"  MEDNUM                 (M)   THE MATERIAL NUMBER (INEGERS)
"                               (MEDNUM=0 TO SKIP)
"  START ZSLAB            (M)   INITIAL ZSLAB (IZ) (INTEGERS)
"  STOP ZSLAB             (M)   FINAL ZSLAB (IZ) (INTEGERS)
"  START RING             (M)   INITIAL RADIAL RING (IX) (INTEGERS)
"  STOP RING              (M)   FINAL RADIAL RING (IX) (INTEGERS)
"                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
"*******************************************************************************
"*******************************************************************************
"
"  CAVITY INPUT DELIMETERS:
"                      :start cavity inputs:
"                      :stop cavity inputs:
"
"*******************************************************************************
"                           CAVITY INFORMATION INPUTS
"                           *************************
"*******************************************************************************
"
"CARD CAV1-A     (ONLY IF   METHOD OF INPUT= Cavity information)
"
"   WALL THICKNESS      (R)   THICKNESS OF THE CHAMBER WALLS (cms)
"                             (DEFAULTS TO 0.273)
"
"   CAVITY RADIUS       (R)   OUTER RADIUS OF THE CAVITY (cms)
"
"   CAVITY LENGHT       (R)   LENGTH OF THE CAVITY (cms) (DEFAULTS TO 0.2)
"
"   ELECTRODE RADIUS    (R)   RADIUS OF THE ELECTRODE (DEFAULTS TO 0.)
"
"   WALL MATERIAL       (C)   WALL MATERIAL  (clear enough?)
"
"CARD CAV1-B     (ONLY IF   ELECTRODE RADIUS > 0.0)
"
"   ELECTRODE MATERIAL  (C)   ELECTRODE MATERIAL
"
"         ---------------------------------------------------
"
"CARD CAV1-C     (ONLY IF   METHOD OF INPUT= groups or = individual)
"
"   NUMBER OF CAVITY REGIONS (I)   NUMBER OF GEOMETRICAL ZONES
"                                  COMPRISING THE CAVITY.
"
"
"   REGION NUMBERS OF THE CAVITY  (M)
"                                  THE ARRAY OF THESE ZONES
"                                  (THE CAVITY REGION NUMBERS)
;
"
"*******************************************************************************
"                             SOURCE INPUT
"                            **************
"*******************************************************************************
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"FOR ALL SOURCES
"                                      Charge of the incident beam
"  INCIDENT PARTICLE= electron   (-1)  electrons
"                     photon     (0)   photons
"                     positron   (1)   positrons
"
"  (for SOURCE 21,22)     all    (2)  include all of the particles
"                                     in the phase space file
"                                     [IQIN]
"                    charged     (3)  include e+ and e-
"
"  SOURCE NUMBER                 (I)   number of the source
"                                      [ISOURC]
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  0 <<<<<<<<
"
"     PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS) ""toc:
"
"
"  SOURCE OPTIONS            (M4)  RBEAM, UINC, VINC, WINC
"
"               RBEAM          radius of parallel beam in cm
"                              (defaults to max radius of geometry)
"               UINC           incident x-axis direction cosine
"               VINC           incident y-axis direction cosine
"               WINC           incident z-axis direction cosine
"                              NOTE: (UINC,VINC,WINC)
"                              get automatically normalized
"                              defaults to (0.0,0.0,1.0)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  1 <<<<<<<<
"
"     POINT SOURCE ON AXIS INCIDENT FROM THE FRONT    ""toc:
"
"  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, 0, 0
"
"               DISTZ          distance of the point source from the
"                              front of the target in cm (DEFAULT 100.)
"               RBEAM          radius of the beam at the front of the
"                              target in cm (defaults to MAX radius)
"
"------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  2 <<<<<<<<
"
"        BROAD PARALLEL BEAM INCIDENT FROM FRONT (+VE Z-AXIS) ""toc:
"               WITH UNIT AREA BEAM AND LARGE SCORING AREA
"
"  SOURCE OPTIONS          (M4)  0, 0, 0, 0
"
"------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  3 <<<<<<<<
"
"     UNIFORM ISOTROPICALLY RADIATING DISK OF FINITE SIZE   ""toc:
"            (MUST BE ALLOWED FOR IN THE GEOMETRICAL DEFINITIONS)
"
"  SOURCE OPTIONS                (M4)  RMINBM, RBEAM, ZSMIN, ZSMAX
"
"               RMINBM,RBEAM           inner and outer radii of source region
"                                      must be inside geometry
"               ZSMIN,ZSMAX            min and max z values for source
"
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  4 <<<<<<<<
"
"     FOR CENTRAL AXIS FLUENCE VS BEAM RADIUS      ""toc:
"
"  SOURCE OPTIONS            (M4)  RCAXIS, 0, 0, 0
"
"               RCAXIS       radius of central axis scoring zone (cm)
"
"        NOTE: this source option treats the cylindrical radii input
"              above as beam radii. the largest radius must be infinite
"              and the phantom must be homogeneous (at least in each layer)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  10 <<<<<<<<
"
"     PARALLEL BEAM INCIDENT FROM THE SIDE (+VE Y-AXIS)    ""toc:
"
"  SOURCE OPTIONS           (M4)  XBEAM, ZBEAM, 0, 0
"
"               XBEAM             half-width of the rectangular beam in cm
"                                 (defaults to max radius)
"               ZBEAM             half-height of the rectangular beam in cm
"                                 (defaults to max)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  11 <<<<<<<<
"
"     POINT SOURCE INCIDENT FROM THE SIDE     ""toc:
"
"
"  SOURCE OPTIONS                (M4)  DISTRH, XBEAM, ZBEAM, 0
"
"               DISTRH                 distance of the source from the middle
"                                      of the target in cm (defaults to 100.)
"               XBEAM                  half-width of the beam at the center of
"                                      the target in cm (defaults to max radius)
"               ZBEAM                  half-height of the beam at the center of
"                                      the target in cm (defaults to max)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  12 <<<<<<<<
"
"   POINT SOURCE OFF AXIS         ""toc:
"
"  SOURCE OPTIONS                (M4)  DISTRH, DISTZ, 0, 0
"
"               DISTRH                 distance of the point source off the
"                                      Z-axis.
"               DISTZ                  perpendicular distance of the
"                                      point source away from the front face.
"                                      a negative value is permitted.
"
"                                      DISTZ > 0
"                                      point located in front of front face
"
"                                      0 > DISTZ > -(ZPLANE(NPLANE)-ZPLANE(1))
"                                      point located between front and rear face
"
"                                      DISTZ < -(ZPLANE(NPLANE)-ZPLANE(1))
"                                      point located rear of rear plane
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  13 <<<<<<<<
"
"        PARALLEL BEAM FROM ANY ANGLE     ""toc:
"
"  SOURCE OPTIONS                (M4)  UINC, VINC, WINC, 0
"
"               UINC                   incident x-axis direction cosine
"               VINC                   incident y-axis direction cosine
"               WINC                   incident z-axis direction cosine
"
"                 NOTE: (UINC,VINC,WINC) get automatically normalized
"                       default is (0.0,0.0,1.0)
"
"
"------------------------------------------------------------------------------
"                     >>>>>>>> SOURCE  14 <<<<<<<<
"
"   POINT SOURCE ON AXIS INCIDENT FROM THE FRONT WITH ALL   ""toc:
"    EVENTS INSIDE RMINBM NOT FOLLOWED (A FUDGE FOR COLLIMATOR STUDIES)
"
"  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, RMINBM, IGNORED
"
"               DISTZ                  distance of the point source from the
"                                      front of the target in cm
"                                      (defaults to 100.)
"               RBEAM                  radius of the beam at the front of the
"                                      target in cm (defaults to max radius)
"               RMINBM                 below this radius, all histories are
"                                      terminated by the source routines by
"                                      giving them zero weight.
"                                      The howfar routines must check for this.
"
"-------------------------------------------------------------------------------
"
"
"
"                     >>>>>>>> SOURCE  15 <<<<<<<<
"
"  POINT SOURCE OFF AXIS. The same as source 12 but uses an alternative
"  implementation for sampling points on the surface of the RZ-geomtry. The
"  motivation for implementing this source was to check that source 12 is OK
"  and to check the effect of varying weights from the source on the
"  statistical uncertainty (contrary to source 12, source 16 produces
"  essentially  constant weights if the geometry-to-source distance is large
"  compared to the geometry dimension, a typical situation for ion chamber
"  simulations)
"
"  SOURCE OPTIONS                (M4)  DIST, ANGLE, IGNORED, IGNORED
"
"             DIST                     distance of the centre of the geometry
"                                      to the source in cm.
"             ANGLE                    angle of rotation around the x-axis.
"                                      (because of the cylindrical symetry,
"                                      rotations around the x-axis and y-axis
"                                      are indistinguishable). 0 degrees
"                                      corresponds to a source above the front
"                                      face (i.e. the same as source 1), 90
"                                      degrees to a source from the side
"                                      (i.e. the same as source 11).
"                                      The source MUST be outside the geometry,
"                                      otherwise the initialization routine
"                                      will abort execution.
"
"           Note that if you are not actually rotating about the center of the
"           geometry, you must calculate the angle and distance as if you
"           were.
"
"-------------------------------------------------------------------------------
"
"
"
"                     >>>>>>>> SOURCE  16 <<<<<<<<
"
"           EXTENDED (CIRCULAR OR RECTANGULAR)  SOURCE OFF AXIS.
"
"  SOURCE OPTIONS                (M4)  DIST, ANGLE, TMP1, TMP2
"
"            DIST                      distance of geometry centre to source
"                                      centre in cm.
"
"            ANGLE                     angle of rotation around the x-axis
"                                      (see comments/explanations to source 15)
"
"            TMP1, if TMP2 <= 0        radius of the source (i.e., the emitting
"        or  TMP2, if TMP1 <= 0        position is picked uniformly within the
"                                      circle).
"
"            TMP1 and TMP2, if both    half-sizes of the radiating rectangle
"            >= 0                      in x- and y-directions before rotation,
"                                      i.e., initially x and y are picked
"                                      within the rectangle and z is set to
"                                      -DIST + geometry centre. Then a rotation
"                                      around the x-axis is performed.
"       In all cases the source plane is perpendicular to the line joining
"       it to the center of the geometry.   Note that this introduces a
"       slight error if the center of your geometry is not the true point
"       of rotation.
"
"       Note: if TEMP1 <= 0 and TEMP2 <= 0, source 16 becomes a point-source
"             off-axis, i.e. the same as source 12 and 15.
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  20 <<<<<<<<
"
"   RADIAL DISTRIBUTION INPUT      ""toc:
"
"  MODEIN= Local                 (0)   if radial distribution is to be input
"                                      locally through the .egs4inp file
"        = External              (1)   if the distribution is to be input
"                                      via an external file
"
"                        -----------------------------
" ONLY IF MODEIN= Local
"
"  NRDIST                        (I)   # radial bins in distribution histogram
"  RDISTF                        (M)   top of radial bin.
"                                      should be values for 1 to NRDIST.
"  RPDF                          (M)   Probability of initial particle being
"                                      in this bin.
"                                      Probability doesn't need to be normalized
"                                      but it should be in units cm**-2
"                                      Should be values for 1 to NRDIST.
"  RDIST IOUTSP= None            (0)   No distribution data in output summary
"              = Include         (1)   include distribution data output summary
"
"                        -----------------------------
"  ONLY IF MODEIN= External
"
"  RDIST FILENAME                (C)   filename(with ext) contains
"                                      distribution information
"
"  RDIST IOUTSP= None            (0)   No distribution data in output summary
"              = Include         (1)   include distribution data output summary
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  21 <<<<<<<<
"
"    FULL BEAM PHASE-SPACE BEAM DATA, INCIDENT ON FRONT FACE    ""toc:
"
"  SOURCE OPTIONS                (M4)  IMODE, 0, 0, 0
"
"               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
"                                  2=> 8 variables/record: the above + ZLAST
"
"  FILSPC                        (C)   filename (with ext) contains
"                                      phase space information
"                                      (maximum of 80 characters)
"                                      (assigned to unit 42)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  22 <<<<<<<<
"
"    FULL BEAM PHASE-SPACE BEAM DATA FROM ANY ANGLE, INSIDE OR OUTSIDE   ""toc:
"
"    PARTICLES ARE READ IN FROM A BEAM PHASE SPACE and placed on a plane
"    described by the SOURCE OPTIONS inputs (see below). Then it is checked
"    whether they are already inside the geometry. If yes, the region index
"    is determined and the shower intiated. If not, it is checked whether
"    the particle trajectory will intersect the geometry (assuming that the
"    geometry is surrounded by vacuum). If not, the particle is rejected and
"    the next one taken from the phase-space file. If yes, the particle
"    is placed on the entry point and the shower is initiated.
"
"  SOURCE OPTIONS                (M4)  IMODE, DIST, ANGLE, ZOFFSET
"
"               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
"                                  2=> 8 variables/record: the above + ZLAST
"               DIST               Perpendicular distance of the phase-space
"                                  plane to the point of rotation in cm.
"               ANGLE              Angle of rotation in degrees. The rotation
"                                  is performed around an axis that is parallel
"                                  to the x-axis and passes through the point
"                                  (x,y,z)=(0,0,ZOFFSET).
"               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
"                                  the centre of the geometry is taken as
"                                  the point of rotation (but note that
"                                  the maximum value allowed by the input
"                                  routine is 1e6, so that |ZOFFSET| must
"                                  be between 1e4 and 1e6 to use the centre
"                                  of the geometry automatically).
"
"    Examples:
"       - to place a phase-space on the upper z-face of the geometry,
"         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
"         This is the same as source 21
"       - to place a phase space on the lower z-face of the geometry,
"         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
"       - to have a phase file incident from, say, 60 degrees with
"         a distance to the centre of the geometry of 30 cm, use
"         DIST=30, ANGLE=60, ZOFFSET=9999.
"   etc.
"
"  FILSPC                        (C)   filename (with ext) contains
"                                      phase space information
"                                      (maximum of 80 characters)
"                                      (assigned to unit 42)
"
"*******************************************************************************
"
"            NOT REQUIRED IF ISOURC=21 (FULL PHASE SPACE OF READ)
"
"CARD SC2    (Input from ENSRC.MORTRAN)
"
" ENSRC DELIMETERS:  :start source inputs:
"                    :stop source inputs:
"
"
"  INCIDENT ENERGY
"        = monoenergetic  (0)  IF MONOENERGETIC BEAM
"        = spectrum       (1)  IF ENERGY SPECTRUM TO BE USED
"
"           ---------------------------------------
"
"       ONLY IF INCIDENT ENERGY= Monoenergetic:
"
"                   INCIDENT KINETIC ENERGY(MEV)   (I)
"                                   KINETIC ENERGY OF THE INCIDENT BEAM IN MeV
"                                   (DEFAULTS TO 1.25)
"
"           ---------------------------------------
"
"       ONLY IF INCIDENT ENERGY= Spectrum:
"
"                   SPEC FILENAME   (C)  FILENAME (WITH EXT)
"                                   CONTAINS SPECTRUM INFORMATION
"
"                                   FILE FORMAT:
"                                   TITLE      SPECTRUM TITLE  (80 char)
"                                   NENSRC, ENMIN, MODE
"                                   NENSRC     # ENERGY BINS IN SPEC. HISTOGRAM
"                                   ENMIN      LOWER ENERGY OF FIRST BIN
"                                   MODE       =0, assumes cts/bin
"                                              =1  assumes cts/MeV
"                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
"                                   TOP OF ENERGY BIN AND PROBABILITY OF
"                                   INITIAL PARTICLE BEING IN THIS BIN.
"                                   PROBABILITY DOES NOT NEED TO BE NORMALIZED
"
"                   SPEC IOUTSP
"                        = none     (0)  NO SPECTRUM DATA IN OUTPUT SUMMARY
"                        = include  (1)  INCLUDE SPECTRUM DATA IN OUTPUT SUMMARY
;
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (except for a few entries,
"  case does not matter):
"
"       Global ECUT=     Set a global (in all regions) electron transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Set a global (in all regions) photon transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Set a global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions will
"                        be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Set the maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%)
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        even in `well conditioned' situations (e.g. depth
"                        dose curves for RTP energy range electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If On, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but signifficant in the keV energy range.
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski or penelope.  If set to On or ik, then
"                        use Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then use the cross-sections of
"                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
"                        Similar for kolbenstvedt, gryzinski and penelope.
"                        This is only of interest in kV X-ray calculations.
"                        Note that the user can supply their own EII
"                        cross-section data as well. The requirement is that
"                        the file eii_suffix.data exists in the $HEN_HOUSE/data
"                        directory, where suffix is the name specified.
"                        Entry is case-sensitive except for Off, On or ik.
"                        [ eii_flag ]
"       Bound Compton scattering=  On, Off, Simple or norej
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impuls approximation. Default is On.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to turn on for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Pair angular sampling= Off, Simple or KM
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.
"                        Default is Simple, make sure you always use Simple or
"                        KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel--the default), epdl (Evaluated Photon
"                        Data Library), xcom and pegs4.  Allows the use of
"                        photon cross-sections other than from the PEGS4 file
"                        unless the pegs4 option is specified.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering,
"                        even if no Rayleigh data in PEGS4 file.
"                        Default is Off. Should be turned on for low energy
"                        applications. If custom, user must provide media names
"                        and form factor files for each medium.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"       Atomic relaxations= Off, On
"                        Default is On. The effect of using On is twofold:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross seections
"                        - Shell vacancies created in photo-absorption events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         Make sure to turn this option on for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"                         can also be turned On/Off on a region-by-region
"                         basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn off in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************
"
"                    VARIANCE REDUCTION
"                    ******************
"
"  Delimeter:       :start variance reduction:
"                   :stop variance reduction:
"
"  ELECTRON RANGE REJECTION
"         = off        (0)  No electron range rejection
"         = on         (1)  Do electron range rejection.
"                           There are 2 components to range rejection.
"                           One uses the EGSnrc range rejection below ESAVEIN
"                           and terminates any charged particle which cannot get
"                           out of its local region.
"                           The second component terminates any charged particle
"                           which cannot reach the cylinder which encloses the
"                           cavity region and any other region of the same
"                           material as the cavity.  This cylinder is determined
"                           automatically.
"                           The parameter ESAVEIN also plays a role (see below)
"                           [IREJCT]
"
"  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
"                           electron  when E< ESAVEIN and RANGE < CDIST
"                           where CDIST is closest distance to region of
"                           interest specified below. This ignores brem
"                           losses below ESAVEIN.
"                           This parameter must be input even if not used.
"                           Note - ESAVEIN is total energy (with 511 keV)
"
"  RUSSIAN ROULETTE DEPTH      (R)
"                           FOR RUSSIAN ROULETTE -
"                           AS ANY PHOTON CROSSES THE Z='RUSSIAN ROULETTE DEPTH'
"                           PLANE,  RUSSIAN ROULETTE IS PLAYED.
"
"  RUSSIAN ROULETTE FRACTION   (R)
"                           EACH TIME RUSSIAN ROULETTE IS PLAYED, RRF IS THE
"                           PROBABILITY OF SURVIVAL.
"                           WEIGHT INCREASES BY 1/RRF,  IF IT SURVIVES
"
"                    ****** IF BOTH ZERO, NO RUSSIAN ROULETTE IS PLAYED ******
"
"  EXPONENTIAL TRANSFORM C     (R)
"                           PARAMETER FOR PATHLENGTH BIASING <0 FOR SHORTENING
"                           IF 0.0, NO BIASING DONE
;
"
"  PHOTON FORCING
"        = Off         (0)    NORMAL PHOTON TRANSPORT (NO FORCING)
"        = On          (1)    FORCE PHOTON INTERACTIONS EXPLICITLY
"                             MUST SET START AND STOP FORCING IN THIS CASE
"
"  START FORCING       (I)    NUMBER OF PHOTON INTERACTION/HISTORY AT WHICH
"                             TO START FORCING PHOTON INTERACTIONS
"
"  STOP FORCING AFTER  (I)    NUMBER OF PHOTON INTERACTION/HISTORY AFTER WHICH
"                             TO STOP FORCING PHOTON INTERACTIONS
"
"                             STOP FORCING AFTER > OR = START FORCING
"
" PHOTON SPLITTING=    (I)    Number of times to split a photon
"                             If missing or < 2  => normal transport
"                             If >= 2 (allowed only for ifull=0,1), the macro
"                             $SELECT-PHOTON-MFP essentially replaces the
"                             entire PHOTON routine.
"                             This option increses the efficiency of ifull=0
"                             caluclations by up to a factor of 3 compared
"                             to simple photon forcing (forcing is ignored
"                             if n_split > 1). A rule of thumb for good eff. is
"                             n_split >= No/(1-exp(-Lambda))
"                             where Lambda is approx. number of photon MFP
"                             in the geometry of interest and No >= 5.
"                             Note that if you use the above, there will
"                             be on average approx. No primary interactions per
"                             incident photon => reduce the number of
"                             histories by this number.
"
"        The algorithm works as follows:
"         * dpmfp_i = -log(1 - (eta+i)/n_split)
"           where dpmfp_i is MFP to the next interaction for the i-th sub-photon
"           eta is a random number (the same for all n_split sub-photons)
"         * Once at the interaction site, the i'th sub-photon produces
"           electrons and/or scattered photons. Scattered photons are
"           killed with probability 1/n_split, so that, if they survive,
"           they have the weight of the original photon. Electrons have the
"           weight of 1/n_split of original weight.
"         * In any radiative events (brems, annih, annih at rest), photons
"           are killed with probability 1/n_split => they have again the
"           weight of the photon that initiated the history, if they survive
"         * If ifano = 1 (regeneration), all scattered photons are killed
"           and split-photons re-generated with probability 1/n_split.
"         * If the user wants to calculate Awall in addition to the dose
"           (ifull=1), at all interaction sites the primary photon is
"           regenerated with probability 1/n_split and marked as such
"           (latch=2). It's descending electrons then only score to the
"           dose with attenuation and scatter removed. The ratio of the
"           real dose to the dose with attenuation and scatter removed
"           is per definition Awall. Due to the strong correlation between
"           the two doses the uncertainty on Awall is much smaller than
"           the uncertainty on the each individual dose.
"
"   BE AWARE: When this option is turned on, the normal scoring arrays
"             in cavrznrc are ignored and scoring is done on a history-
"             by-history basis (instead of batch scoring) for the whole
"             cavity only => detailed output for each cavity region
"             is not done even if requested.

"   BE AWARE: If you select too a big splitting number, a stack overflow
"             may result. In such cases either use a smaller n_split
"             or increase $MXSTACK (currently 2000)
"
"        Implemented by I.Kawrakow, February 2000.
"
"-----------------------------------------------------------------------------
"
" CS ENHANCEMENT FACTOR= (R) Cross section enhancement factor.
"                            If this input is missing or set to <= 1, it
"                            has no effect on the simulation. But if
"                            the enhancement factor is set to > 1, the
"                            effect is dramatic: all other user input
"                            concerning photon forcing, splitting, exp.
"                            transform, etc., is ignored. In addition,
"                            the calculation result corresponds  ALWAYS
"                            to 'Aatt and Ascat', no matter what the
"                            user requested (but only Awall is calculated,
"                            not the individual Ascat and Aatt).
"                            The algorithm employed is implemented via
"                            $RAYLEIGH-CORRECTION and appropriate calls to
"                            AUSGAB and works as follows:
"       - the photon cross section is multiplied with the enhancement
"         factor (say, C).
"       - when a photon arrives at an interaction site, it is split into
"         an interacting part (fraction 1/C) and a non-interacting part
"         (fraction  1-1/C).
"       - Electrons set in motion by the interacting fraction are kept
"       - Scattered photons and the non-interacting portion of the
"         original photon are killed with probabilities 1/C and 1-1/C,
"         respectively.
"       - Because the goal is to calculate Awall in addition to the real
"         cavity dose, killed non-interacting fractions of primary
"         photons are left on
"         the stack but marked as such so that, when they are transported,
"         all their descending alectrons contribute only to the dose
"         with attenuation and scatter removed.
"       - Scattered photons descending from a 'killed' non-interacting
"         fractions are always removed from the stack
"       - Because no forcing is done, it is a good idea to set the
"         enhancement factor to a big enough number so that
"         photons interact several times in the chamber. For instance,
"         the attenuation coefficient of a Co60 beam in graphite is ~0.1,
"         if the chamber wall thickness is, say, 1 cm, the average
"         number of MFP is 0.1. To have on average 5 interactions per
"         incident photon one needs C=50 (0.1*50 = 5)
"
"   BE AWARE: If you select to a big enhancement factor, a stack overflow
"             may result. In such cases either use a smaller enhancement
"             factor or increase $MXSTACK (currently 2000)
"
"        Implemented by I.Kawrakow, April 2001.
"
"******************************************************************************
;
;
"
"                       USER DEFINED MACROS
"                       *******************
"
;
"******************************************************************************
;
" Why do we need to put things into 1000 different places !!!!! "
" That sort of thing should be replaced in the machine dependent macro "
" file and NOT IN EVERY SINGLE USER CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!! "
" Whoever put the replacement below: use your brain before doing things "
" LONG_INT is already defined in egsnrc.macros. "
"REPLACE {$LONG_INT} WITH {INTEGER*8}""used for variables that store no. of"
"                                    ""histories to allow > 2.15x10^9 histories"
"                                    ""to be run.  If your compiler gives you"
"                                    ""problems with this, change to INTEGER*4"

REPLACE {$ONE-EPS} WITH {0.9999} "USED TO KEEP THE BEAM INSIDE THE TARGET      "
REPLACE {$NSWTCH} WITH {8}       "# OF NRC SWITCHES FOR CONTROLLING SCATTERING "
REPLACE {$MXMED} WITH {5}        "MAX # OF MEDIA                               "
REPLACE {$MXREG} WITH {50}      "#REGIONS, $MAXRADII*($MAXZPLANE-1)+1(VAC)    "
REPLACE {$NBATCH} WITH {10}        "OUTPUT BATCHES                             "
REPLACE {$NCASEMIN} WITH {100}   "min. no. of histories                        "
REPLACE {$MXDATA} WITH {1040}    "MAXIMUM DATA POINTS FOR ANALYSIS (i.e.       "
"                                     ($MXREG-1))                              "
REPLACE {$MXSTACK} WITH {4000}  "NEED HUGE STACK FOR CORRELATIONS+splitting   "
REPLACE {$MAXZREG} WITH {20}     "MAX # OF DOSE SCORING PLANAR ZONES           "
REPLACE {$MAXRADII} WITH {8}     "MAX # OF DOSE SCORING RADIAL ZONES           "
REPLACE {$MAXRADII+1} WITH {9}   "MAX # OF DOSE SCORING RADIAL ZONES + 1       "
REPLACE {$MAXRZ} WITH {$MAXZREG} "MAX(MAXRADII,MAXZREG)                        "
REPLACE {$MXRDIST} WITH {1000}   "# OF POINTS IN RADIAL DISTRIBUTION FIT       "
REPLACE {$MAXIT} WITH {4}        "MAX # OF PARAMETERS TO BE SCORED             "
"                                (1) PRIMARY EDEP TO GAS                       "
"                                (2) SECONDARY EDEP TO GAS                     "
"                                (3) UNATTENUATED PRIMARY EDEP TO GAS          "
"                                     - PRIMARY EDEP TO GAS                    "
"                                (4) (R**2-R0**2)(UNATTENUATED PRIMARY         "
"                                     EDEP TO GAS)                             "
"                                (5) UNSOURCED UNATTENUATED PRIMARY EDEP TO    "
"                                     GAS WITH GAS MATERIAL REPLACED BY WALL   "
"                                     MATERIAL                                 "
"                                (6) UNSOURCED UNATTENUATED PRIMARY EDEP TO    "
"                                     WALL MATERIAL WITH GAS MATERIAL REPLACED "
"                                     BY WALL MATERIAL                         "
REPLACE {$MAXZPLANE} WITH  {{COMPUTE $MAXZREG+1}}
"                                 MAX # OF PLANAR BOUNDARIES (i.e.$MAXZREG+1)  "
REPLACE {$MAXCMPTS} WITH {$MAXIT}  "FOR THE GRID OUTPUTS"

REPLACE {$MAX_SC_PLANES} WITH {1};"required to use phase space macros"
;

" ************************ try ************************************
"REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH {
"  $RANDOMSET xphi; xphi = xphi*6.283185307179586;
  "{P2} = sin(xphi); {P1} = cos(xphi);"
"  call sincosf(%val(xphi),{P2},{P1});
"};
"REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
"  $REAL xphi;
"};
" ************************ try ************************************

;
"THIS APPENDS COMIN/GEOM/ TO $COMIN-PHOTON;"
"THIS IS NECESSARY SO THAT THE CORRELATIONS CAN BE PROPERLY HANDLED."
"Found a better idea to use APPEND instead of REPLACE, IK Oct 97"
APPEND {;COMIN/GEOM,SCORE/;} TO {$COMIN-PHOTON;}
;

"Define variables used in $SELECT-PHOTON-MFP in order to "
"use implicit data types, IK Nov 97"
APPEND
{;
$REAL DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG;
$INTEGER IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP;
$REAL    d_eta,eta_prime,dpmfp_old,
         x_save,y_save,z_save,u_save,v_save,w_save,
         e_save,wt_save,wt_start,a_survive;
$INTEGER ir_save,ip,i_split,np_start,latch_save,i_survive,i_survive_s;
;} TO
{$DEFINE-LOCAL-VARIABLES-PHOTON;}

" We want the output of the subroutines egs_init and egs_finished "
" to be echoed to the list file => we replace the default $egs_info macro "
REPLACE {$egs_info(#,#);} WITH {
    write(6,{P1}) {P2}; write(1,{P1}) {P2};
};

"MACRO USED FOR FORCING INTERACTIONS IN THE GEOMETRY"
"USED BY EGS4 FOR VARIANCE REDUCTION"
REPLACE {$SELECT-PHOTON-MFP;} WITH {;


  IF( n_split > 1 ) [  "we use photon splitting instead of interaction"
                       "forcing. This is much more efficient as it "
                       "always gives interactions in the chamber "
                       "(provided n_split is large enough) and does"
                       "not lead to varying weights"

      np_start = np; wt_start = wt(np);
      :START-MFP-LOOP:;

      $RANDOMSET RNNO35;
      rnno35 = rnno35/n_split;
      d_eta = 1./n_split;
      x_save = x(np); y_save = y(np); z_save = z(np);
      u_save = u(np); v_save = v(np); w_save = w(np);
      e_save = e(np); wt_save = wt(np)/n_split; ir_save = ir(np);
      latch_save = latch(np);
      np = np-1;
      i_survive = -1;
      IF( iifano = 1 | (ifull = 1 & latch_save ~= 3) ) [
          $RANDOMSET xxx; a_survive = xxx*n_split;
          i_survive = 1 + a_survive;
      ]
      IF( iifano = 1 | latch_save = 2 ) [ i_survive_s = -1; ]
      ELSE [
          $RANDOMSET xxx; a_survive = xxx*n_split;
          i_survive_s = 1 + a_survive;
      ]

      dpmfp_old = 0;
      eta_prime = 1 - rnno35;
      IF(IWATCH ~=0 & IWATCH~=4)["output a message about splitting"
         OUTPUT n_split,wt_save;
        (' Splitting photon into ',I4,' photons with weight ',1PE10.3);
      ]
      DO i_split = 1,n_split [
          IF(eta_prime <= 0 ) goto :END-MFP-LOOP:;
          dpmfp = -log(eta_prime) - dpmfp_old;
          dpmfp_old = dpmfp_old + dpmfp;
          np = np+1;
          IF( np > $MXSTACK ) [
              write(6,*) ' Stack overflow in $SELECT-PHOTON-MFP ';
              stop;
          ]
          x(np) = x_save; y(np) = y_save; z(np) = z_save;
          u(np) = u_save; v(np) = v_save; w(np) = w_save;
          wt(np) = wt_save; e(np) = e_save; iq(np) = 0; ir(np) = ir_save;
          latch(np) = latch_save; dnear(np) = 0;
          irl = ir(np); irold = irl; medium = med(irl);
          LOOP [
              IF( medium ~= 0 ) [
                  $SET INTERVAL GLE,GE;
                  $EVALUATE GMFPR0 USING GMFP(GLE);
                  $SET-RHOF;
                  GMFP=GMFPR0/RHOF;
                  $RAYLEIGH-CORRECTION;
                  TSTEP=GMFP*DPMFP;
              ]
              ELSE [ TSTEP=VACDST; ]
              irnew = irl; idisc = 0; ustep = tstep; tustep = ustep;
              call howfar;
              VSTEP=USTEP;
              TVSTEP=VSTEP;
              EDEP=PZERO;
              IF (IWATCH>0) CALL WATCH($TRANAUSB,IWATCH);
              x(np) = x(np) + u(np)*ustep;
              y(np) = y(np) + v(np)*ustep;
              z(np) = z(np) + w(np)*ustep;
              IF( idisc > 0 ) [
                  IF (IWATCH>0) CALL WATCH($USERDAUS,IWATCH);
                  np = np-1;
                  IF( np = 0 ) [
                      ircode = 2; return;
                  ]
                  goto :END-MFP-LOOP:;
              ]
              IF( medium ~= 0 ) dpmfp = dpmfp - ustep/gmfp;
              IF( irnew ~= irold ) [
                  ir(np) = irnew; irl = irnew; irold = irnew;
                  medium = med(irl);
              ]
              IF (IWATCH>0) CALL WATCH($TRANAUSA,IWATCH);
          ] UNTIL (medium ~= 0 & dpmfp < $EPSGMFP);
          x_save = x(np); y_save = y(np); z_save = z(np);
          ir_save = ir(np);
          IF(IRAYLR(IRL).EQ.1) [
              $RANDOMSET RNNO37;
              IF (RNNO37.LE.(1.0-COHFAC)) [
                  IF( i_split ~= i_survive_s ) [
                      np = np-1; goto :JUST-RAYLEIGH-EVENT:;
                  ]
                  IF (IWATCH>0) CALL WATCH($RAYLAUSB,IWATCH);
                  wt(np) = wt(np)*n_split; latch(np) = 3;
                  /* New Rayleigh sampling */
                  call egs_rayleigh_sampling(medium,e(np),gle,lgle,
                                             costhe,sinthe);
                  /* Left here in case one wants to use the old sampling
                  :RAYLEIGH-SAMPLING-LOOP: LOOP [
                      $RANDOMSET XXX;
                      $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
                      Q2=X2*RMSQ/(20.60744*20.60744);
                      COSTHE=1.-Q2/(2.*E(NP)*E(NP));
                      IF (ABS(COSTHE).GT.1.0) GO TO :RAYLEIGH-SAMPLING-LOOP:;
                      CSQTHE=COSTHE*COSTHE;
                      REJF=(1.0+CSQTHE)/2.0;
                      $RANDOMSET RNNORJ;
                  ] UNTIL (RNNORJ <= REJF);
                  SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
                  */
                  IF (IWATCH>0) CALL WATCH($RAYLAUSA,IWATCH);
                  goto :JUST-RAYLEIGH-EVENT:;
              ]
          ]
          $RANDOMSET RNNO36;
          $EVALUATE GBR1 USING GBR1(GLE);
          IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )[
              IF (IWATCH>0) CALL WATCH($PAIRAUSB,IWATCH);
              call pair;
              IF (IWATCH>0) CALL WATCH($PAIRAUSA,IWATCH);
          ]
          ELSE [
              $EVALUATE GBR2 USING GBR2(GLE);
              IF (RNNO36.LT.GBR2) [
                   IF (IWATCH>0) CALL WATCH($COMPAUSB,IWATCH);
                   call compt;
                   IF (IWATCH>0) CALL WATCH($COMPAUSA,IWATCH);
              ]
              ELSE [
                   IF (IWATCH>0) CALL WATCH($PHOTOAUSB,IWATCH);
                   call photo;
                   IF (IWATCH>0) CALL WATCH($PHOTOAUSA,IWATCH);
              ]
          ]
          "If ifano is on, we traw away all scattered photons"
          "if the latch of the photons is 2, it is a regenerated"
          "primary photon => we need to remove resulting scatter"
          "as well. To save some time, we also discard on the spot"
          "all electrons that can not get into the cavity, if"
          "rejection is on"
          ip = NPold;
          LOOP [
              IF( iq(ip) = 0 ) [
                  IF( i_split ~= i_survive_s ) [
                      IF( ip < np ) [
                          IF(IWATCH~=0 & IWATCH~=4)[
                            OUTPUT ip,e(ip),iq(ip),ir(ip),x(ip),y(ip),
                            z(ip),u(ip),v(ip),w(ip),latch(ip),wt(ip);
                            (' Eliminating scattered photon',T36,':',
                            I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                          ]
                          e(ip) = e(np); iq(ip) = iq(np);
                          u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                          wt(ip) = wt(np); latch(ip) = latch(np);
                      ]
                      np = np-1;
                  ]
                  ELSE [
                      wt(ip) = wt(ip)*n_split; latch(ip) = 3; ip = ip+1;
                  ]
              ]
              ELSE [
                  IF( irejct = 1 ) [
                      "edep = e(ip) - prm;"
                      "elke = log(edep);"
                      elke = log(e(ip)-prm);
                      call range_rejection(elke,x(ip),y(ip),z(ip),
                                           ir(ip),iq(ip),idisc);
                      IF( idisc = 0 ) [ ip = ip+1; ]
                      ELSE [
                          IF( ip < np ) [
                            e(ip) = e(np); iq(ip) = iq(np);
                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                            wt(ip) = wt(np); latch(ip) = latch(np);
                          ]
                          np = np-1;
                          IF (IWATCH>0) CALL WATCH($USERDAUS,IWATCH);
                      ]
                  ] ELSE [ ip = ip+1; ]
              ]
          ] UNTIL (ip > np);

          :JUST-RAYLEIGH-EVENT:

          "IF( iifano = 1 | (ifull = 1 & latch_save ~= 3) ) [ "
          IF( i_split = i_survive ) [
             "Re-generate the original photon with prob."
             "1/n_split, so that we get back the original"
             "weight. This is necessary when ifano is set "
             "(i.e. dose calculation with attenuation and scatter removed)"
             "or ifull is 1 (i.e. user wants to get Awall in addition to"
             "the dose)"
             "$RANDOMSET xxx;"
             " IF(xxx*n_split < 1) ["
                  np = np + 1;
                  x(np) = x_save; y(np) = y_save; z(np) = z_save;
                  u(np) = u_save; v(np) = v_save; w(np) = w_save;
                  e(np) = e_save; ir(np) = ir_save;
                  IF( ifull = 1 ) [ latch(np) = 2; ]
                  ELSE            [ latch(np) = 0; ]
                  wt(np) = wt_save*n_split; iq(np) = 0;
                  IF(IWATCH~=0 & IWATCH~=4)[
                     OUTPUT np,e(np),iq(np),ir(np),x(np),y(np),
                            z(np),u(np),v(np),w(np),latch(np),wt(np);
                            (' Regenerating original photon',T36,':',
                            I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                  ]
              "]"
          ]
          eta_prime = eta_prime - d_eta;
      ]
      :END-MFP-LOOP:;

      IF( np <= 0 ) [ ircode = 2; return; ]
      IF( iq(np) = 0 ) [
          peig = e(np); eig = peig; irl = ir(np); medium = med(irl);
          IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
          gle = log(eig);
          goto :START-MFP-LOOP:;
      ]
      return;
  ]

NFTIME=NFTIME+1;
$RANDOMSET RNNO35;

"------------------------------------------------------------"
"CHANGE: J.S. Aug 95                                         "
"FOLLOWING CHANGE IS JUST TO PREVENT FAKE TRANSPORT IN CASE  "
"OF CORRELATED Afl CALCULATIONS.                             "
"PREVIOUSLY THERE WAS:                                       "
"IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))["
"NOW THE WT(NP)==0 IS INCLUDED TO PREVENT THE FORCING MACRO  "
"FROM INFINITE LOOPING DURING FAKE TRANSPORT FOR CORRELATED  "
"Afl CALCULATIONS WHEN SWITCHED TO PARALLEL BEAMS            "
"------------------------------------------------------------"
IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN).
 OR.(WT(NP).EQ.0))[
"------------------------------------------------------------"
"END OF CHANGE                                               "
"------------------------------------------------------------"
    IF(RNNO35 = 0.0)[RNNO35=1.E-30;]
    DPMFP=-LOG(RNNO35);
    ]
ELSE[
    IF(
          (IFPB.EQ.0).AND.
          (IQINC.EQ.0).AND.
          (NFTIME.EQ.1).AND.
          (MONOEN.EQ.0)
          )
        GOTO :FASTSTEP:;
    "IFPB, IQINC IN COMIN USER-VARIANCE-REDUCTION"
    DUMU=USTEP;
    DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);
    IRODUM=IROLD;IRNDUM=IRNEW;IRDUM=IR(NP);MEDDUM=MEDIUM;
    IDUM=IDISC;
    PATHL=0.0;MEDTMP=0;
    LOOP[
        USTEP=VACDST;
        IROLD=IR(NP);
        MEDIUM=MED(IROLD);
        IF(MEDIUM=0)["vacuum"
           DELTAP=0.;
        ]
        ELSE[
           IF(MEDTMP.NE.MEDIUM)[
              MEDTMP=MEDIUM;
              $SET INTERVAL GLE,GE;
              $EVALUATE DELTAP USING GMFP(GLE);
           ]
           IF(IRAYLR(IROLD).EQ.1)[
              $EVALUATE COHFAC USING COHE(GLE);
           ]
           ELSE[
              COHFAC=1.0;
           ]
        ]
        CALL HOWFAR;
        IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
        "only add to pathl if not a vacuum"
        IF(IRNEW.EQ.1) EXIT;
        IR(NP)=IRNEW;
        X(NP)=X(NP)+USTEP*U(NP);
        Y(NP)=Y(NP)+USTEP*V(NP);
        Z(NP)=Z(NP)+USTEP*W(NP);
        ]
    USTEP=DUMU;
    X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;
    IROLD=IRODUM;IRNEW=IRNDUM;IR(NP)=IRDUM;MEDIUM=MEDDUM;
    IDISC=IDUM;
    IF(PATHL.LE.1.0E-3)[GWAIT=PATHL*(1.-0.5*PATHL);]
    ELSE[GWAIT=1.-EXP(-PATHL);]
    GWTOLD=WT(NP);
    WT(NP)=GWTOLD*GWAIT;
    :FASTSTEP:;EPSLON=RNNO35*GWAIT;
    IF(EPSLON.LE.1.0E-3)[
        IF(NFTIME.EQ.1)EXPMFP=EPSLON*(1.+EPSLON);
        DPMFP=EPSLON*(1.+0.5*EPSLON);
        ]
    ELSE[
        ARG=1./(1.-EPSLON);
        DPMFP=LOG(ARG);
        IF(NFTIME.EQ.1)EXPMFP=EPSLON*ARG;
        ]
    ]
}

;
"THIS MACRO SETS THE PARAMETERS FOR FORCING THE INITIAL INCIDENT PHOTON TO
"INTERACT IN THE GEOMETRY FOR THE FRONTAL PARALLEL BEAM CASE. IT IS MUCH
"FASTER THAN THE GENERALIZED CODING IN THE $SELECT-MEAN-FREE-PATHS MACRO
REPLACE {$SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-BEAM;} WITH {
;
IF((IFPB.EQ.0).AND.(IQINC.EQ.0).AND.(IFORCE.EQ.1))[
    GLE=LOG(EIN);
    DO IX=1,NR[
        PATHL=0.0;
        DO IZ=1,NZ[
            $GET-IRL(IZ,IX);MEDIUM=MED(IRL);
            IF(MEDIUM=0)["vacuum"
                DELTAP=0.;
            ]
            ELSE[
                $SET INTERVAL GLE,GE;
                $EVALUATE DELTAP USING GMFP(GLE);
                IF(IRAYLR(IRL).EQ.1)[
                   $EVALUATE COHFAC USING COHE(GLE);
                ]
                ELSE[
                   COHFAC=1.0;
                ]
            ]
            IF(DELTAP~=0)["only add to pathl if not a vacuum"
               DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP);
               PATHL=PATHL+DELTAP;
            ]
            IF(PATHL.LE.1.0E-3)[GWATE(IX)=PATHL*(1.-0.5*PATHL);]
            ELSE[GWATE(IX)=1.-EXP(-PATHL);]
            ]
        ]
    ]
}

;
"MACRO THAT GETS PLANE AND RADIUS NUMBERS FROM THE REGION NUMBER
REPLACE {$GET-IX-IZ(#);} WITH {;IX=({P1}-2)/NZ+1; IZ={P1}-1-NZ*(IX-1);}

;
"MACRO THAT GETS THE GEOMETRY NUMBER FROM THE PLANAR AND RADIAL ZONES
REPLACE {$GET-IRL(#,#);} WITH {;IRL={P1}+NZ*({P2}-1)+1;}

;
"  In the new version of ELECTR, range is calculated prior "
"  $USER-RANGE-DISCARD ==> no necessity to calculate range "

"  **** RANGE REJECTION MACRO****"

REPLACE {$USER-RANGE-DISCARD;} WITH {

    ;IF (irejct = 1) [
        "Note that in EGSnrc the standard range rejection has already"
        "rejected a particle if it cannot get out of its local region"
        "and if it is below e_max_rr for that region"

        "The following implements the original CAVRZnrc range rejection    "
        "but has a better range calculation (not just range in graphite)"
        "Note that initialize_range_rejection() must have been called   "
        call range_rejection(elke,x(np),y(np),z(np),ir(np),iq(np),idisc);
        IF( idisc ~= 0 ) [
            go to :USER-ELECTRON-DISCARD:
        ]
    ]
}
;


REPLACE {$CLEAN-STACK;} WITH {
;
NPSAVE=NP;
DO NP=1,$MXSTACK [
U(NP)=0.0;V(NP)=0.0;W(NP)=0.0;
X(NP)=0.0;Y(NP)=0.0;Z(NP)=0.0;
WT(NP)=0.0;IQ(NP)=0;LATCH(NP)=0;]
NP=NPSAVE;
;
}

REPLACE {$SCORE(#,#:#)} WITH {;

"Scoring macro used in AUSGAB for quantities other than DOSE and KERMA"
"{P1}{P2}=scoring array (eg SCSTP)"
"{P3}=quantity to be scored (eg 1)"

"If the (primary) history number, NHSTRY, is the same as the history"
"that last scored in this array, {P1}_LAST{P2}, then {P3} is added"
"to a temporary array, {P1}_TMP{P2}.  Otherwise, we add"
"{P1}_TMP{P2} to {P1}{P2}, {P1}_TMP{P2}*{P1}_TMP{P2} to {P1}2{P2},"
"set {P1}_TMP{P2}={P3}, and set {P1}_LAST{P2}=NHSTRY."
"This scoring method allows us to calculate  uncorrelated value"
"of {P1}2{P2} which is then used to calculate the uncertainty"
"in {P1}{P2}.  In cavrznrc, this macro is only used for counting"
"no. of charged particle steps."

IF(NHSTRY={P1}_LAST{P2})[
  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
]
ELSE[
  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
  {P1}_TMP{P2}={P3};
  {P1}_LAST{P2}=NHSTRY;
]
;
}

REPLACE {$ANALYZE(#,#:#)} WITH {;

"Macro to analyze uncertainty:"
"{P1}{P2}=scoring array (eg SCDOSE(IDZ,IDX,ITDOSE))"
"{P3}=quantity to normalize by (eg incident no. of particles)"

"Calculates the uncertainty on {P1}{P2}/{P3}.  The "
"uncertainty is stored in {P1}2{P2} and is expressed as a percentage of"
"{P1}{P2}/{P3} (max 99.9%).  Note that you must define the REAL*8 variable"
"SCORE_TEMP in any subroutine where this macro is used.  This macro"
"is only used in the analysis of no. of steps."

SCORE_TEMP={P1}{P2}/{P3};
{P1}2{P2}={P1}2{P2}/{P3};
{P1}2{P2}=({P1}2{P2}-SCORE_TEMP*SCORE_TEMP)/({P3}-1);
IF({P1}2{P2}>=0.) {P1}2{P2}= SQRT({P1}2{P2});
IF(SCORE_TEMP~=0.)[
    {P1}2{P2}= MIN({P1}2{P2}/SCORE_TEMP*100.,99.9D00);
]
ELSE[
    {P1}2{P2}=99.9D00;
]
;
}

%E     "cavrznrc.mortran"
"                       COMMON BLOCK DEFINITIONS
"                       ************************

;
"CHARACTERS BLANK,*,A,B,C,D,I,M,R,S,T,U,V IN I*4(F4) OR CHARACTER(F77) FORM"
REPLACE {;COMIN/CHARS/;} WITH
"       ================
{;
$TYPE BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,
      TCHAR,UCHAR,VCHAR;
COMMON/CHARS/
BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,TCHAR,UCHAR,VCHAR;
}

;
"GEOMETRICAL INFORMATION"
REPLACE {;COMIN/GEOM/;} WITH
"       ===============          "
{;COMMON/GEOM/
ZPLANE($MAXZPLANE),RCYL(0:$MAXRADII),CYRAD2($MAXRADII+1),
NTRACK($MXREG),NZ,NR,NREG,NPLANE,IDNEAR;
"Define GEOM variables to be able to use implicit none"
$REAL ZPLANE,RCYL,CYRAD2;
$INTEGER NTRACK,NZ,NR,NREG,NPLANE,IDNEAR;
}
"
"ZPLANE(IZ)    CONTAINS THE REAL VALUED COORDINATE OF THE IZ'TH PLANE
"RCYL(IX)      CONTAINS THE REAL VALUED COORDINATE OF THE IX'TH CYL.
"CYRAD2(IX)    =RCYL(IX)**2
"NTRACK(IRL)   =1 IF CAVITY REGION ELSE =0
"NZ/NR         NUMBER OF PLANAR SLABS/CYLINDRICAL REGIONS DEFINING THE TARGET
"NREG          =NZ*NR+1 (+1 FOR THE SURROUNDING VACUUM), NPLANE=NZ+1
"NPLANE        NUMBER OF PLANES DEFINING THE GEOMETRY

;
"FOUR COMMONS FOR INPUT AND OUTPUT"
REPLACE {;COMIN/IODAT1/;} WITH
"       =================
{;
LOGICAL*1 TITLE(80);
COMMON/IODAT1/TITLE;
}
"
"TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES

;
REPLACE {;COMIN/IODAT2/;} WITH
"       ================
{;
COMMON/IODAT2/
NCASE,NCASEO,NCASET,NNREADO,
AMASS($MAXZREG,$MAXRADII),TMCPUO,TIMMAX,STATLM,EIN,
ISUMCV($MXREG),MEDSAV($MXREG),RHOSAV($MXREG),
IDAT,IDOPES,IRESTART,IQIN,IVAL,datcount,jrng1,jrng2;
$REAL    AMASS,TMCPUO,TIMMAX,STATLM,EIN,
         RHOSAV;
$INTEGER ISUMCV,MEDSAV,IDAT,IDOPES,IRESTART,IQIN,IVAL,datcount,
     jrng1,jrng2;
$LONG_INT NCASE,NCASEO,NCASET,NNREADO;
"Added type declarations, IK January 10 2000"
"datcount used to be a local variable that holds the number of parallel"
"jobs if irestart=5. As now data file reading from parallel runs is done"
"in a separate routine, it must go into a common block as it is used in"
"main."
}

"
"AMASS(IZ,IX)  MASS OF ZONE WITH COORDINATES (IZ,IX)
"TMCPUO        CPU TIME USED IN PREVIOUS SESSIONS
"TIMMAX        MAXIMUM ALLOWED CPU HOURS FOR A GIVEN CALCULATION
"STATLM        TARGET STATISTICS IN CAVITY USED FOR AN EARLY EXIT
"EIN           KINETIC ENERGY OF THE EXTERNAL BEAM
"ISUMCV(NREG)  THE ARRAY OF ZONES COMPRISING THE CAVITY REGION
"MEDSAV(NREG)  SAVES MEDIUM NUMBERS FOR CORRELATION SCORING
"RHOSAV(NREG)  SAVES DENSITIES  FOR CORRELATION SCORING
"IDAT          = 0 STORE DATA ARRAYS FOR RE-USE
"              = 1 DON'T STORE THEM
"IDOPES        = 1 INCLUDES PHOTOELECTRON ANGLE SELECTION
"              = 0 DOES NOT INCLUDE PHOTOELECTRON ANGLE SELECTION
"NCASE         NUMBER OF HISTORIES REMAINING TO BE DONE
"NCASEO        NUMBER OF HISTORIES DONE IN PREVIOUS SESSIONS
"NCASET        NUMBER OF HISTORIES ALREADY DONE
"NNREADO       TOTAL NO. OF PARTICLES READ FROM PHSP SOURCE IN PREVIOUS
"              RUNS
"IRESTART        = 0 => INITIAL RUN
"              = 1 => RESTARTED RUN
"              = 3 => DATA ANALYSIS ONLY
"              = 4 => READ STARTING RANDOM NUMBERS FROM A FILE
"              = 5 => analyse previous parallel runs
"IQIN          CHARGE OF THE EXTERNAL BEAM
;
"PRINTER CONTROLS"
REPLACE {;COMIN/PRINTC/;} WITH {
 ;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
 $INTEGER ICHPIN,ILPIN,IOUT,IPAGE;
"Added type declarations, IK January 10 2000"
};

"       =================
"ICHPIN  NUMBER OF CHARACTERS PER INCH
"ILPIN   NUMBER OF LINES PER INCH
"IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
"IPAGE   =1 => PAGE THROW

;
REPLACE {;COMIN/RUSROU/;} WITH
"       =================
{;
$LOGICAL RUSROU;
COMMON/RUSROU/RRZ,RRCUT,RUSROU;
$REAL RRZ,RRCUT;
"Added type declarations, IK January 10 2000"
}
"
"COMMON USED FOR RUSSIAN ROULETTE
"RRZ      COORDINATE OF PLANE AT WHICH RUSSIAN ROULETTE IS PLAYED
"RRCUT    SURVIVAL PROBABILITY AFTER CROSSING THE PLANE
"RUSROU   = .FALSE. => RUSSIAN ROULETTE WILL NOT BE PLAYED
"         = .TRUE.  => RUSSIAN ROULETTE WILL BE PLAYED

;
REPLACE {;COMIN/SCORE/;} WITH
"       ================
{;
COMMON/SCORE/
cav_dose,cav_dose1,cav2_dose,cav2_dose1,cav_dose0, cav2_dose0,
cav_dose2, cav2_dose2,cav_dosec,cav_dosec01,cav_dosec02,
SCSTP,SCSTP2,SCCSTP,SCCSTP2,SCDOSE,SCDOSE2,SCDOSE_COV,PIISTP,
last_case,IHSTRY,SCSTP_LAST,SCCSTP_LAST,SCDOSE_LAST,
tmp_dose,tmp_dose1,tmp_dose0,tmp_dose2,corr_02,
SCSTP_TMP,SCCSTP_TMP,SCDOSE_TMP,cs_enhance,
MXNP,IFULL,ISTORE,IWATCH,IOOPTN,IOUTSP,ifano,NSUMCV,
use_enhance;
REAL*8 cav_dose,cav_dose1,cav2_dose,cav2_dose1,cav_dose0, cav2_dose0,
       cav_dose2, cav2_dose2,cav_dosec,cav_dosec01,cav_dosec02,
       SCSTP,SCSTP2,SCCSTP,SCCSTP2,
       SCDOSE($MAXZREG,$MAXRADII,$MAXIT),SCDOSE2($MAXZREG,$MAXRADII,$MAXIT),
       SCDOSE_COV($MAXZREG,$MAXRADII,3),PIISTP;
$LONG_INT last_case,IHSTRY,SCSTP_LAST,SCCSTP_LAST,
          SCDOSE_LAST($MAXZREG,$MAXRADII);
$REAL tmp_dose,tmp_dose1,tmp_dose0,tmp_dose2,corr_02,
      SCSTP_TMP,SCCSTP_TMP,SCDOSE_TMP($MAXZREG,$MAXRADII,$MAXIT),
      cs_enhance;
$INTEGER MXNP,IFULL,ISTORE,IWATCH,IOOPTN,IOUTSP,ifano,NSUMCV;
LOGICAL use_enhance;
}
"
"COMMON USED FOR SCORING IN AUSGAB

"cav_dose     => total dose in cavity
"cav_dose0    => primary dose in cavity
"cav_dose1    => primary dose corrected for attenuation in cavity
"cav_dose2    => secondary dose in cavity
"cav2_dose    => total dose squared in cavity
"cav2_dose0   => primary dose squared in cavity
"cav2_dose1   => unattenuated primary dose squared in cavity
"cav2_dose2   => secondary dose squared in cavity
"             => eventually, they hold the uncertainty in their respective doses
"cav_dosec    => correlation total - primary(unatttenuated) in cavity
"cav_dosec01  => correlation primary - primary (unattenuated) in cavity
"cav_dosec02  => correlation secondary - primary in cavity
"SCSTP        => total no. of charged particle steps
"SCSTP2       => total no. of charged particle steps squared--eventually holds
"                uncertainty in SCSTP
"SCCSTP       => no. of charged particle steps in cavity
"SCCSTP2      => no. of charged particle steps in cavity squared--eventually
"                holds uncertainty in SCCSTP
"SCDOSE(IZ,IX,IT)      => dose in cavity voxel IZ,IX:
"                        IT=1 -- total
"                        IT=2 -- primary
"                        IT=3 -- primary corrected for attenuation
"                        IT=4 -- secondary
"SCDOSE2(IZ,IX,IT)     => dose in cavity voxel IZ,IX squared.  IT same as above.
"                        Eventually holds uncertainties in respective doses.
"SCDOSE_COV(IZ,IX,IT)  => correlation in cavity voxel IZ,IX for:
"                        IT=1 -- total and primary (unattenuated)
"                        IT=2 -- primary and primary (unattenuated)
"                        IT=3 -- secondary and primary

"PIISTP                => no. of PRESTA-II steps from previous runs
"IHSTRY                => counter for total no. of histories

"last_case             => last primary history to score dose in cavity
"SCSTP_LAST            => last primary history to score charged particle step
"SCCSTP_LAST           => last primary history to score charged particle step
"                         in cavity
"SCDOSE_LAST(IZ,IX)    => last primary history to score dose in cavity
"                         voxel IZ,IX.
"tmp_dose              => temporay arrays for scoring the different
"tmp_dose0                dose components in the cavity
"tmp_dose1
"tmp_dose2
"corr_02               => correlation primary - secondary cavity doses
"SCSTP_TMP             => temp. variable for scoring total no. of charged
"                         particle steps
"SCCSTP_TMP            => temp. variable for scoring total no. of charged
"                         particle steps in cavity
"SCDOSE_TMP(IZ,IX,IT)  => temp. variable for scoring dose in cavity voxel
"                        IZ,IX.  IT same as for SCDOSE.
"cs_enhance            => cross-section enhancement factor

"MXNP    MAXIMUM LEVEL TO WHICH THE STACK OF DAUGHTER PARTICLES FROM AN
"        INCIDENT PARTICLE RISES (STACK MAY INCLUDE INCIDENT PARTICLE)
"IFULL   = 0 JUST CALCULATE TOTAL DOSE AND THAT DUE TO STOPPERS
"            AND DISCARDS (THE DEFAULT)
"        = 1 ABOVE PLUS Aatt, Ascat
"ISTORE  = 0 DO NOT STORE THE INITIAL RANDOM NUMBERS (THE DEFAULT)
"        = 1 STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
"        = 2 STORE THE INITIAL RANDOM NUMBER FOR ALL HISTORIES
"            THAT DEPOSIT ENERGY IN THE CAVITY
"        = 3 STORE ALL THE INITIAL RANDOM NUMBERS
"IWATCH  = 0 FOR NORMAL OUTPUT (THE DEFAULT)
"        = 1 OUTPUT ON EVERY DISCRETE INTERACTION
"        = 2 OUTPUT ON EVERY ELECTRON/PHOTON STEP AS WELL
"        = 3 PRINTS OUT ONLY WHEN ENERGY IS DEPOSITED
"        = 4 PRINTS OUT FILE FOR GRAPHICS
"IOOPTN  = 0 SHORT OUTPUT (THE DEFAULT) -JUST CAVITY SUMMARY
"            AND THE MATERIAL GRID
"        = 1 ABOVE PLUS OUTPUT GRID
"IOUTSP  = 0 NO SPECTRUM DATA IN OUTPUT SUMMARY
"        = 1 INCLUDE SPECTRUM DATA IN OUTPUT SUMMARY
"IFANO   = 0 NO PHOTON REGENERATION
"        = 1 PHOTONS REGENERATED AFTER THEY HAVE INTERACTED
"        = 2 NO PHOTON REGENERATION, ELECTRONS FROM CAVITY WALL ARE ELIMINATED
"NSUMCV  = NO. OF REGIONS MAKING UP THE CAVITY
"use_enhance = .true. if cross-section enhancement is used.

REPLACE {$RAYLEIGH-CORRECTION;} WITH {
  ;
  IF(IRAYLR(IRL).EQ.1) [
      $EVALUATE COHFAC USING COHE(GLE);
      GMFP=GMFP*COHFAC
  ];
  IF( use_enhance ) [ gmfp = gmfp/cs_enhance; ]
    " the above is for the cross section enhancement technique, see "
    " description around definition of common SCORE                "
};

;
"COMMONS USED FOR NON-MONOENERGETIC BEAM DATA                             "
"       NOTE MONOEN IS PASSED IN USER                                     "
"                                                                         "
REPLACE {$NENSRC} WITH {300}     "MAX # OF POINTS IN ENERGY DISTRIBUTION  "
"        =======                                                          "
REPLACE {$INVDIM} WITH {1000}    "DIMENSION CONTROLS GRID SIZE FOR INVERSE"
"        =======                                                          "
;
REPLACE {;COMIN/SPECTR/;} WITH
"       ================="
{;
COMMON/SPECTR/
CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
NENSRC;
$INTEGER NENSRC;
$REAL    CDFINV,ENSRCD,SRCPDF,SRCCDF;
"Added type declarations, IK January 10 2000"
}
"CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
"SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
"SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION

" IK changed USER-MISC to USER for prestaII and included USERVR"
;
REPLACE {;COMIN/USER/;} WITH
"       ===================="
{
;
common/uservr/ cexptr,gwait,
               iforce,nfmin,nfmax,nftime,isourc,ifpb,iqinc,monoen,
               n_split,iifano;
$REAL cexptr,gwait;
$INTEGER iforce,nfmin,nfmax,nftime,isourc,ifpb,iqinc,monoen,
               n_split,iifano;

REPLACE {$MXRANGE} WITH {500}  "for range arrays used in range_rejection()"

COMMON/USERRR/
rangerr0($MXRANGE),rangerr1($MXRANGE),eker0,eker1,
z_cavity_min,z_cavity_max,r_cavity_max,ESAVEIN,IREJCT;
"CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,"
"MINZ,MAXZ,MINR,MAXR;"
$REAL rangerr0,rangerr1,eker0,eker1,z_cavity_min,z_cavity_max,r_cavity_max;
$REAL ESAVEIN;
$INTEGER IREJCT;
"                                                                            "
"COMMON USED FOR RANGE REJECTION                                             "
"ERANGE        ENERGY BOUNDARY FOR TWO-PIECE RANGE FIT USED FOR RANGE DISCARD"
"Z/RMINR/MAX   PLANE/CYLINDER COORDINATES OF THE MIN/MAX PLANES/CYLINDERS    "
"              FOR RANGE REJECTION                                           "
"ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                        "
"MIN/MAX/Z/R   MIN/MAX PLANE/CYLINDER NUMBERS OF RANGE REJECTION REGION      "
"IREJCT        = 0 => NO ELECTRON RANGE REJECTION                            "
"              = 1 => DO ELECTRON RANGE REJECTION OUTSIDE CAVITY             "
"              = 2 => ON SECOND PASS, DO IT IN THE CAVITY AS WELL            "
"FOR THE REMAINING VARIABLES SEE DOCUMENTATION IN SUBROUTINE INPUTS          "
;
COMMON/USERMI/
EXPMFP,GWTOLD,IDECAV,INEED2,IPASS,INOCAV,NOSCT2,INOMED,IPTSRC,icsda;
$REAL EXPMFP,GWTOLD;
$INTEGER IDECAV,INEED2,IPASS,INOCAV,NOSCT2,INOMED,IPTSRC,icsda;
}

"                                                                        "
"COMIN/USER-MISC/USERMI  EXTRA USER COMMON FOR CAVITY                    "
"EXPMFP   EXPONENTIAL MEAN-FREE-PATH USED FOR INTERACTION FORCING
"GWTOLD   OLD WEIGHT
" change for presta-II "
"ICSDA    CSDA CALCULATION ON(1) OR OFF(0)                              "
"                      "
"IDECAV   FLAG SET BY AUSGAB, CLEARED BY MAIN
"         = 0 => NO ENERGY DEPOSITED IN THE CAVITY
"         = 1 => ENERGY DEPOSITED IN THE CAVITY IN ANY FASHION        (IFULL<=1)
"INEED2   FLAG SET BY AUSGAB INDICATING NEED FOR A SECOND PASS IF Afl
"         IS TO BE CALCULATED--currently not used
"         = 0 => NO NEED FOR THIRD PASS
"         = 1 => A SECOND PASS IS NEED (A PRIMARY ELECTRON HAS HIT THE CAVITY
"                OR A PRIMARY PHOTON IS DIRECTED AT THE CAVITY)
"IPASS    FLAG USED FOR CORRELATED SAMPLING--currently not used
"         = 0 => PRESENTLY EXECUTING THE FIRST PASS
"         = 1 => PRESENTLY EXECUTING THE SECOND PASS (TO CALCULATE Apn)
"         = 2 => PRESENTLY EXECUTING THE THIRD  PASS (TO CALCULATE Afl)
"                (NOTE: FOR PARALLEL BEAMS THERE IS NO SECOND PASS)
"INOCAV   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN THE CAVITY
"NOSCT2   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN A CORRELATED
"         RUN WITH THE CAVITY REPLACED BY WALL MATERIAL (THIRD PASS ONLY)
"INOMED   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN THE CAVITY
"         REGION IN A CORRELATED RUN WITH THE CAVITY REPLACED BY WALL MATERIAL
"         (THIRD PASS ONLY)
"IPTSRC   FLAG USED TO INDICATE A POINT SOURCE DISTRIBUTION WAS USED
"         = 0 => BROAD PARALLEL OR UNIFORM BEAM SOURCE DISTRIBUTION
"         = 1 => POINT SOURCE DISTRIBUTION


" The following is an addition taken from dosrzII (Apr, 23,97)         "
" for PRESTA-II                                                        "
"THIS MACRO ALLOW THE USER TO SWITCH ON CSDA CALCULATIONS.             "
"THE MEAN FREE PATH IS SET TO INFINITY AND THE PROPER CSDA STOPPING    "
"POWERS SHOULD BE USED HAVING BEEN CREATED BY PEGS4 VIA IUNRST = N.    "
;
REPLACE {$SELECT-ELECTRON-MFP;} WITH {;
    IF(ICSDA.EQ.0)[
        ;$RANDOMSET RNNE1;IF(RNNE1.EQ.0.0)[RNNE1=1.E-30;]
        "DEMFP=AMAX1(-ALOG(RNNE1),$EPSEMFP);"
        DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);
        ]
    ELSE[
        DEMFP=VACDST;
        ]
;}

"END OF MACRO DEFINITIONS

"                       DATA DECLARATIONS
"                       *****************

$IMPLICIT-NONE;

"***************************************************************************"
"*             Variables passed to the subroutine GET_INPUTS               *"
"***************************************************************************"
REPLACE {$NMAX} WITH {100}  "max number of inputs"
REPLACE {$NVALUE} WITH {100}  "max number of values per input"

COMIN/GetInput/;
"******************************************************* ADDED BY JT, DEC.98"
"*                Variables for post-processing parallel run               *"
"***************************************************************************"

"extra components added    "
"to obtain Aatt and Ascat  "
"with a history by history "
"scoring scheme            "
"            EMH March 2002"
REAL*8     TSCSTP,TSCSTP2,TSCCSTP,TSCCSTP2,
           TSCDOSE($MAXZREG,$MAXRADII,$MAXIT),
           TSCDOSE2($MAXZREG,$MAXRADII,$MAXIT),
           TSCDOSE_COV($MAXZREG,$MAXRADII,3);
real*8 tcav_dose,tcav2_dose,tcav_dose1,tcav2_dose1,tcav_dosec;
real*8 tcav_dose0,tcav2_dose0,tcav_dose2,tcav2_dose2,tcav_dosec01,tcav_dosec02;
"***************************************************************************"

$REAL SCORE_NORM_NUM,
      SCORE_TEMP;    "variables for uncertainty analysis + normalization"

$DECLARE_TIMING_VARIABLES;

$INTEGER NETADJ,IZ,IX,IT,I,J,JJ,LGLE,NBATCH,IRL,MEDNUM,
         IBATCH,IBTCH,ICASE,NPSAVE;
$REAL TIMCPU,TIMEB,ETIMETOT,RATIO,BATCHT;

$REAL XIN,YIN,ZIN,UIN,VIN,WIN;
$INTEGER IRIN,NRCFLG;

$LONG_INT JCASE; "no. of histories per batch"

$REAL EI,EKMAX,DEPTH,VOLUME,RLOW2;
$REAL WEIGHT,PATHL,DELTAP,COHFAC;

$REAL FMASSC,FMASS,AINFLU_CURRENT;
$INTEGER ISUMX,IRNG;

$REAL DCAVUN,DCAV_CURRENT;

REAL*4
    GWATE($MAXRADII); "PHOTON INTERACTION FORCING WEIGHTING FACTORS FOR
                      "NORMALLY INCIDENT PARALLEL BEAMS

;
COMIN/
    BOUNDS,CHARS,EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,
    PRINTC,MEDIA,MISC,PHOTIN,RUSROU,SCORE,SOURCE,SPECTR,
    STACK,THRESH,UPHIOT,USEFUL,USER,RANDOM,ET-Control,RWPHSP,CH-Steps,
    EGS-IO/;

" I/O units "
$INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit;

" Particle counters "
$LONG_INT  n_photons, n_electrons;
real*8     sumE_photons, sumE2_photons, sumE_electrons, sumE2_electrons;

external combine_results;

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler. The macro $HAVE_C_COMPILER is defined in
"    machine.macros and is either #define HAVE_C_COMPILER;, if a working
"    C compiler was found, or NULL if no working C compiler was found.
"
$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;

real*8  last_dose, last2_dose, tmpf;
$REAL   part_dose, part2_dose, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last;
$INTEGER  n_job;
$LOGICAL first_time;

#endif;

$LOGICAL is_finished;


"                       START OF EXECUTABLE CODE
"                       ************************

" Initialize the EGSnrc system "
call egs_init;
is_finished = .true.;

;
"INITIALIZE THE CHARACTER ARRAY"
BLANK=' ';
ASTER='*';
ACHAR='A';
BCHAR='B';
CCHAR='C';
DCHAR='D';
ICHAR='I';
MCHAR='M';
RCHAR='R';
SCHAR='S';
TCHAR='T';
UCHAR='U';
VCHAR='V';

$SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"

OUTPUT $MAXZREG,$MAXRADII;
(//' CAVRZnrc(EGSnrc) Version '$VERSION' on '$MACHINE' with'/
T20,I3,' depth regions and',I3,' radial regions'//);

"******************************************************************************
"
"                       *** SECTION 1 ***
"
"------------------------------------------------------------------------------
"
"READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
"
"------------------------------------------------------------------------------

IOUT=1; "OUTPUT FORTRAN UNIT NUMBER"

CALL INPUTS;

"CHECK FOR END-OF-FILE AND EXIT IF ENCOUNTERED
"error_flag comes back through common block get_input
IF(ERROR_FLAG=1)[
    OUTPUT;
    (//' *** END OF FILE IN SUBROUTINE INPUTS WAS REACHED ***'/
       ' *** OR A RESTART OF A CALCULATION WAS REQUESTED  ***'/
       ' *** WITH NO PREVIOUS DAT FILE                    ***'/
       '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'/);
    GOTO :END-OF-RUN:;
]

"OPEN A FILE FOR STORING OR READING RANDOM NUMBERS"
IF( istore > 0 ) [ "We want to store the rng state in a file"
    rng_unit = egs_open_file(2,0,1,'.egsrns');
]
ELSE IF( irestart = 4 ) [
    rng_unit = egs_open_datfile(2,0,1,'.egsrns');
]

IF(IRESTART.EQ.5)[

    call egs_combine_runs(combine_results,'.egsdat');

    NBATCH=0;      "DON'T WANT IT TO RUN ANY HISTORIES"
    NCASET=NCASEO; "To prevent a wrong normalization if some of the "
                   "parallel runs not available, IK, Jan 21 1999"
] "end of IRESTART = 5, DISTRIBUTED POST-PROCESSING"
ELSE [
    IF(NCASE/$NBATCH=0)[NCASE=$NBATCH;]
    JCASE=NCASE/$NBATCH; NCASE=JCASE*$NBATCH;"NUMBER OF HISTORIES PER BATCH
]

MXNP=0; "reset the maximum stack indicator"
IHSTRY=NCASEO; "reset the number of histories counter"

"set up the broad parallel beam defaults"
IF (ISOURC = 2)[ NR=1;RCYL(1)=1000.;NREG=NZ+1;CYRAD2(1)=RCYL(1)**2;]

"set up ausgab calls"
"JAN CHANGE: 21 is not the final IAUSFL argument; 25 is."
"            An inproper initialization of elements 22,23,24 and 25"
"            gave problems"
"was: "
"DO J=1,5[IAUSFL(J)=1;]DO J=6,21[IAUSFL(J)=0;] NORMAL EXECUTION"
DO J=1,5[IAUSFL(J)=1;]DO J=6,25[IAUSFL(J)=0;] "NORMAL EXECUTION"
"END OF JAN CHANGE"

IF(IFULL=1)[
    "these flags are the minimum set needed to identify primary and secondary"
    IAUSFL(8) =1; "After BREMSSTRAHLUNG"
    IAUSFL(14)=1; "After ANNIHILATION IN FLIGHT"
    IAUSFL(15)=1; "After ANNIHILATION AT REST"
    IAUSFL(19)=1; "After COMPTON"
    IAUSFL(21)=1; "After Photo"
    iausfl(25)=1; "After Rayleigh"
    ]
IF(ifano = 1)
[

    "AUSGAB will be responsible for making sure that the beam is not"
    "attenuated and getting rid of the scattered photons."
    iausfl(16) = 1; "Before pair"
    iausfl(18) = 1; "Before Compton"
    iausfl(19) = 1; "After Compton"
    iausfl(20) = 1; "Before photoelectric"
    iausfl(21) = 1; "After photoelectric"
    iausfl(24) = 1; "Before Rayleigh"
    iausfl(25) = 1; "After Rayleigh"

    "AUSGAB will be responsible for throwing away any photons resulting"
    "from a primary electron. ie. True equilibtrium requires that all"
    "energy deposition be local to the primary interaction site."
    iausfl(8)  = 1; "After bremsstrahlung"
    iausfl(14) = 1; "A positron has annihilated in-flight"
    iausfl(15) = 1; "A positron has annihilated at rest"
]

IF( n_split > 1 ) [
    iausfl(8)  = 1; "After bremsstrahlung"
    iausfl(14) = 1; "A positron has annihilated in-flight"
    iausfl(15) = 1; "A positron has annihilated at rest"

    "With n_split > 1, we don't need the following calls even if ifano = 1"
    iausfl(16) = 0;
    iausfl(18) = 0;
    iausfl(20) = 0;
    iausfl(24) = 0;
    iausfl(25) = 0;

]

IF(ifano = 2) [

    "AUSGAB will be responsible for discarding energy due to electrons set"
    "in motion in the wall"
    iausfl(17) = 1; "After pair"
    iausfl(19) = 1; "After Compton"
    iausfl(21) = 1; "After photoelectric"

]

IF( use_enhance ) [
    iausfl(16) = 1; "Before pair"
    iausfl(18) = 1; "Before Compton"
    iausfl(19) = 1; "After Compton"
    iausfl(20) = 1; "Before photoelectric"
    iausfl(21) = 1; "After photoelectric"
    iausfl(24) = 1; "Before Rayleigh"
    iausfl(25) = 1; "After Rayleigh"
    iausfl(8)  = 1; "After bremsstrahlung"
    iausfl(14) = 1; "A positron has annihilated in-flight"
    iausfl(15) = 1; "A positron has annihilated at rest"
]

write(6,'(/a)')
'************************ IAUSFL ************************** ';
DO j=1,28 [
  IF( iausfl(j).ne.0 ) write(6,'(i3,$)') j;
]
write(6,'(/a//)')
'********************************************************** ';


"HATCH CALL PREPARATION AND EXECUTION"
"-------------------------------------

DUNIT=1; "SET LENGTH UNITS TO CMS"

OUTPUT; (//'CALL TO HATCH AT  ',$); call egs_time(6); write(6,*);

CALL HATCH; "INPUT THE PEGS GENERATED DATA"

OUTPUT; (//'HATCH COMPLETED AT ',$); call egs_time(6); write(6,*);

IF( irejct = 1 ) [ call initialize_range_rejection; ]

IF(MONOEN.EQ.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22) ["MONOENERGETIC INPUT BEAM"
    IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]
    EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
]
ELSEIF(MONOEN.EQ.1)[ "ENERGY SPECTRUM"
    CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
    EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
]
ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22)[ "phase space input"
    EKMAX=EKSRCM;
]
ELSE [ EKMAX=0; ] " <------------ fixme"

"CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY RANGE REQUIRED"
DO I=1,NMED[
    IF((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))[
        OUTPUT I,EKMAX,UP(I),UE(I);
        (//1X,50('*')//
        ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MEV'/
        ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MEV'/
        '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
        1X,50('*')//);
        GOTO :END-OF-RUN:;
        ]
    ] "END OF LOOP OVER MEDIA"

"CALCULATE THE MASS OF EACH ZONE (AREAL MASS FOR ISOURC=2 OR 4)
DO IZ=1,NZ[
    DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ);
    DO IX=1,NR[
        $GET-IRL(IZ,IX);
        MEDNUM=MED(IRL);
        IF(MEDNUM.NE.0)[
            IF((ISOURC.EQ.2).OR.(ISOURC.EQ.4))[VOLUME=DEPTH;]
            ELSE[
                IF(IX.EQ.1)[RLOW2=0.0;]
                ELSE[RLOW2=CYRAD2(IX-1);]
                VOLUME=PI*DEPTH*(CYRAD2(IX)-RLOW2);
                ]
            AMASS(IZ,IX)=RHOR(IRL)*VOLUME;
            ]
        ELSE[AMASS(IZ,IX)=0.0;]
        ]"END OF IX LOOP"
    ]"END OF IZ LOOP"

"CALCULATE ONE-TIME-ONLY CONSTANTS FOR SOURCE"
CALL SRCOTO(WEIGHT);
IF((IFPB.EQ.0).AND.(IFORCE.NE.0).AND.(IQIN.EQ.0).AND.(MONOEN.EQ.0))[
    $SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-BEAM;
    ]

"INITIALIZE DATA ARRAYS FOR FLUORESCENT X-RAYS IF NEEDED"
ISUMX=0;
DO JJ=1,NREG[ISUMX=ISUMX+IEDGFL(JJ); "NON-ZERO IF X-RAYS ANYWHERE"]
IF(ISUMX.NE.0) [CALL EDGSET(2,NREG);]
"NOTE THE ABOVE WILL PRODUCE LOTS OF EXTRA OUTPUT AND SHOULD BE"
"CLEANED UP"

CALL ISUMRY; "PRINT THE SUMMARY OF INPUTS"

"******************************************************************************
"
"                       *** SECTION 2 ***
"
"------------------------------------------------------------------------------
"
"LOOP THROUGH THE NUMBER OF HISTORIES. CALCULATE CONSTANTS THAT MAY CHANGE FOR
"EACH HISTORY AND DO THE SIMULATION
"
"------------------------------------------------------------------------------

"WRITE THE HEADER"
WRITE(IOUT,100) TITLE; call egs_fdate(iout); write(iout,*);
WRITE(IOUT,200);WRITE(6,200); "PRINT HEADER FOR EXECUTION MESSAGES"

"PRINT EXECUTION MODE"
IF(IRESTART =  0)[WRITE(6,201);WRITE(IOUT,201);]
ELSEIF(IRESTART.EQ.1)[
    WRITE(6,202) NCASE,NCASEO;
    write(6,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(6); write(6,*);
    write(iout,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(iout); write(iout,*);
]
ELSEIF(IRESTART.EQ.3)[WRITE(6,204);WRITE(IOUT,204);GO TO :END-SIM:;]
ELSEIF(IRESTART.EQ.4)[WRITE(6,205);WRITE(IOUT,205);]
ELSEIF(IRESTART.EQ.5)[WRITE(6,206);WRITE(IOUT,206);GO TO :END-SIM:;]

"Initialize IWATCH routine"
IF(IWATCH ~= 0) CALL WATCH(-99,IWATCH);

"SET CLOCK AT THE BEGINNING OF SIMULATIONS"
$SET_ELAPSED_CPUTIME(CPUT1);
$INITIALIZE_ELAPSED_TOTAL_TIME;
ETIMETOT=0;
TIMEB=0;
NETADJ=0;

"dcav_old = 0.0;"

"Calculate the cavity mass for in-flight dose display"
FMASSC=0.0; "TOTAL CAVITY MASS"
DO IX=1,NR[
    DO IZ=1,NZ[
        $GET-IRL(IZ,IX);
        IF(NTRACK(IRL).EQ.1)[
            FMASS=AMASS(IZ,IX);
            FMASSC=FMASSC+FMASS; "SUM THE CAVITY MASS USED LATER"
        ]
    ]
]
"end of calculation of cavity mass"

"Initialize variables for the cs_enhance scoring "
tmp_dose = 0; tmp_dose1 = 0;
last_case = 0;NHSTRY = 0;

"Open file for data storage, if requested "
"The file is opened in the temporary working directory"
IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');

/n_photons, n_electrons/ = 0;
/sumE_photons, sumE2_photons, sumE_electrons, sumE2_electrons/ = 0;

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.
#ifdef HAVE_C_COMPILER;
;
/last_dose,last2_dose/ = 0;  n_tot = ncaseo;
first_time = .true.; is_finished = .false.;

:start_parallel_loop:;

IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    last_dose = cav_dose - last_dose + tmp_dose;
    last2_dose = cav2_dose - last2_dose + tmp_dose*tmp_dose;
    tmpf = fmassc*ainflu/ncaset/1.602e-10;
    part_dose = last_dose/tmpf; part2_dose = last2_dose/(tmpf*tmpf);
    last_dose = cav_dose + tmp_dose;
    last2_dose = cav2_dose + tmp_dose*tmp_dose;
    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(6,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        goto :END-SIM:;
    ]
    IF( statlm > 0 & current_uncertainty < statlm ) [
        write(6,'(//a,a//)') '****** Desired uncertainty reached',
                      '       => end simulation';
        goto :END-SIM:;
    ]
    jcase = n_run/$NBATCH;
    IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
    IF( first_time ) [
        first_time = .false.; n_last = n_run;
        write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
]
#endif;


"Output batches. Statistical analysis is done after each batch. Execution
"stops if the desired statistical accuracy is obtained or there is not enough
"time to do another batch.

DO IBATCH=1,$NBATCH[

    IBTCH=IBATCH;
    IF(IBATCH = 1)[
        OUTPUT;
        (/' BATCH',2X,'ELAPSED',2X,'CPUtime',2X,'RATIO',2X,
        'time of day',2X,'cavity stats(%)',2X,'cav.dose(Gy.cm^2)'//
        2X,'1',5X,'0.0',6X,'0.0',6X,'0.00',3X,' ',$); call egs_time(6);

        "IK: it is annoing that for batch runs we don't see the progress"
        "    info in the log file until the job is finished. This is because"
        "    Fortran uses buffered I/O. The following flushes unit 6 so that"
        "    we can see the progress of the calculation. "
        $FLUSH_UNIT(6);
    ]
    ELSE[" not first batch"
        $SET_ELAPSED_TOTAL_TIME(TIMEB);
        ETIMETOT = ETIMETOT+TIMEB;
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU = CPUT2-CPUT1;

        "*****************************************************************"
        OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU;
                  (1X,I2,F8.1,1X,F8.1,2X,F8.2,3X,' ',$);  call egs_time(6);
        "*****************************************************************"

        "IK: it is annoing that for batch runs we don't see the progress"
        "    info in the log file until the job is finished. This is because"
        "    Fortran uses buffered I/O. The following flushes unit 6 so that"
        "    we can see the progress of the calculation. "
        $FLUSH_UNIT(6);

        "Check there is time left for another batch"
        BATCHT = TIMCPU/dble(IBATCH-1);"time per batch so far"
        IF(TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)[
            "not enough time for another batch"
            "print message and exit simulation loop"
            WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
            WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
            "adjust the incident fluence"
            "IK: do it at the end for all possible exits from the
            "shower loop
            "AINFLU = AINFLU*dble(IHSTRY)/dble(NCASET);
            GO TO :END-SIM:;
        ]
    ]" end of before batch ne 1 block"

    DO ICASE = 1,JCASE["now fill each IS bin"

            IF( ISOURC ~= 23 ) IHSTRY = IHSTRY+1; "increment history counter"
              " For source 23 ihstry is set in srchst "

            :CORRELATION-RESTART:; "restart here for a correlated history"

            NFTIME = 0; "reset the photon forced interaction counter"

            "retrieve starting random numbers if reading from a file"
            IF(IRESTART.EQ.4) [
                $RETRIEVE RNG STATE FROM UNIT rng_unit; "was $RESET-RNG(2);"
            ]

            "store the initial random number, another pass might be needed"
            IRNG = 1;
            $STORE-RNG(IRNG);     "was $STORE-RNG(0);"

            "store initial random #s if requested"
            IF(ISTORE =  1)[
                $STORE RNG STATE ON UNIT rng_unit;
            ]
            ELSEIF(ISTORE =  2)[
                "temporarily store the initial random number seed"
                IRNG = 3;
                $STORE-RNG(IRNG);  "was $STORE-RNG(-2);"
                "clear the flag that signals energy deposit in the cavity"
                IDECAV = 0;
            ]
            ELSEIF(ISTORE.EQ.3)[
                "STORE THE INITIAL RANDOM NUMBER SEED"
                $PUT RNG STATE ON UNIT rng_unit;
            ]

            "calculate the source dependent values which change for each
            "history these include :
                "entry point into target,
                "initial direction cosines,
                "statistical weight,
                "entry flag(nrcflg)
            CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);

            "calculate the initial energy if a distribution is to be used"
            IF(MONOEN ~= 0)["if equal to 0, it is monoenergetic"
                CALL ENSRCH(EIN);   "returns K.E. from distribution"
                IF(IQIN.EQ.0)[EI = EIN;]ELSE[EI = EIN+RM;]  "total energy"
                " there was a check that the data file had data over the energy
                "range required, the location of it will eventually be in
                "ESRCIN.MOR
            ]
            ELSEIF(ISOURC = 21 | ISOURC = 22 | ISOURC = 23 )[ EI = EIN; ]

            "Set photon weights if gamma interactions are to be forced in the
            "target in the frontal parallel beam case if monoenergetic
            IF((MONOEN.EQ.0).AND.(IQIN.EQ.0).AND.(IFORCE.EQ.1).AND.(IFPB.EQ.0).
                AND.(ISOURC.NE.21).AND.(ISOURC.NE.22))[
                  IX=(IRIN-2)/NZ+1;
                  GWAIT=GWATE(IX);
                  WEIGHT=GWAIT;
            ]

            "FOR AN INPUT ENERGY SPECTRUM, DETAILED FORCING MACRO IS USED"

            LATCHI=0;

            IF((IWATCH ~= 0) & (IWATCH ~= 4))[
                OUTPUT 1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,WEIGHT;
                (/' INITIAL SHOWER VALUES',T36,':',
                I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
            ]
            "ALL INITIAL SHOWER VARIABLES ARE SET, CALL THE SHOWER ROUTINE"
            IF( iqin = 0 ) [
                n_photons = n_photons + 1;
                sumE_photons = sumE_photons + ei;
                sumE2_photons = sumE2_photons + ei*ei;
            ]
            ELSE [
                n_electrons = n_electrons + 1;
                sumE_electrons = sumE_electrons + ei-rm;
                sumE2_electrons = sumE2_electrons + (ei-rm)**2;
            ]

            CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);

            IF(ISTORE.EQ.2)[
                "STORE INITIAL RN SEED IF ENERGY SCORED IN THE CAVITY"
                 IF(IDECAV.EQ.1)[ "ENERGY WAS DEPOSITED IN THE CAVITY"
                         IRNG = 1;
                         $STORE-RNG(IRNG);              "was $STORE-RNG(0);"
                         IRNG = 3;
                         $RESET-RNG(IRNG);              "was $RESET-RNG(-2);"
                         $PUT RNG STATE ON UNIT rng_unit;"was $STORE-RNG(2);"
                         IRNG = 1;
                         $RESET-RNG(IRNG);              "was $RESET-RNG(0);"
                 ]
            ]

            "SIGNAL THE END OF A HISTORY IF WATCH MODE IS SET"
            "JAN CHANGE: ZERO STACK ELEMENTS TO PREVENT CROSS TALKING"
            "IK: Huh ? $CLEAN-STACK;"
            "END OF JAN CHANGE"
            IF(IWATCH.GT.0) CALL WATCH(-1,IWATCH);

    ] "END OF THE ICASE LOOP"

    "Succesful completion of a batch. delete the raw data from the last batch"
    "and record the new batch only if requested"
    IF(IDAT = 0)[

        " discard data from previous batches (if any) "
        rewind(data_unit);

        TSCSTP=SCSTP+SCSTP_TMP;
        TSCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
        TSCCSTP=SCCSTP+SCCSTP_TMP;
        TSCCSTP2=SCCSTP2+SCCSTP_TMP*SCCSTP_TMP;

        WRITE(data_unit,*)TSCSTP,TSCSTP2,TSCCSTP,TSCCSTP2;

"******************"
"history by history"
"  EMH  March, 2002"
"******************"
        tcav_dose  = cav_dose  + tmp_dose;
        tcav2_dose = cav2_dose + tmp_dose*tmp_dose;

        tcav_dose0  = cav_dose0   + tmp_dose0;
        tcav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;

        tcav_dose1  = cav_dose1  + tmp_dose1;
        tcav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;

        tcav_dose2  = cav_dose2  + tmp_dose2;
        tcav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;

        tcav_dosec   = cav_dosec   + tmp_dose*tmp_dose1;
        tcav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
        tcav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;

        write(data_unit,*) tcav_dose, tcav_dose0, tcav_dose1, tcav_dose2;
        write(data_unit,*) tcav2_dose,tcav2_dose0,tcav2_dose1,tcav2_dose2;
        write(data_unit,*) tcav_dosec,tcav_dosec01,tcav_dosec02;

"*****************"

        IF(NSUMCV>1)["store data for individual cavity regions"

           DO IZ=1,NZ[
               DO IX=1,NR[
                  $GET-IRL(IZ,IX);
                  IF(NTRACK(IRL).EQ.1)[
                   DO IT=1,4[
                    TSCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT);
                    TSCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
                                                          SCDOSE_TMP(IZ,IX,IT);
                   ]
                   TSCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)+
                                       SCDOSE_TMP(IZ,IX,1)*SCDOSE_TMP(IZ,IX,3);
                   TSCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)+
                                       SCDOSE_TMP(IZ,IX,2)*SCDOSE_TMP(IZ,IX,3);
                   TSCDOSE_COV(IZ,IX,3)=SCDOSE_COV(IZ,IX,3)+
                                       SCDOSE_TMP(IZ,IX,2)*SCDOSE_TMP(IZ,IX,4);
                   WRITE(data_unit,*)
                     (TSCDOSE(IZ,IX,IT),TSCDOSE2(IZ,IX,IT),IT=1,4);
                   WRITE(data_unit,*)(TSCDOSE_COV(IZ,IX,IT),IT=1,3);
                  ]
               ]
           ]
        ]

    ]"end of conditional data storage"

    $SET_ELAPSED_CPUTIME(CPUT2);
    TIMCPU=CPUT2-CPUT1+TMCPUO;
    IF(IDAT.EQ.0)[
        $PUT RNG STATE ON UNIT data_unit;
        WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD,PIISTP+count_pII_steps;
    ]
"******************"
"history by history"
"    EMH March 2002"
"******************"
    IF(ISOURC=21|ISOURC=22)[
      AINFLU_CURRENT=
            dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
    ]
    ELSE IF( ISOURC=23 ) [ AINFLU_CURRENT=IHSTRY; ]
    ELSE[ AINFLU_CURRENT=AINFLU*dble(IHSTRY)/dble(NCASET); ]
    dcav_current = cav_dose*1.602E-10/(FMASSC*AINFLU_CURRENT);
    /*
    IF( ISOURC=23 ) [
        dcavun = (cav2_dose*nhstry-cav_dose*cav_dose)/(nhstry-1);
    ]
    ELSE [
        dcavun = (cav2_dose*ihstry-cav_dose*cav_dose)/(ihstry-1);
    ]
    */
    dcavun = (cav2_dose*ihstry-cav_dose*cav_dose)/(ihstry-1);
    IF( dcavun > 0 ) [ dcavun = sqrt(dcavun); ];
    dcavun = dcavun*1.602E-10/(FMASSC*AINFLU_CURRENT);
    dcavun = 100*dcavun/dcav_current;

    OUTPUT DCAVUN,DCAV_CURRENT;('+',5X,F5.2,10X,1PE11.4,5X,1PE10.3);

    IF(dcavun<=STATLM & STATLM>0.)[
      "we have reached the desired statistics, print a message and exit"
      WRITE(6,230)dcavun,IBTCH;WRITE(IOUT,230)dcavun,IBTCH;
      GO TO :END-SIM:;
    ]
] "END OF SIMULATIONS"

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]

#endif;

"PRINT INSUFFICIENT STATS WARNING"
WRITE(IOUT,240) STATLM,DCAVUN,IBTCH;WRITE(6,240) STATLM,DCAVUN,IBTCH;

:END-SIM:;

SCSTP=SCSTP+SCSTP_TMP; SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
SCCSTP=SCCSTP+SCCSTP_TMP; SCCSTP2=SCCSTP2+SCCSTP_TMP*SCCSTP_TMP;

"******************"
"history by history"
"    EMH March 2002"
"******************"
"we have to add the temporary scoring"
"variables for the last history      "
cav_dose  = cav_dose  + tmp_dose; cav2_dose = cav2_dose + tmp_dose*tmp_dose;

cav_dose0  = cav_dose0   + tmp_dose0;
cav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;

cav_dose1  = cav_dose1  + tmp_dose1;
cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;

cav_dose2  = cav_dose2  + tmp_dose2;
cav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;

cav_dosec   = cav_dosec   + tmp_dose*tmp_dose1;
cav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
cav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;

IF(NSUMCV>1)["store data for individual cavity regions"

    DO IZ=1,NZ[ DO IX=1,NR[
        $GET-IRL(IZ,IX);
        IF(NTRACK(IRL).EQ.1)[
            DO IT=1,4[
                SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT);
                SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
                                                     SCDOSE_TMP(IZ,IX,IT);
            ]
            SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)+
                                   SCDOSE_TMP(IZ,IX,1)*SCDOSE_TMP(IZ,IX,3);
            SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)+
                                   SCDOSE_TMP(IZ,IX,2)*SCDOSE_TMP(IZ,IX,3);
            SCDOSE_COV(IZ,IX,3)=SCDOSE_COV(IZ,IX,3)+
                                   SCDOSE_TMP(IZ,IX,2)*SCDOSE_TMP(IZ,IX,4);
        ]
    ] ]
]

write(6,'(/a,$)') '****** FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(6); write(6,'(a)') '  ******';
write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(iout); write(iout,'(a)') '  *********';
$SET_ELAPSED_TOTAL_TIME(TIMEB);
ETIMETOT=ETIMETOT+TIMEB;
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=CPUT2-CPUT1;
IF(IRESTART=3)["just analyzing data--no elapsed time"
  WRITE(IOUT,250)TMCPUO,TMCPUO/3600;
  WRITE(6,250)TMCPUO,TMCPUO/3600;
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRESTART=5)["output time results for parallel runs"
  WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSE[
  IF(TMCPUO.EQ.0)["This is first run"
   RATIO=ETIMETOT/TIMCPU;
   WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
   WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
  ]
  ELSE[ "There was previous run, but don't have elapsed time for it"
   RATIO = ETIMETOT/(TIMCPU-TMCPUO); "ratio this run only"
   WRITE(IOUT,261) ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
   WRITE(6,261) ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
  ]
  IF(IHSTRY.NE.0 .AND. TIMCPU.NE.0.0) ["this should always happen"
   WRITE(IOUT,280) TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
  ]
]


;
"******************************************************************************
"
"                       *** SECTION 3 ***
"
"------------------------------------------------------------------------------

"STATISTICAL AND OTHER DATA HANDLING AND CALL THE OUTPUT SUMMARY ROUTINE"

"------------------------------------------------------------------------------

:STATS-ANAL:;

FMASSC=0.0; "total cavity mass"
DO IX=1,NR[ DO IZ=1,NZ[
    $GET-IRL(IZ,IX);
    IF(NTRACK(IRL).EQ.1)[
        FMASS=AMASS(IZ,IX); FMASSC=FMASSC+FMASS;
    ]
] ]

IF(ISOURC = 21|ISOURC = 22)[
   "normalize dose to number of incident particles from primary source
   AINFLU = dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
   "we estimate the total number of particles from the primary source "
   "(original non-phase space source) by taking the ratio of the total "
   "number of particles read from the phase source in this simulation "
   "to the total number of particles in the phase space source and multiply "
   "this by the number of particles from the primary source that were used "
   "to obtain this phase space  source."
   OUTPUT AINFLU, NNREAD, NNREAD-IHSTRY, NCASE_PHSP, NINCSRC;
   (/' Corresponding number of particles in original BEAM simulation =', F13.0/
     ' Based on reading', I13, ' particles from the phase space file,'/
     ' rejecting',I13,' particles (due to wrong charge, missing the'/
     ' geometry or being multiple passers),'/
     ' and  file having', I13, ' particles in it.'/
     ' The phase space file was generated by', F13.0, ' initial particles'/);
   WRITE(IOUT,:tgh1:) AINFLU, NNREAD, NNREAD-IHSTRY, NCASE_PHSP, NINCSRC;
   :tgh1: FORMAT(/' Corresponding number of particles in original BEAM',
     ' simulation =', F13.0/
     ' Based on reading', I13, ' particles from the phase space file,'/
     ' rejecting',I13,' particles (due to wrong charge, missing the'/
     ' geometry or being multiple passers),'/
     ' and phase space file having', I13, ' particles in it'/
     ' The phase space file was generated by', F13.0, ' initial particles'/);
   SCORE_NORM_NUM=AINFLU;
]
ELSEIF( ISOURC = 23 ) [
    /*
    AINFLU = NHSTRY; SCORE_NORM_NUM=NHSTRY;
    */
    AINFLU = IHSTRY; SCORE_NORM_NUM=IHSTRY;
    OUTPUT AINFLU;
    (/'Source 23: number of particles in BEAM source: ',F13.0/);
    IF( n_photons > 0 ) [
        sumE_photons = sumE_photons/n_photons;
        sumE2_photons = sumE2_photons/n_photons;
        sumE2_photons = sumE2_photons - sumE_photons*sumE_photons;
        IF( sumE2_photons > 0 ) sumE2_photons = sqrt(sumE2_photons/n_photons);
        OUTPUT n_photons,sumE_photons,sumE2_photons;
        ('   Number of photons:      ',i10/
         '   Average energy:         ',f10.5,' +/- ',f10.5,/);
    ] ELSE [ OUTPUT; ('   Number of photons:        0'); ]
    IF( n_electrons > 0 ) [
        sumE_electrons = sumE_electrons/n_electrons;
        sumE2_electrons = sumE2_electrons/n_electrons;
        sumE2_electrons = sumE2_electrons - sumE_electrons*sumE_electrons;
        IF( sumE2_electrons > 0 ) [
            sumE2_electrons = sqrt(sumE2_electrons/n_electrons);
        ]
        OUTPUT n_electrons,sumE_electrons,sumE2_electrons;
        ('   Number of electrons:    ',i10/
         '   Average energy:         ',f10.5,' +/- ',f10.5,/);
    ] ELSE [ OUTPUT; ('   Number of electrons:      0'); ]

]
ELSE[
   "IK: adjust incident fluence
   AINFLU = AINFLU*dble(IHSTRY)/dble(NCASET);
   SCORE_NORM_NUM=dble(IHSTRY);
]

"******************"
"history by history"
"    EMH March 2002"
"******************"

$ANALYZE(SCOMEG, :SCORE_NORM_NUM);
SCOMEG = SCOMEG/dble(IHSTRY);"Corrected, IK May 4 1999"

OUTPUT SCOMEG,SCOMEG2;(/' OMEG =',1PE12.3,'(',0PF5.1,'%)'/);

$ANALYZE(SCSTP, :SCORE_NORM_NUM);
$ANALYZE(SCCSTP, :SCORE_NORM_NUM);

"first, estimate uncertainties for entire cavity"
cav2_dose = (cav2_dose*SCORE_NORM_NUM - cav_dose*cav_dose)/
                (SCORE_NORM_NUM-1);
IF( cav2_dose > 0 ) cav2_dose = sqrt(cav2_dose);

IF( ifull = 1 ) [

        cav2_dose0 = (cav2_dose0*SCORE_NORM_NUM - cav_dose0*cav_dose0)/
                     (SCORE_NORM_NUM-1);
        IF( cav2_dose0 > 0 ) cav2_dose0 = sqrt(cav2_dose0);
        cav2_dose1 = (cav2_dose1*SCORE_NORM_NUM - cav_dose1*cav_dose1)/
                     (SCORE_NORM_NUM-1);
        IF( cav2_dose1 > 0 ) cav2_dose1 = sqrt(cav2_dose1);
        cav2_dose2 = (cav2_dose2*SCORE_NORM_NUM - cav_dose2*cav_dose2)/
                     (SCORE_NORM_NUM-1);
        IF( cav2_dose2 > 0 ) cav2_dose2 = sqrt(cav2_dose2);

        corr_02=(cav_dosec02*SCORE_NORM_NUM-cav_dose0*cav_dose2)/
                (SCORE_NORM_NUM-1);
        corr_02=cav2_dose0**2+cav2_dose2**2+ 2*corr_02;
        IF (corr_02 > 0) corr_02 = sqrt(corr_02);

        cav_dosec   = (cav_dosec*SCORE_NORM_NUM   - cav_dose*cav_dose1)/
                      (SCORE_NORM_NUM-1);
        cav_dosec01 = (cav_dosec01*SCORE_NORM_NUM - cav_dose0*cav_dose1)/
                      (SCORE_NORM_NUM-1);
        cav_dosec02 = (cav_dosec02*SCORE_NORM_NUM - cav_dose0*cav_dose2)/
                      (SCORE_NORM_NUM-1);
]

cav_dose  = cav_dose*1.602e-10/(ainflu*fmassc);
cav_dose0 = cav_dose0*1.602e-10/(ainflu*fmassc);
cav_dose1 = cav_dose1*1.602e-10/(ainflu*fmassc);
cav_dose2 = cav_dose2*1.602e-10/(ainflu*fmassc);

cav2_dose  = cav2_dose*1.602e-10/(ainflu*fmassc);
cav2_dose0 = cav2_dose0*1.602e-10/(ainflu*fmassc);
cav2_dose1 = cav2_dose1*1.602e-10/(ainflu*fmassc);
cav2_dose2 = cav2_dose2*1.602e-10/(ainflu*fmassc);

corr_02    = corr_02*1.602e-10/(ainflu*fmassc);

cav_dosec   = cav_dosec*(1.602e-10/(ainflu*fmassc))**2;
cav_dosec01 = cav_dosec01*(1.602e-10/(ainflu*fmassc))**2;
cav_dosec02 = cav_dosec02*(1.602e-10/(ainflu*fmassc))**2;

IF(NSUMCV>1)["multiple cavity regions, analyze quantities in each region"

    "FOR ISOURC=4 WE NEED THE DATA FOR CIRCLES, NOT RINGS, SO ADD IT UP"
    "THIS SHOULD ONLY BE USED IF THE CAVITY HAS AN INFINITE DIAMETER"
    IF((ISOURC.EQ.4).AND.(NR.GT.1))[
       DO IX=1,NR[
            DO IZ=1,NZ[
               $GET-IRL(IZ,IX);
               IF(NTRACK(IRL).EQ.1)[
                   DO IT=1,4[
                        "IK: this must be a bug. for ix=1 ix-1=0 and the"
                        "    array is not defined"
                      SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE(IZ,IX-1,IT);
                      SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE2(IZ,IX-1,IT);
                      IF(IT<4)[
                        SCDOSE_COV(IZ,IX,IT)=SCDOSE_COV(IZ,IX,IT)+
                                             SCDOSE_COV(IZ,IX-1,IT);
                      ]
                   ]
               ]
            ]
       ]
    ]
    DO IX=1,NR[
        DO IZ=1,NZ[
            $GET-IRL(IZ,IX);
            IF(NTRACK(IRL).EQ.1)[
                SCDOSE2(IZ,IX,1)=(SCDOSE2(IZ,IX,1)*SCORE_NORM_NUM -
                                  SCDOSE(IZ,IX,1)*SCDOSE(IZ,IX,1))/
                                   (SCORE_NORM_NUM-1);
                IF( SCDOSE2(IZ,IX,1) > 0 ) SCDOSE2(IZ,IX,1)=
                                               SQRT(SCDOSE2(IZ,IX,1));
                IF(IFULL=1)[
                  SCDOSE2(IZ,IX,2)=(SCDOSE2(IZ,IX,2)*SCORE_NORM_NUM -
                                  SCDOSE(IZ,IX,2)*SCDOSE(IZ,IX,2))/
                                   (SCORE_NORM_NUM-1);
                  IF( SCDOSE2(IZ,IX,2) > 0 ) SCDOSE2(IZ,IX,2)=
                                               SQRT(SCDOSE2(IZ,IX,2));
                  SCDOSE2(IZ,IX,3)=(SCDOSE2(IZ,IX,3)*SCORE_NORM_NUM -
                                  SCDOSE(IZ,IX,3)*SCDOSE(IZ,IX,3))/
                                   (SCORE_NORM_NUM-1);
                  IF( SCDOSE2(IZ,IX,3) > 0 ) SCDOSE2(IZ,IX,3)=
                                               SQRT(SCDOSE2(IZ,IX,3));
                  SCDOSE2(IZ,IX,4)=(SCDOSE2(IZ,IX,4)*SCORE_NORM_NUM -
                                  SCDOSE(IZ,IX,4)*SCDOSE(IZ,IX,4))/
                                   (SCORE_NORM_NUM-1);
                  IF( SCDOSE2(IZ,IX,4) > 0 ) SCDOSE2(IZ,IX,4)=
                                               SQRT(SCDOSE2(IZ,IX,4));
                  "now calculate the covariances"

                  SCDOSE_COV(IZ,IX,1)=(SCDOSE_COV(IZ,IX,1)*SCORE_NORM_NUM -
                                       SCDOSE(IZ,IX,1)*SCDOSE(IZ,IX,3))/
                                       (SCORE_NORM_NUM-1);
                  SCDOSE_COV(IZ,IX,2)=(SCDOSE_COV(IZ,IX,2)*SCORE_NORM_NUM -
                                       SCDOSE(IZ,IX,2)*SCDOSE(IZ,IX,3))/
                                       (SCORE_NORM_NUM-1);
                  SCDOSE_COV(IZ,IX,3)=(SCDOSE_COV(IZ,IX,3)*SCORE_NORM_NUM -
                                       SCDOSE(IZ,IX,2)*SCDOSE(IZ,IX,4))/
                                       (SCORE_NORM_NUM-1);
                ]

                "now normalize quantities and convert to dose"
                FMASS=AMASS(IZ,IX);

                SCDOSE(IZ,IX,1)=SCDOSE(IZ,IX,1)*1.602e-10/(ainflu*FMASS);
                SCDOSE(IZ,IX,2)=SCDOSE(IZ,IX,2)*1.602e-10/(ainflu*FMASS);
                SCDOSE(IZ,IX,3)=SCDOSE(IZ,IX,3)*1.602e-10/(ainflu*FMASS);
                SCDOSE(IZ,IX,4)=SCDOSE(IZ,IX,4)*1.602e-10/(ainflu*FMASS);

                SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)*1.602e-10/(ainflu*FMASS);
                SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)*1.602e-10/(ainflu*FMASS);
                SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)*1.602e-10/(ainflu*FMASS);
                SCDOSE2(IZ,IX,4)=SCDOSE2(IZ,IX,4)*1.602e-10/(ainflu*FMASS);

                SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)*
                                    (1.602e-10/(ainflu*FMASS))**2;
                SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)*
                                    (1.602e-10/(ainflu*FMASS))**2;
                SCDOSE_COV(IZ,IX,3)=SCDOSE_COV(IZ,IX,3)*
                                    (1.602e-10/(ainflu*FMASS))**2;
            ]
        ]
    ]
]

CALL OSUMRY; "PRINT THE OUTPUT SUMRY"

:END-OF-RUN:;

;"******************************************************************************
"
"                       *** SECTION 4 ***
"
"------------------------------------------------------------------------------
"
"THE CONCLUSION"
"
"------------------------------------------------------------------------------

:END:;
OUTPUT; (//'END OF RUN',9X,' ',$); call egs_fdate(6);
OUTPUT; (//);
write(iout,'(/a,$)') 'END OF RUN          '; call egs_fdate(iout);
write(iout,'(////)');

call egs_finish;

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IF( n_job = 0 ) [
        is_finished = .true.;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET;
        CALL SRCOTO(WEIGHT);
        goto :STATS-ANAL:;
    ]
]
#endif;

call SRCEND;

$CALL_EXIT(0);

"FORTRAN FORMAT STATEMENTS. FORMAT STATEMENT N## IS FIRST USED IN SECTION N."
%I0
100  FORMAT(80A1//'Calculation using CAVRZnrc(EGSnrc) '$VERSION' ',
             /' ON '$MACHINE' ',T55,' ',$);
200  FORMAT(//,79('*')/
            // ,T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
            // ,79('*')/
            //'USING CAVRZnrc(EGSnrc) '$VERSION' ON '$MACHINE' ');
201  FORMAT(/'********* NEW INPUT FILE *********'/);
202  FORMAT(/'********* RESTARTED INPUT FILE ********* '/
             ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES');
204  FORMAT(/'********* DATA ANALYSIS ONLY *********'/);
205  FORMAT(/'********* RANDOM NUMBERS READ FROM FILE *********'/);
206  FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/);
210  FORMAT(/'********* NOT ENOUGH TIME TO FINISH WITHIN',
       ' LIMIT OF',F8.2,' HOURS',I5,' BATCHES USED********'/
       ' ',I12,' HISTORIES RUN, ',I12,' HISTORIES ANALYZED'//);
230  FORMAT(/'DESIRED STATISTICAL ACCURACY OBTAINED.'/
            ' STATS IN CAVITY= ',F5.2,'%',
            ' AFTER ',I2,' BATCHES');
240  FORMAT(/'*********DESIRED STATISTICAL ACCURACY OF ',F5.2,'%',
            ' NOT REACHED*********'/
            ' STATS IN CAVITY= ',F5.2,' % AFTER ',I2,' BATCHES');
250  FORMAT(/' FOR OLD RUN:'/
             ' ----------- '/
             ' Total cputime =',F8.1,'s (=',F5.2,' hr)');
255  FORMAT(/' FOR PARALLEL RUNS:'/
             ' ----------------- '/
             ' On ',I5,' machines '/
             ' Total cputime =',F8.1,'s (=',F8.2,' hr), cputime/machine =',
              F8.1,'s');
260  FORMAT(/'Finished simulations:'/'     time elapsed,cputime',
             ',ratio= ',2F8.1,'(=',F5.2,'hr)',F8.2);
261  FORMAT(/' Finished: time elapsed this run', F10.1/
             '           CPUtime total run    ', F10.1,'(=',F8.2,'hr)'/
             '           Ratio ELAPSED/CPU this run:', F8.3);
280  FORMAT(/'    CPUtime/history=',F10.5,'  sec.  Histories/hour=',F12.0);

END; "END OF MAIN ROUTINE-CAVRZnrc"
%C80
%I4
%Q1
%E     "cavrznrc.mortran"
"******************************************************************************
"
"
"                               **********
"                               *        *
"                               * AUSGAB *
"                               *        *
"                               **********
"
"
"       An AUSGAB routine to be used with cavrznrc.mortran
"
"       This routine scores the dose and other ionisation cavity parameters
"       in a finite, azimuthally symmetric cylindrical geometry which the
"       user defines via plane and radius coordinates. The user must specify
"       both the target geometry as well as the planes and radii between
"       which the quantities are to be scored. All the geometrical checks for
"       crossing 'geometrical' or 'dose' regions are handled by the subroutine
"       HOWFAR.
"
"       FOR IT = 1      the total primary dose
"              = 2      the total dose dose less the total primary dose
"                       (i.e. the scatter fraction for calculating Ascat)
"              = 3      the total primary unattenuated dose less the
"                       total primary dose (for calculating Aatt)
"              = 4      the total primary unattenuated dose with the source
"                       distribution factored out less the total primary
"                       unattenuated dose (for calculating Apn)
"              = 5      the total primary unattenuated dose to the cavity
"                       gas with the source distribution factored out with
"                       the electron tranport taking place in the chamber
"                       with the cavity filled with wall material (for
"                       calculating Afl and the stopping power ratio)
"              = 6      the total primary unattenuated dose to the wall
"                       material with the source distribution factored out with
"                       the electron tranport taking place in the chamber
"                       with the cavity filled with wall material (for
"                       calculating the stopping power ratio)
"
"
;"******************************************************************************
%Q0
SUBROUTINE AUSGAB(IARG);

$IMPLICIT-NONE;

REAL*8 FTMP;
integer*4 ip;

$INTEGER IRL,IX,IZ,IQL,LATCHL,IARG,IDUMMY;
$REAL WTL,FDUMMY,xsi;

;COMIN/
ELECIN,EPCONT,GEOM,MEDIA,PHOTIN,RUSROU,SCORE,SOURCE,STACK,USEFUL,USER,
 RANDOM,BOUNDS/;

"STACK OVERFLOW CHECK"
MXNP=MAX(MXNP,NP);"keep track of how deep stack is"
                  "MXNP is not output but it should be"

IF(IWATCH > 0) [CALL WATCH(IARG,IWATCH); "signal watch routine if active"]

"check if particle is leaving the transport geometry"
IRL=IR(NP);  "local region number"
IF(IRL =  1) RETURN; "outside the chamber"

"OBTAIN FREQUENTLY USED LOCAL VARIABLES"
$GET-IX-IZ(IRL);   "local plane and radius numbers"
IQL=IQ(NP);        "local charge variable"
WTL=WT(NP);        "local weight variable"
LATCHL=LATCH(NP);  "LATCHL=0 for primaries, 1 otherwise"

IF( use_enhance | n_split > 1 ) [
    IF( iarg < 5 ) [
        IF( edep > 0 & wtl > 0 & ntrack(irl) = 1 ) [
            "If we use cross section enhancement or photon splitting,"
            "all energy scoring is done here and the rest of ausgab is ignored"
            "We use the technique proposed by the PENELOPE group for scoring "
            "the energy deposition. This results in a much better estimate   "
            "of the uncertainty                                              "

            ftmp = wtl*edep;
            IF( NHSTRY = last_case ) [
                " Still the same history scoring into the cavity => update    "
                " temporary variables                                         "
                IF( latchl ~= 2 ) tmp_dose = tmp_dose + ftmp;
                IF( latchl ~= 3 ) tmp_dose1 = tmp_dose1 + ftmp;
            ]
            ELSE [
                " A new history scoring into the cavity. "
                last_case = NHSTRY;
                cav_dose = cav_dose + tmp_dose;
                cav2_dose = cav2_dose + tmp_dose*tmp_dose;
                cav_dose1 = cav_dose1 + tmp_dose1;
                cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;
                cav_dosec = cav_dosec + tmp_dose*tmp_dose1;
                IF( latchl ~= 2 ) [ tmp_dose = ftmp; ] ELSE [ tmp_dose = 0; ]
                IF( latchl ~= 3 ) [ tmp_dose1 = ftmp;] ELSE [ tmp_dose1 = 0; ]
            ]
        ]
        return;
    ]
]

IF( use_enhance ) [ "If we use cross section enhancement, all scoring "
                    " is done here and the rest of ausgab is ignored  "

    IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23)
    [
        "A pair/Compton/photoelectric/Rayleigh event is about to take place"
        "As we have increased the photon cross section by a factor of      "
        "cs_enhance, we must split the photon into a scattering portion    "
        "(1/cs_enhance) and a nor-scattering portion (1-1/cs_enhance)      "
        "Start with placing an identical photon on the stack               "
        np = np + 1;
        IF(np + 1 > $MXSTACK) [
            OUTPUT;
            ( ' Calculation with CS-enhancement: unable to boost stack.'/
                ' Stopping.'/ 1x,80('*')/);
            stop;
        ]
        $TRANSFER PROPERTIES TO (np) FROM (np - 1);
        e(np)  =  e(np - 1);
        u(np)  =  u(np - 1);
        v(np)  =  v(np - 1);
        w(np)  =  w(np - 1);
        iq(np) = iq(np - 1);
        IF( latch(np-1)  ~= 2 ) [
          " This is either a primary photon that has not yet been attenuated "
          " away or a scattered photon. Let's decide what to do with the     "
          " unscattered fraction of that photon (which is at np-1)           "
            $RANDOMSET xsi;
            IF( cs_enhance*xsi < 1 ) [  " The photon doesn't survive. "
                IF( latch(np-1) = 3 ) [ " It is a scattered photon => kill it"
                    wt(np-1) = 0; dnear(np-1) = -1;
                ]
                ELSE [ " This is a primary => mark it as attenuated.         "
                       " From now on, all descendents of this photon will    "
                       " only contribute to the cavity dose with attenuation "
                       " and scatter removed                                 "
                    latch(np-1) = 2;
                ]
            ]
        ]
        "Adjust the weight of to be scattered photon"
        wt(np) = wt(np)/cs_enhance;
        return;
    ]

    IF( iarg = 18 | iarg = 20 | iarg = 24 |
         " A Compton/photo-absorption/Rayleigh event just occured"
        iarg = 7 | iarg = 13 | iarg = 14 ) [
         " A bremas/annihilation event just occured"
         " All scattered photons and photons originating in brems/annihilation"
         " events contribute to the scattered dose. But because all of them   "
         " have a small weight (initial weight/cs_enhance), we will play      "
         " Russian Roulette with them, using 1/cs_enhance as a sirvivng       "
         " probability. If they survive, their weight will become equal to the"
         " intial photon weight. In addition, we have to set their latch to 3 "
         " so that they and rheir descendents only contribute to the scattered"
         " dose.                                                              "
        $RANDOMSET xsi; xsi = xsi*cs_enhance;
        DO ip=NPold,NP [
            IF( iq(ip) = 0 ) [
                IF( latch(ip) = 2 ) [ "that's a descendent of a photon that"
                                      "has been attenuated away => kill it"
                    wt(ip) = 0; dnear(ip) = -1;
                ]
                ELSE [
                  IF( e(ip) >= pcut(irl) ) [
                    IF( xsi < 1 ) [ latch(ip) = 3; wt(ip) = wt(ip)*cs_enhance; ]
                    ELSE          [ wt(ip) = 0; dnear(ip) = -1; ]
                  ]
                  ELSE [ latch(ip) = 3; ]
                   " i.e. we don't need the Russian Roulette for photons below"
                   " threshold because they will be discarded and their energy"
                   " deposited locally anyway                                 "
                ]
            ]
        ]
        return;
    ]
    return;
]

IF( n_split > 1 ) [

    IF( iarg = 7 | iarg = 13 | iarg = 14 ) [
        IF( iifano = 1 ) [
            DO ip=NPold,NP [
                IF( iq(ip) = 0 ) [ wt(ip) = 0; e(ip) = 0; ]
            ]
            return;
        ]
        DO ip=NPold,NP [
            IF( iq(ip) = 0 ) [
                $RANDOMSET XSI;
                IF( xsi*n_split > 1) [ wt(ip) = 0; e(ip) = 0; ]
                ELSE [ latch(ip) = 3;  wt(ip) = wt(ip)*n_split; ]
            ]
        ]
        return;
    ]
]

IF(IARG = 0)["ABOUT TO TRANSPORT A PARTICLE"
    IF(IQL.NE.0)[
        IF(LATCHL = 0)[ "COUNT PRIMARY CHARGED PARTICLES ONLY"
                $SCORE(SCSTP, :1);"COUNT CHARGED PARTICLE STEPS TAKEN"
                IF(NTRACK(IRL) = 1)[ $SCORE(SCCSTP, :1);
                       "WRITE(*,*)' sccstp ',SCCSTP;"
                ]
                                             "COUNT STEPS IN CAVITY REGION"
        ]
    ]
    ELSE["PHOTON STEP - PLAY RUSSIAN ROULETTE?"
        IF(RUSROU.AND.(W(NP).GT.0.0))["YES, PLAY IF CROSSES RRZ "
            IF((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))["CROSSES"
                $RANDOMSET XSI;
                    IF(XSI.LT.RRCUT)[
                        "PARTICLE SURVIVES"
                        WT(NP)=WTL/RRCUT;
                        ]
                    ELSE["DISCARD PARTICLE ON NEXT CALL TO HOWFAR"
                        WT(NP)=0.0;
                        ]
                ] "END TEST IF CROSSES RUSSIAN ROULETTE PLANE"
            ] "END TEST FOR PLAYING RUSSIAN ROULETTE"
        ] "END TEST FOR PHOTON STEP"
    ] "END TEST FOR IARG = 0"

IF (ifano = 1)
[
    IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23)
    [
        "A pair/Compton/photoelectric/Rayleigh event is about to take place"
        np = np + 1; "Boost the stack"
        IF(np + 1 > $MXSTACK)
        [
            OUTPUT;
            (
                ' Fano calculation unable to boost stack.'/
                ' Stopping.'/
                1x,80('*')/
            );
            stop;
        ]
        "Create an identical photon"
        $TRANSFER PROPERTIES TO (np) FROM (np - 1);
        e(np)  =  e(np - 1);
        u(np)  =  u(np - 1);
        v(np)  =  v(np - 1);
        w(np)  =  w(np - 1);
        iq(np) = iq(np - 1);
        return;
    ]

    "Throw away any scattered photons from the primary interaction site."
    " Now there is a stack pointer NPold which points to the particle "
    " befor the last discrete interaction. This change was necessary "
    " for the implementation of atomic relaxations. So, check all particles"
    " between NPold and NP and discard photons "
    "IF ( (iarg = 18 & NP > NPold)" " Compton has occured"
    IF (  iarg = 18               " Compton has occured"
        | iarg = 20               " After photo-absorption "
        | iarg = 24               " After Rayleigh "
        | iarg = 7                " After brems "
        | iarg = 13               " After annihilation "
        | iarg = 14)              " After annihilation at rest "
    [
        DO ip=NPold,NP [
            IF( iq(ip) = 0 ) [ wt(ip) = 0; e(ip) = 0; ]
        ]
    ]
]
IF (ifano = 2)
[
    IF (  iarg = 16               " After pair production "
        | iarg = 18               " After Compton "
        | iarg = 20)              " After photo absorption "
    [
       IF ( NTRACK(ir(np)) = 0)
       [
          DO ip=NPold,NP
          [
             IF( iq(ip) ~= 0 ) [ wt(ip) = 0; e(ip) = 0; ]
          ]
        ]
    ]
]
"SCORE THE ENERGY AS REQUIRED FOR THE DIFFERENT MODES"
"****************************************************"

IF((EDEP.NE.0.0).AND.(WTL.GT.0.0).AND.(IARG.LT.5).AND.(NTRACK(IRL).EQ.1))[
    "ENERGY HAS BEEN DEPOSITED IN THE CAVITY REGION"

    "SCORE PRIMARY AND SECONDARY ENERGY DEPOSITED"
    FTMP=WT(NP)*EDEP;

"***************************************************************************"
"                                                                           "
" Implementation of a history by history scoring scheme for the cavity dose "
" taken from Iwan's splitting implementation, EMH, March 2002               "
"                                                                           "
" For the meaning of the variables see the COMIN/SCORE block                "
"                                                                           "
"         expmfp = exp(di) - 1 (see macro $SELECT-PHOTON-MFP)               "
"                                                                           "
"***************************************************************************"
    IF( NHSTRY = last_case ) [
            " Still the same history scoring into the cavity => update    "
            " temporary variables                                         "
            tmp_dose = tmp_dose + ftmp;
            IF( latchl = 0 ) [
              tmp_dose0 = tmp_dose0 + ftmp;
              tmp_dose1 = tmp_dose1 + ftmp*(expmfp+1);
            ]
            ELSE [
              tmp_dose2 = tmp_dose2 + ftmp;
            ]
    ]
    ELSE [
            " A new history scoring into the cavity. "
            last_case = NHSTRY;

            cav_dose  = cav_dose + tmp_dose;
            cav2_dose = cav2_dose + tmp_dose*tmp_dose;

            cav_dose0  = cav_dose0 + tmp_dose0;
            cav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;

            cav_dose1  = cav_dose1 + tmp_dose1;
            cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;

            cav_dose2  = cav_dose2 + tmp_dose2;
            cav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;

            cav_dosec = cav_dosec + tmp_dose*tmp_dose1;
            cav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
            cav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;

            tmp_dose = ftmp;

            IF( latchl = 0 ) [
                tmp_dose0 = ftmp ;
                tmp_dose1 = ftmp*(expmfp+1) ;
                tmp_dose2 = 0.0;
            ]
            ELSE [
                tmp_dose0 = 0.0;
                tmp_dose1 = 0.0;
                tmp_dose2 = ftmp;
            ]
        ]

  IDECAV=1;

  IF(NSUMCV>1)["calculate quantities in individual cavity regions"
               "do it the same as for the overall cavity above"

        IF(NHSTRY=SCDOSE_LAST(IZ,IX))[
             SCDOSE_TMP(IZ,IX,1)=SCDOSE_TMP(IZ,IX,1)+FTMP;
             IF(LATCHL=0)["primary dose"
                SCDOSE_TMP(IZ,IX,2)=SCDOSE_TMP(IZ,IX,2)+FTMP;
                SCDOSE_TMP(IZ,IX,3)=SCDOSE_TMP(IZ,IX,3)+FTMP*(1+EXPMFP);
             ]
             ELSE["secondary dose"
                SCDOSE_TMP(IZ,IX,4)=SCDOSE_TMP(IZ,IX,4)+FTMP;
             ]
        ]
        ELSE[
             SCDOSE_LAST(IZ,IX)=NHSTRY;

             SCDOSE(IZ,IX,1)=SCDOSE(IZ,IX,1)+SCDOSE_TMP(IZ,IX,1);
             SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)+SCDOSE_TMP(IZ,IX,1)*
                                               SCDOSE_TMP(IZ,IX,1);

             SCDOSE(IZ,IX,2)=SCDOSE(IZ,IX,2)+SCDOSE_TMP(IZ,IX,2);
             SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)+SCDOSE_TMP(IZ,IX,2)*
                                               SCDOSE_TMP(IZ,IX,2);

             SCDOSE(IZ,IX,3)=SCDOSE(IZ,IX,3)+SCDOSE_TMP(IZ,IX,3);
             SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)+SCDOSE_TMP(IZ,IX,3)*
                                               SCDOSE_TMP(IZ,IX,3);

             SCDOSE(IZ,IX,4)=SCDOSE(IZ,IX,4)+SCDOSE_TMP(IZ,IX,4);
             SCDOSE2(IZ,IX,4)=SCDOSE2(IZ,IX,4)+SCDOSE_TMP(IZ,IX,4)*
                                               SCDOSE_TMP(IZ,IX,4);

             SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)+SCDOSE_TMP(IZ,IX,1)*
                                                     SCDOSE_TMP(IZ,IX,3);
             SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)+SCDOSE_TMP(IZ,IX,2)*
                                                     SCDOSE_TMP(IZ,IX,3);
             SCDOSE_COV(IZ,IX,3)=SCDOSE_COV(IZ,IX,3)+SCDOSE_TMP(IZ,IX,2)*
                                                     SCDOSE_TMP(IZ,IX,4);

             SCDOSE_TMP(IZ,IX,1)=FTMP;

             IF(LATCHL=0)[
                SCDOSE_TMP(IZ,IX,2)=FTMP;
                SCDOSE_TMP(IZ,IX,3)=FTMP*(1+EXPMFP);
                SCDOSE_TMP(IZ,IX,4)= 0.0;
             ]
             ELSE [
                SCDOSE_TMP(IZ,IX,2)=0.0;
                SCDOSE_TMP(IZ,IX,3)=0.0;
                SCDOSE_TMP(IZ,IX,4)=FTMP;
             ]
        ]

  ]

] "END OF ENERGY DEPOSITED IN THE CAVITY"

"SET FLAG FOR SECONDARY INTERACTIONS"
"***********************************"

IF((IFULL.GT.0).AND.(IARG.GT.5).AND.(LATCHL = 0))
[
"ONLY IF PRIMARY PARTICLES HAVE INTERACTED DISCRETELY                 "
"IF A SECONDARY PARTICLE IS CREATED ON THE SECOND PASS, GIVE IT A ZERO"
"WEIGHT SO THAT HOWFAR WILL DISCARD IT.                               "

    IF( iarg = 7 ) [  "brem has occured"

        IF( iql = 0 ) [ $EXCHANGE-STACK(NP,NP-1); ]
        latch(np-1) = 1; " Flag the photon as a secondary"
        IF( ipass >= 1 ) [ wt(np-1) = 0; ] "To save time in correlation runs"

    ]
    ELSE IF( iarg = 18 ) [ "Compton has occured, with binding effects"
                           "taken into account, 0, 1, or more particles"
                           "may have resulted"

            DO ip=NPold,NP [
                IF( iq(ip) = 0 ) [
                    latch(ip) = 1;
                    IF( ipass >=1 ) [ wt(ip) = 0; ] "To save time"
                ]
            ]
        " NP = NPold means the interactiopn has been rejected and thus "
        " the emerging (unscattered) photon  is still a primary "
    ]
    ELSE IF( iarg = 9 ) [ "Moller has occured. For now there is only"
                          "one secondary. When impact ionization is implemented"
                          "the following should be changed"
        IF( e(np) < e(np-1) ) [ $EXCHANGE-STACK(NP,NP-1); ]
    ]
    ELSE IF( iarg = 13 | iarg = 14 ) ["Annihilation, flag the photons"
        latch(np) = 1;
        latch(np-1) = 1;
        IF( ipass >= 1 ) [ wt(np) = 0; wt(np-1) = 0; ]
    ]
    ELSE IF (iarg = 20)
    [
        DO ip=NPold,NP [
            IF( iq(ip) = 0 )
            [
               latch(ip) = 1;
               IF( ipass >= 1 ) [ wt(ip) = 0; e(ip) = 0; ]
            ]
        ]
    ]
    ELSE IF( iarg = 24 ) [
        latch(np) = 1;
        IF( ipass >= 1 ) [ wt(np) = 0; ]
    ]
]

RETURN;

END;  "END OF SUBROUTINE AUSGAB"
"%U11   PICK UP ENSRC.MOR FROM THE HENHOUSE ON UNIT 11"
%Q1
%C80
%I2
%E     "cavrznrc.mortran"
;"******************************************************************************
"
"                               **********
"                               *        *
"                               * HOWFAR *
"                               *        *
"                               **********
"
"       A GENERAL PURPOSE CYLINDRICAL GEOMETRY ROUTINE FOR USE WITH THE EGS4
"       CODE SYSTEM ADAPTED FOR USE WITH CAVRZnrc.
"
"       FOR PARTICLE NP ON THE STACK IN REGION IR(NP), THIS ROUTINE
"       DETERMINES IF THE PARTICLE CAN GO A DISTANCE USTEP WITHOUT CHANGING
"       ZONES. IF USTEP CAUSES A ZONE CROSSING, IT IS REDUCED TO PLACE IT ON
"       THE BOUNDRY AND IRNEW IS SET TO THE ZONE NUMBER ON THE FAR SIDE OF
"       THE BOUNDARY. IF IR(NP) IS 1 THEN THE PARTICLE HAS ESCAPED THE REGION
"       OF INTEREST AND THE HISTORY IS TERMINATED.(IDISC IS SET TO 1.)
"
"
"
"
"       SOME VARIABLES
"       ==============
;"
"OUTEND =       .TRUE.  =>      PARTICLE MAY TRANSMIT OR BACKSCATTER OUT ENDS
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE END BOUNDARIES
"OUTSID =       .TRUE.  =>      PARTICLE MAY TRANSMIT OUT THE SIDES
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE SIDE BOUNDARY
"IRL    =       STARTING REGION NUMBER THE PARTICLE IS IN
"IZ     =       STARTING PLANAR ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN ZPLANE(IZ) AND ZPLANE(IZ+1).
"IX     =       STARTING CYLINDRICAL ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN RCYL(IX-1) AND RCYL(IX).
"
"       COMMON/GEOM/
"               ZPLANE(IZ)      Z VALUES OF PLANES
"                               1<=IZ<=NZ+1
"               RCYL(IRR)       RADII OF CYLINDERS
"                               1<=IRR<=NR
"               CYRAD2(IRR)     =RCYL(IRR)**2
"               NZ              # PLANAR GEOMETRICAL ZONES (NPLANE-1)
"                               ZONE(I) IS BETWEEN ZPLANE(I) AND ZPLANE(I+1)
"               NR              # CYLINDRICAL GEOMETRICAL ZONES
"                               ZONE(I) IS BETWEEN RCYL(I-1) AND RCYL(I)
"               NREG            TOTAL # GEOMETRICAL ZONES =NR*NZ +1
"                                       +1 FOR VACUUM ENVELOPE
%E     "cavrznrc.mortran"
"       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
"       ===========================================================
"               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
"
"
"                                       1
"
"
"       --------------------------------------------------------- RCYL(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
"       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
"       --------------------------------------------------------- RCYL(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RCYL(2)
"       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
"       --------------------------------------------------------- RCYL(1)
"..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
;"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
"
"                                       1
"
"
"
"       VERSION 1       ADAPTED FROM CAVITY HOWFAR          06/84  ERIC FOX
"       VERSION 2       THE SUBROUTINE CALLS TO PLANES AND  10/87  AFB
"                       CYLINDER HAVE BEEN REPLACED BY MACROS
"                       TO SPEED THINGS UP
"
"
"******************************************************************************
"
;
%E     "cavrznrc.mortran"
"THE MACRO REPLACING THE CALL TO CYLNDR
"*****************************************************************************
"
"                               ***********
"                               *         *
"                               * $CYLNDR *
"                               *         *
"                               ***********
"
"MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
"A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
"OF THE STANDARD NRCC DISTRIBUTION
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT CYLINDERS,
"THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A CYLINDER.
"THE CYLINDERS ARE ASSUMED TO BE ALIGNED AND CENTERED ALONG THE Z-AXIS.
"
"       SOME VARIABLES
"       ==============
"
"{P1} = ICYL  = THE NUMBER OF THE OUTER CYLINDER
"{P2} = IHITC = 1 => PARTICLE HITS THE OUTER SURFACE
"             = 0 => PARTICLE MISSES THE SURFACES
"             =-1 => PARTICLE HITS THE INNER SURFACE
"{P3} = TCYL  = DISTANCE TO SURFACE IF IT HITS
"CYRAD2(ICYL) = RADIUS**2 OF THE OUTER CYLINDER
"
"THIS CODE IS OPTIMIZED FOR SPEED, NOT SIZE.
"
"FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
"FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TCYL=0.
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
"
"
"******************************************************************************
"
REPLACE {$CYLNDR(#,#,#,#);} WITH {
;
U1=U(NP);V1=V(NP);A=U1*U1+V1*V1;
IF(A = 0.0)[{P2}=0;{P3}=1.0E30;]
ELSE[
    X1=X(NP);Y1=Y(NP);B=X1*U1+Y1*V1;B2=B*B;
    C=X1*X1+Y1*Y1;
    COUT=C-CYRAD2({P1});
    IF(COUT.GT.0.0)[
        IF(IWATCH.GT.0)[OUTPUT COUT;(' COUT=',E11.3);]
        COUT=0.0;
    ]
    IF(B.GT.0.0)[{P2}=1;
        IF(COUT/B2.GT.-1.0E-5)[{P3}=-0.5*COUT/B;]
        ELSE[{P3}=-COUT/(SQRT(B2-A*COUT)+B);]
        IF( {P3} <= {P4} ) [
            {P4} = {P3};
            IF( {P1}+1 <= nr ) [ irnew = irl + nz; ] ELSE [ irnew = 1; ]
        ]
    ]
    ELSEIF(B.LT.0.0)[
        {P2}=1;
        IF(COUT/B2.GT.-1.0E-5)[{P3}=-2.*B/A*(1.-0.25*A*COUT/B2);]
        ELSE[{P3}=(SQRT(B2-A*COUT)-B)/A;]
        IF( {P3} <= {P4} ) [
            {P4} = {P3};
            IF( {P1}+1 <= nr ) [ irnew = irl + nz; ] ELSE [ irnew = 1; ]
        ]
        IF({P1}.NE.1)[
            CIN=C-CYRAD2({P1}-1);
            IF(CIN.LT.0.0)[
                IF(IWATCH.GT.0)[OUTPUT CIN;(' CIN=',E11.3);]
                CIN=0.0;
            ]
            RAD=B2-A*CIN;
            IF(RAD.GE.0.0)[
                IF(CIN/B2.LT.1.0E-5)[{P3}=-0.5*CIN/B;]
                ELSE[{P3}=CIN/(SQRT(RAD)-B);]
                IF( {P3} <= {P4} ) [
                    {P4} = {P3}; irnew = irl - nz;
                ]
            ]
        ]
    ]
]
;
}

"THE MACRO REPLACING THE CALL TO PLANES
"******************************************************************************
"
"                               ***********
"                               *         *
"                               * $PLANES *
"                               *         *
"                               ***********
"
"PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
"A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
"OF THE STANDARD NRCC DISTRIBUTION
"
"FOR A PARTICLE TRAVELLING INSIDE TWO PARALLEL, INFINITE PLANES WITH NORMALS
"ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
"IT MUST GO TO HIT ONE OF THE PLANES
"
"       SOME VARIABLES
"       ==============
"
"{P1}           =       THE NUMBER OF THE INNER PLANE (LESSER Z-COORDINATE)
"                       IT MUST BE .GE. 1
"{P2}           =       THE NUMBER OF THE OUTER PLANE (GREATER Z-COORDINATE)
"                       IT MUST BE .GE. 2
"{P3} = IHITP   =       1  => PARTICLE HITS THE OUTER PLANE
"               =       0  => PARTICLE MISSES BOTH PLANES
"               =       -1 => PARTICLE HITS THE INNER PLANE
"{P4} = TPLANE  =       DISTANCE TO THE PLANE THAT IT HITS
"ZPLANE(IPLANE) =       Z-COORDINATE OF THE OUTER PLANE
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
"
"
"******************************************************************************
"
REPLACE {$PLANES(#,#,#,#,#);} WITH {
;
WL=W(NP);
IF (WL.GT.0.0) [
    {P4}=(ZPLANE({P2})-Z(NP))/WL;
    IF( {P4} <= {P5} ) [
      {P5} = {P4};
      IF( {P1}+1 <= nz ) [ irnew = irl + 1; ] ELSE [ irnew = 1; ]
    ]
]
ELSEIF (WL.LT.0.0) [
    {P4}=(ZPLANE({P1})-Z(NP))/WL;
    IF( {P4} <= {P5} ) [
      {P5} = {P4};
      IF( {P1}-1 >= 1 ) [ irnew = irl - 1; ] ELSE [ irnew = 1; ]
    ]
]
;
}

"******************************************************************************
"
"The following is the $CALL-HOWNEAR macro for PRESTA-II

REPLACE {$CALL-HOWNEAR(#);} WITH {
    ;
    "write(6,'(2i3,4e15.8)') np,ir(np),dnear(np), "
    "   sqrt(x(np)*x(np)+y(np)*y(np)),z(np),tustep; "
    IF( dnear(np) < tustep ) [
        call hownear({P1},x(np),y(np),z(np),ir(np));
        " write(6,*) ' --> new dnear: ',{P1}; "
    ]
    ELSE [ {P1} = dnear(np); ]
}

subroutine hownear(tperp,x,y,z,ir);

$IMPLICIT-NONE;

COMIN/GEOM,SCORE/;   "SCORE needed for IHSTRY'

"Subroutine arguments
$REAL
    tperp, "nearest distance to any boundary (output)
    tustep,
    x,     "x-position of the particle (input)
    y,     "y-position of the particle (input)
    z;     "z-position of the particle (input)
;
$INTEGER
    ir     "region number of the particle
;

"Local variables

$REAL r;

$INTEGER
    ix, "current cylindrical radius number
    iz  "current planar slab number
;
ix = (ir - 2)/nz + 1;
iz = ir - 1 - nz*(ix - 1);
r = sqrt(x*x + y*y);
tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r);
IF(ix ~= 1) [ tperp = min(tperp,r - rcyl(ix - 1)); ]

"IF( tperp < -1e-6 ) [
"  OUTPUT IHSTRY, tperp; (/' Error in HOWNEAR: IHSTRY=',I12,
"                      '  tperp negative =',1PE10.3);
"  OUTPUT ir,x,y,z,r; (' ir x y z r=', I5, 4F15.7);
"  OUTPUT iz,ix;(' depth,radial regions iz,ix=',2I10);
"  OUTPUT zplane(iz),zplane(iz+1);( ' upper/lower z planes=',2F15.7);
"  IF( ix > 1) [
"    OUTPUT rcyl(ix-1),rcyl(ix); (' Radial boundaries=',2F15.7);
"  ]
"  ELSE [
"    OUTPUT rcyl(ix); (' Radial boundary of 1st region =', F15.7);
"  ]
"]

return;
end;

%E     "cavrznrc.mortran"
%Q0
SUBROUTINE HOWFAR;

$IMPLICIT-NONE;

;
"MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
REPLACE {$SET NEW REGION(#,#);} WITH
{
;
IF({P1}.LE.USTEP)[USTEP={P1};IRNEW={P2};]RETURN;}

"Debug macro, usually not used, to verify that region is correct on entry"
"    It must be used after IX and IZ have been determined"
"    REAL Rdebug must be declared"

REPLACE {$Check_region;} WITH {

Rdebug = SQRT(X(NP)**2 + Y(NP)**2);
IF(IX = 1)["we are in inner radial region"
   IF(Rdebug > (RCYL(IX)+1.E-6) | (Z(NP) < ZPLANE(IZ) & Z(NP) > ZPLANE(IZ+1)))[
      OUTPUT IRL, IX, IZ, X(NP), Y(NP), Z(NP), Rdebug, RCYL(IX),
             ZPLANE(IZ),ZPLANE(IZ+1);
      (/' Error in HOWFAR, particle in wrong region'/
       '      IRL, IX,IZ =', 3I7/
       '      X,Y,Z,R=', 4F15.7/
       '      RCYL(1)=', F15.7/
       '      ZPLANE(IZ),ZPLANE(IZ+1)=', 2F15.7);
   ]
]"end of IX=1 block"

ELSE [
   IF((Rdebug > (RCYL(IX)+1E-6) & Rdebug < (RCYL(IX-1) -1.E-6)) |
                   (Z(NP) < ZPLANE(IZ) & Z(NP) > ZPLANE(IZ+1)))[
      OUTPUT IRL, IX, IZ, X(NP), Y(NP), Z(NP), Rdebug, RCYL(IX-1), RCYL(IX),
             ZPLANE(IZ),ZPLANE(IZ+1);
      (/' Error in HOWFAR, particle in wrong region'/
       '      IRL, IX,IZ =', 3I7/
       '      X,Y,Z,R=', 4F15.7/
       '      RCYL(IX-1), RCYL(IX)=', 2F15.7/
       '      ZPLANE(IZ),ZPLANE(IZ+1)=', 2F15.7);
   ]
]
;}


;COMIN/EPCONT,STACK,GEOM,SCORE,MISC",MULTS"/;
" PRESTA-II eliminated COMIN/MULTS"

LOGICAL OUTEND,OUTSID;

$INTEGER IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW;
$REAL WL,TPLANE,U1,V1,A,TCYL,X1,Y1,B,B2,C,COUT,CIN,RAD;
"$REAL Rdebug; " "Uncomment if using $Check_region;"

"First set idisc and irnew "
idisc = 0; irnew = ir(np);

"DISCARD ZERO WEIGHT PARTICLES"
IF(WT(NP) = 0.0)[IDISC=1;RETURN;]

OUTEND=.FALSE.;OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"
IRL=IR(NP); "LOCAL REGION NUMBER"

"DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY"
IF(IRL = 1)[IDISC=1;RETURN;]

$GET-IX-IZ(IRL); "GET PLANAR AND CYLINDRICAL ZONES NUMBERS"

"Following commented out usually"
"$Check_region;"

"write(6,*);"
"write(6,*) 'howfar: ',ix,iz,ustep,nz,nr;"
$PLANES(IZ,IZ+1,IHITP,TPLANE,ustep);"GET DISTANCE TO PLANE"
        "IHITP  =  1 => HITS GREATER Z PLANE"
        "       =  0 => MISSES BOTH PLANES"
        "       = -1 => HITS LESSER Z PLANE"

$CYLNDR(IX,IHITC,TCYL,ustep);"GET DISTANCE TO CYLINDER"
"       IHITC   =  1 => HITS OUTER CYLINDER"
"               =  0 => MISSES BOTH CYLINDERS"
"               = -1 => HITS INNER CYLINDER"

return; end; "END OF SUBROUTINE HOWFAR"

%I4
%C80
%Q1
%E     "cavrznrc.mortran"
"******************************************************************************
"
"
"                               **********
"                               *        *
"                               * INPUTS *
"                               *        *
"                               **********
"
"
"       AN INPUT FILE USED WITH CAVRZnrc. THE INPUTS ARE DEFINED AS THEY ARE
"       INPUT. CONSIDERABLE DEFAULTING AND ERROR CHECKING IS DONE.
"
"       VERSION 1       AFB    10/87            ADAPTED FROM CAVITY(EGS3)
"       VERSION 2       A.M.   04/98            New input routine (get_inputs)
;
"******************************************************************************
"
SUBROUTINE INPUTS;

$IMPLICIT-NONE;

;COMIN/BOUNDS,
CHARS,EDGE,ELECIN,GEOM,IODAT1,IODAT2,MEDIA,MISC,
RUSROU,SCORE,SOURCE,SPECTR,USEFUL,USER,RANDOM,GetInput,
COMPTON-DATA,ET-Control,EGS-VARIANCE-REDUCTION,PRINTC,EGS-IO/;

"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
"REPLACE {$NMAX} WITH {120}"
"REPLACE {$NVALUE} WITH {120}"
REPLACE {$GET_INPUT(#);} WITH  "Used to get only one input"
{
"{P1}=Array index of the value_sought"
NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT;
}
;
REPLACE {$GET_INPUTS(#,#);} WITH  "Used to get many inputs"
{
NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT;
}
;
"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"
INTEGER INEXT;

INTEGER ITERSE;

REAL CAVRAD, ELERAD, CAVLNG, WALLTH;                "Cavity input"

INTEGER IZ;                         "transport control"
INTEGER IFARCE;                                     "transport control"

"INTEGER MONOEN;"

INTEGER I, J, SLENGHT;

$INTEGER ISSAME,IT,IX,LNBLNK1,IRL;

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
INTEGER NUM_TITLE,

"I/O Contol"
        NUM_IWATCH,
        NUM_STRAND,
        NUM_IRESTART,
        NUM_OUTOPTS,
        NUM_STORE,

"M-C Input"
        NUM_HIST,
        NUM_MXTIME,
        NUM_IFULL,
        NUM_STATLM,
        NUM_IFANO,

"Cavity inputs"
        NUM_ITERSE,
        NUM_WALLTH,
        NUM_CAVRAD,
        NUM_CAVLNG,
        NUM_ELERAD,
        NUM_WALMAT,
        NUM_ELEMAT,
        NUM_NCAVREG,
        NUM_RNUMCAV,

"Tranport Control"
        NUM_IREJCT,
        NUM_ESAVEIN,
        NUM_RUSROU,
        NUM_RUSFRAC,
        NUM_XTRANSF,
        NUM_FORCE,
        NUM_STRTFRC,
        NUM_STPFRC,
        num_cs_enhance;

$INTEGER my_unit, egs_open_datfile;

"---------------------------------------------------------------------------"
IVAL=0;  "number of the value_sought"

ERROR_FLAG=0;   "Initialization of bad input flag"
DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"

OUTPUT $MAXRADII,$MAXZPLANE;
(// T20,'MAXIMUM NUMBER OF RADIAL AND DEPTH ZONES=',2I4);

"*********************************************************"
"* set up the values_sought(i) and echo inputs to screen *"
"*********************************************************"
"*********"
"* TITLE *"
"*********"
IVAL=IVAL+1;
NUM_TITLE=IVAL;
VALUES_SOUGHT(IVAL)='TITLE';
TYPE(IVAL)=2;
NVALUE(IVAL)=1;

DELIMETER='NONE';
$GET_INPUT(NUM_TITLE);

$SKIP-LINE;$SKIP-LINE;
OUTPUT;(' *** INPUT CARD I01 ***');
READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
WRITE (*,:FMT:) (TITLE(I),I=1,79);
:FMT: FORMAT ('TITLE: ',79A1);
$SKIP-LINE;

"************************"
"* INPUT/OUTPUT CONTROL *"
"************************"
IVAL=IVAL+1;
NUM_IWATCH=IVAL;
VALUES_SOUGHT(IVAL)='IWATCH';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='INTERACTIONS';
ALLOWED_INPUTS(IVAL,2)='STEPS';
ALLOWED_INPUTS(IVAL,3)='DEPOSITED';
ALLOWED_INPUTS(IVAL,4)='GRAPH';

IVAL=IVAL+1;
NUM_STRAND=IVAL;
VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='LAST';
ALLOWED_INPUTS(IVAL,2)='ALL DEPOSITED';
ALLOWED_INPUTS(IVAL,3)='ALL';

IVAL=IVAL+1;
NUM_IRESTART=IVAL;
VALUES_SOUGHT(IVAL)='IRESTART';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='FIRST';
ALLOWED_INPUTS(IVAL,1)='RESTART';
ALLOWED_INPUTS(IVAL,3)='ANALYZE';
ALLOWED_INPUTS(IVAL,4)='START-RNS';
ALLOWED_INPUTS(IVAL,5)='PARALLEL';       " ADDED BY JT, DEC.98 "

IVAL=IVAL+1;
NUM_OUTOPTS=IVAL;
VALUES_SOUGHT(IVAL)='OUTPUT OPTIONS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='SHORT';
ALLOWED_INPUTS(IVAL,1)='CAVITY DETAILS';

IVAL=IVAL+1;
NUM_STORE=IVAL;
VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='YES';
ALLOWED_INPUTS(IVAL,1)='NO';

DELIMETER='I/O CONTROL';
$GET_INPUTS(NUM_IWATCH,NUM_STORE);

OUTPUT;(' *** INPUT CARD IO2 ***');
IWATCH=VALUE(NUM_IWATCH,1);
ISTORE=VALUE(NUM_STRAND,1);
IRESTART=VALUE(NUM_IRESTART,1);
IOOPTN=VALUE(NUM_OUTOPTS,1);
IDAT=VALUE(NUM_STORE,1);
OUTPUT IWATCH,ISTORE,IRESTART,IOOPTN,IDAT;
    (/' Do not track(0) or track(>0) every interaction:',T60,I12/
    ' Do not store(0) or store(1,2,3) initial random #:',T60,I12/
    ' First run(0),restarted(1),analyze(3),read RNS(4),'/
    '    parallel(5):',T60,I12/
    ' Output option: cavity summary(0) plus region detail(1):',T60,I12/
    ' Store raw data(0) or not(1):',T60,I12/);

$SKIP-LINE;

IF(IDAT.EQ.1)[INEXT=0;]ELSE[INEXT=1;]
IF(IRESTART = 4) [
    IDAT=1;   "do not store output in this case to avoid biasing"
    ISTORE=0; "do not store the starting random numbers either"
]

"                       MONTE CARLO CONTROL INPUT
"                       *************************
IVAL=IVAL+1;
NUM_HIST=IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=1;
VALUE_MAX(IVAL)=4.611686e18;
DEFAULT(IVAL)=20000;

IVAL=IVAL+1;
NUM_MXTIME=IVAL;
VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=1000;
DEFAULT(IVAL)=999.;

IVAL=IVAL+1;
NUM_IFULL=IVAL;
VALUES_SOUGHT(IVAL)='IFULL';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='DOSE AND STOPPERS';
ALLOWED_INPUTS(IVAL,1)='AATT AND ASCAT';

IVAL=IVAL+1;
NUM_STATLM=IVAL;
VALUES_SOUGHT(IVAL)='STATISTICAL ACCURACY SOUGHT';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0;
VALUE_MAX(IVAL)=100.0;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_IFANO=IVAL;
VALUES_SOUGHT(IVAL)='PHOTON REGENERATION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='YES';
ALLOWED_INPUTS(IVAL,2)='NO ELECTRONS FROM WALL';

DELIMETER='MONTE CARLO INPUTS';
$GET_INPUTS(NUM_HIST,NUM_IFANO);


"************"
"* CARD MC1 *"
"************"
OUTPUT;(/,' *** INPUT CARD MC1 ***');
NCASE=VALUE(NUM_HIST,1);
TIMMAX=VALUE(NUM_MXTIME,1);
IFULL=VALUE(NUM_IFULL,1);
STATLM=VALUE(NUM_STATLM,1);
ifano=VALUE(NUM_IFANO,1);

IF(IWATCH=0 & NCASE < $NCASEMIN)[NCASE=$NCASEMIN;]

"Random number initializations"
$RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',jrng1,jrng2);
IF( i_parallel > 0 ) jrng2 = jrng2 - 1 + i_parallel;
$INITIALIZE RNG USING jrng1 AND jrng2;

OUTPUT NCASE,jrng1,jrng2,TIMMAX,IFULL,STATLM,ifano;
    (/' # OF HISTORIES:',T60,I12/
     $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
    ' MAXIMUM CPU TIME ALLOWED:',T60,F10.2,'HRS'/
    ' SCORING OPTION IFULL (0,1):',T60,I12/
    ' STATISTICAL ACCURACY DESIRED:',T60,F10.1,'%'/
    ' REGENERATION OPTION IFANO (0,1,2):',T60,I12);

IF( ifano = 1 ) [  "With ifano option turned on, it is a waste of time to"
                   "have RAYLEIGH turned on (scattered photon will be killed,"
                   "original photon re-created) => turn Rayleigh off"
    DO j=1,$MXREG [ iraylr(j) = 0; ]
    OUTPUT; (//' ******** ifano set => turning off Rayleigh! **** '//);
]

IF (ERROR_FLAG=1) [GOTO :FINISHED:;]

"                CYLINDRICAL GEOMETRY AND MATERIAL INPUT
"                ***************************************
IVAL=IVAL+1;
NUM_ITERSE=IVAL;
VALUES_SOUGHT(IVAL)='METHOD OF INPUT';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='GROUPS';
ALLOWED_INPUTS(IVAL,1)='INDIVIDUAL';
ALLOWED_INPUTS(IVAL,2)='CAVITY INFORMATION';
DELIMETER='GEOMETRICAL INPUTS';
$GET_INPUT(NUM_ITERSE);  "get the value for ITERSE"
ITERSE=VALUE(IVAL,1);

IF (ITERSE~=2) [
   "EXECUTED FROM SUBROUTINE GEOMRZ(ERROR_FLAG)"
   CALL GEOMRZ;
   IF(NMED>$MXMED)[
      OUTPUT $MXMED;(//' *****************ERROR******************'/
                    ' No. of media > max. no. of media allowed (',I4,')'/
                    ' Increase $MXMED in srcrznrc.mortran, recompile'/
                    ' and try again.'//);
      ERROR_FLAG=1;
   ]
   IF (ERROR_FLAG=1) [
      WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMRZ************';
      GOTO :FINISHED:;
   ]
]

"                            CAVITY INPUTS
"                            *************

IF (ITERSE = 2) [
   IVAL=IVAL+1;
   NUM_WALLTH=IVAL;
   VALUES_SOUGHT(IVAL)='WALL THICKNESS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=1.e-10;
   VALUE_MAX(IVAL)=999999;
   DEFAULT(IVAL)=0.273;

   IVAL=IVAL+1;
   NUM_CAVRAD=IVAL;
   VALUES_SOUGHT(IVAL)='CAVITY RADIUS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=1.e-10;
   VALUE_MAX(IVAL)=999999;
   DEFAULT(IVAL)=1.0;

   IVAL=IVAL+1;
   NUM_CAVLNG=IVAL;
   VALUES_SOUGHT(IVAL)='CAVITY LENGTH';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=1.e-10;
   VALUE_MAX(IVAL)=999999;
   DEFAULT(IVAL)=0.2;

   IVAL=IVAL+1;
   NUM_ELERAD=IVAL;
   VALUES_SOUGHT(IVAL)='ELECTRODE RADIUS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=0.0;
   VALUE_MAX(IVAL)=999999;
   DEFAULT(IVAL)=0.0;
   IVAL=IVAL+1;
   NUM_WALMAT=IVAL;
   VALUES_SOUGHT(IVAL)='WALL MATERIAL';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=2;

   DELIMETER='CAVITY INPUTS';
   $GET_INPUTS(NUM_WALLTH,NUM_WALMAT);

   WALLTH=VALUE(NUM_WALLTH,1);
   CAVRAD=VALUE(NUM_CAVRAD,1);
   CAVLNG=VALUE(NUM_CAVLNG,1);
   ELERAD=VALUE(NUM_ELERAD,1);
   SLENGHT=LNBLNK1(CHAR_VALUE(NUM_WALMAT,1));
   READ (CHAR_VALUE(NUM_WALMAT,1),FMT='(24A1)')
        (MEDIA(J,1),J=1,SLENGHT);
   DO J=SLENGHT+1, 24 [MEDIA(J,1)=' ';]

   IF (ELERAD=0.0) [ "ITERSE=0 AND NO ELECTRODE"
      "***************"
      "* CARD CAV1-A *"
      "***************"
      OUTPUT;(' *** INPUT CARD CAV1-A ***');
      OUTPUT WALLTH,(MEDIA(J,1),J=1,24),CAVRAD,CAVLNG;
      (' WALL THICKNESS',T60,F10.4,' cms'/
       ' WALL MATERIAL',T64,24A1/
       ' GAS CAVITY RADIUS',T60,F10.4,' cms'/
       ' GAS CAVITY LENGTH',T60,F10.4,' cms'/);

       "SECOND MATERIAL IS GAS (AIR)"
      MEDIA(1,2)='A';MEDIA(2,2)='I';MEDIA(3,2)='R';
      DO J=4,24 [MEDIA(J,2)=' ';]

      "FILL THE GEOMETRY WITH THE MATERIALS"
      NMED=2; "TWO MEDIA"
      MED(1)=0; "VACUUM ENVELOPE"
      MED(3)=2; "THE GAS CAVITY"
      MED(2)=1; DO J=4,6 [MED(J)=1]; "THE WALLS"

      "DEFINE THE RADII OF THE GEOMETRY"
      NR=2; "TWO RADII"
      RCYL(1)=CAVRAD; "FIRST IS THE CAVITY RADIUS"
      RCYL(2)=CAVRAD+WALLTH; "SECOND IS THE CHAMBER RADIUS"
      DO J=1,2 [CYRAD2(J)=RCYL(J)**2;];

      "DEFINE THE PLANES OF THE GEOMETRY"
      NZ=3;NPLANE=4; "THREE PLANAR ZONES, FOUR DEFINING PLANES"
      ZPLANE(1)=0.; "FIRST PLANE AT 0"
      ZPLANE(2)=WALLTH;
      ZPLANE(3)=WALLTH+CAVLNG;
      ZPLANE(4)=2.*WALLTH+CAVLNG;
      NREG=NR*NZ+1; "TOTAL NUMBER OF GEOMETRICAL REGIONS"

      "DEFINE THE CAVITY REGION"
      NSUMCV=1; ISUMCV(1)=3; DO I=2,NREG [ISUMCV(I)=0;]
   ]
   ELSE [ "ITERSE=0 AND WITH AN ELECTRODE"
      "***************"
      "* CARD CAV1-B *"
      "***************"
      OUTPUT;(' *** INPUT CARD CAV1-B ***');

      "READ IN THE ELECTRODE MATERIAL"
      IVAL=IVAL+1;
     NUM_ELEMAT=IVAL;
      VALUES_SOUGHT(IVAL)='ELECTRODE MATERIAL';
      NVALUE(IVAL)=1;
      TYPE(IVAL)=2;
      DELIMETER='CAVITY INPUTS';
      $GET_INPUT(NUM_ELEMAT);
      SLENGHT=LNBLNK1(CHAR_VALUE(NUM_ELEMAT,1));
      READ (CHAR_VALUE(NUM_ELEMAT,1),FMT='(24A1)')
           (MEDIA(J,3),J=1,SLENGHT);
      DO J=SLENGHT+1, 24 [MEDIA(J,3)=' ';]

      OUTPUT WALLTH,(MEDIA(J,1),J=1,24),CAVRAD,CAVLNG,ELERAD,
                    (MEDIA(J,3),J=1,24);
        (' WALL THICKNESS',T60,F10.4,' cms'/
        ' WALL MATERIAL',T64,24A1/
        ' GAS CAVITY RADIUS',T60,F10.4,' cms'/
        ' GAS CAVITY LENGTH',T60,F10.4,' cms'/
        ' ELECTRODE RADIUS',T60,F10.4,' cms'/
        ' ELECTRODE MATERIAL',T64,24A1/);

      "SECOND MATERIAL IS GAS"
      MEDIA(1,2)='A';MEDIA(2,2)='I';MEDIA(3,2)='R';
      DO J=4,24 [MEDIA(J,2)=' ';]

      "FILL THE GEOMETRY WITH THE MATERIALS"
      MED(1)=0; "VACUUM ENVELOPE"

      "CHECK ALL THE CHARACTERS TO SEE IF THE WALL MATERIAL"
      "AND THE ELECTRODE MATERIAL ARE THE SAME"
      J=0; ISSAME=0;
      LOOP[
         J=J+1;
         IF(MEDIA(J,1).NE.MEDIA(J,3)) [ISSAME=1;EXIT;]
      ] WHILE(J.LT.24);

      IF (ISSAME = 0) [ "WALL AND ELECTRODE ARE THE SAME MATERIAL"
         NMED=2;
         MED(3)=1; "THE ELECTRODE"
         MED(6)=2; "THE GAS CAVITY"
         MED(5)=1; DO J=7,10 [MED(J)=1;] "THE WALLS"
      ]
      ELSE [ "WALL AND ELECTRODE HAVE DIFFERENT MATERIALS"
         NMED=3;
         MED(3)=3; "THE ELECTRODE"
         MED(6)=2; "THE GAS CAVITY"
         MED(5)=1;DO J=7,10[MED(J)=1]; "THE WALLS"
      ]
      "DEFINE THE CAVITY REGION"
      NSUMCV=1; ISUMCV(1)=6; DO J=2, NREG [ISUMCV(J)=0;]

      "DEFINE THE RADII OF THE GEOMETRY"
      NR=3; "THREE RADII"
      RCYL(1)=ELERAD; "FIRST IS THE ELECTRODE RADIUS"
      RCYL(2)=CAVRAD; "SECOND IS THE OUTER CAVITY RADIUS"
      RCYL(3)=CAVRAD+WALLTH; "LAST IS THE CHAMBER RADIUS"
      DO J=1,3 [CYRAD2(J)=RCYL(J)**2;];

      "DEFINE THE PLANES OF THE GEOMETRY"
      NZ=3;NPLANE=4; "THREE PLANAR ZONES, FOUR DEFINING PLANES"
      ZPLANE(1)=0.; "FIRST PLANE AT 0"
      ZPLANE(2)=WALLTH;
      ZPLANE(3)=WALLTH+CAVLNG;
      ZPLANE(4)=2.*WALLTH+CAVLNG;
      NREG=NR*NZ+1; "TOTAL NUMBER OF GEOMETRICAL REGIONS"
   ]
   IF(NMED>$MXMED)[
      OUTPUT $MXMED;(//' *****************ERROR******************'/
                    ' No. of media > max. no. of media allowed (',I4,')'/
                    ' Increase $MXMED in srcrznrc.mortran, recompile'/
                    ' and try again.'//);
      ERROR_FLAG=1;
      GOTO :FINISHED:;
   ]
]

IF ( (ITERSE = 0) | (ITERSE = 1) ) [
   OUTPUT;(' *** INPUT CARD CAV1-C ***');
   DELIMETER='CAVITY INPUTS';

   IVAL=IVAL+1;
   NUM_NCAVREG=IVAL;
   VALUES_SOUGHT(IVAL)='NUMBER OF CAVITY REGIONS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NREG-1;
   DEFAULT(IVAL)=1;
   $GET_INPUT(NUM_NCAVREG);

   IVAL=IVAL+1;
   NUM_RNUMCAV=IVAL;
   VALUES_SOUGHT(IVAL)='REGION NUMBERS OF THE CAVITY';
   NVALUE(IVAL)=VALUE(NUM_NCAVREG,1);
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=2;
   VALUE_MAX(IVAL)=NREG;
   DEFAULT(IVAL)=NREG;
   $GET_INPUT(NUM_RNUMCAV);

   "***************"
   "* CARD CAV1-C *"
   "***************"
   NSUMCV=VALUE(NUM_NCAVREG,1);
   DO J=1, NSUMCV [ISUMCV(J)=VALUE(NUM_RNUMCAV,J);]
   IF (NSUMCV=NREG-1) [ "WHOLE GEOMETRY IS A CAVITY ZONE, SCORE EVERYWHERE"
      DO J=2,NREG [ISUMCV(J-1)=J;]
   ]
   IF(NSUMCV=1) [
        OUTPUT ISUMCV(1);
        (' THE CAVITY ZONE REGION NUMBER IS: ',I4);
   ]
   ELSE [
        OUTPUT NSUMCV,(ISUMCV(I),I=1,NSUMCV);
        (' THE ',I4,' CAVITY ZONES ARE: ',/' ',19I4);
   ]
]

"SET THE GEOMETRY FLAG FOR THE CAVITY"
DO J=1,NREG [NTRACK(J)=0;]  "ASSUME IT IS NON-CAVITY EVERYWHERE"


"SET THE CAVITY FLAG FOR THE CAVITY REGIONS"
DO J=1, NSUMCV [NTRACK(ISUMCV(J))=1;]


"                       SOURCE CONFIGURATION INPUT
"                       **************************
"************"
"* CARD SC1 *"
"************"
"EXECUTED FROM SUBROUTINE SRCRZ(ERROR_FLAG)"
CALL SRCRZ;  "Get source data"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************';
   GOTO :FINISHED:;
]
"the call to srcrz reads the data into svtmp's (source commonblock) "
"the call to srcini will do the actual initialization               "
"based on the numbers in svtmp (transferred as parameters to srcini)"
"following line is to comply with g77 compiler                      "
"call of an entry in a subroutine was not allowed by g77            "
"see also the few changes in SRCRZ                                  "
"Jan S. Oct 2, 1996                                                 "
CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0);


"************           ***********************
"* CARD TC1 *"
"************"
"EXECUTED FROM SUBROUTINE ENSRC(ERROR_FLAG)"
IF (ISOURC=21.OR.ISOURC=22.OR.ISOURC=23) [MONOEN=0;]
             "no need to input monoen for source 21,22"
ELSE [CALL ENSRC;] "Get data re-source energies"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
   GOTO :FINISHED:;
]

$SKIP-LINE;

call get_transport_parameter(6); " This will scan the input file for
                                 " transport parameter input and then
                                 " output all settings to unit 6

"*************************************************************************"
"                variance reduction section                               "
"*************************************************************************"



IVAL=IVAL+1;
NUM_IREJCT=IVAL;
VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_ESAVEIN=IVAL;
VALUES_SOUGHT(IVAL)='ESAVEIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

ival = ival + 1;
num_cs_enhance = ival;
values_sought(ival) = 'CS ENHANCEMENT FACTOR';
nvalue(ival) = 1;
type(ival) = 1;
value_min(ival) = 0;
value_max(ival) = 1e6;
default(ival) = 0.5;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_IREJCT,num_cs_enhance);

"************"
"* CARD TC2 *"
"************"
OUTPUT;(' *** INPUT CARD TC2 ***');
IREJCT=VALUE(NUM_IREJCT,1);
ESAVEIN=VALUE(NUM_ESAVEIN,1);
cs_enhance = value(num_cs_enhance,1);
IF( cs_enhance > 1 ) [ use_enhance = .true.; ]
ELSE [ use_enhance = .false.; ]

OUTPUT IREJCT; ( / ' Range rejection is On(1) or Off(0):',T60,I12);
IF(IREJCT > 0) [
    OUTPUT ESAVEIN;
    (' ESAVEIN cutoff value(total) for range rejection:', T60,F10.4,' MeV'/);
   IF (ESAVEIN = 0.0 ) [
     OUTPUT;(/'**********************************************************'/
              '   Have asked for range rejection but left ESAVEIN=0.0    '/
              '        There will be no range rejection'/
              '**********************************************************'/);
   ]
   DO i=1,NREG [i_do_rr(i) = 1; e_max_rr(i) = ESAVEIN;]
   "note  e_max_r is total energy"
   "above two arrays needed for each region for EGSnrc RANGE-DISCARD macro"
]

IVAL=IVAL+1;
NUM_RUSROU=IVAL;
VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e30;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_RUSFRAC=IVAL;
VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e30;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_XTRANSF=IVAL;
VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e30;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_RUSROU,NUM_XTRANSF);

"*************"
"* CARD TC2C *"
"*************"
OUTPUT;(' *** INPUT CARD TC2C ***');
RRZ=VALUE(NUM_RUSROU,1);
RRCUT=VALUE(NUM_RUSFRAC,1);
CEXPTR=VALUE(NUM_XTRANSF,1);
RUSROU=.FALSE.;IF(RRZ+RRCUT.NE.0.0)RUSROU=.TRUE.;
IF(RUSROU)[
    OUTPUT RRZ,RRCUT;
    (/' RUSSIAN ROULETTE WILL BE PLAYED'/
    ' RUSSIAN ROULETTE PLANE:',T30,E14.7/
    ' SURVIVAL PROBABILITY:',T30,E14.7/)
]
ELSE [OUTPUT;(' RUSSIAN ROULETTE WILL NOT BE PLAYED'/);]
IF (CEXPTR = 0) [OUTPUT;(' NO PATHLENGTH BIASING TO BE DONE'/);]
ELSE [OUTPUT CEXPTR;(' CEXPTR PARAMATER:',T30,E14.7/);]

IVAL=IVAL+1;
NUM_FORCE=IVAL;
VALUES_SOUGHT(IVAL)='PHOTON FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
DEFAULT(IVAL)=0;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';
IVAL=IVAL+1;
NUM_STRTFRC=IVAL;
VALUES_SOUGHT(IVAL)='START FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

IVAL=IVAL+1;
NUM_STPFRC=IVAL;
VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(NUM_STPFRC)=0;
VALUE_MAX(NUM_STPFRC)=NREG+1;
DEFAULT(NUM_STPFRC)=1;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_FORCE,NUM_STPFRC);

"************"
"* CARD TC3 *"
"************"
OUTPUT;(' *** INPUT CARD TC3 ***');
IFARCE=VALUE(NUM_FORCE,1);
NFMIN=VALUE(NUM_STRTFRC,1);
NFMAX=VALUE(NUM_STPFRC,1);
IF (IFARCE=0) [
      IFORCE=0;NFMIN=0;NFMAX=0;
      OUTPUT;(' NO INTERACTION FORCING IS IN EFFECT'/);
]
ELSEIF (IFARCE=1) [
    IFORCE=1;
    IF (NFMAX.LT.NFMIN) NFMAX=NFMIN;
    OUTPUT NFMIN,NFMAX;
    (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
    ' # INTERACTIONS'/);
]
IQINC=IQIN; "NEEDED TO TURN OFF FASTSTEP FOR INCIDENT ELECTRONS"
            "WHEN FORCING INTERACTIONS"
$SKIP-LINE;

IVAL=IVAL+1;
VALUES_SOUGHT(IVAL)='PHOTON SPLITTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(ival)=1;
VALUE_MAX(ival)=$MXSTACK-2;
DEFAULT(ival)=1;
$GET_INPUT(ival);
IF( error_flags(ival) = 0 ) [

    n_split = value(ival,1);
    IF( n_split > 1 ) [
        IF( ifull > 1 ) [
            OUTPUT;
            (//' ******** Photon splitting only for ifull = 0,1! ******'//);
            n_split = 1;
        ]
        ELSE [
            OUTPUT n_split;
            (//' ****** Calculation with photon splitting ********** '/
             '   n_split = ',i4//);
            iifano = ifano;
        ]
    ]
]

IF( use_enhance ) [
    OUTPUT cs_enhance;
    (//' ************** Calculation with CS enhancement *******************'/,
       '    photon forcing, exp. transform, etc. input will be ignored! '/,
       '    IFULL will be set to 1! (i.e. Ascat and Aatt) '//,
       '    Using cs_enhance = ',f10.4,/
     ' ******************************************************************'///);
    ifull = 1; IFORCE=0;NFMIN=0;NFMAX=0; n_split = 1;
]

"if we are calculating Aatt and Ascatt, we must have n_split>1,"
"cs_enhance on, or photon forcing on"
IF(IFULL=1 & cs_enhance<=1 & IFORCE=0 & n_split <=1)[
  IFORCE=1;
  NFMIN=1;
  NFMAX=1;
  OUTPUT;
  (//' *****WARNING*******'/
     ' If you are calculating Aatt, Ascat (IFULL=1), you must be using'/
     ' photon forcing, photon splitting, or cross-section enhancement.'/
     ' Currently, none of these are being used.  Will continue run with'/
     ' photon forcing on and one interaction forced (NFMIN=NFMAX=1).'//);
  WRITE(IOUT,100);
100 FORMAT(//' *****WARNING*******'/
     ' If you are calculating Aatt, Ascat (IFULL=1), you must be using'/
     ' photon forcing, photon splitting, or cross-section enhancement.'/
     ' Currently, none of these are being used.  Will continue run with'/
     ' photon forcing on and one interaction forced (NFMIN=NFMAX=1).'//);
]

IF(IOOPTN=1 & (n_split>1 | use_enhance))[
  IOOPTN=0;
  OUTPUT;
  (//' *****WARNING*******'/
     ' You cannot have cross-section enhancement or photon splitting on '/
     ' and still output detailed results for each cavity zone.  IOOPTN '/
     ' reset to 0.'//);
]
"                        SCORING ARRAY INITIALISATION
"                        ****************************
"

NCASEO=0;NCASET=0;TMCPUO=0; NNREADO=0; "SET PREVIOUS RUN COUNTERS"

IF(IRESTART.EQ.0.OR.IRESTART.EQ.5)[ "FRESH START, SET EVERYTHING TO ZERO"
    NNREAD=0;
    SCSTP=0.; SCSTP2=0.; SCSTP_TMP=0.; SCSTP_LAST=0;
    SCCSTP=0.; SCCSTP2=0.; SCCSTP_TMP=0.; SCCSTP_LAST=0;
    cav_dose  = 0; cav2_dose  = 0;
    cav_dose0 = 0; cav2_dose0 = 0;
    cav_dose1 = 0; cav2_dose1 = 0;
    cav_dose2 = 0; cav2_dose2 = 0;

    cav_dosec   = 0;
    cav_dosec01 = 0;
    cav_dosec02 = 0;

    tmp_dose  = 0.0;
    tmp_dose0 = 0.0;
    tmp_dose1 = 0.0;
    tmp_dose2 = 0.0;

    PIISTP=0.;
    DO IZ=1,NZ[
       DO IX=1,NR[
           DO IT=1,4[
             SCDOSE(IZ,IX,IT)=0.;
             SCDOSE2(IZ,IX,IT)=0.;
             SCDOSE_TMP(IZ,IX,IT)=0.;
             IF(IT<4)SCDOSE_COV(IZ,IX,IT)=0.;
           ]
           SCDOSE_LAST(IZ,IX)=0;
       ]
    ]
]
ELSEIF(IRESTART.NE.4)[
    "Restart or stats analysis only, read old data from unit 4"
    "open unit 4 as an old file"
    OUTPUT;(' About to read the previous .egsdat file');
    my_unit = egs_open_datfile(4,0,1,'.egsdat');
    READ(my_unit,*) SCSTP,SCSTP2,SCCSTP,SCCSTP2;
    READ(my_unit,*) cav_dose, cav_dose0, cav_dose1, cav_dose2;
    READ(my_unit,*) cav2_dose,cav2_dose0,cav2_dose1,cav2_dose2;
    READ(my_unit,*) cav_dosec,cav_dosec01,cav_dosec02;

    IF(NSUMCV>1)["get data for individual cavity regions"
       DO IZ=1,NZ[
           DO IX=1,NR[
              $GET-IRL(IZ,IX);
              IF(NTRACK(IRL).EQ.1)[
                   READ(my_unit,*)(SCDOSE(IZ,IX,IT),SCDOSE2(IZ,IX,IT),IT=1,4);
                   READ(my_unit,*)(SCDOSE_COV(IZ,IX,IT),IT=1,3);
              ]
           ]
        ]
    ]
    $RETRIEVE RNG STATE FROM UNIT my_unit;
    READ(my_unit,*,END=:EOFA:)NCASEO,TMCPUO,NNREADO,PIISTP;
    CLOSE(my_unit);
    NNREAD=NNREADO;
]

IF(IRESTART = 3)[NCASE=0;]

NCASET=NCASE+NCASEO;

:FINISHED: CONTINUE;
"************************"
"* Check for any errors *"
"************************"
IF(ERROR_FLAG =  0) [
   OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   DO J=1,5[$SKIP-LINE;]
   RETURN; "normal return"
]

IF (ERROR_FLAG = 1) [
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   WRITE(15,*) '************************************************';
   WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********';
   WRITE(15,*) '************************************************';
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   OUTPUT;(/' CAVRZnrc input file is not correct! - look for error message');
   RETURN; "error return"
]
"Bad data file, stop and print message"
:EOFA:;OUTPUT;(/' End of  file before all of egsdat file read in');

ERROR_FLAG=1;
RETURN; "END OF DAT FILE RETURN"

END; "END OF SUBROUTINE INPUTS

%Q1
%I4
%C80
%E     "cavrznrc.mortran"
"***************************************************************************
"
SUBROUTINE ISUMRY;
"
"
"                AFB      87/12/11     VAX/IBM COMPATIBLE VERSION CODED
"
"*************************************************************************
;
$IMPLICIT-NONE;

REPLACE {$IRL} WITH {IZ+1+NZ*(IX-1)}

;
$INTEGER I,J,JJ,IRL;

COMIN/
BOUNDS,CHARS,EDGE,ELECIN,ET-Control,GEOM,IODAT1,IODAT2,
PRINTC,MEDIA,MISC,RUSROU,SCORE,SOURCE,SPECTR,
THRESH,USEFUL,USER,RANDOM/;
"added ET-control to give proper access to ESTEPR, even though we do not"
"ever use it at this point, we were prining out garbage before"
"Note it is initialized in HATCH to unity via a macro in egsnrc.macros"

"For the grid output defaults"
CHARACTER*4 CDSTBL($MXREG),CTRTBL($MXREG),CABSRB($MXREG);
CHARACTER*4 CAVTRACK($MXREG); "for identifying a cavity region"


"WRITE THE HEADER"
write(iout,110) title;
call egs_fdate(iout);
110  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
  ' *',T80, '*'/
  ' *',T34,'************',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'* CAVRZnrc *',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'************',T80,'*'/
  ' *',T80, '*'/
  ' *   Cylindrical-geometry EGSnrc user-code for scoring cavity details',
   T80,'*'/
  ' *',T80, '*'/
  ' *   CAVRZnrc was developed by the National Research Council of Canada',
                                                                      T80,'*'/
  ' *',T80, '*'/
  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
                                                                       T80,'*'/
  ' *            This is version '$VERSION' ',T80,'*'/
  ' *             running on '$MACHINE' ',T80,'*'/
  ' *',T80, '*'/
  ' *',  T53,' ',$);
write(iout,111);
111 FORMAT('  *'/1X,79('*'));

"Print info about transport parameter settings"
call show_transport_parameter(iout);

"MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS"
WRITE(IOUT,200) NCASE,NCASET;
IF(IQIN = 0 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''photons'')');
IF(IQIN = -1) WRITE(IOUT,'(T20,''Incident Charge'',T60,''electrons'')');
IF(IQIN = 1 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''positrons'')');
IF(IQIN = 2 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''all'')');
IF(IQIN = 3 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''e- & e+'')');

IF(MONOEN = 0 & ISOURC ~= 21 & ISOURC ~= 22 & ISOURC ~= 23)[
    WRITE(IOUT,201) EIN;
] ELSE[ CALL ENSRCO;]

"Now we check to see if ECUT(i) is the same for all regions"
"If so, we print the value"
"Note that this is a fudge for the RZ codes so that even if we "
"SET ECUT(1) = 0.0 to avoid warning messages, there is still a fixed ECUT"
DO I=2,NREG [ IF( (ECUT(I) ~= ECUT(2)) |(PCUT(I) ~= PCUT(2)) ) [
     "we failed at least one test, so this means there really are"
     "varying ECUTs and these will be printed in the grid if we want them"
     "print the first 12 ECUT & PCUT just to be sure"
     j = MIN(12,NREG);
     WRITE(IOUT,'( ''First ECUTs:''/(6(F12.3)))') (ECUT(JJ),JJ=2,j);
     WRITE(IOUT,'( ''First PCUTs:''/(6(F12.3)))') (PCUT(JJ),JJ=2,j);
     GO TO :past:]]
"if we get here, they were all the same"
WRITE(IOUT,220) ECUT(2),PCUT(2);
:past:

IF(IFORCE ~= 0)[WRITE(IOUT,230)NFMIN,NFMAX;]ELSE[WRITE(IOUT,231);]
IF(IREJCT > 0)[
   " WRITE(IOUT,242);IF(IREJCT = 2)WRITE(IOUT,243);"
    WRITE(IOUT,251)
       z_cavity_min, z_cavity_max, r_cavity_max;
    251 FORMAT(T20,'Range rejection on a region by region basis'/
      T20,'Also globally to region between z=',F10.4,' &',F10.4,' cm'/
      T20,'     and inside radius=', F12.4,' cm');
    WRITE(IOUT,252) ESAVEIN;
    252 FORMAT(T20,'Range rejection only for electrons < ESAVEIN=',
    F10.3,' MeV');
]
ELSE[WRITE(IOUT,244);]
WRITE(IOUT,260) TIMMAX,STATLM,jrng1,jrng2;
write(iout,'(19x,a,$)') 'Initial RNG state:    ';
$SHOW-RNG-STATE(iout); write(iout,*);
IF(RUSROU)[WRITE(IOUT,265)RRZ,RRCUT;]
IF(CEXPTR.NE.0)[WRITE(IOUT,266)CEXPTR;]
IF(ifano = 1) [
  OUTPUT; ('  *** REGENERATION REQUESTED (IFANO SET TO 1) ! *** ');
  WRITE(iout,*) '  *** REGENERATION REQUESTED (IFANO SET TO 1) ! *** ';
]
ELSEIF(ifano = 2) [
  OUTPUT; ('  *** ELECTRONS SET IN MOTION IN WALL WILL BE ELIMINATED *** '/
           '  (IFANO SET TO 2) ! *** ');
  WRITE(iout,*)'  *** ELECTRONS SET IN MOTION IN WALL WILL BE ELIMINATED *** ';
  WRITE(iout,*)'  (IFANO SET TO 2) ! *** ';
]
ELSE [
  OUTPUT; (T20,'  *** NO REGENERATION REQUESTED (IFANO SET TO 0) ! *** ');
  WRITE(iout,'(T20,''** No regeneration requested (IFANO set to 0)! ** '')');
]

"EK0=EIN;"
"$PRESTA-INPUT-SUMMARY; OUTPUT THE PRESTA INPUT VARIABLES"
"taken out input-summary at upgrade to PRESTA-II"

"MATERIAL INPUT SUMMARY"
"====================="

WRITE(IOUT,300) NMED;
DO I=1,NMED[
    WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP(I);
    ]

CALL GEOMRZ_ISUMRY(IOUT);

CALL SRCOUT;

"       PRINT A GRID OF THE ZONE DEPENDENT VARIABLES"
"       ============================================"

"Set defaults for non-used variables"
CDSTBL(1)='0';CTRTBL(1)='0';CABSRB(1)='0';
"For identifying a cavity region"
DO IRL=2, NR*NZ+1 [
    IF (NTRACK(IRL)=1) [CAVTRACK(IRL)='C';]
    ELSE [CAVTRACK(IRL)=' ';]
]
"Make the material grid"
CALL MATERIALGRID(NR, NZ, AMASS, 1, ECUT, PCUT,
                  RCYL, ZPLANE, MED, MEDIA, CAVTRACK, CTRTBL, CABSRB);
WRITE (IOUT, *) '\f'; "Page break"
RETURN;
%I0
"FORMATS"
"100    FORMAT('1',80A1//'NRCC calculation using CAVRZnrc(EGSnrc) '$VERSION' ',
"             /'on '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
200    FORMAT(80('*')/
             /,T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/
             /80('*')/
             //T20,'max # of histories to RUN',T58,I12/
             ' ',T20,'Max # of histories to ANALYZe',T58,I12);
201    FORMAT(' ',T20,'Incident kinetic energy',T57,F9.3,' (MeV)');
210    FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,'DEFAULT');
211    FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,F5.3);
220    FORMAT(' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF',
                     T56,0PF9.3,' (MeV)'/
             ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF',
                     T56,F9.3,' (MeV)');
230    FORMAT(' ',T20,'Min/max photon step forced',T60,I6,'/',I6);
231    FORMAT(' ',T20,'Photon force interaction switch',T60,'OFF');
242    FORMAT(' ',T20,'RANGE REJECTION SWITCH OUTSIDE CAVITY',T60,'ON');
243    FORMAT(' ',T20,'RANGE REJECTION SWITCH INSIDE CAVITY',T60,'ON');
244    FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'OFF');
258    FORMAT(' ',T20,' ZONAL DISCARD OF CHARGE PARTICLES BELOW',
             T57,F9.3,' (MeV) kinetic energy');
260    FORMAT(' ',T20,'Maximum cputime allowed',T58,F6.2,' (hrs)'/
             ' ',T20,'Stats in cavity objective',T59,F6.3,' %'/
             ' ',T20,'1ST INITIAL RANDOM NUMBER SEED',T57,I12/
            ' ',T20,'2ND INITIAL RANDOM NUMBER SEED',T57,I12);
265    FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'/
            T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4);
266    FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/T25,
            'VARIABLE FOR FORWARD GOING PHOTNS: ',T60,F10.3);
270    FORMAT(' ',T20,'RAYLEIGH (COHERENT) SCATTERING',T60,'OFF');
271    FORMAT(' ',T20,'RAYLEIGH (COHERENT) SCATTERING',T60,'ON');
272    FORMAT(' ',T20,'PHOTOELECTRON ANGULAR SAMPLING',T60,'OFF');
273    FORMAT(' ',T20,'PHOTOELECTRON ANGULAR SAMPLING',T60,'ON');
288    FORMAT(' ',T20,'*** WARNING *** DNEAR CALLS REDUCTION AND RANGE',
            ' REJECTION BOTH INVOKED');
300    FORMAT(80('*')/
             // ,T20,'MATERIAL SUMMARY   ',I1,' MATERIALS USED'/
             //80('*')/
             //'# MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',4X,'AP(MeV)',
                 9X,'UE(MeV)',4X,'UP(MeV)'/
             ' - --------  ----------------',6X,'-------',4X,'-------',
                 9X,'-------',4X,'-------');
305  FORMAT(T22,' REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3);
306  FORMAT(T20,' REGIONS WITH FLUORESCENT X-RAYS FOLLOW: ');
307  FORMAT(T20,' FLUORESCENT X-RAYS ARE DISCARDED');
310    FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3));
399    FORMAT(// ,'ZONAL VARIABLES-NONROTATED OUTPUT'/' ',
            '*********************************');
400    FORMAT(// ,'#IRL/X/MED/ : #IRL = GEOMETRY REGION NUMBER'/
            ' ',18X,'X = "*" IF CAVITY REGION'/
            ' ',18X,'MEDIUM, FIRST 6 CHARACTERS ONLY'/
            ' ','MASS',13X,': MASS OF THE REGION IN GRAMS');
401    FORMAT(// ,'#IRL/X/MED/ : #IRL = GEOMETRY REGION NUMBER'/
            ' ',18X,'X = "*" IF DOSE SCORING REGION'/
            ' ',18X,'MEDIUM, FIRST 6 CHARACTERS ONLY'/
            ' ','THICK',12X,': THICKNESS OF REGION IN g/cm**2');
406    FORMAT(' ');
408    FORMAT('1');

END; "LAST LINE OF SUBROUTINE ISUMRY"
%C80
%Q1
%I4
%E     "cavrznrc.mortran"
"*************************************************************************
"
SUBROUTINE OSUMRY;
"
"************************************************************************

$IMPLICIT-NONE;

COMIN/GEOM,IODAT1,IODAT2,PRINTC,SCORE,SOURCE,USER/;
COMIN/CH-Steps/;

$INTEGER I,IRL,IX,IZ;
$REAL ASCT,ASCTUN,AATT,AATTUN,AWLL,AWLLUN,TDAW,TDAWUN;

REAL*4 KSCT,KATT,KWLL,KSCTUN,KATTUN,KWLLUN;

"SET UP THE PRINTER"
ICHPIN=12; "12 CHARACTERS/INCH"
ILPIN=6;   "6 LINES/INCH"
IPAGE=0;   "NO PAGE THROW"
"CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"

"WRITE(IOUT,100)TITLE,DATEN,TIMEN; HEADER"

IF(ISOURC=21 | ISOURC=22)[
    WRITE(IOUT,200) SCSTP,SCSTP2,
         SCSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*
                       NINCSRC),SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
]
ELSE[
    WRITE(IOUT,200) SCSTP,SCSTP2,SCSTP/dble(IHSTRY),
                  SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
]

"PRINT # CHARGED PARTICLE STEPS IN cavity REGION, etc"
IF(ISOURC=21 | ISOURC=22)[
   WRITE(IOUT,210) SCCSTP,SCCSTP2,
          SCCSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*
                      NINCSRC),SCCSTP2;
]
ELSE[
    WRITE(IOUT,210) SCCSTP,SCCSTP2,SCCSTP/dble(IHSTRY),SCCSTP2;
]

IF( isourc = 15 ) call src15_out(iout);

"THE CAVITY SUMMARY"
"******************"

IF(NSUMCV.EQ.1)[WRITE(IOUT,300);]ELSE[WRITE(IOUT,301)NSUMCV;]

"******************"
"history by history"
"    EMH March 2002"
"******************"
cav2_dose = cav2_dose/cav_dose;
IF (iifano = 1) [
       write(iout,'(/t20,a)')
         'This calculation was performed using regeneration ';
       write(iout,'(t20,a/)')
         '================================================= ';
       write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
        'D/Awall (grays/incident fluence): ',cav_dose,' +/-  ',
         100*cav2_dose,'%';
       return;
]

IF( use_enhance ) [
        write(iout,'(/t20,a)')
          'This calculation was performed using CS enhancement ';
        write(iout,'(t20,a,f10.2)')
          '  enhancement factor was ',cs_enhance;
        write(iout,'(t20,a)')
          '=================================================== ';
]
    ELSEIF ( n_split > 1 ) [
        write(iout,'(/t20,a)')
          'This calculation was performed using photon splitting ';
        write(iout,'(t20,a,i6)') '  splitting number was ',n_split;
        write(iout,'(t20,a)')
          '===================================================== ';
]
IF (ifano.eq.1)
[
 write(iout,*) 'This calculation was performed using regeneration ';
]
IF (ifano.eq.2)
[
 write(iout,*)'This calculation was performed eliminating electrons';
 write(iout,*)'originating in the cavity wall.';
]
"THE TOTAL DOSE"
IF(ISOURC=3|ISOURC=21|ISOURC=22)[
   WRITE(IOUT,311)cav_dose,100*cav2_dose;
]
ELSE[
   WRITE(IOUT,310)cav_dose,100*cav2_dose;
]

IF(IFULL=1)[
    "CALCULATE Ascat, Aatt, Awall, DOSE/Awall"

    cav2_dose1 = cav2_dose1/cav_dose1;
    cav_dosec = cav_dosec/cav_dose/cav_dose1;

    "total dose/Awall"
    TDAW=cav_dose1;
    TDAWUN=cav2_dose1;
    WRITE(IOUT,350)TDAW,TDAWUN*100.;

    cav_dosec = cav2_dose*cav2_dose + cav2_dose1*cav2_dose1 - 2*cav_dosec;
    IF( cav_dosec > 0 ) cav_dosec = sqrt(cav_dosec);
    "Awall"
    AWLL=cav_dose/cav_dose1;
    AWLLUN=cav_dosec;
    WRITE(IOUT,340)AWLL,AWLLUN*100.;

    IF( ~use_enhance & n_split <= 1 )[

      corr_02 = corr_02/(cav_dose0+cav_dose2);

      cav2_dose0 = cav2_dose0/cav_dose0;
      cav2_dose2 = cav2_dose2/cav_dose2;

      cav_dosec01 = cav_dosec01/cav_dose0/cav_dose1;
      cav_dosec02 = cav_dosec02/cav_dose0/cav_dose2;

      cav_dosec01 = cav2_dose0*cav2_dose0 + cav2_dose1*cav2_dose1 -
                    2*cav_dosec01;
      cav_dosec02 = cav2_dose0*cav2_dose0 + cav2_dose2*cav2_dose2 -
                    2*cav_dosec02;

      IF( cav_dosec01 > 0 ) cav_dosec01 = sqrt(cav_dosec01);
      IF( cav_dosec02 > 0 ) cav_dosec02 = sqrt(cav_dosec02);

      "... we had rel.error(x), get now rel.error(1+x)"
      cav_dosec02 = cav_dosec02/(1 + cav_dose0/cav_dose2);

      "Ascatt"
      ASCT=1+cav_dose2/cav_dose0;
      ASCTUN=cav_dosec02;
      WRITE(IOUT,320)ASCT,ASCTUN*100.;

      "Aatt"
      AATT=cav_dose0/cav_dose1;
      AATTUN=cav_dosec01;
      WRITE(IOUT,330)AATT,AATTUN*100.;

      "Dpr + Dsec"
      WRITE(IOUT,345)cav_dose2+cav_dose0,corr_02*100.;
    ]
] "END OF IFULL = 1"

"OUTPUT Kscat,Katt,Kwall,Kpn,Kfl THE INVERSES OF THE Ai's"
IF(IFULL.GT.0)[
    KWLL=1./AWLL;KWLLUN=AWLLUN/AWLL**2;WRITE(IOUT,341)KWLL,KWLLUN*100.;
    IF( ~use_enhance & n_split <= 1 )[
      KSCT=1./ASCT;KSCTUN=ASCTUN/ASCT**2;WRITE(IOUT,321)KSCT,KSCTUN*100.;
      KATT=1./AATT;KATTUN=AATTUN/AATT**2;WRITE(IOUT,331)KATT,KATTUN*100.;
    ]
]

"THE DETAILED OUTPUT FOR EACH CAVITY ZONE"
"****************************************"
IF(IOOPTN=1 & NSUMCV>1)[
    "ONLY IF REQUESTED AND MORE THAN ONE CAVITY ZONE"

    WRITE(IOUT,400) NSUMCV;

    "PRINT THE TABLE HEADER"
    IF(IFULL.EQ.0)[
        WRITE(IOUT,410);
    ]
    ELSEIF(IFULL.GT.0)[
        "SET UP THE PRINTER"
        ICHPIN=16; "16 CHARACTERS/INCH"
        ILPIN=6;   "6 LINES/INCH"
        IPAGE=0;   "NO PAGE THROW"
        "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"

        WRITE(IOUT,420);
    ]

    "LOOP OVER THE CAVITY ZONES"
    DO I=1,NSUMCV[
        IRL=ISUMCV(I);
        $GET-IX-IZ(IRL);
        "total dose"
        IF(SCDOSE(IZ,IX,1)>0.)SCDOSE2(IZ,IX,1)=SCDOSE2(IZ,IX,1)/SCDOSE(IZ,IX,1);
        IF(IFULL=1)[
            "CALCULATE Ascat, Aatt, Awall, DOSE/Awall"

            IF(SCDOSE(IZ,IX,3)>0.)[
                SCDOSE2(IZ,IX,3)=SCDOSE2(IZ,IX,3)/SCDOSE(IZ,IX,3);
                SCDOSE_COV(IZ,IX,1)=SCDOSE_COV(IZ,IX,1)/SCDOSE(IZ,IX,1)/
                                    SCDOSE(IZ,IX,3);
            ]

            "TOTAL DOSE/Awall"
            TDAW=SCDOSE(IZ,IX,3);TDAWUN=SCDOSE2(IZ,IX,3);

            SCDOSE_COV(IZ,IX,1) = SCDOSE2(IZ,IX,1)*SCDOSE2(IZ,IX,1) +
                                  SCDOSE2(IZ,IX,3)*SCDOSE2(IZ,IX,3) -
                                  2*SCDOSE_COV(IZ,IX,1);
            IF(SCDOSE_COV(IZ,IX,1)>0)SCDOSE_COV(IZ,IX,1)=
                                            SQRT(SCDOSE_COV(IZ,IX,1));
            "Awall"
            AWLL=SCDOSE(IZ,IX,1)/SCDOSE(IZ,IX,3);
            AWLLUN=SCDOSE_COV(IZ,IX,1);

            IF( ~use_enhance & n_split <= 1 )[ "this condition not "
                                               "strictly necessary because"
                                               "IOOPTN set = 0 if either of"
                                               "these options on"

               IF(SCDOSE(IZ,IX,2)>0.)[
                   SCDOSE2(IZ,IX,2)=SCDOSE2(IZ,IX,2)/SCDOSE(IZ,IX,2);
                   SCDOSE_COV(IZ,IX,2)=SCDOSE_COV(IZ,IX,2)/SCDOSE(IZ,IX,2)/
                                           SCDOSE(IZ,IX,3);
                   IF(SCDOSE(IZ,IX,4)>0.)[
                     SCDOSE_COV(IZ,IX,3)=SCDOSE_COV(IZ,IX,3)/SCDOSE(IZ,IX,2)/
                                           SCDOSE(IZ,IX,4);
                   ]
               ]
               IF(SCDOSE(IZ,IX,4)>0.)SCDOSE2(IZ,IX,4)=SCDOSE2(IZ,IX,4)/
                                                      SCDOSE(IZ,IX,4);

               SCDOSE_COV(IZ,IX,2)=SCDOSE2(IZ,IX,2)*SCDOSE2(IZ,IX,2)+
                                   SCDOSE2(IZ,IX,3)*SCDOSE2(IZ,IX,3)-
                                   2*SCDOSE_COV(IZ,IX,2);
               SCDOSE_COV(IZ,IX,3)=SCDOSE2(IZ,IX,2)*SCDOSE2(IZ,IX,2)+
                                   SCDOSE2(IZ,IX,4)*SCDOSE2(IZ,IX,4)-
                                   2*SCDOSE_COV(IZ,IX,3);

               IF(SCDOSE_COV(IZ,IX,2)>0)SCDOSE_COV(IZ,IX,2)=
                                              SQRT(SCDOSE_COV(IZ,IX,2));
               IF(SCDOSE_COV(IZ,IX,3)>0)SCDOSE_COV(IZ,IX,3)=
                                              SQRT(SCDOSE_COV(IZ,IX,3));

               "... we had rel.error(x), get now rel.error(1+x)"
               IF(SCDOSE(IZ,IX,4)>0.) SCDOSE_COV(IZ,IX,3)=SCDOSE_COV(IZ,IX,3)/
                                      (1+SCDOSE(IZ,IX,2)/SCDOSE(IZ,IX,4));

               "Ascatt"
               ASCT=1+SCDOSE(IZ,IX,4)/SCDOSE(IZ,IX,2);
               ASCTUN=SCDOSE_COV(IZ,IX,3);

               "Aatt"
               AATT=SCDOSE(IZ,IX,2)/SCDOSE(IZ,IX,3);
               AATTUN=SCDOSE_COV(IZ,IX,2);

            ]
        ]
        IF(IFULL.EQ.0)[
            WRITE(IOUT,430)
                IRL,IZ,IX,                     "POSITION"
                SCDOSE(IZ,IX,1),SCDOSE2(IZ,IX,1)*100.; "TOTAL DOSE"
        ]

        ELSEIF(IFULL.EQ.1)[
            WRITE(IOUT,440)
                IRL,IZ,IX,                     "POSITION"
                SCDOSE(IZ,IX,1),SCDOSE2(IZ,IX,1)*100., "TOTAL DOSE"
                ASCT,ASCTUN,                   "Ascat"
                AATT,AATTUN,                   "Aatt"
                AWLL,AWLLUN,                   "Awall"
                TDAW,TDAWUN*100;                   "TOTAL DOSE/Awall"
        ]

    ] "END OF LOOP OVER CAVITY ZONES"
] "END OF DETAILED SUMMARY"

"RESET UP THE PRINTER"
ICHPIN=12; "12 CHARACTERS/INCH"
ILPIN=6;   "6 LINES/INCH"
IPAGE=0;   "NO PAGE THROW"
"CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"

RETURN;
%I0
"FORMATS"
200  FORMAT(//' ' ,'                    # primary charged particle steps',T58,
             1PE10.3,' +/- ',0PF6.3,'%'/
             ' ','     # primary charged particle steps/initial history',T58,
             1PE10.3,' +/- ',0PF6.3,'%'/
             ' ','# of presta-II steps/# primary charged particle steps',
             T58,F10.3,' +/- ',0PF6.3,'%');
202   FORMAT(//' ' ,'                 # charged particle steps in run',T58,
             1PE10.3,/
             ' ','    # charged particle steps in run/initial history',T58,
             1PE10.3/
             ' ','# of presta-II steps/# primary charged particle steps',
             T58,F10.3,' +/- ',0PF6.3,'%');
210  FORMAT(//' ','   # primary charged particle steps in cavity region'
             ,T58,1PE10.3,' +/- ',0PF6.3,'%'/
              ' ','    # primary steps in cavity region/initial history'
             ,T58,1PE10.3,' +/- ',0PF6.3,'%');
220  FORMAT(// ,T8,'STEP COUNTING RESULTS FOR WALL MATERIAL IN THE CAVITY'/
             // ,T8,'# primary charged particle steps',T51,
             I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'# OF Times mscat switched off',T51,
             I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'RATIO',T54,F7.3,' +/- ',0PF5.2,'%');
230  FORMAT(// ,T8,'# Primary charged particle steps in cavity region'
             ,T51,I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'# Times mscat switched off in cavity region.'
             ,T51,I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'Ratio',T56,F7.3,' +/- ',0PF5.2,'%');
300  FORMAT(// ,T20,'SUM OF RESULTS FOR THE CAVITY: 1 REGION'/
            ' ',T20,'***************************************');
301  FORMAT(// ,T20,'SUM OF RESULTS FOR THE CAVITY: ',I2,' REGIONS'/
            ' ',T20,'*****************************************');
310  FORMAT(//'TOTAL DOSE (GRAYS/INCIDENT FLUENCE):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
311  FORMAT(//'TOTAL DOSE (GRAYS/INCIDENT PARTICLE):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
320  FORMAT(' Ascat:',T50,F8.5,'    +/- ',F5.2,'%');
321  FORMAT(' Kscat:',T50,F8.5,'    +/- ',F5.2,'%');
330  FORMAT(' Aatt :',T50,F8.5,'    +/- ',F5.2,'%');
331  FORMAT(' Katt :',T50,F8.5,'    +/- ',F5.2,'%');
340  FORMAT(' Awall:',T50,F8.5,'    +/- ',F5.2,'%');
341  FORMAT(' Kwall:',T50,F8.5,'    +/- ',F5.2,'%');
345  FORMAT(' Dprimary + Dsecondary:',T50,1PE11.4,' +/- ',0PF5.2,'%');
350  FORMAT(' TOTAL DOSE/Awall:',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
360  FORMAT(//'Apn  :',T50,F8.5,'   +/- ',F8.5);
361  FORMAT(' Kpn  :',T50,F8.5,'   +/- ',F8.5);
370  FORMAT(' TOTAL DOSE/([Apn]*Awall):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
380  FORMAT(//'Afl  :',T50,F8.5,'   +/- ',F8.5);
381  FORMAT(' Kfl  :',T50,F8.5,'   +/- ',F8.5);
390  FORMAT(' TOTAL DOSE/(Afl*[Apn]*Awall):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
395  FORMAT(//'<s>g,w  :',T50,F8.5,'   +/- ',F8.5);
396  FORMAT(' TOTAL DOSE/(Afl*[Apn]*Awall*<s>g,w):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
400  FORMAT(// ,T15,'DETAILED RESULTS FOR EACH OF THE ',I4,' CAVITY REGIONS'/
            ' ',T15,'****************************************************');
410  FORMAT(//'Z# P# C#     Total Dose     '/
            ' -- -- -- -------------------');
420  FORMAT(//'Z# P# C#',
            '     Total Dose   ',
            '      Ascat      ',
            '       Aatt      ',
            '      Awall      ',
            '  Total Dose/Awall'/
            ' -- -- --',
            '     ----------   ',
            '      -----      ',
            '       ----      ',
            '      -----      ',
            '  ----------------');
430  FORMAT(' ',I2,2(1X,I2),1X,1PE11.4,' +/-',0PF5.2,'%');
440  FORMAT(' ',I2,2(1X,I2),
                1X,1PE11.4,'(',0PF5.2,'%)',
                3(F8.5,'(',F7.5,')'),
                1X,1PE11.4,'(',0PF5.2,'%)');
445  FORMAT(' ',I2,2(1X,I2),
                1X,1PE11.4,'(',0PF5.2,'%)',
                3(F8.5,'(',F7.5,')'),
                1X,1PE11.4,'(',0PF5.2,'%)',
                F8.5,'(',F7.5,')',
                1X,1PE11.4,'(',0PF5.2,'%)');
450  FORMAT(' ',I2,2(1X,I2),
                1X,1PE11.4,
                3(1X,F8.5,1X),
                1X,1PE11.4,
                1X,F8.5,1X,
                1X,1PE11.4,
                1X,F8.5,1X,
                1X,1PE11.4,
                1X,F8.5,1X,
                1X,1PE11.4/
            ' ','ERRORS = ',
                4X,'(',0PF5.2,'%)',
                3(1X,'(',F7.5,')'),
                4X,'(',0PF5.2,'%)',
                1X,'(',F7.5,')',
                4X,'(',0PF5.2,'%)',
                1X,'(',F7.5,')',
                4X,'(',0PF5.2,'%)',
                1X,'(',F7.5,')',
                4X,'(',0PF5.2,'%)');

END; "END OF SUBROUTINE OSUMRY"

%E   "start of subroutine initialize_range_rejection"
"*******************************************************************************
"
"
subroutine initialize_range_rejection;
"
"      This sets up the needed parameters to do a global range rejection on
"      electrons which cannot reach the cavity.  For this range rejection,
"      the cavity is any region of the same material as the cavity as designated
"      by the user.
"      The procedure followed is to determine the longest range for any material
"      outside the cavity and then use this value in the range rejection.
"      Thus, it would be in-efficient if there were any air regions outside
"      the cavity and it is more efficient to define the cavity as being
"      bigger than it actually is.
"
"      Note that the EGSnrc region by region range rejection is performed
"      prior to this more approximate global range rejection.
"
"
"*******************************************************************************
$IMPLICIT-NONE;

COMIN/ELECIN,GEOM,MISC,USER,MEDIA/;

$INTEGER irl,medium,cavity_medium,ix,iz,neke,lelke,lelec,qel;
$REAL    elke,elke_min,elke_max,rhof,rhof_min,range,max_range,si,sip;
$REAL    eke,ekei,elkei,elktmp,dedxmid,aux,fedep;
$INTEGER lelktmp,j;

write(6,*);
write(6,*) '  initialize_range_rejection';
write(6,*) '  ==========================';
write(6,*);

lelec = -1; qel = 0;
cavity_medium = 0;
"Determin first the cavity medium and check for possible errors"
DO irl = 2,nreg [
    medium = med(irl);
    IF( ntrack(irl) = 1 ) ["set 1 for all regions user specifies as in cavity"
        IF( cavity_medium = 0 ) ["only for first region"
            cavity_medium = medium;
            write(6,*) '  Cavity medium is med # ',cavity_medium;
        ]
        ELSE [
            IF( medium ~= cavity_medium ) [
                write(6,*)
                  ' Warning: cavity composed of several media: ',medium;
                write(6,*)
                  ' Turning off range rejection! ';
                irejct = 0;
                return;
            ]
        ]
    ]"end ntrack = 1 block"
]

" Now determine smallest cylinder enclosing the cavity "
" (non-cavity regions composed of cavity material are counted as cavity)"

z_cavity_max = -1e10;
z_cavity_min = 1e10;
r_cavity_max = -1e10;
DO irl = 2,nreg [
    medium = med(irl);
    IF( ntrack(irl) = 1 | medium = cavity_medium ) [
        $GET-IX-IZ(irl);
        IF( z_cavity_min > zplane(iz) ) [ z_cavity_min = zplane(iz); ]
        IF( z_cavity_max < zplane(iz+1) ) [ z_cavity_max = zplane(iz+1); ]
        IF( r_cavity_max < rcyl(ix) ) [ r_cavity_max = rcyl(ix); ]
    ]
]
write(6,*) '  The smallest cylinder enclosing the cavity is: ';
write(6,*) z_cavity_min,' < z < ',z_cavity_max;
write(6,*) '  r < ',r_cavity_max;
write(6,*);

" Now prepare an array for range calculation in the medium with the "
" smallest stopping power (excluding the cavity material)            "
" First determine energy window. We assume that the PEGS data has been "
" checked to cover the necessary energy range                          "
elke_min = -1e10;
elke_max = 1e10;
DO medium = 1,nmed [
  IF( medium ~= cavity_medium ) [
      neke = meke(medium);
      elke = (1 - eke0(medium))/eke1(medium);
      IF( elke > elke_min ) [ elke_min = elke; ]
      elke = (neke - eke0(medium))/eke1(medium);
      IF( elke < elke_max ) [ elke_max = elke; ]
  ]
]
write(6,*) ' Range rejection data will be calculated for ';
write(6,*) Exp(elke_min),' < E < ',Exp(elke_max);
write(6,*);

"Then determine the minimum density scaling factor (rhof)"
rhof_min = 1e10;
DO irl = 2,nreg [
    medium = med(irl); $SET-RHOF;
    IF( rhof < rhof_min ) [ rhof_min = rhof; ]
]
write(6,*) ' rhof_min = ',rhof_min;
write(6,*);

rhof = rhof_min;
eker1 = ($MXRANGE-1)/(elke_max - elke_min);
eker0 = $MXRANGE - eker1*elke_max;
"write(6,*) ' eker1 eker0: ',eker1,eker0;
"write(6,*);

" Calculate maxium range for 1st table energy "
elke = (1-eker0)/eker1;
eke = Exp(elke);
max_range = -1e10;
DO medium=1,nmed[
    IF( medium ~= cavity_medium ) [
        $SET INTERVAL elke,eke;
        IF( lelke < 1 ) [ lelke = 1; ]
        $COMPUTE-RANGE;
        IF( range > max_range ) [ max_range = range; ]
    ]
]
si = 1.02*max_range;

DO j=1,$MXRANGE-1 [
    elke = (j+1-eker0)/eker1;
    eke = Exp(elke);
    max_range = -1e10;
    DO medium=1,nmed[
        IF( medium ~= cavity_medium ) [
            $SET INTERVAL elke,eke;
            $COMPUTE-RANGE;
            IF( range > max_range ) [ max_range = range; ]
        ]
    ]
    sip = 1.02*max_range;  "A safety factor"
    rangerr1(j) = (sip - si)*eker1;
    rangerr0(j) = sip - rangerr1(j)*elke;
    "write(6,'(4g15.6)') eke,sip,rangerr0(j),rangerr1(j);"
    si = sip;
]
rangerr1($MXRANGE) = rangerr1($MXRANGE-1);
rangerr0($MXRANGE) = rangerr0($MXRANGE-1);

return;
end;

%E    "start of subroutine range_rejection"
"*******************************************************************************
"
subroutine range_rejection(elke,x,y,z,ir,iq,idisc);
"
"
"*******************************************************************************

$IMPLICIT-NONE;

$INTEGER ir,iq,idisc;
$REAL    elke,x,y,z;

COMIN/GEOM,USER/;

$REAL    r2,r,zl,rl,tperp,range;
$INTEGER lelke;

idisc = 0;  "No range discard
IF( ntrack(ir) = 1 ) [ return; ]  "No additional rejection in the cavity

" discard sub-threshold electrons without expensive geometry calculations "
lelke = eker1*elke + eker0;
IF( lelke < 1 ) [ idisc = 50 + 49*iq; return; ]

r2 = x*x + y*y;
r  = Sqrt(r2); rl = r - r_cavity_max;
IF( z <= z_cavity_min ) [
    zl = z_cavity_min - z;
    IF( r <= r_cavity_max ) [ tperp = zl; ]
    ELSE [ tperp = Sqrt( zl*zl + rl*rl ); ]
]
ELSE IF( z <= z_cavity_max ) [
    IF( r <= r_cavity_max ) [ return; ]
    tperp = rl;
]
ELSE [
    zl = z - z_cavity_max;
    IF( r <= r_cavity_max ) [ tperp = zl; ]
    ELSE [ tperp = Sqrt( zl*zl + rl*rl ); ]
]

range = rangerr1(lelke)*elke + rangerr0(lelke);
IF( range <= tperp ) [ idisc = 50 + 49*iq; ]

return; end;


"****************************************************************************

subroutine combine_results(file_name);

"****************************************************************************
implicit none;
character*(*) file_name;

;COMIN/SCORE,RANDOM,IODAT2,GEOM,SOURCE/;

REAL*8     TMPPIISTP,TSCSTP,TSCSTP2,TSCCSTP,TSCCSTP2,
           TSCDOSE($MAXZREG,$MAXRADII,$MAXIT),
           TSCDOSE2($MAXZREG,$MAXRADII,$MAXIT),
           TSCDOSE_COV($MAXZREG,$MAXRADII,3);
real*8 tcav_dose,tcav2_dose,tcav_dose1,tcav2_dose1,tcav_dosec;
real*8 tcav_dose0,tcav2_dose0,tcav_dose2,tcav2_dose2,tcav_dosec01,tcav_dosec02;
$LONG_INT  TMPNCASE,TMPNNREAD;
$REAL      TMPTMCPU;

$INTEGER my_unit,egs_get_unit,iout,iz,ix,it,lnblnk1,irl;
$LOGICAL first_time;
data first_time/.true./, iout/1/;
save first_time,iout;

IF( first_time ) [

      OUTPUT ;(/1X,'Summing the following .egsdat files');
      OUTPUT ; (1X,'------------------------------------'/);
      WRITE(IOUT,'(/1X,''Summing the following .egsdat files'')');
      WRITE(IOUT,'(1X,''------------------------------------''/)');

      datcount=0;
      /TMCPUO,NCASEO,PIISTP,NNREAD/               =0;
      /SCSTP,SCSTP2,SCCSTP,SCCSTP2/               =0;
      /cav_dose, cav_dose0, cav_dose1, cav_dose2/ =0;
      /cav2_dose,cav2_dose0,cav2_dose1,cav2_dose2/=0;
      /cav_dosec,cav_dosec01,cav_dosec02/         =0;
      DO iz=1,nz [ DO ix=1,nr [
          DO it=1,4 [
                  /SCDOSE(IZ,IX,IT),SCDOSE2(IZ,IX,IT)/=0;
          ]
          DO it=1,3 [ SCDOSE_COV(IZ,IX,IT) = 0; ]
      ] ]

      first_time = .false.;
]

my_unit = egs_get_unit(4);
WRITE(IOUT,'(A)') $cstring(file_name);
WRITE(6,'(A)') $cstring(file_name);
open(my_unit,file=file_name,status='old',err=:EOF_RS1:);

READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TSCSTP,TSCSTP2,TSCCSTP,TSCCSTP2;

SCSTP=SCSTP+TSCSTP; SCSTP2=SCSTP2+TSCSTP2; SCCSTP=SCCSTP+TSCCSTP;
SCCSTP2=SCCSTP2+TSCCSTP2;

read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav_dose, tcav_dose0,
                                            tcav_dose1, tcav_dose2;
read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav2_dose,tcav2_dose0,
                                            tcav2_dose1,tcav2_dose2;
read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav_dosec,tcav_dosec01,
                                            tcav_dosec02;

cav_dose =cav_dose +tcav_dose; cav_dose0=cav_dose0+tcav_dose0;
cav_dose1=cav_dose1+tcav_dose1;cav_dose2=cav_dose2+tcav_dose2;

cav2_dose = cav2_dose + tcav2_dose;
cav2_dose0 = cav2_dose0 + tcav2_dose0;
cav2_dose1 = cav2_dose1 + tcav2_dose1;
cav2_dose2 = cav2_dose2 + tcav2_dose2;

cav_dosec   = cav_dosec   + tcav_dosec;
cav_dosec01 = cav_dosec01 + tcav_dosec01;
cav_dosec02 = cav_dosec02 + tcav_dosec02;

IF(NSUMCV>1)["read data for individual cavity regions"

    DO IZ=1,NZ[ DO IX=1,NR[
        $GET-IRL(IZ,IX);
        IF(NTRACK(IRL).EQ.1)[
            READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
               (TSCDOSE(IZ,IX,IT),TSCDOSE2(IZ,IX,IT),IT=1,4);
            READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
               (TSCDOSE_COV(IZ,IX,IT),IT=1,3);
            DO IT=1,4[
                SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+TSCDOSE(IZ,IX,IT);
                SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+TSCDOSE2(IZ,IX,IT);
                IF(IT<4)[
                    SCDOSE_COV(IZ,IX,IT)=SCDOSE_COV(IZ,IX,IT)+
                                             TSCDOSE_COV(IZ,IX,IT);
                ]
            ]
        ]
    ] ]
]

$RETRIEVE RNG STATE FROM UNIT my_unit;
READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TMPNCASE,TMPTMCPU,
                                            TMPNNREAD,TMPPIISTP;
write(6,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;
write(iout,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;

TMCPUO=TMCPUO+TMPTMCPU; NCASEO=NCASEO+TMPNCASE;
PIISTP=PIISTP+TMPPIISTP; NNREAD=NNREAD+TMPNNREAD;
datcount=datcount+1;

CLOSE(UNIT=my_unit);
return;

:EOF_RS1:;
WRITE(6,*) 'failed to open file';
return;

:EOF_RS3:;
write(6,*) 'failed to read file';
close(my_unit); return; end;
