%C80
"#############################################################################"
"                                                                             "
"  EGSnrc cavsphnrc application                                               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Alex Bielajew, 1988                                       "
"                                                                             "
"  Contributors:    Joanne Treurniet                                          "
"                   Ernesto Mainegra-Hing                                     "
"                   Iwan Kawrakow                                             "
"                   Blake Walters                                             "
"                   Frederic Tessier                                          "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code was originally adapted from CAVRZ V0.09 by Alex Bielajew         "
"  in 1988.                                                                   "
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The cavsphnrc application simulates the passage of an electron or photon   "
"  beam in a finite, spherical-conical geometry. It is intended for use in    "
"  calculating quantities of interest for thick-walled ion chambers exposed   "
"  to photon beams although it may be used simply to score dose in a          "
"  spherical-conical geometry.                                                "
"                                                                             "
"#############################################################################"


%L TURN ON LISTING IN CASE IT WAS OFF FOR EGS
%I4
!INDENT F2;
%C80
%Q1
%E     "cavsphnrc.mortran"
;
REPLACE {$VERSION} WITH {,' ',};

REPLACE {$MXMDSH} WITH {200};

"This line is 80 characters long, use it to set up the screen width
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"******************************************************************************
"
"
"                               *********************
"                               *                   *
"                               * CAVSPHnrc.mortran *
"                               *                   *
"                               *********************
"
"
"       INTRODUCTION:
"       THIS CODE SIMULATES THE PASSAGE OF AN ELECTRON OR PHOTON BEAM IN A
"       FINITE, SHPERICAL-CONICAL GEOMETRY.
"       IT IS INTENDED FOR USE IN CALCULATING QUANTITIES OF INTEREST FOR
"       THICK-WALLED ION CHAMBERS EXPOSED TO PHOTON BEAMS ALTHOUGH IT MAY
"       BE USED SIMPLY TO SCORE DOSE IN A SPHERICAL-CONICAL GEOMETRY. IN
"       ADDITION TO SCORING DOSE, THE FOLLOWING QUANTITIES MAY ALSO BE
"       SCORED:
"
"          1)THE Aatt  CORRECTION FACTOR    (attenuation of primary beam),
"          2)THE Ascat CORRECTION FACTOR    (photon scatter),
"          3)THE Apn   CORRECTION FACTOR    (for point-source beams, obtained
"                                             by correlated sampling),
"          4)THE Afl   CORRECTION FACTOR    (obtained by correlated sampling),
"          5)<s>g,w STOPPING POWER RATIO    (obtained by correlated sampling)
"
"       FOR A DERIVATION OF THE ABOVE FACTORS, CONSULT
"       `Correction factors for thick-walled ionisation chambers in
"        point source photon beams' by AF Bielajew PMB 35(1990)501-516.
"
"       STARTING WITH VERSION 4.0 OF cavsphnrc, CONVERTING TO SPHERICAL
"       COORDINATES (R, THETA). -- APRIL 1999, JT
"
"******************************************************************************
"
"       ADAPTED FROM AN EARLIER VERSION OF CAVSPHnrc AND INTRODUCING MANY OF
"       THE CURRENT IMPROVEMENTS IN CAVRZnrc.
"
"       - only IFULL=0 and 1 are currently available,i.e.,only Dgas, Dgas/Awall,
"         Ascat, Aatt and Awall are currently calculated.
"
"       - Scoring is performed on a hist/hist basis parallel to the usual batch
"         scoring mode.
"
"       - Although most ion chambers are modeled with pure spherical geometries,
"         one could use this code to just score the dose in a spherical-conical
"         geometry.
"
"       - Sources available : parallel (0) and point source (1) from any angle.
"         One can also select ISOURC=4 to have photons starting at origin moving
"         along the z-axis and forcing the first interaction, but it hasn't been
"         tested here. A code for point spread function calculations is also
"         available: PSFnrc.mortran
"
"                                                       EMH, October, 2003
;
"*******************************************************************************
"*******************************************************************************
"                                TITLE
"                                *****
"*******************************************************************************
"
"CARD TI1
"
"       TITLE          (C)  TITLE OF THE INPUT FILE (FORMAT= '80A1')
;
"*******************************************************************************
"
" I/O DELIMETERS:    :start I/O control:
"                    :stop I/O control:
"
"*******************************************************************************
"                       INPUT/OUTPUT CONTROL INPUT
"                       **************************
"*******************************************************************************
"
"CARD IO1
"
"  IWATCH= off         (0)  FOR NORMAL OUTPUT
"        = interactions(1)  OUTPUT ON EVERY DISCRETE INTERACTION
"        = steps       (2)  OUTPUT ON EVERY ELECTRON/PHOTON STEP AS WELL
"        = deposited   (3)  PRINTS OUT ONLY WHEN ENERGY IS DEPOSITED
"        = graph       (4)  PRINTS OUT FILE FOR GRAPHICS
"
"  STORE INITIAL RANDOM NUMBERS
"        = no          (0)  DO NOT STORE THE INITIAL RANDOM NUMBERS
"        = last        (1)  STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
"        = all deposited (2)STORE THE INITIAL RANDOM NUMBER FOR ALL
"                           THAT DEPOSIT ENERGY IN THE CAVITY
"        = all         (3)  STORE ALL THE INITIAL RANDOM NUMBERS
"
"  IRESTART
"        = first       (0)  FIRST RUN FOR THIS DATA SET
"        = restart     (1)  RESTART OF A PREVIOUS RUN
"        = make        (2)  JUST CREATE THE INPUT FILE AND EXIT
"        = analyze     (3)  JUST READ IN THE RAW DATA AND DO THE STATISTICAL
"                           ANALYSIS
"        = for graphics(4)  READ STARTING RANDOM NUMBERS FROM A FILE (e.g. FOR
"                           OUTPUT TO A GRAPHICS PACKAGE)
"
"  OUTPUT OPTIONS
"        = short              (0)  SHORT OUTPUT -JUST THE CAVITY SUMMARY
"                                  AND THE DOSE GRID.
"        = cavity details     (1)  ABOVE PLUS DETAILS FOR EACH CAVITY ZONE
"
"  STORE DATA ARRAYS
"        = yes             (0) Store data arrays for re-use
"        = no              (1) don't store them
;
"*******************************************************************************
"
" MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
"                            :stop Monte Carlo inputs:
"
"*******************************************************************************
"                       MONTE CARLO CONTROL INPUT
"                       *************************
"*******************************************************************************
"
"CARD MC1
"
"  NUMBER OF HISTORIES         (I)  # HISTORIES TO RUN
"                                   (MIN:100, DEFAULTS TO 20 000)
"
"  INITIAL RANDOM NO. SEEDS    (M2) IXX, JXX
"               IXX   RANDOM NUMBER INITIAL SEED, MUST BE AN ODD INTEGER
"               JXX   0 OR EVEN INTEGER
"
"  MAX CPU HOURS ALLOWED       (I)  MAX CPU TIME ALLOWED IN HOURS, DEFAULT=0.99
"
"  IFULL
"         = dose and stoppers         (0) just calculate total dose and that due
"                                         to stoppers and discards.
"         = Aatt and Ascat            (1) Above plus Aatt, Ascat
"         = Ap                        (2) Above plus Ap as well
"         = Afl and <s>g w            (3) Above plus Afl and <s>g,w as well
"
"  NOTE THAT IFULL>=2 DOES NOT WORK YET -- JT
"
"  STATISTICAL ACCURACY SOUGHT        (R) % statistical accuracy of the total
"                                         dose in the peak region that is sought
"                                         The program executes until this
"                                         accuracy is obtained ot the CPU time
"                                         runs out.
"
"  PHOTON REGENERATION
"         = yes (ifano = 1) the calculation is performed with regeneration
"                           of the parent photon after they have interacted. A
"                           typical setting when FANO conditions are examined.
"         = no (ifano = 0)  a normal calculation.
"
"*******************************************************************************
"*******************************************************************************
"
" GEOMSPH DELIMETERS:    :start geometrical inputs:
"                       :stop geometrical inputs:
"
"*******************************************************************************
"                  SPHERICAL GEOMETRY & MATERIAL INPUT
"                  *************************************
"
"CARD CGM1
"
"  NUMBER OF CONES        (M)   number of cones (individual or by group)
"                               If omitted or ZERO, pure spherical geometry
"                               assumed.
"
"  ANGLES                 (M)   ANGLES defining the geometry (reals)
"                               No needed in pure spherical geometries.
"
"                               For group input there must be as many entries
"                               as for the NUMBER OF CONES, i.e. :
"                               NCON1,NCON2,...,NCONn
"                               DANG1,DANG2,...,DANGn
"
"                               For individual input, ncones must be equal
"                               to the number of entries, i.e.:
"                               ncones
"                               DANG1, DANG2,...,DANGncones
"
"  NUMBER OF SPHERES      (M)   number of spheres (individual or by group)
"
"                               For individual inputs, number of spheres
"                               can be omitted
"
"
"  RADII                  (M)   radii of spheres defining the geometry (reals)
"
"                               For group input there must be as many entries
"                               as for the NUMBER OF SPHERES, i.e. :
"                               NSPH1,NSPH2,...,NSPHn
"                               DRAD1,DRAD2,...,DRADn
"
"  CAVITY ZONES           (M)   geometrical zone numbers in the cavity (reals)
"
"*******************************************************************************
"                                MATERIAL INPUT
"                                **************
"*******************************************************************************
"
"CARD M1
"
"  MEDIA                  (M)   TYPE OF MATERIAL (FMT='24A1')
"                               BY CONVENTION THE PRIMARY WALL
"                               MATERIAL IS FIRST, THE CAVITY MATERIAL
"                               IS SECOND AND THE REST FOLLOWS
"
"*******************************************************************************
"
"CARD M3-A  (CHOICE OF CARD M3-A AND CARD M3-B)
"
"  MEDNUM                 (M)   THE MATERIAL NUMBER (INTEGERS)
"                               (MEDNUM=0 TO SKIP)
"  START REGION           (M)   INITIAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"  STOP REGION            (M)   FINAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
;
"*******************************************************************************
"
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"*******************************************************************************
"                             SOURCE INPUT
"                            **************
"*******************************************************************************
"CARD SC1       FOR ALL SOURCES
"                                      CHARGE OF THE INCIDENT BEAM
"  INCIDENT PARTICLE= electron   (-1)  ELECTRONS
"                     photon     (0)   PHOTONS
"                     positron   (1)   POSITRONS
"
"  (IF SOURCE 21)     all        (2)   INCLUDE ALL OF THE PARTICLES
"                                      IN THE PHASE SPACE FILE
"
"  SOURCE NUMBER                 (I)   NUMBER OF THE SOURCE
"
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"FOR ALL SOURCES
"                                      Charge of the incident beam
"  INCIDENT PARTICLE= electron   (-1)  electrons
"                     photon     (0)   photons
"                     positron   (1)   positrons
"
"  SOURCE NUMBER                 (I)   number of the source
"                                      [ISOURC]
"
;
"------------------------------------------------------------------------------
"
" SOURCE 0:    FOR PARALLEL BEAM FROM ANY ANGLE
"              RBEAM,UINC,VINC,WINC
"               RBEAM   RADIUS OF THE BEAM AT THE FRONT OF THE TARGET IN CM
"                               DEFAULTS TO MAX RADIUS
"               UINC    INCIDENT X-AXIS DIRECTION COSINE
"               VINC    INCIDENT Y-AXIS DIRECTION COSINE
"               WINC    INCIDENT Z-AXIS DIRECTION COSINE
"                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
"                             DEFAULTS TO (0.0,0.0,1.0)
;
"------------------------------------------------------------------------------
"
" SOURCE 1:   FOR POINT SOURCE INCIDENT FROM ANY ANGLE
"             DISTR,RBEAM,UINC,VINC,WINC
"               DISTR   DISTANCE OF THE SOURCE FROM THE MIDDLE OF THE TARGET
"                       IN CM (DEFAULTS TO 100.)
"               RBEAM   RADIUS OF THE BEAM AT THE FRONT OF THE TARGET IN CM
"                               DEFAULTS TO MAX RADIUS
"               UINC    INCIDENT X-AXIS DIRECTION COSINE
"               VINC    INCIDENT Y-AXIS DIRECTION COSINE
"               WINC    INCIDENT Z-AXIS DIRECTION COSINE
"                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
"                             DEFAULTS TO (0.0,0.0,1.0)
;
"------------------------------------------------------------------------------
"*******************************************************************************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and default parameters assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  You can change this by including the statement
"
"  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
"
"  in your input file.
"
"  Currently, the following options are available (except for a few entries,
"  case does not matter):
"
"       Global ECUT=     Set a global (in all regions) electron transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Set a global (in all regions) photon transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Set a global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions will
"                        be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Set the maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%)
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        even in `well conditioned' situations (e.g. depth
"                        dose curves for RTP energy range electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If On, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but signifficant in the keV energy range.
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski or penelope.  If set to On or ik, then
"                        use Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then use the cross-sections of
"                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
"                        Similar for kolbenstvedt, gryzinski and penelope.
"                        This is only of interest in kV X-ray calculations.
"                        Note that the user can supply their own EII
"                        cross-section data as well. The requirement is that
"                        the file eii_suffix.data exists in the $HEN_HOUSE/data
"                        directory, where suffix is the name specified.
"                        Entry case-sensitive except for Off, On or ik.
"                        [ eii_flag ]
"       Bound Compton scattering=  On, Off, Simple or norej
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impuls approximation. Default is On.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to turn on for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Pair angular sampling= Off, Simple or KM
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.
"                        Default is Simple, make sure you always use Simple or
"                        KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel--the default), epdl (Evaluated Photon
"                        Data Library), xcom and pegs4.  Allows the use of
"                        photon cross-sections other than from the PEGS4 file
"                        unless the pegs4 option is specified.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering,
"                        even if no Rayleigh data in PEGS4 file.
"                        Default is Off. Should be turned on for low energy
"                        applications. If custom, user must provide media names
"                        and form factor files for each medium.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"       Atomic relaxations= Off, On
"                        Default is On. The effect of using On is twofold:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross seections
"                        - Shell vacancies created in photo-absorption events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         Make sure to turn this option on for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"                         can also be turned On/Off on a region-by-region
"                         basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use
"
"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn off in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"*******************************************************************************
"
"                    VARIANCE REDUCTION
"                    ******************
"
"  Delimeter:       :start variance reduction:
"                   :stop variance reduction:
"
"  ELECTRON RANGE REJECTION
"         = off        (0)  No electron range rejection
"         = on         (1)  Do electron range rejection.
"                           There are 2 components to range rejection.
"                           One uses the EGSnrc range rejection below ESAVEIN
"                           and terminates any charged particle which cannot get
"                           out of its local region.
"                           The second component terminates any charged particle
"                           which cannot reach the cylinder which encloses the
"                           cavity region and any other region of the same
"                           material as the cavity.  This cylinder is determined
"                           automatically.
"                           The parameter ESAVEIN also plays a role (see below)
"                           [IREJCT]
"
"  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
"                           electron  when E< ESAVEIN and RANGE < CDIST
"                           where CDIST is closest distance to region of
"                           interest specified below. This ignores brem
"                           losses below ESAVEIN.
"                           This parameter must be input even if not used.
"                           Note - ESAVEIN is total energy (with 511 keV)
"
"  EXPONENTIAL TRANSFORM C     (R)
"                           PARAMETER FOR PATHLENGTH BIASING <0 FOR SHORTENING
"                           IF 0.0, NO BIASING DONE
;
"
"  PHOTON FORCING
"        = Off         (0)    NORMAL PHOTON TRANSPORT (NO FORCING)
"        = On          (1)    FORCE PHOTON INTERACTIONS EXPLICITLY
"                             MUST SET START AND STOP FORCING IN THIS CASE
"
"  START FORCING       (I)    NUMBER OF PHOTON INTERACTION/HISTORY AT WHICH
"                             TO START FORCING PHOTON INTERACTIONS
"
"  STOP FORCING AFTER  (I)    NUMBER OF PHOTON INTERACTION/HISTORY AFTER WHICH
"                             TO STOP FORCING PHOTON INTERACTIONS
"
"                             STOP FORCING AFTER > OR = START FORCING
"
"*****************************************************************************"
"
"                       USER DEFINED MACROS
"                       *******************
"
;
"******************************************************************************
;
REPLACE {$ONE-EPS} WITH {0.9999} "USED TO KEEP THE BEAM INSIDE THE TARGET"
REPLACE {$NSWTCH} WITH {8}       "# OF NRC SWITCHES FOR CONTROLLING SCATTERING"
REPLACE {$MXMED} WITH {3}        "MAX # OF MEDIA"
REPLACE {$MXREG} WITH {50}       "#REGIONS, $MAXRADII*$MAXCDOSE+1(VAC)"
REPLACE {$STAT} WITH {10}        "# BINS FOR UNCERTAINTY ANALYSIS"
REPLACE {$NBATCH} WITH {10}      "OUTPUT BATCHES                 "
REPLACE {$MXDATA} WITH {490}     "MAXIMUM DATA POINTS FOR ANALYSIS (i.e."
"                                     ($MXREG-1)*$STAT)"
REPLACE {$MXSTACK} WITH {2000}     "MAXIMUM STACK"
REPLACE {$MAXCDOSE} WITH {7}     "MAX # OF DOSE SCORING CONICAL ZONES"
REPLACE {$MAXCANGLE} WITH {6}    "MAX # OF CONICAL BOUNDARIES (i.e.$MAXCDOSE-1)"
REPLACE {$MAXRADII} WITH {7}     "MAX # OF DOSE SCORING RADIAL ZONES"
REPLACE {$MAXRADII+1} WITH {8}   "MAX # OF DOSE SCORING RADIAL ZONES + 1"
REPLACE {$MAXRC} WITH {7}        "MAX(MAXRADII,MAXCDOSE)"
REPLACE {$MXRDIST} WITH {1000}   "# OF POINTS IN RADIAL DISTRIBUTION FIT"
REPLACE {$MAXIT} WITH {6}        "MAX # OF PARAMETERS TO BE SCORED"
"                                (1) PRIMARY EDEP TO GAS"
"                                (2) SECONDARY EDEP TO GAS"
"                                (3) UNATTENUATED PRIMARY EDEP TO GAS"
"                                     - PRIMARY EDEP TO GAS"
"                                (4) (R**2-R0**2)(UNATTENUATED PRIMARY"
"                                     EDEP TO GAS)"
"                                (5) UNSOURCED UNATTENUATED PRIMARY EDEP TO"
"                                     GAS WITH GAS MATERIAL REPLACED BY WALL"
"                                     MATERIAL"
"                                (6) UNSOURCED UNATTENUATED PRIMARY EDEP TO"
"                                     WALL MATERIAL WITH GAS MATERIAL REPLACED"
"                                     BY WALL MATERIAL"
REPLACE {$MAXCMPTS} WITH {$MAXIT}  "FOR THE GRID OUTPUTS"
;
"MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
REPLACE {$HATCH-USER-INPUT-INIT;} WITH
{;
DO J=1,$MXREG
[
  IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
]
LATCHI=0.0;
;}
"  IF(ESTEPR(J)<=0.0) [ESTEPR(J)=1;] <=== removed this since ESTEPR is not used"
;
"THIS APPENDS COMIN/GEOM/ TO $COMIN-PHOTON;"
"THIS IS NECESSARY SO THAT THE CORRELATIONS CAN BE PROPERLY HANDLED."
"Found a better idea to use APPEND instead of REPLACE, IK Oct 97"
APPEND {;COMIN/GEOM,SCORE/;} TO {$COMIN-PHOTON;}
;

"Define variables used in $SELECT-PHOTON-MFP in order to "
"use implicit data types, IK Nov 97"
APPEND
{;
$REAL DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG;
$INTEGER IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP;
$REAL    d_eta,eta_prime,dpmfp_old,
         x_save,y_save,z_save,u_save,v_save,w_save,
         e_save,wt_save,wt_start,a_survive;
real*8   ftmp;
$INTEGER ir_save,ip,i_split,np_start,latch_save,i_survive,i_survive_s;
;} TO
{$DEFINE-LOCAL-VARIABLES-PHOTON;}
;

"MACRO USED FOR FORCING INTERACTIONS IN THE GEOMETRY"
"USED BY EGS4 FOR VARIANCE REDUCTION"
REPLACE {$SELECT-PHOTON-MFP;} WITH {;

  IF( n_split > 1 ) [  "we use photon splitting instead of interaction"
                       "forcing. This is much more efficient as it "
                       "always gives interactions in the chamber "
                       "(provided n_split is large enough) and does"
                       "not lead to varying weights"
      np_start = np; wt_start = wt(np);
      :START-MFP-LOOP:;

      $RANDOMSET RNNO35;
      rnno35 = rnno35/n_split;
      d_eta = 1./n_split;
      x_save = x(np); y_save = y(np); z_save = z(np);
      u_save = u(np); v_save = v(np); w_save = w(np);
      e_save = e(np); wt_save = wt(np)/n_split; ir_save = ir(np);
      latch_save = latch(np);
      np = np-1;
      i_survive = -1;
      IF( iifano = 1 | (ifull = 1 & latch_save ~= 3) ) [
          $RANDOMSET xxx; a_survive = xxx*n_split;
          i_survive = 1 + a_survive;
      ]
      IF( iifano = 1 | latch_save = 2 ) [ i_survive_s = -1; ]
      ELSE [
          $RANDOMSET xxx; a_survive = xxx*n_split;
          i_survive_s = 1 + a_survive;
      ]

      dpmfp_old = 0;
      eta_prime = 1 - rnno35 + d_eta;
      DO i_split = 1,n_split [
          eta_prime = eta_prime - d_eta;
          IF(eta_prime <= 0 ) goto :END-MFP-LOOP:;
          dpmfp = -log(eta_prime) - dpmfp_old;
          dpmfp_old = dpmfp_old + dpmfp;
          np = np+1;
          IF( np > $MXSTACK ) [
              write(6,*) ' Stack overflow in $SELECT-PHOTON-MFP ';
              stop;
          ]
          x(np) = x_save; y(np) = y_save; z(np) = z_save;
          u(np) = u_save; v(np) = v_save; w(np) = w_save;
          wt(np) = wt_save; e(np) = e_save; iq(np) = 0; ir(np) = ir_save;
          latch(np) = latch_save;
          irl = ir(np); irold = irl; medium = med(irl);
          LOOP [
              IF( medium ~= 0 ) [
                  $SET INTERVAL GLE,GE;
                  $EVALUATE GMFPR0 USING GMFP(GLE);
                  $SET-RHOF;
                  GMFP=GMFPR0/RHOF;
                  $RAYLEIGH-CORRECTION;
                  TSTEP=GMFP*DPMFP;
              ]
              ELSE [ TSTEP=VACDST; ]
              irnew = irl; idisc = 0; ustep = tstep; tustep = ustep;
              call howfar;
              x(np) = x(np) + u(np)*ustep;
              y(np) = y(np) + v(np)*ustep;
              z(np) = z(np) + w(np)*ustep;
              IF( idisc > 0 ) [
                  np = np-1;
                  IF( np = 0 ) [
                      ircode = 2; return;
                  ]
                  goto :END-MFP-LOOP:;
              ]
              IF( medium ~= 0 ) dpmfp = dpmfp - ustep/gmfp;
              IF( irnew ~= irold ) [
                  ir(np) = irnew; irl = irnew; irold = irnew;
                  medium = med(irl);
              ]
          ] UNTIL (medium ~= 0 & dpmfp < $EPSGMFP);
          x_save = x(np); y_save = y(np); z_save = z(np);
          ir_save = ir(np);
          IF(IRAYLR(IRL).EQ.1) [
              $RANDOMSET RNNO37;
              IF (RNNO37.LE.(1.0-COHFAC)) [
                  IF( i_split ~= i_survive_s ) [
                      np = np-1; goto :JUST-RAYLEIGH-EVENT:;
                  ]
                  wt(np) = wt(np)*n_split; latch(np) = 3;
                  :RAYLEIGH-SAMPLING-LOOP: LOOP [
                      $RANDOMSET XXX;
                      $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
                      Q2=X2*RMSQ/(20.60744*20.60744);
                      COSTHE=1.-Q2/(2.*E(NP)*E(NP));
                      IF (ABS(COSTHE).GT.1.0) GO TO :RAYLEIGH-SAMPLING-LOOP:;
                      CSQTHE=COSTHE*COSTHE;
                      REJF=(1.0+CSQTHE)/2.0;
                      $RANDOMSET RNNORJ;
                  ] UNTIL (RNNORJ <= REJF);
                  SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
                  goto :JUST-RAYLEIGH-EVENT:;
              ]
          ]
          $RANDOMSET RNNO36;
          $EVALUATE GBR1 USING GBR1(GLE);
          IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )[
              call pair;
          ]
          ELSE [
              $EVALUATE GBR2 USING GBR2(GLE);
              IF (RNNO36.LT.GBR2) [ call compt; ]
              ELSE                [ call photo; ]
          ]
          "If ifano is on, we traw away all scattered photons"
          "if the latch of the photons is 2, it is a regenerated"
          "primary photon => we need to remove resulting scatter"
          "as well. To save some time, we also discard on the spot"
          "all electrons that can not get into the cavity, if"
          "rejection is on"
          ip = NPold;
          LOOP [
              IF( iq(ip) = 0 ) [
                  IF( i_split ~= i_survive_s ) [
                      IF( ip < np ) [
                          e(ip) = e(np); iq(ip) = iq(np);
                          u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                          wt(ip) = wt(np); latch(ip) = latch(np);
                      ]
                      np = np-1;
                  ]
                  ELSE [
                      wt(ip) = wt(ip)*n_split; latch(ip) = 3; ip = ip+1;
                  ]
              ]
              ELSE [
                  IF( irejct = 1 ) [
                      edep = e(ip) - prm;
                      elke = log(edep);
                      call range_rejection(elke,x(ip),y(ip),z(ip),
                                           ir(ip),iq(ip),idisc);
                      IF( idisc = 0 ) [ ip = ip+1; ]
                      ELSE [
                          IF( ip < np ) [
                            e(ip) = e(np); iq(ip) = iq(np);
                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
                            wt(ip) = wt(np); latch(ip) = latch(np);
                          ]
                          np = np-1;
                      ]
                  ] ELSE [ ip = ip+1; ]
              ]
          ] UNTIL (ip > np);

          :JUST-RAYLEIGH-EVENT:

          "IF( iifano = 1 | (ifull = 1 & latch_save ~= 3) ) [ "
          IF( i_split = i_survive ) [
             "Re-generate the original photon with prob."
             "1/n_split, so that we get back the original"
             "weight. This is necessary when ifano is set "
             "(i.e. dose calculation with attenuation and scatter removed)"
             "or ifull is 1 (i.e. user wants to get Awall in addition to"
             "the dose)"
             "$RANDOMSET xxx;"
             " IF(xxx*n_split < 1) ["
                  np = np + 1;
                  x(np) = x_save; y(np) = y_save; z(np) = z_save;
                  u(np) = u_save; v(np) = v_save; w(np) = w_save;
                  e(np) = e_save; ir(np) = ir_save;
                  IF( ifull = 1 ) [ latch(np) = 2; ]
                  ELSE            [ latch(np) = 0; ]
                  wt(np) = wt_save*n_split; iq(np) = 0;
              "]"
          ]

      ]
      :END-MFP-LOOP:;

      IF( np <= 0 ) [ ircode = 2; return; ]
      IF( iq(np) = 0 ) [
          peig = e(np); eig = peig; irl = ir(np); medium = med(irl);
          IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
          gle = log(eig);
          goto :START-MFP-LOOP:;
      ]
      return;
  ]
NFTIME=NFTIME+1;
$RANDOMSET RNNO35;

"------------------------------------------------------------"
"CHANGE: J.S. Aug 95                                         "
"FOLLOWING CHANGE IS JUST TO PREVENT FAKE TRANSPORT IN CASE  "
"OF CORRELATED Afl CALCULATIONS.                             "
"PREVIOUSLY THERE WAS:                                       "
"IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))["
"NOW THE WT(NP)==0 IS INCLUDED TO PREVENT THE FORCING MACRO  "
"FROM INFINITE LOOPING DURING FAKE TRANSPORT FOR CORRELATED  "
"Afl CALCULATIONS WHEN SWITCHED TO PARALLEL BEAMS            "
"------------------------------------------------------------"
IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN).
 OR.(WT(NP).EQ.0))[
"------------------------------------------------------------"
"END OF CHANGE                                               "
"------------------------------------------------------------"
    IF(RNNO35 = 0.0)[RNNO35=1.E-30;]
    DPMFP=-LOG(RNNO35);
]
ELSE[
    IF (ISOURC.EQ.4) [
        DPMFP = 0.0;
        GOTO :SKIPFORCING:;
    ]
    DUMU=USTEP;
    DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);
    IRODUM=IROLD;IRNDUM=IRNEW;IRDUM=IR(NP);MEDDUM=MEDIUM;
    IDUM=IDISC;
    PATHL=0.0;MEDTMP=0;
    LOOP[
        USTEP=VACDST;
        IROLD=IR(NP);
        IF(NTRACK(IROLD).EQ.1)INEED2=1;
        MEDIUM=MED(IROLD);
        IF(MEDTMP.NE.MEDIUM)[
            MEDTMP=MEDIUM;
            $SET INTERVAL GLE,GE;
            $EVALUATE DELTAP USING GMFP(GLE);
            ]
        IF(IRAYLR(IROLD).EQ.1)[
            $EVALUATE COHFAC USING COHE(GLE);
            ]
        ELSE[
            COHFAC=1.0;
            ]
        CALL HOWFAR;
        IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
        "only add to pathl if not a vacuum"
        IF(IRNEW.EQ.1) EXIT;
        IR(NP)=IRNEW;
        X(NP)=X(NP)+USTEP*U(NP);
        Y(NP)=Y(NP)+USTEP*V(NP);
        Z(NP)=Z(NP)+USTEP*W(NP);
        ]
    USTEP=DUMU;
    X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;
    IROLD=IRODUM;IRNEW=IRNDUM;IR(NP)=IRDUM;MEDIUM=MEDDUM;
    IDISC=IDUM;
    IF(PATHL.LE.1.0E-3)[GWAIT=PATHL*(1.-0.5*PATHL);]
    ELSE[GWAIT=1.-EXP(-PATHL);]
    GWTOLD=WT(NP);
    WT(NP)=GWTOLD*GWAIT;
    :FASTSTEP:;EPSLON=RNNO35*GWAIT;
    IF(EPSLON.LE.1.0E-3)[
        IF(NFTIME.EQ.1)EXPMFP=EPSLON*(1.+EPSLON);
        DPMFP=EPSLON*(1.+0.5*EPSLON);
        ]
    ELSE[
        ARG=1./(1.-EPSLON);
        DPMFP=LOG(ARG);
        IF(NFTIME.EQ.1)EXPMFP=EPSLON*ARG;
        ]
    :SKIPFORCING:;
    ]
}
;

"THIS MACRO SETS THE PARAMETERS FOR FORCING THE INITIAL INCIDENT PHOTON TO
"INTERACT IN THE GEOMETRY FOR THE FRONTAL PARALLEL BEAM CASE. IT IS MUCH
"FASTER THAN THE GENERALIZED CODING IN THE $SELECT-MEAN-FREE-PATHS MACRO
" ***removed******

"MACRO THAT GETS CONE AND RADIUS NUMBERS FROM THE REGION NUMBER
REPLACE {$GET-IX-IC(#);} WITH {;IX=({P1}-2)/NC+1; IC={P1}-1-NC*(IX-1);}

;
"MACRO THAT GETS THE GEOMETRY NUMBER FROM THE CONICAL AND RADIAL ZONES
REPLACE {$GET-IRL(#,#);} WITH {;IRL={P1}+NC*({P2}-1)+1;}

;
"  In the new version of ELECTR, range is calculated prior "
"  $USER-RANGE-DISCARD ==> no necessity to calculate range "
"  IK, Dec 1998                                            "
"  **** RANGE REJECTION MACRO****"
REPLACE {$USER-RANGE-DISCARD;} WITH
{
    ;
    IF (irejct = 1)
    [
        "As tperp and range already known, check first for a simple"
        "range rejection in the present region                     "
        IF(tperp >= range)
        [
            idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            go to :USER-ELECTRON-DISCARD:
        ]
        "The following implements the original CAVRZ range rejection    "
        "but has a better range calculation (not just range in graphite)"
        "Note that initialize_range_rejection() must have been called   "
        call range_rejection(elke,x(np),y(np),z(np),ir(np),iq(np),idisc);
        IF( idisc ~= 0 ) [
            go to :USER-ELECTRON-DISCARD:
        ]
    ]
}
;
"THE FOLLOWING FIVE MACROS ARE FOR STATISTICAL ANALYSIS.

"STATS ANALYSIS FOR A 3-D ARRAY
REPLACE {$ANALYZE3 #(#;#;#) USING MODE #;} WITH {
$ANALYZE3 {P1}(1,{P2}/1,{P3}/1,{P4}) USING MODE {P5};}
;
REPLACE {$ANALYZE3 #(#,#/#,#/#,#) USING MODE #;} WITH {
;
NDATA=0;
DO I1={P6},{P7}[
    DO I2={P4},{P5}[
        DO I3={P2},{P3}[
            NDATA=NDATA+1;
            DO IS=1,$STAT[
                DATA(NDATA,IS)={P1}IS(I3,I2,I1,IS);
                ]
            ]
        ]
    ]
CALL SIGMA(NDATA,$STAT,{P8},IERR);
NDATA=0;
DO I1={P6},{P7}[
    DO I2={P4},{P5}[
        DO I3={P2},{P3}[
            NDATA=NDATA+1;
            {P1}(I3,I2,I1)=DATA(NDATA,1);
            {P1}UN(I3,I2,I1)=DATA(NDATA,2);
            ]
        ]
    ]
;}

;
"STATS ANALYSIS FOR A 1-D ARRAY
REPLACE {$ANALYZE1 #(#;) USING MODE #;} WITH {
;
$ANALYZE1 {P1}(1,{P2}) USING MODE {P3};
}
;
REPLACE {$ANALYZE1 #(#,#) USING MODE #;} WITH {
;
NDATA=0;
DO I1={P2},{P3}[
    NDATA=NDATA+1;
    DO IS=1,$STAT[
        DATA(NDATA,IS)={P1}IS(I1,IS);
        ]
    ]
CALL SIGMA(NDATA,$STAT,{P4},IERR);
NDATA=0;
DO I1={P2},{P3}[
    NDATA=NDATA+1;
    {P1}(I1)=DATA(NDATA,1);
    {P1}UN(I1)=DATA(NDATA,2);
    ]
;}

;
"STATS ANALYSIS FOR A REAL NUMBER
REPLACE {$ANALYZE0 # USING MODE #;} WITH {
;
NDATA=1;
DO IS=1,$STAT[
    DATA(NDATA,IS)={P1}IS(IS);
    ]
CALL SIGMA(NDATA,$STAT,{P2},IERR);
{P1}=DATA(NDATA,1);
{P1}UN=DATA(NDATA,2);
}


REPLACE {$CLEAN-STACK;} WITH {
;
NPSAVE=NP;
DO NP=1,$MXSTACK [
U(NP)=0.0;V(NP)=0.0;W(NP)=0.0;
X(NP)=0.0;Y(NP)=0.0;Z(NP)=0.0;
WT(NP)=0.0;IQ(NP)=0;LATCH(NP)=0;]
NP=NPSAVE;
;
}

%E     "cavsphnrc.mortran"
"                       COMMON BLOCK DEFINITIONS
"                       ************************

;
"CHARACTERS BLANK,*,A,B,C,D,I,M,R,S,T,U,V IN I*4(F4) OR CHARACTER(F77) FORM"
REPLACE {;COMIN/CHARS/;} WITH
"       ================
{;
$TYPE BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,
      TCHAR,UCHAR,VCHAR;
COMMON/CHARS/
BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,TCHAR,UCHAR,VCHAR;
}

;
"COMMON FOR THE ERROR ROUTINE"
REPLACE {;COMIN/ERROR/;} WITH {
;COMMON/ERROR/DATA($MXDATA,$STAT);
 $REAL DATA;
}
"       ================                                            "
"THE DATA ARRAY IS A GENERAL PURPOSE ARRAY TO TRANSPORT DATA BETWEEN"
"THE MAIN PROGRAM AND THE STATISTICS SUBROUTINE. ASSINGMENTS TO     "
"THE ARRAY ARE MADE IN THE $ANALYZE MACROS                          "

;
REPLACE {;COMIN/GEOM/;} WITH
"       ===============          "
{;
COMMON/GEOM/
TANALP(0:$MAXCANGLE),TANAL2(0:$MAXCANGLE),
COSALP(0:$MAXCANGLE),SINALP(0:$MAXCANGLE),
ALPHA(0:$MAXCANGLE),RSPH(0:$MAXRADII),
RSPH2($MAXRADII+1),
NTRACK($MXREG),NC,NR,NREG,NPLAN1,NPLAN2,IDNEAR;
$REAL TANALP, TANAL2, COSALP, SINALP, ALPHA, RSPH, RSPH2;
$INTEGER NTRACK,NC,NR,NREG,NPLAN1,NPLAN2,IDNEAR;
}
"
"GEOMETRICAL INFORMATION"
"TANALP(IC)    TANGENT OF THE OPENING ANGLE OF THE IC'TH CONE
"TANAL2(IC)    TANALP(IC)**2
"COSALP(IC)    COSINE OF THE OPENING ANGLE OF THE IC'TH CONE
"SINALP(IC)    SINE   OF THE OPENING ANGLE OF THE IC'TH CONE
"ALPHA(IC)     CONTAINS THE REAL VALUED COORDINATE OF THE IC'TH CONE
"RSPH(IX)      CONTAINS THE REAL VALUED COORDINATE OF THE IX'TH SPHERE
"RSPH2(IX)     =RSPH(IX)**2
"NTRACK(IRL)   =1 IF CAVITY REGION ELSE =0
"NC/NR         NUMBER OF CONICAL SLABS/SPHERICAL REGIONS DEFINING THE TARGET
"NREG          =NC*NR+1 (+1 FOR THE SURROUNDING VACUUM)
"NPLAN1        CONE REGION THAT HAS THE 90 DEGREE CONE AS THE GREATER CONE
"NPLAN2        NPLAN1+1

;
"FOUR COMMONS FOR INPUT AND OUTPUT"
REPLACE {;COMIN/IODAT1/;} WITH
"       =================
{;
LOGICAL*1 TITLE(80);
COMMON/IODAT1/TITLE;
}
"
"TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES
"DATEN,TIMEN : MACHINE VARIABLES FOR TIME AND DATE

;
REPLACE {;COMIN/IODAT2/;} WITH
"       ================
{;
COMMON/IODAT2/
AMASS($MAXCDOSE,$MAXRADII),TMCPUO,TIMMAX,STATLM,EIN,ECUTIN,PCUTIN,
RHOSAV($MXREG),cavreg($MXREG),MEDSAV($MXREG),
NCASE,NCASEO,NCASET,IDAT,IDORAY,IDOPES,IRESTART,IQIN,IVAL,
numcavreg,datcount;
$REAL     AMASS,TMCPUO,TIMMAX,STATLM,EIN,ECUTIN,PCUTIN,
          RHOSAV;
$INTEGER  cavreg,MEDSAV,IDAT,IDORAY,IDOPES,IRESTART,IQIN,IVAL,datcount;
$LONG_INT NCASE,NCASEO,NCASET;
$INTEGER  numcavreg; "moved from IODAT3 to IODAT2"
"Added type declarations from cavrznrc, EMH January 9 2002"
}
"
"AMASS(IC,IX)  MASS OF ZONE WITH COORDINATES (IC,IX)
"TMCPUO        CPU TIME USED IN PREVIOUS SESSIONS
"TIMMAX        MAXIMUM ALLOWED CPU HOURS FOR A GIVEN CALCULATION
"STATLM        TARGET STATISTICS IN CAVITY USED FOR AN EARLY EXIT
"EIN           KINETIC ENERGY OF THE EXTERNAL BEAM
"ECUTIN        GLOBAL ECUT FOR THIS SIMULATION
"PCUTIN        GLOBAL PCUT FOR THIS SIMULATION
"cavreg(NREG)  THE ARRAY OF ZONES COMPRISING THE CAVITY REGION
"MEDSAV(NREG)  SAVES MEDIUM NUMBERS FOR CORRELATION SCORING
"RHOSAV(NREG)  SAVES DENSITIES  FOR CORRELATION SCORING
"IDAT          = 0 STORE DATA ARRAYS FOR RE-USE
"              = 1 DON'T STORE THEM
"IDORAY        = 1 INCLUDES RAYLEIGH SCATTERING
"              = 0 DOES NOT INCLUDE RAYLEIGH SCATTERING
"IDOPES        = 1 INCLUDES PHOTOELECTRON ANGLE SELECTION
"              = 0 DOES NOT INCLUDE PHOTOELECTRON ANGLE SELECTION
"NCASE         NUMBER OF HISTORIES REMAINING TO BE DONE
"NCASEO        NUMBER OF HISTORIES DONE IN PREVIOUS SESSIONS
"NCASET        NUMBER OF HISTORIES ALREADY DONE
"IRESTART        = 0 => INITIAL RUN
"              = 1 => RESTARTED RUN
"              = 2 => CREATION OF INPUT FILE ONLY
"              = 3 => DATA ANALYSIS ONLY
"              = 4 => READ STARTING RANDOM NUMBERS FROM A FILE
"IQIN          CHARGE OF THE EXTERNAL BEAM
"numcavreg     NUMBER OF GEOMETRICAL ELEMENTS IN THE CAVITY

;
REPLACE {;COMIN/IODAT3/;} WITH
"       ================
{;
COMMON/IODAT3/
DOSE($MAXCDOSE,$MAXRADII,$MAXIT),
DOSEUN($MAXCDOSE,$MAXRADII,$MAXIT),
SCAV($MAXIT),SCAVUN($MAXIT),
TDA($MAXCDOSE,$MAXRADII,4),
TDAUN($MAXCDOSE,$MAXRADII,4),
TTDA(4),TTDAUN(4),
FMS,FMSUN,FMSC,FMSCUN,FN,FNUN,FD,FDUN,FCN,FCNUN,FCD,FCDUN,
FMM,FMMUN,FMMC,FMMCUN,FSM,FSMUN,FTM,FTMUN,FSMC,FSMCUN,FTMC,FTMCUN;
"numcavreg;"
"$INTEGER numcavreg;"
$REAL    DOSE,DOSEUN,SCAV,SCAVUN,TDA,TDAUN,TTDA,TTDAUN,
         FMS,FMSUN,FMSC,FMSCUN,FN,FNUN,FD,FDUN,FCN,FCNUN,FCD,FCDUN,
         FMM,FMMUN,FMMC,FMMCUN,FSM,FSMUN,FTM,FTMUN,FSMC,FSMCUN,FTMC,FTMCUN;
"Added type declarations from cavrznrc, EMH January 9 2002"
}

"
"DOSE                 THE SCORED QUANTITIES BY REGION AND MODE (IE. VALUE OF IT)
"DOSEUN               UNCERTAINTY IN DOSE
"SCAV                 TOTALS OF THE DOSE ARRAY FOR THE CAVITY REGION
"SCAVUN               UNCERTAINTY OF SCAV
"TDA                  DOSE/CORRECTIONS BY REGION AND CATEGORY.
"TDAUN                UNCERTAINTY IN TDA
"TTDA                 TOTALS OF THE TDA ARRAY FOR THE CAVITY REGION
"TTDAUN               UNCERTAINTY OF TTDA
"FMS                  AVERAGE RATIO OF NUMBER OF TIMES MULTIPLE SCATTERING
"                     SWITCHED OFF TO THE NUMBER OF STEPS TAKEN
"                     (FMSC FOR RATIO IN CAVITY REGION)
"FMS(C)UN             UNCERTAINTY IN THE RATIO FMS(C)
"FN                   AVERAGE NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF
"FD                   AVERAGE NUMBER OF STEPS TAKEN
"FCUN/FNUN            UNCERTAINTIES IN FN AND FD RESPECTIVELY
"FCN/FCD/FCNUN/FCDUN  CORRESPONDING QUANTITIES FOR CAVITY REGION
"
"FMM                  AVERAGE RATIO OF NUMBER OF TIMES MULTIPLE SCATTERING
"                     SWITCHED OFF TO THE NUMBER OF STEPS TAKEN
"                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
"                     (FMMC FOR RATIO IN CAVITY REGION)
"FMM(C)UN             UNCERTAINTY IN THE RATIO FMM(C)
"                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
"FSM                  AVERAGE NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF
"                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
"FTM                  AVERAGE NUMBER OF STEPS TAKEN
"                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
"FSMUN/FTMUN          UNCERTAINTIES IN FSM AND FTM RESPECTIVELY
"                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
"FSMC/FTMC/...        CORRESPONDING QUANTITIES FOR CAVITY REGION
"  .. FSMCUN/FTMCUN   IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
"
;
REPLACE {;COMIN/IODAT4/;} WITH
"       =================   "
{;
COMMON/IODAT4/
DOSEIS($MAXCDOSE,$MAXRADII,$MAXIT,$STAT),SCAVIS($MAXIT,$STAT),
TDAIS($MAXCDOSE,$MAXRADII,4,$STAT),TTDAIS(4,$STAT),
ISTIS($STAT),ISTCIS($STAT),
IMSIS($STAT),IMSCIS($STAT),
ISMIS($STAT),ISMCIS($STAT),
IMMIS($STAT),IMMCIS($STAT);
$LONG_INT ISTIS,ISTCIS,IMSIS,IMSCIS,ISMIS,ISMCIS,IMMIS,IMMCIS;
DOUBLE PRECISION DOSEIS;
$REAL    SCAVIS,TDAIS,TTDAIS;
"Added type declarations from cavrznrc, EMH January 9 2002"
}
"JAN CHANGE: DOUBLE PRECISION ON DOSEIS IS AN EXTENSION"
"
"DOSEIS    SAME AS DOSE BUT BY STATISTICAL BIN (IE. DOSE = AVERAGE OF DOSEIS)
"SCAVIS    SAME AS SCAV BUT BY STATISTICAL BIN (IE. SCAV = AVERAGE OF SCAVIS)
"TDAIS     SAME AS TDA BUT BY STATISTICAL BIN (IE. TDA = AVERAGE OF TDAIS)
"TTDAIS    SAME AS TTDA BUT BY STATISTICAL BIN (IE. TTDA = AVERAGE OF TTDAIS)
"IST(C)IS  NUMBER OF STEPS (IN CAVITY REGION) BY STATISTICAL BIN
"IMS(C)IS  NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF (IN CAVITY REGION)
"          BY STATISTICAL BIN
"ISM(C)IS  NUMBER OF STEPS (IN CAVITY REGION) IN A CORRELATED RUN WITH THE
"          CAVITY FILLED WITH WALL MATERIAL BY STATISTICAL BIN
"IMM(C)IS  NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF (IN CAVITY REGION)
"          IN A CORRELATED RUN WITH THE CAVITY FILLED WITH WALL MATERIAL
"          BY STATISTICAL BIN

;
"PRINTER CONTROLS"
REPLACE {;COMIN/PRINTC/;} WITH {
  ;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
  $INTEGER ICHPIN,ILPIN,IOUT,IPAGE;
"Added type declarations from cavrznrc, EMH January 9 2002"
}
"       =================
"ICHPIN  NUMBER OF CHARACTERS PER INCH
"ILPIN   NUMBER OF LINES PER INCH
"IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
"IPAGE   =1 => PAGE THROW

;
REPLACE {;COMIN/RUSROU/;} WITH
"       =================
{;
LOGICAL RUSROU;
COMMON/RUSROU/RRZ,RRCUT,RUSROU;
$REAL RRZ,RRCUT;
"Added type declarations from cavrznrc, EMH January 9 2002"
}
"
"COMMON USED FOR RUSSIAN ROULETTE
"RRZ      COORDINATE OF PLANE AT WHICH RUSSIAN ROULETTE IS PLAYED
"RRCUT    SURVIVAL PROBABILITY AFTER CROSSING THE PLANE
"RUSROU   = .FALSE. => RUSSIAN ROULETTE WILL NOT BE PLAYED
"         = .TRUE.  => RUSSIAN ROULETTE WILL BE PLAYED

;
REPLACE {;COMIN/SCORE/;} WITH
"       ================
{;
COMMON/SCORE/
SCDOSE,OMEGIS($STAT),IST,ISTC,ISM,ISMC,IHSTRY,
IS,MXNP,IFULL,ISTORE,IWATCH,IOOPTN,IOUTSP,ifano;
REAL*8    SCDOSE($MAXCDOSE,$MAXRADII,$MAXIT);
$LONG_INT IST,ISTC,ISM,ISMC,IHSTRY;
$INTEGER  IS,MXNP,IFULL,ISTORE,IWATCH,IOOPTN,IOUTSP,ifano;
$REAL     OMEGIS;
"Added type declarations from cavrznrc, EMH January 9 2002"


" The following common is for an alternative calculation of   "
" D/Awall and D using cross section enhancement. If turned on "
" (by setting cs_enhance > 1), the photon cross section is    "
" multiplied with cs_enhance (this is accomplished via a      "
" modifcation of the $RAYLEIGH-CORRECTION nacro, see below).  "
" When an interaction occurs, the "
" electrons set in motion are given the weight 1/cs_enhance.  "
" The scattered photons are killed with probability           "
" 1/cs_enhance. If they survive, their latch variable is set  "
" to 3 so that they contribute only to the calculation of the "
" real dose. The original photons get their latch set to 1 or "
" 2 with the probability 1/cs_enhance and 1-1/cs_enhance, resp. "
" All brems and annihilation photons as well as relaxation    "
" particles get latch 3. The real dose to the cavity is then  "
" scored from particles with latch 0,1,3, the dose with       "
" attenuation and scatter removed from latch 0,1,2. That dose "
" is simply D/Awall, so that                                  "
"   Awall = dose(latch=0,1,3)/dose(latch=0,1,2)               "
"                                                             "
" <D> and <D^2> is scored in cav_dose and cav2_dose,          "
" <D/Awall> and <(D/Awall)^2> in cav_dose1 and cav2_dose1,    "
" <D*(D/Awall)> (the correlation) in cavc_dose. Scoring is    "
" done on a history-by-history basis using the technique first"
" proposed by the Barcelona group. To do so, last_case is the "
" last history that scored into the cavity, the_case is the   "
" current history.                                            "
"                                                             "
" I. Kawrakow, April 2001.                                    "
"                                                             "
common/score1/ cs_enhance,cav_dose,cav_dose1,cav2_dose,cav2_dose1,
               cav_dosec,tmp_dose,tmp_dose1,
               cav_dose0, cav2_dose0, cav_dosec01, tmp_dose0,
               cav_dose2, cav2_dose2, cav_dosec02, tmp_dose2,
               corr_02,
               the_case,last_case,cav_case,use_enhance;

real*8         cs_enhance,cav_dose,cav_dose1,cav2_dose,cav2_dose1,
               tmp_dose,tmp_dose1,cav_dosec,
               cav_dose0, cav2_dose0, cav_dosec01, tmp_dose0,
               cav_dose2, cav2_dose2, cav_dosec02, tmp_dose2,
               corr_02;

$LONG_INT      the_case,last_case,cav_case;
logical        use_enhance;

}

"extra scoring components to obtain Aatt and Ascat besides Awall"
"                                              EMH,January 2002"
"cav_dose     => total dose
"cav_dose0    => primary dose
"cav_dose1    => primary dose corrected for attenuation
"cav_dose2    => secondary dose

"cav2_dose    => total dose squared
"cav2_dose0   => primary dose squared
"cav2_dose1   => unattenuated primary  dose squared
"cav2_dose2   => secondary dose squared

"tmp_dose     => temporay arrays for scoring the different
"tmp_dose0       dose components using a history by history
"tmp_dose1       scoring scheme
"tmp_dose2

"cav_dosec    => correlation total - primary(unatttenuated)
"cav_dosec01  => correlation primary - primary (unattenuated)
"cav_dosec02  => correlation secondary - primary

"corr_02      => correlation primary - secondary

REPLACE {$RAYLEIGH-CORRECTION;} WITH {
  ;
  IF(IRAYLR(IRL).EQ.1) [
      $EVALUATE COHFAC USING COHE(GLE);
      GMFP=GMFP*COHFAC
  ];
  IF( use_enhance ) [ gmfp = gmfp/cs_enhance; ]
    " the above is for the cross section enhancement technique, see "
    " description around definition of common score1                "
};


"JAN CHANGE: HAVE CHANGED SCDOSE TO DOUBLE PRECISION"

"
"COMMON USED FOR SCORING IN AUSGAB
"SCDOSE  ACCUMULATES DOSE SCORED BY REGION OVER EACH BIN OF EACH BATCH
"OMEGIS  ACCUMULATES THE SOLID ANGLE OF THE TARGET
"IST(C)  NUMBER OF STEPS TAKEN (IN CAVITY REGION)
"ISM(C)  NUMBER OF STEPS TAKEN (IN CAVITY REGION) IN A CORRELATED RUN WITH
"        WALL MATERIAL IN THE CAVITY
"MXNP    MAXIMUM LEVEL TO WHICH THE STACK OF DAUGHTER PARTICLES FROM AN
"        INCIDENT PARTICLE RISES (STACK MAY INCLUDE INCIDENT PARTICLE)
"IFULL   = 0 JUST CALCULATE TOTAL DOSE AND THAT DUE TO STOPPERS
"            AND DISCARDS (THE DEFAULT)
"        = 1 ABOVE PLUS Aatt, Ascat
"        = 2 ABOVE PLUS Ap AS WELL
"        = 3 ABOVE PLUS Afl and <s>g,w AS WELL
"ISTORE  = 0 DO NOT STORE THE INITIAL RANDOM NUMBERS (THE DEFAULT)
"        = 1 STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
"        = 2 STORE THE INITIAL RANDOM NUMBER FOR ALL HISTORIES
"            THAT DEPOSIT ENERGY IN THE CAVITY
"        = 3 STORE ALL THE INITIAL RANDOM NUMBERS
"IWATCH  = 0 FOR NORMAL OUTPUT (THE DEFAULT)
"        = 1 OUTPUT ON EVERY DISCRETE INTERACTION
"        = 2 OUTPUT ON EVERY ELECTRON/PHOTON STEP AS WELL
"        = 3 PRINTS OUT ONLY WHEN ENERGY IS DEPOSITED
"        = 4 PRINTS OUT FILE FOR GRAPHICS
"IHSTRY  COUNTER FOR TOTAL NUMBER OF HISTORIES SUCCESSFULLY SIMULATED
"IOOPTN  = 0 SHORT OUTPUT (THE DEFAULT) -JUST CAVITY SUMMARY
"            AND THE MATERIAL GRID
"        = 1 ABOVE PLUS OUTPUT GRID
"IOUTSP  = 0 NO SPECTRUM DATA IN OUTPUT SUMMARY
"        = 1 INCLUDE SPECTRUM DATA IN OUTPUT SUMMARY

;
REPLACE{$SWITCH-TO-PARALLEL-BEAM-SOURCE;} WITH {;
DO I=1,23[SRCEQ(I)=SRCPAR(I);]DO I=1,2[ISRCEQ(I)=ISRCPR(I);];
ISOURC=ISRPAR;
}
;
;
REPLACE{$RECOVER-POINT-SOURCE;} WITH {;
DO I=1,23[SRCEQ(I)=SRCPT(I);]DO I=1,2[ISRCEQ(I)=ISRCPT(I);];
ISOURC=ISRPT;
"JAN CHANGE: ADDED FOR RECOVERY OF POINT SOURCE, AFTER SWITCH"
"            TO PARRALEL BEAM SOURCE                         "
IFPB=1;
"END OF JAN CHANGE"
}

;
"COMMONS USED FOR NON-MONOENERGETIC BEAM DATA                             "
"       NOTE MONOEN IS PASSED IN USER                                     "
"                                                                         "
REPLACE {$NENSRC} WITH {300}     "MAX # OF POINTS IN ENERGY DISTRIBUTION  "
"        =======                                                          "
REPLACE {$INVDIM} WITH {1000}    "DIMENSION CONTROLS GRID SIZE FOR INVERSE"
"        =======                                                          "
;
REPLACE {;COMIN/SPECTR/;} WITH
"       ================="
{;
COMMON/SPECTR/
CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
NENSRC;
$INTEGER NENSRC;
$REAL    CDFINV,ENSRCD,SRCPDF,SRCCDF;
"Added type declarations from cavrznrc, EMH January, 2002"
}
"CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
"SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
"SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION

" IK changed USER-MISC to USER for prestaII and included USERVR"
;
REPLACE {;COMIN/USER/;} WITH
"       ===================="
{
;
common/uservr/ cexptr,gwait,
               iforce,nfmin,nfmax,nftime,isourc,ifpb,iqinc,monoen,
               n_split,iifano;
$REAL cexptr,gwait;
$INTEGER iforce,nfmin,nfmax,nftime,isourc,ifpb,iqinc,monoen,
               n_split,iifano;

REPLACE {$MXRANGE} WITH {500}  "for range arrays used in range_rejection()"

COMMON/USERRR/
rangerr0($MXRANGE),rangerr1($MXRANGE),eker0,eker1,
r_cavity_min,r_cavity_max,ESAVEIN,IREJCT;
"CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,"
"MINZ,MAXZ,MINR,MAXR;"
$REAL rangerr0,rangerr1,eker0,eker1,r_cavity_min,r_cavity_max;
$REAL ESAVEIN;
$INTEGER IREJCT;
"                                                                            "
"COMMON USED FOR RANGE REJECTION                                             "
"ERANGE        ENERGY BOUNDARY FOR TWO-PIECE RANGE FIT USED FOR RANGE DISCARD"
"Z/RMINR/MAX   PLANE/CYLINDER COORDINATES OF THE MIN/MAX PLANES/CYLINDERS    "
"              FOR RANGE REJECTION                                           "
"ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                        "
"MIN/MAX/Z/R   MIN/MAX PLANE/CYLINDER NUMBERS OF RANGE REJECTION REGION      "
"IREJCT        = 0 => NO ELECTRON RANGE REJECTION                            "
"              = 1 => DO ELECTRON RANGE REJECTION OUTSIDE CAVITY             "
"              = 2 => ON SECOND PASS, DO IT IN THE CAVITY AS WELL            "
"FOR THE REMAINING VARIABLES SEE DOCUMENTATION IN SUBROUTINE INPUTS          "
;
COMMON/USERMI/
EXPMFP,GWTOLD,IDECAV,INEED2,IPASS,INOCAV,NOSCT2,INOMED,IPTSRC,icsda;
$REAL EXPMFP,GWTOLD;
$INTEGER IDECAV,INEED2,IPASS,INOCAV,NOSCT2,INOMED,IPTSRC,icsda;
}

"                                                                        "
"COMIN/USER-MISC/USERMI  EXTRA USER COMMON FOR CAVITY                    "
"EXPMFP   EXPONENTIAL MEAN-FREE-PATH USED FOR INTERACTION FORCING
"GWTOLD   OLD WEIGHT
" change for presta-II "
"ICSDA    CSDA CALCULATION ON(1) OR OFF(0)                              "
"                      "
"IDECAV   FLAG SET BY AUSGAB, CLEARED BY MAIN
"         = 0 => NO ENERGY DEPOSITED IN THE CAVITY
"         = 1 => ENERGY DEPOSITED IN THE CAVITY IN ANY FASHION        (IFULL<=1)
"         = 1 => PRIMARY ENERGY DEPOSITED IN THE CAVITY               (IFULL>=2)
"         = 2 => SECONDARY ENERGY DEPOSITED IN THE CAVITY             (IFULL>=2)
"         = 3 => PRIMARY AND SECONDARY ENERGY DEPOSITED IN THE CAVITY (IFULL>=2)
"INEED2   FLAG SET BY AUSGAB INDICATING NEED FOR A SECOND PASS IF Afl
"         IS TO BE CALCULATED
"         = 0 => NO NEED FOR THIRD PASS
"         = 1 => A SECOND PASS IS NEED (A PRIMARY ELECTRON HAS HIT THE CAVITY
"                OR A PRIMARY PHOTON IS DIRECTED AT THE CAVITY)
"IPASS    FLAG USED FOR CORRELATED SAMPLING
"         = 0 => PRESENTLY EXECUTING THE FIRST PASS
"         = 1 => PRESENTLY EXECUTING THE SECOND PASS (TO CALCULATE Apn)
"         = 2 => PRESENTLY EXECUTING THE THIRD  PASS (TO CALCULATE Afl)
"                (NOTE: FOR PARALLEL BEAMS THERE IS NO SECOND PASS)
"INOCAV   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN THE CAVITY
"NOSCT2   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN A CORRELATED
"         RUN WITH THE CAVITY REPLACED BY WALL MATERIAL (THIRD PASS ONLY)
"INOMED   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN THE CAVITY
"         REGION IN A CORRELATED RUN WITH THE CAVITY REPLACED BY WALL MATERIAL
"         (THIRD PASS ONLY)
"IPTSRC   FLAG USED TO INDICATE A POINT SOURCE DISTRIBUTION WAS USED
"         = 0 => BROAD PARALLEL OR UNIFORM BEAM SOURCE DISTRIBUTION
"         = 1 => POINT SOURCE DISTRIBUTION

" The following is an addition taken from dosrzII (Apr, 23,97)         "
" for PRESTA-II                                                        "
"THIS MACRO ALLOW THE USER TO SWITCH ON CSDA CALCULATIONS.             "
"THE MEAN FREE PATH IS SET TO INFINITY AND THE PROPER CSDA STOPPING    "
"POWERS SHOULD BE USED HAVING BEEN CREATED BY PEGS4 VIA IUNRST = N.    "
;
REPLACE {$SELECT-ELECTRON-MFP;} WITH {;
    IF(ICSDA.EQ.0)[
        ;$RANDOMSET RNNE1;IF(RNNE1.EQ.0.0)[RNNE1=1.E-30;]
        "DEMFP=AMAX1(-ALOG(RNNE1),$EPSEMFP);"
        DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);
        ]
    ELSE[
        DEMFP=VACDST;
        ]
;}

"END OF MACRO DEFINITIONS

"                       DATA DECLARATIONS
"                       *****************

$IMPLICIT-NONE;

"***************************************************************************"
"*             Variables passed to the subroutine GET_INPUTS               *"
"***************************************************************************"
REPLACE {$NMAX} WITH {100}  "max number of inputs"
REPLACE {$NVALUE} WITH {100}  "max number of values per input"

COMIN/GetInput/;
INTEGER MAKE_IT_AN_INT;
"******************************************************* ADDED BY JT, DEC.98"
"*                Variables for post-processing parallel run               *"
"***************************************************************************"
"$INTEGER   DATCOUNT;                      T>number of .egs4dat files
"datcount used to be a local variable that holds the number of parallel"
"jobs if irestart=5. As now data file reading from parallel runs is done"
"in a separate routine, it must go into a common block as it is used in"
"main."

"extra components added    "
"to obtain Aatt and Ascat  "
"with a history by history "
"scoring scheme            "
"            EMH March 2002"
real*8 tcav_dose,tcav2_dose,tcav_dose1,tcav2_dose1,tcav_dosec;
real*8 tcav_dose0,tcav2_dose0,tcav_dose2,tcav2_dose2,tcav_dosec01,tcav_dosec02;
"***************************************************************************"

$DECLARE_TIMING_VARIABLES;

$LONG_INT ITEMP;
$INTEGER NETADJ,ITMAX,IC,IX,IT,I,J,JJ,LGLE,IRL,MEDNUM,I1,I2,I3,
         IBATCH,IBTCH,NOSCAT,ICASE,NPSAVE,ICAV,NDATA,IERR;
$REAL TIMCPU,TIMEB,ETIMETOT,RATIO,BATCHT,TEMP,TEMP1,TEMP2,TEMP3,TEMP4,TEMP5;

$INTEGER NBATCH;"no. of histories per batch, per statistical bin"
"$INTEGER JCASE; no. of histories per batch <=== used in other NRC user-codes"
"                                                Batch and hist/hist scoring"
"                                                still co-exist"

$INTEGER ISTAT;

$REAL XIN,YIN,ZIN,UIN,VIN,WIN;
$INTEGER IRIN,NRCFLG;

$INTEGER IDECV1;

$REAL EI,EKMAX,DEPTH,VOLUME,RLOW2;
$REAL WEIGHT,PATHL,DELTAP,COHFAC;

$REAL DISTRZ,FMASSC,FMASS,AINFLU_CURRENT,FLURAT;
$INTEGER ISUMX,IRNG;

$REAL DCAV,DCAVUN,DCAV_SEC,DCAV_SECUN,DCAV_CURRENT,FR_SEC;

"**********************************************************************"
$REAL    CMINC,SMINC,CMAXC,SMAXC,RMINR2,RMAXR2,DELCOS,RINNER,R2POM0;
$INTEGER MINC, MAXC, ISRCDV;
"Added type declarations, EMH January, 2002"
"**********************************************************************"

REAL*4
    GWATE($MAXRADII), "PHOTON INTERACTION FORCING WEIGHTING FACTORS FOR
                      "NORMALLY INCIDENT PARALLEL BEAMS
"change: DCAVIS is now defined as TOTAL energy deposited, not only
"primary energy (used for display purposes only) (JAN)
    DCAVIS($STAT),    "TOTAL ENERGY DEPOSIT PER STATISTICAL BATCH USED TO
                      "TEST EARLY QUIT
    DCAV_SECIS($STAT),"ENERGY DEPOSIT SECONDARIES PER STATISTICAL BATCH ADDED
                      "TO FRACTION OF SEC DOSE IN THE FLY (FOR DISPLAY
                      "PURPOSES ONLY)
    FMSIS($STAT),     "FRACTION MULTIPLE SCATTERING SWITCHED OFF
    FMSCIS($STAT),    "FRACTION MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
    FDIS($STAT),      "# OF CHARGED PARTICLE STEPS
    FNIS($STAT),      "# TIMES MULTIPLE SCATTERING SWITCHED OFF
    FCDIS($STAT),     "# OF CHARGED PARTICLE STEPS IN THE CAVITY
    FCNIS($STAT),     "# TIMES MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
    FMMIS($STAT),     "FRACTION MULTIPLE SCATTERING SWITCHED OFF
                      "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
    FMMCIS($STAT),    "FRACTION MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
                      "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
    FTMIS($STAT),     "# OF CHARGED PARTICLE STEPS
                      "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
    FSMIS($STAT),     "# TIMES MULTIPLE SCATTERING SWITCHED OFF
                      "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
    FTMCIS($STAT),    "# OF CHARGED PARTICLE STEPS IN THE CAVITY
                      "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
    FSMCIS($STAT);    "# TIMES MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
                      "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY

;
COMIN/
    BOUNDS,CHARS,EDGE,ELECIN,EPCONT,ERROR,GEOM,IODAT1,IODAT2,IODAT3,IODAT4,
    PRINTC,MEDIA,MISC,PHOTIN,RUSROU,SCORE,SOURCE,SPECTR,
    STACK,THRESH,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO/;
"                                                       ^    "
"                                                       |    "
"   EGSnrc opens units explicitly, i.e.,    ____________|    "
"   this COMMON block  contains information                  "
"   like extensions, unit numbers, file na-                  "
"   mes, etc.                                                "

"**********************************************************************"
"                EGSnrcMP variables and macros                         "
"**********************************************************************"
" I/O units "
$INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit;

external combine_results;

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler. The macro $HAVE_C_COMPILER is defined in
"    machine.macros and is either #define HAVE_C_COMPILER;, if a working
"    C compiler was found, or NULL if no working C compiler was found.
"
$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;

real*8  last_dose, last2_dose, tmpf;
$REAL   part_dose, part2_dose, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last, n_left;
$INTEGER  n_job;
$LOGICAL first_time;

#endif;

$LOGICAL is_finished;

"**********************************************************************"

"                       START OF EXECUTABLE CODE
"                       ************************


"**********************************************************************"
"            STEP 0 : Initialize the EGSnrc system                     "
"**********************************************************************"
call egs_init;
is_finished = .true.;
"**********************************************************************"

;
"INITIALIZE THE CHARACTER ARRAY"
BLANK=' ';
ASTER='*';
ACHAR='A';
BCHAR='B';
CCHAR='C';
DCHAR='D';
ICHAR='I';
MCHAR='M';
RCHAR='R';
SCHAR='S';
TCHAR='T';
UCHAR='U';
VCHAR='V';

$SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"

OUTPUT $MAXRADII,$MAXCDOSE;
(//' CAVSPHnrc(EGSnrc) '$VERSION' on '$MACHINE'.'//
T20,'Maximum number of radial and conical zones=',2I4);

"******************************************************************************
"
"                       *** SECTION 1 ***
"
"------------------------------------------------------------------------------
"
"READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
"
"------------------------------------------------------------------------------

IOUT=1; "OUTPUT FORTRAN UNIT NUMBER"

CALL INPUTS;

"CHECK FOR END-OF-FILE AND EXIT IF ENCOUNTERED
"error_flag comes back through common block get_input
IF(ERROR_FLAG=1)[
    OUTPUT;
    (//' *** END OF FILE IN SUBROUTINE INPUTS WAS REACHED ***'/
       ' *** OR A RESTART OF A CALCULATION WAS REQUESTED  ***'/
       ' *** WITH NO PREVIOUS DAT FILE                    ***'/
       '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'/);
    GOTO :END-OF-RUN:;"SIGNAL AN EARLY EXIT"
    "IRESTART=2; SIGNAL AN EARLY EXIT"
    ]

"OPEN A FILE FOR STORING OR READING RANDOM NUMBERS"
IF( istore > 0 ) [ "We want to store the rng state in a file"
    rng_unit = egs_open_file(2,0,1,'.egsrns');
]
ELSE IF( irestart = 4 ) [
    rng_unit = egs_open_datfile(2,0,1,'.egsrns');
]

IF(IRESTART.EQ.5)[
    call egs_combine_runs(combine_results,'.egsdat');

    NBATCH=0;      "DON'T WANT IT TO RUN ANY HISTORIES"
    NCASET=NCASEO; "To prevent a wrong normalization if some of the "
                   "parallel runs not available, IK, Jan 21 1999"

] "end of IRESTART = 5, DISTRIBUTED POST-PROCESSING"
ELSE [
    IF(NCASE/$STAT**2=0)[NCASE=$STAT**2;]
    NBATCH=NCASE/($STAT**2); "NUMBER OF HISTORIES IN EACH BIN PER BATCH
]

MXNP=0; "RESET THE MAXIMUM STACK INDICATOR"
IHSTRY=NCASEO; "RESET THE NUMBER OF HISTORIES COUNTER"

"CALCULATE THE NUMBER OF DOSE COMPONENTS"
IF(    IFULL.EQ.0)[ITMAX=2;]      "SCORE DOSE ONLY"
ELSEIF(IFULL.EQ.1)[ITMAX=3;]      "SCORE Ascat, Aatt AS WELL"
ELSEIF(IFULL.EQ.2)[ITMAX=4;]      "SCORE Apn as well"
ELSEIF(IFULL.EQ.3)[ITMAX=$MAXIT;] "SCORE Afl AND <s>g,w AS WELL"


"ZERO THE CAVITY SUMMARY ARRAY"
DO IT=1,ITMAX[DO IS=1,$STAT[SCAVIS(IT,IS)=0.0;]]

"SET UP AUSGAB CALLS"
DO J=1,5[IAUSFL(J)=1;]DO J=6,$MXAUS[IAUSFL(J)=0;] "NORMAL EXECUTION"

IF(IFULL.GE.1)[
    "THESE FLAGS ARE THE MINIMUM SET NEEDED TO IDENTIFY PRIMARY AND SECONDARY"
    IAUSFL(8) =1; "After BREMSSTRAHLUNG"
    IAUSFL(14)=1; "After ANNIHILATION IN FLIGHT"
    IAUSFL(15)=1; "After ANNIHILATION AT REST"
    IAUSFL(19)=1; "After COMPTON"
    IAUSFL(21)=1; "After Photo"
    iausfl(25)=1; "After Rayleigh"
]
"JAN CHANGE: DEBUGGING DIFFERENCES BETWEEN NON-CORR AND CORR RUNS"
"            We now switch off auscall on moller interaction"
"            because it led to differences in 1st pass transport"
"            when corr sampling was requested (ifull .ge. 2)"
"IF(IFULL.GE.2)["
   " THIS FLAGS IS NEEDED FOR CORRELATIONS"
   " IAUSFL(10) =1; MOLLER"
   " ]"

IF(ifano = 1)
[

    "AUSGAB will be responsible for making sure that the beam is not"
    "attenuated and getting rid of the scattered photons."
    iausfl(16) = 1; "Before pair"
    iausfl(18) = 1; "Before Compton"
    iausfl(19) = 1; "After Compton"
    iausfl(20) = 1; "Before photoelectric"
    iausfl(21) = 1; "After photoelectric"
    iausfl(24) = 1; "Before Rayleigh"
    iausfl(25) = 1; "After Rayleigh"

    "AUSGAB will be responsible for throwing away any photons resulting"
    "from a primary electron. ie. True equilibtrium requires that all"
    "energy deposition be local to the primary interaction site."
    iausfl(8)  = 1; "After bremsstrahlung"
    iausfl(14) = 1; "A positron has annihilated in-flight"
    iausfl(15) = 1; "A positron has annihilated at rest"
]

"**************************************"
"taken from cavrznrc, EMH, January 2002"
"**************************************"

IF( n_split > 1 ) [
    iausfl(8)  = 1; "After bremsstrahlung"
    iausfl(14) = 1; "A positron has annihilated in-flight"
    iausfl(15) = 1; "A positron has annihilated at rest"

    "With n_split > 1, we don't need the following calls even if ifano = 1"
    iausfl(16) = 0;
    iausfl(18) = 0;
    iausfl(20) = 0;
    iausfl(24) = 0;
    iausfl(25) = 0;

]

IF(ifano = 2) [

    "AUSGAB will be responsible for discarding energy due to electrons set"
    "in motion in the wall"
    iausfl(17) = 1; "After pair"
    iausfl(19) = 1; "After Compton"
    iausfl(21) = 1; "After photoelectric"

]

IF( use_enhance ) [
    iausfl(16) = 1; "Before pair"
    iausfl(18) = 1; "Before Compton"
    iausfl(19) = 1; "After Compton"
    iausfl(20) = 1; "Before photoelectric"
    iausfl(21) = 1; "After photoelectric"
    iausfl(24) = 1; "Before Rayleigh"
    iausfl(25) = 1; "After Rayleigh"
    iausfl(8)  = 1; "After bremsstrahlung"
    iausfl(14) = 1; "A positron has annihilated in-flight"
    iausfl(15) = 1; "A positron has annihilated at rest"
]

write(6,'(/a)')
'************************ IAUSFL ************************** ';
DO j=1,28 [
  IF( iausfl(j).ne.0 ) write(6,'(i3,$)') j;
]
write(6,'(/a//)')
'********************************************************** ';

"*****************************************"


"HATCH CALL PREPARATION AND EXECUTION"
"-------------------------------------

DUNIT=1; "SET LENGTH UNITS TO CMS"

"ELECTRON,PHOTON AND RANGE REJECTION CUTOFFS"
"DO I=2,NREG[ECUT(I)=ECUTIN;PCUT(I)=PCUTIN;ESAVE(I)=ESAVIN;]"
DO I=2,NREG[ECUT(I)=ECUTIN;PCUT(I)=PCUTIN;]
"changed by EMH, January 20002"

OUTPUT; (//'CALL TO HATCH AT  ',$); call egs_time(6); write(6,*);

CALL HATCH; "INPUT THE PEGS GENERATED DATA"

OUTPUT; (//'HATCH COMPLETED AT ',$); call egs_time(6); write(6,*);

IF( irejct = 1 ) [ call initialize_range_rejection; ]

IF(MONOEN.EQ.0) ["MONOENERGETIC INPUT BEAM"
    IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]
    EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
    ]
ELSE[ "ENERGY SPECTRUM"
    EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
    CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
    ]

"CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY RANGE REQUIRED"
DO I=1,NMED[
    IF((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))[
        OUTPUT I,EKMAX,UP(I),UE(I);
        (//1X,50('*')//
        ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MEV'/
        ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MEV'/
        '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
        1X,50('*')//);
        IRESTART=2; "SIGNAL AN EARLY EXIT"
        ]
    ] "END OF LOOP OVER MEDIA"

"CALCULATE THE MASS OF EACH ZONE
DO IC=1,NC[
    IF(NC.EQ.1)     [DELCOS=2.0;                    ]
    ELSEIF(IC.EQ.1) [DELCOS=1.0-COSALP(1);          ]
    ELSEIF(IC.EQ.NC)[DELCOS=COSALP(NC-1)+1;         ]
    ELSE            [DELCOS=COSALP(IC-1)-COSALP(IC);]
    DO IX=1,NR[
        $GET-IRL(IC,IX);
        MEDNUM=MED(IRL);
        IF(MEDNUM.NE.0)[
            IF(IX.EQ.1)[RINNER=0.0;       ]
            ELSE       [RINNER=RSPH(IX-1);]
            VOLUME=(TWOPI/3.)*DELCOS*(RSPH(IX)**3-RINNER**3);
            AMASS(IC,IX)=RHO(MEDNUM)*VOLUME;
            ]
        ELSE[
            AMASS(IC,IX)=0.0;
            ]
        ]"END OF IX LOOP"
    ]"END OF IC LOOP"

"CALCULATE ONE-TIME-ONLY CONSTANTS FOR SOURCE"
CALL SRCOTO(WEIGHT);

"CALCULATE THE SQUARE OF THE DISTANCE TO THE CENTER OF THE GEOMETRY AND"
"RESET THE FLUENCES TO THE CENTER OF THE CHAMBER FOR POINT SOURCES"
IF(ISRCTY.EQ.1)[ "POINT SOURCES"
    R2POM0=DISTR2;ISRCDV=1;
    ]
ELSE["UNIFORM SOURCE"
    ISRCDV=0;
    ]

"INITIALIZE DATA ARRAYS FOR FLUORESCENT X-RAYS IF NEEDED"
ISUMX=0;
DO JJ=1,NREG[ISUMX=ISUMX+IEDGFL(JJ); "NON-ZERO IF X-RAYS ANYWHERE"]
IF(ISUMX.NE.0) [CALL EDGSET(2,NREG);]
"NOTE THE ABOVE WILL PRODUCE LOTS OF EXTRA OUTPUT AND SHOULD BE"
"CLEANED UP"

CALL ISUMRY; "PRINT THE SUMMARY OF INPUTS"

"SAVE ORIGINAL MEDIUM NUMBERS AND DENSITIES FOR CORRELATION SCORING"
IF(IFULL.EQ.3)[ "MEDIUM CHANGES WITH THIS CORRELATION RUN"
    DO IRL=1,NREG[
        MEDSAV(IRL)=MED(IRL);RHOSAV(IRL)=RHOR(IRL);
        ]
    ]


"******************************************************************************
"
"                       *** SECTION 2 ***
"
"------------------------------------------------------------------------------
"
"LOOP THROUGH THE NUMBER OF HISTORIES. CALCULATE CONSTANTS THAT MAY CHANGE FOR
"EACH HISTORY AND DO THE SIMULATION
"
"------------------------------------------------------------------------------

"WRITE THE HEADER"
WRITE(IOUT,100) TITLE; call egs_fdate(iout); write(iout,*);
WRITE(IOUT,200);WRITE(6,200); "PRINT HEADER FOR EXECUTION MESSAGES"

"PRINT EXECUTION MODE"
IF(IRESTART.EQ.0)[WRITE(6,201);WRITE(IOUT,201);]
ELSEIF(IRESTART.EQ.1)["updated from cavrznrc, EMH January, 2002"
    WRITE(6,202) NCASE,NCASEO;
    write(6,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(6); write(6,*);
    write(iout,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(iout); write(iout,*);
]
ELSEIF(IRESTART.EQ.2)[WRITE(6,203);WRITE(IOUT,203);GO TO :END-OF-RUN:;]
ELSEIF(IRESTART.EQ.3)[WRITE(6,204);WRITE(IOUT,204);GO TO :STATS-ANAL:;]
ELSEIF(IRESTART.EQ.4)[WRITE(6,205);WRITE(IOUT,205);]
ELSEIF(IRESTART.EQ.5)[WRITE(6,206);WRITE(IOUT,206);GO TO :END-SIM:;]

"INITIALIZE IWATCH ROUTINE"
IF(IWATCH.NE.0) CALL WATCH(-99,IWATCH);

"INITIALIZE THE FLAGS THAT CONTROL CORRELATION SAMPLING"
INEED2=0;IPASS=0;

"SET CLOCK AT THE BEGINNING OF SIMULATIONS"
$INITIALIZE_ELAPSED_CPU_TIME;
$SET_ELAPSED_CPUTIME(CPUT1);
$INITIALIZE_ELAPSED_TOTAL_TIME;
ETIMETOT=0;
TIMEB=0;
NETADJ=0;

"dcav_old = 0.0;"

"Calculate the cavity mass for in-flight dose display"
FMASSC=0.0; "TOTAL CAVITY MASS"
DO IX=1,NR[
    DO IC=1,NC[
        $GET-IRL(IC,IX);
        IF(NTRACK(IRL).EQ.1)[
            FMASS=AMASS(IC,IX);
            FMASSC=FMASSC+FMASS; "SUM THE CAVITY MASS USED LATER"
            ]
           ]
          ]
"end of calculation of cavity mass"

"Initialize variables for the cs_enhance scoring "
tmp_dose = 0;  tmp_dose0 = 0;
tmp_dose1 = 0; tmp_dose2 = 0;
last_case = 0; cav_case = 0;

"Open file for data storage, if requested "
"The file is opened in the temporary working directory"
IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');

"*******************************************************************"
"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.
"*******************************************************************"
#ifdef HAVE_C_COMPILER;
;
/last_dose,last2_dose/ = 0;  n_tot = ncaseo;
first_time = .true.; is_finished = .false.;

:start_parallel_loop:;

IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    last_dose = cav_dose - last_dose + tmp_dose;
    last2_dose = cav2_dose - last2_dose + tmp_dose*tmp_dose;
    tmpf = fmassc*ainflu/ncaset/1.602e-10;
    part_dose = last_dose/tmpf; part2_dose = last2_dose/(tmpf*tmpf);
    last_dose = cav_dose + tmp_dose;
    last2_dose = cav2_dose + tmp_dose*tmp_dose;
    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(6,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        "ainflu = ainflu*dble(IHSTRY)/dble(NCASET);"
        goto :END-SIM:;
    ]
    IF( statlm > 0 & current_uncertainty < statlm ) [
        write(6,'(//a,a//)') '****** Desired uncertainty reached',
                      '       => end simulation';
        "ainflu = ainflu*dble(IHSTRY)/dble(NCASET);"
        goto :END-SIM:;
    ]
    NBATCH = n_run/$STAT**2;
    IF( NBATCH < 1 ) [ NBATCH = 1; n_run = NBATCH*$STAT**2; ]
    IF( first_time ) [
        first_time = .false.; n_last = n_run;
        write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
]
#endif;
"*******************************************************************"

"STATISTICAL BATCHES. STATISTICAL ANALYSIS IS DONE AFTER EACH BATCH. EXECUTION
"STOPS IF THE DESIRED STATISTICAL ACCURACY IS OBTAINED OR THERE IS NOT ENOUGH
"TIME TO DO ANOTHER BATCH.
DO IBATCH=1,$STAT[

    IBTCH=IBATCH;
    IF(IBATCH.EQ.1)[
        OUTPUT;
        (/' BATCH',2X,'ELAPSED',2X,'CPUtime',2X,'RATIO',2X,
        'time of day',2X,'cavity stats(%)',2X,'cav.dose(Gy.cm^2)'//
        2X,'1',5X,'0.0',6X,'0.0',6X,'0.00',3X,' ',$); call egs_time(6);

        "IK: it is annoing that for batch runs we don't see the progress"
        "    info in the log file until the job is finished. This is because"
        "    Fortran uses buffered I/O. The following flushes unit 6 so that"
        "    we can see the progress of the calculation. "
        $FLUSH_UNIT(6);
    ]
    ELSE[
        $SET_ELAPSED_TOTAL_TIME(TIMEB);
        ETIMETOT = ETIMETOT+TIMEB;
        $SET_ELAPSED_CPUTIME(CPUT2);
        TIMCPU=(CPUT2-CPUT1)*$CONVERSION_TO_SECONDS+$TIME_RESOLUTION;
        "*****************************************************************"
        OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU;
                  (1X,I2,F8.1,1X,F8.1,2X,F8.2,3X,' ',$);  call egs_time(6);
        "*****************************************************************"

        "IK: it is annoying that for batch runs we don't see the progress"
        "    info in the log file until the job is finished. This is because"
        "    Fortran uses buffered I/O. The following flushes unit 6 so that"
        "    we can see the progress of the calculation. "
        $FLUSH_UNIT(6);
        "*****************************************************************"

        "CHECK THERE IS TIME LEFT FOR ANOTHER BATCH"
        BATCHT=TIMCPU/dble(IBATCH-1);"TIME PER BATCH SO FAR"
        IF(TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)[
            "NOT ENOUGH TIME FOR ANOTHER BATCH"
            "PRINT MESSAGE AND EXIT SIMULATION LOOP"
            WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
            WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
            "ADJUST THE INCIDENT FLUENCE"
            "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
            IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
                SRCPT(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
                $SWITCH-TO-PARALLEL-BEAM-SOURCE;
                "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
                SRCPAR(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
                $RECOVER-POINT-SOURCE;
                ]
                GO TO :END-SIM:;
            ]
     ]

    "LOOP OVER EACH HISTORY FILLING EACH STATISTICAL BIN. THIS ALLOWS
    "STATISTICAL ANALYSIS TO BE DONE EVEN IF ONLY ONE BATCH EXECUTES.
    DO IS=1,$STAT[

        "ZERO THE SCORING ARRAYS AND VARIABLES USED BY AUSGAB AND MSCAT"
        /IST,ISTC,ISM,ISMC,NOSCAT,INOCAV,NOSCT2,INOMED/=0;
        DO IC=1,NC[
            DO IX=1,NR[
                $GET-IRL(IC,IX);
                IF(NTRACK(IRL).EQ.1)[
                   DO IT=1,ITMAX[
                       SCDOSE(IC,IX,IT)=0.0
                       ]
                   ]
               ]
            ]

        DO ICASE=1,NBATCH["NOW FILL EACH IS BIN"
            IHSTRY=IHSTRY+1; "INCREMENT HISTORY COUNTER"
            the_case = IHSTRY;

            :CORRELATION-RESTART:; "RESTART HERE FOR A CORRELATED HISTORY"

            NFTIME = 0; "reset the photon forced interaction counter"

"*****************************************************"
"RNG macros updated from cavrznrc, EMH, January, 2002 "
"*****************************************************"
            "retrieve starting random numbers if reading from a file"
            IF((IPASS.EQ.0).AND.(IRESTART.EQ.4)) [
                "$RETRIEVE RNG STATE FROM UNIT 2; was $RESET-RNG(2);"
                $RETRIEVE RNG STATE FROM UNIT rng_unit; "was $RESET-RNG(2);"
            ]


            IF(IPASS =  0)[
                "store the initial random number, another pass might be needed"
                IRNG = 1;
                $STORE-RNG(IRNG);     "was $STORE-RNG(0);"
            ]
            ELSE[ "initialize random number if correlation pass is starting"
                IRNG = 1;
                $RESET-RNG(IRNG);     "was $RESET-RNG(0);"
            ]

            "store initial random #s if requested"
            IF(ISTORE =  1)[
                IF(IPASS =  0)[ $STORE RNG STATE ON UNIT rng_unit; ]
            ]
            ELSEIF(ISTORE =  2)[
                "temporarily store the initial random number seed"
                IRNG = 3;
                $STORE-RNG(IRNG);  "was $STORE-RNG(-2);"
                "clear the flag that signals energy deposit in the cavity"
                IDECAV = 0;
            ]
            ELSEIF(ISTORE.EQ.3)[
                IF(IPASS.EQ.0)[
                    "STORE THE INITIAL RANDOM NUMBER SEED"
                    $PUT RNG STATE ON UNIT rng_unit;
                ]
            ]
"*****************************************************"

            "CALCULATE THE SOURCE DEPENDENT VALUES WHICH CHANGE FOR EACH
            "HISTORY THESE INCLUDE :
                "ENTRY POINT INTO TARGET,
                "INITIAL DIRECTION COSINES,
                "STATISTICAL WEIGHT,
                "ENTRY FLAG(NRCFLG)
            CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);

            "CALCULATE THE INITIAL ENERGY IF A DISTRIBUTION IS TO BE USED"
            IF(MONOEN.NE.0)["IF EQUAL TO 0, IT IS MONOENERGETIC"
                CALL ENSRCH(EIN);   "RETURNS K.E. FROM DISTRIBUTION"
                IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]  "TOTAL ENERGY"
                " THERE WAS A CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY
                "RANGE REQUIRED, THE LOCATION OF IT WILL EVENTUALLY BE IN
                "ESRCIN.MOR
            ]
            "FOR AN INPUT ENERGY SPECTRUM, DETAILED FORCING MACRO IS USED"
            LATCHI=0;
            IF((IWATCH.NE.0).AND.(IWATCH.NE.4))[
"JAN CHANGE: (FOR DEBUGGING)"
                IF(IPASS.EQ.0)[OUTPUT;(/'***** ZEROTH CORRELATION *****'/);]
"END OF JAN CHANGE"
                IF(IPASS.EQ.1)[OUTPUT;(/'***** FIRST CORRELATION *****'/);]
                IF(IPASS.EQ.2)[OUTPUT;(/'***** SECOND CORRELATION *****'/);]
                OUTPUT 1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,WEIGHT;
                (' INITIAL SHOWER VALUES',T36,':',
                I2,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
                ]

            "ALL INITIAL SHOWER VARIABLES ARE SET, CALL THE SHOWER ROUTINE"
            CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);

"JAN CHANGE:"
"            IF (IFULL.EQ.3).AND.(IPASS.EQ.0)["
                 "STORE THE FINAL RANDOM NUMBER, TO ENSURE THE SAME FIRST"
                 "PASS TRANSPORT AS THE IFULL.EQ.1 OPTION"
"                 $STORE-FINAL-IPASS0-RNG;"
"                 ]"
"END OF JAN CHANGE"

"*****************************************************"
"RNG macros updated from cavrznrc, EMH, January, 2002 "
"*****************************************************"
            IF(ISTORE.EQ.2)[
                "STORE INITIAL RN SEED IF ENERGY SCORED IN THE CAVITY"
                 IF(IFULL.LE.1)[ "UNCORRELATED RUNS"
                     IF(IDECAV.EQ.1)[ "ENERGY WAS DEPOSITED IN THE CAVITY"
                         IRNG = 1;
                         $STORE-RNG(IRNG);              "was $STORE-RNG(0);"
                         IRNG = 3;
                         $RESET-RNG(IRNG);               "was $RESET-RNG(-2);"
                         $PUT RNG STATE ON UNIT rng_unit;"was $STORE-RNG(2);"
                         IRNG = 1;
                         $RESET-RNG(IRNG);              "was $RESET-RNG(0);"
                     ]
                 ]
                 ELSE[ "CORRELATED RUNS"
                     IF((IFULL.EQ.2).AND.(IPASS.EQ.1))[
                             "AFTER THE SECOND PASS ONLY"
                             IRNG = 3;
                             $RESET-RNG(IRNG);           "was $RESET-RNG(-2);"
                             $PUT RNG STATE ON UNIT rng_unit;
                             WRITE(2,*) IDECV1,IDECAV;
                     ]
                     IF((IFULL.EQ.3).AND.(IPASS.EQ.2))[
                         "AFTER THE THIRD PASS ONLY"
                         IRNG = 3;
                         $RESET-RNG(IRNG);               "was $RESET-RNG(-2);"
                         $PUT RNG STATE ON UNIT rng_unit;"was $STORE-RNG(2);"
                         WRITE(2,*) IDECV1,IDECAV;
                     ]
                 ]
            ]

            IF((IFULL.GE.2).AND.(IPTSRC.EQ.1).AND.(IPASS.EQ.0))
                [
                "FIRST PASS COMPLETED. SET UP FOR SECOND PASS IF"
                "A POINT SOURCE IS BEING USED"
                IRNG = 2;
                $STORE-RNG(IRNG);                       "was $STORE-RNG(-1);"
                IPASS=1; "FLAG FOR SECOND PASS"
                INEED2=0;       "ZERO THIS FLAG"
                IF(IDECAV.NE.0) IDECV1=IDECAV; "1ST PASS ENERGY DEPOSITION"
                $SWITCH-TO-PARALLEL-BEAM-SOURCE;
                GO TO :CORRELATION-RESTART:; "RESTART THE HISTORY"
                ]
            ELSEIF((IFULL.EQ.3).AND.(IPTSRC.EQ.0).AND.(IPASS.EQ.0)
                   .AND.(INEED2.EQ.1))[
                "FIRST PASS COMPLETED, NO POINT SOURCE USED"
                "SET UP FOR MATERIAL CORRELATION PASS."
                IRNG = 2;
                $STORE-RNG(IRNG);  "was $STORE-RNG(-1);"
                IPASS=2;       "FLAG NEED FOR THIRD PASS"
                INEED2=0;       "ZERO THIS FLAG"
"*****************************************************"
                IF(IDECAV.NE.0) IDECV1=IDECAV; "1ST PASS ENERGY DEPOSITION"
"JAN CHANGE: FILL ONLY CAVITY NOT OUTER ENVELOPE"
"I.E. MED(IRL)=1 ONLY FOR IRL>1; ie LEAVE MED(1) UNCHANGED"
                DO IRL=2,NREG[ "SWITCH TO UNIFORM WALL MATERIAL"
                    MED(IRL)=1;RHOR(IRL)=RHO(1);
                    ]
                GO TO :CORRELATION-RESTART:; "RESTART THE HISTORY"
                ]
            ELSEIF((IFULL.EQ.3).AND.(IPTSRC.EQ.1).AND.(IPASS.EQ.1)
                  .AND.(INEED2.EQ.1))[
                "SECOND PASS COMPLETED. SET UP FOR THIRD PASS IF"
                "A POINT SOURCE IS BEING USED"
                IPASS=2;       "FLAG NEED FOR THIRD PASS"
                INEED2=0;       "ZERO THIS FLAG"
                IF(IDECAV.NE.0) IDECV1=IDECAV; "1ST PASS ENERGY DEPOSITION"
"JAN CHANGE: FILL ONLY CAVITY NOT OUTER ENVELOPE"
"I.E. MED(IRL)=1 ONLY FOR IRL>1; ie LEAVE MED(1) UNCHANGED"
                DO IRL=2,NREG[ "SWITCH TO UNIFORM WALL MATERIAL"
                    MED(IRL)=1;RHOR(IRL)=RHO(1);
                    ]
                GO TO :CORRELATION-RESTART:; "RESTART THE HISTORY"
                ]
"JAN CHANGE: IPASS.EQ.2 to IPASS.GE.1 BECAUSE OTHERWISE NO BACKUP FOR"
" IFULL=3 AND IPASS=1 AND INEED2=0"
            ELSEIF(
               ((IFULL.EQ.2).AND.(IPASS.EQ.1))
               .OR.
               ((IFULL.EQ.3).AND.(IPASS.GE.1))
               )[
                "THE FINAL CORRELATION PASS WAS JUST COMPLETED"
                IPASS=0;        "RESET THE FLAG"
                IRNG = 2;
                $RESET-RNG(IRNG);                      "was $RESET-RNG(-1);"
                IDECV1=0;       "CLEAR 1ST PASS ENERGY DEPOSITION FLAG"
                INEED2=0;       "ZERO THIS FLAG"
"JAN CHANGE: DONT RECOVER POINT SOURCE IF PAR BEAM Afl CALC"
" WAS REQUESTED. CHANGED IFULL.GE.2 to"
" IFULL.EQ.2 OR IFULL.EQ.3 AND IPTSRC.EQ.1"
                IF(IFULL.EQ.2).OR.((IFULL.EQ.3).AND.(IPTSRC.EQ.1))[
                    $RECOVER-POINT-SOURCE;
                    ]
                IF(IFULL.EQ.3)[
                    "RECOVER THE ORIGINAL MATERIAL CONFIGURATION"
"JAN CHANGE: RECOVER ONLY CAVITY NOT OUTER ENVELOPE"
"I.E. MED(IRL)=1 ONLY FOR IRL>1; ie LEAVE MED(1) UNCHANGED"
                    DO IRL=2,NREG[
                        MED(IRL)=MEDSAV(IRL);RHOR(IRL)=RHOSAV(IRL);
                        ]
                    ]
                ]
"JAN CHANGE: THIS PASS ONLY FOR DEBUGGING"
            ELSE [ IF (IFULL.EQ.2).OR.((IFULL.EQ.3).AND.(INEED2.EQ.1))
                   [WRITE(6,*) 'SHOULD NOT GET HERE...';
                    write(6,*) 'ipass ',ipass;
                    write(6,*) 'ifull ',ifull;
                   ]]

            "SIGNAL THE END OF A HISTORY IF WATCH MODE IS SET"
            "JAN CHANGE: ZERO STACK ELEMENTS TO PREVENT CROSS TALKING"
            "$CLEAN-STACK;"
            "END OF JAN CHANGE"
            IF(IWATCH.GT.0) CALL WATCH(-1,IWATCH);

            ] "END OF THE ICASE LOOP"

        "LOAD THE RAW DATA INTO THE STATISTICAL ARRAYS"
        ISTCIS(IS)=ISTCIS(IS)+ISTC;
        ISTIS(IS)=ISTIS(IS)+IST;
        IMSIS(IS)=IMSIS(IS)+NOSCAT;
        IMSCIS(IS)=IMSCIS(IS)+INOCAV;
        ISMCIS(IS)=ISMCIS(IS)+ISMC;
        ISMIS(IS)=ISMIS(IS)+ISM;
        IMMIS(IS)=IMMIS(IS)+NOSCT2;
        IMMCIS(IS)=IMMCIS(IS)+INOMED;

        DO IT=1,ITMAX[
            DO IX=1,NR[
                DO IC=1,NC[
                    $GET-IRL(IC,IX);
                    IF(NTRACK(IRL).EQ.1)[
                        DOSEIS(IC,IX,IT,IS)=
                            DOSEIS(IC,IX,IT,IS)+SCDOSE(IC,IX,IT);

                        ]
                    ]
                ]
            ]

        ] "END OF THE IS LOOP"

    "SUCCESFUL COMPLETION OF A BATCH. DELETE THE RAW DATA FROM THE LAST BATCH"
    "AND RECORD THE NEW BATCH ONLY IF REQUESTED"
    IF(IDAT.EQ.0)[
        " discard data from previous batches (if any) "
        rewind(data_unit);

"******************"
"history by history"
"  EMH, January2002"
"******************"

        tcav_dose  = cav_dose  + tmp_dose;
        tcav2_dose = cav2_dose + tmp_dose*tmp_dose;

        tcav_dose0  = cav_dose0   + tmp_dose0;
        tcav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;

        tcav_dose1  = cav_dose1  + tmp_dose1;
        tcav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;

        tcav_dose2  = cav_dose2  + tmp_dose2;
        tcav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;


        tcav_dosec   = cav_dosec   + tmp_dose*tmp_dose1;
        tcav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
        tcav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;

        write(data_unit,*) tcav_dose, tcav_dose0, tcav_dose1, tcav_dose2;
        write(data_unit,*) tcav2_dose,tcav2_dose0,tcav2_dose1,tcav2_dose2;
        write(data_unit,*) tcav_dosec,tcav_dosec01,tcav_dosec02;
"********************"

        DO IS=1,$STAT[
            WRITE(data_unit,*) ISTIS(IS),ISTCIS(IS),
                       IMSIS(IS),IMSCIS(IS),
                       ISMIS(IS),ISMCIS(IS),
                       IMMIS(IS),IMMCIS(IS);
            WRITE(data_unit,*)
                (((DOSEIS(IC,IX,IT,IS),IT=1,$MAXIT),IX=1,NR),IC=1,NC);
        ]
    ]"END OF CONDITIONAL DATA STORAGE"

    $SET_ELAPSED_CPUTIME(CPUT2);
    TIMCPU=$CONVERSION_TO_SECONDS*(CPUT2-CPUT1)+TMCPUO;
    IF(IDAT.EQ.0)[
        "$STORE-RNG(4);WRITE(4,*) IHSTRY,TIMCPU;"
        $PUT RNG STATE ON UNIT data_unit;
        WRITE(data_unit,*) IHSTRY,TIMCPU;
    ]
"DO STATISTICAL ANALYSIS ON THE CAVITY REGION TO SEE IF WE QUIT EARLY"
"JAN CHANGE"
"WRITE(6,*) 'Early quit test ??';"
    DO IS=1,$STAT[
        DCAVIS(IS)=0.0;
        DCAV_SECIS(IS)=0.0;
        DO ICAV=1,NREG[
            IF(NTRACK(ICAV).EQ.1)[
                $GET-IX-IC(ICAV);
"change: I defined DCAVIS as the TOTAL cavity dose (used to be  "
"primary dose only) so that the uncertainty is consistent with  "
"uncertainty printed in the listing file                   (JAN)"
"DCAV_SEC is the dose solely due to secondary particles         "
                DCAVIS(IS)=DCAVIS(IS)+DOSEIS(IC,IX,1,IS)+DOSEIS(IC,IX,2,IS);
                DCAV_SECIS(IS)=DCAV_SECIS(IS)+DOSEIS(IC,IX,2,IS);
               ]
            ]
        ]
    $ANALYZE0 DCAV USING MODE 2;
"note that DCAV is now TOTAL dose, DCAVUN its uncertainty"
    IF(DCAVUN.LE.STATLM)[
        "REACHED OBJECTIVE-PRINT MESSAGE AND JUMP OUT OF SIMULATION LOOP"
        WRITE(6,230)DCAVUN,IBTCH;WRITE(IOUT,230)DCAVUN,IBTCH;
        "FIX NORM ON EARLY EXIT"
        "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
        IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
            SRCPT(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
            $SWITCH-TO-PARALLEL-BEAM-SOURCE;
            "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
            SRCPAR(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
            $RECOVER-POINT-SOURCE;
        ]
        GO TO :END-SIM:;
    ]

"the following is to calculate current dose in cavity (JAN)  "
"makes us of variable dcav_secis(is) and dcav_sec to do same "
"for secondary dose                                          "
    $ANALYZE0 DCAV_SEC USING MODE 2;
    AINFLU_CURRENT=AINFLU*dble(IHSTRY)/dble(NCASET);
    DCAV_CURRENT = DCAV*1.602E-10/(FMASSC*AINFLU_CURRENT);
    FR_SEC = DCAV_SEC/DCAV*100;
    "FR_SEC is not put on output during run "
"**************************************"
"taken from cavrznrc, EMH, January 2002"
"**************************************"
"******************"
"history by history"
"******************"
"we do this always, so remove conditional"
"on a later stage, the above will be removed!!!"
"    IF( use_enhance | n_split > 1 ) ["
        dcav_current = cav_dose*1.602E-10/(FMASSC*AINFLU_CURRENT);
        dcavun = (cav2_dose*ihstry-cav_dose*cav_dose)/(ihstry-1);
        IF( dcavun > 0 ) [ dcavun = sqrt(dcavun); ];
        dcavun = dcavun*1.602E-10/(FMASSC*AINFLU_CURRENT);
        dcavun = 100*dcavun/dcav_current;
"    ] "

    OUTPUT DCAVUN,DCAV_CURRENT;('+',5X,F5.2,10X,1PE11.4,5X,1PE10.3);
"end of change"

] "END OF SIMULATIONS"

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]

#endif;

"PRINT INSUFFICIENT STATS WARNING"
WRITE(IOUT,240) STATLM,DCAVUN,IBTCH;WRITE(6,240) STATLM,DCAVUN,IBTCH;

:END-SIM:;

"**************************************"
"taken from cavrznrc, EMH, January 2002"
"**************************************"
"******************"
"history by history"
"******************"
"IF( use_enhance | n_split > 1 ) [ we have to add the temporary scoring"
                                  "variables for the last history      "
    cav_dose  = cav_dose  + tmp_dose;
    cav2_dose = cav2_dose + tmp_dose*tmp_dose;

    cav_dose0  = cav_dose0  + tmp_dose0;
    cav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;

    cav_dose1  = cav_dose1  + tmp_dose1;
    cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;

    cav_dose2  = cav_dose2  + tmp_dose2;
    cav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;


    cav_dosec   = cav_dosec   + tmp_dose*tmp_dose1;
    cav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
    cav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;
"]"

write(6,'(/a,$)') '****** FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(6); write(6,'(a)') '  ******';
write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(iout); write(iout,'(a)') '  *********';

$SET_ELAPSED_TOTAL_TIME(TIMEB);
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=(CPUT2-CPUT1)*$CONVERSION_TO_SECONDS+TMCPUO;
"**************************************"
"taken from cavrznrc, EMH, January 2002"
"**************************************"
IF(IRESTART=3)["just analyzing data--no elapsed time"
  WRITE(IOUT,250)TMCPUO,TMCPUO/3600;
  WRITE(6,250)TMCPUO,TMCPUO/3600;
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRESTART=5)["output time results for parallel runs"
  WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSE[
  IF(TMCPUO.EQ.0)["This is first run"
   RATIO=ETIMETOT/TIMCPU;
   WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
   WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
  ]
  ELSE[ "There was previous run, but don't have elapsed time for it"
   RATIO = ETIMETOT/(TIMCPU-TMCPUO); "ratio this run only"
   WRITE(IOUT,261) ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
   WRITE(6,261) ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
  ]
  IF(IHSTRY.NE.0 .AND. TIMCPU.NE.0.0) ["this should always happen"
   WRITE(IOUT,280) TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
  ]
]

"**************************************"
;
"******************************************************************************
"
"                       *** SECTION 3 ***
"
"------------------------------------------------------------------------------

"STATISTICAL AND OTHER DATA HANDLING AND CALL THE OUTPUT SUMMARY ROUTINE"

"------------------------------------------------------------------------------

:STATS-ANAL:;


write(6,'(A,I10)') 'Total number of stories :', IHSTRY;
write(6,'(A,I10)')
'Number of primary stories scoring in the cavity :', cav_case;

FMASSC=0.0; "total cavity mass"
DO IX=1,NR[
    DO IC=1,NC[
        $GET-IRL(IC,IX);
        IF(NTRACK(IRL).EQ.1)[
            FMASS=AMASS(IC,IX);
            FMASSC=FMASSC+FMASS;
        ]
    ]
]

"Adjust incident fluence and total number of histories run"
AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);
NCASET = IHSTRY;


"IF( use_enhance | n_split > 1 ) ["
"******************"
"history by history"
"    EMH, Jan. 2002"
"******************"

    cav2_dose = (cav2_dose*ncaset - cav_dose*cav_dose)/(ncaset-1);
    IF( cav2_dose > 0 ) cav2_dose = sqrt(cav2_dose);

    IF( ifull = 1 ) [

        cav2_dose0 = (cav2_dose0*ncaset - cav_dose0*cav_dose0)/(ncaset-1);
        IF( cav2_dose0 > 0 ) cav2_dose0 = sqrt(cav2_dose0);
        cav2_dose1 = (cav2_dose1*ncaset - cav_dose1*cav_dose1)/(ncaset-1);
        IF( cav2_dose1 > 0 ) cav2_dose1 = sqrt(cav2_dose1);
        cav2_dose2 = (cav2_dose2*ncaset - cav_dose2*cav_dose2)/(ncaset-1);
        IF( cav2_dose2 > 0 ) cav2_dose2 = sqrt(cav2_dose2);

        corr_02=(cav_dosec02*ncaset-cav_dose0*cav_dose2)/(ncaset-1);
        corr_02=cav2_dose0**2+cav2_dose2**2+ 2*corr_02;
        IF (corr_02 > 0) corr_02 = sqrt(corr_02);

        cav_dosec   = (cav_dosec*ncaset   - cav_dose*cav_dose1)/(ncaset-1);
        cav_dosec01 = (cav_dosec01*ncaset - cav_dose0*cav_dose1)/(ncaset-1);
        cav_dosec02 = (cav_dosec02*ncaset - cav_dose0*cav_dose2)/(ncaset-1);
    ]

    cav_dose  = cav_dose*1.602e-10/(ainflu*fmassc);
    cav_dose0 = cav_dose0*1.602e-10/(ainflu*fmassc);
    cav_dose1 = cav_dose1*1.602e-10/(ainflu*fmassc);
    cav_dose2 = cav_dose2*1.602e-10/(ainflu*fmassc);

    cav2_dose  = cav2_dose*1.602e-10/(ainflu*fmassc);
    cav2_dose0 = cav2_dose0*1.602e-10/(ainflu*fmassc);
    cav2_dose1 = cav2_dose1*1.602e-10/(ainflu*fmassc);
    cav2_dose2 = cav2_dose2*1.602e-10/(ainflu*fmassc);

    corr_02    = corr_02*1.602e-10/(ainflu*fmassc);

    cav_dosec   = cav_dosec*(1.602e-10/(ainflu*fmassc))**2;
    cav_dosec01 = cav_dosec01*(1.602e-10/(ainflu*fmassc))**2;
    cav_dosec02 = cav_dosec02*(1.602e-10/(ainflu*fmassc))**2;

IF( use_enhance | n_split > 1 ) [ goto :IGNORE-OTHER-SCORING:;]
"]"


"LOAD THE SUMMATION OVER THE CAVITY ARRAY"
DO IC=1,NC[
    DO IX=1,NR[
        $GET-IRL(IC,IX);
        IF(NTRACK(IRL).EQ.1)[
            DO IT=1,ITMAX[
                DO IS=1,$STAT[
                    SCAVIS(IT,IS)=SCAVIS(IT,IS)+DOSEIS(IC,IX,IT,IS);
                    ]
                ]
            ]
        ]
    ]

"MANIPULATE THE RAW DATA ARRAYS INTO THE DESIRED QUANTITIES PRIOR TO           "
"THE STATISTICAL ANALYSES                                                      "
"BEFOREHAND FOR THE ARRAYS DOSEIS AND SCAVIS:                                  "
"   IT=1 PRIMARY EDEP TO GAS                                                   "
"   IT=2 SECONDARY EDEP TO GAS                                                 "
"   IT=3 UNATTENUATED PRIMARY EDEP TO GAS                                      "
"   IT=4 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS                        "
"   IT=5 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS WITH GAS MATERIAL      "
"        REPLACED BY WALL MATERIAL                                             "
"   IT=6 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO WALL MATERIAL GAS WITH GAS "
"        MATERIAL REPLACED BY WALL MATERIAL                                    "
"AFTERHAND FOR THE ARRAYS DOSEIS AND SCAVIS:                                   "
"   IT=1 TOTAL EDEP TO GAS                                                     "
"   IT=2 Ascat-1                                                               "
"   IT=3 1/Aatt-1                                                              "
"   IT=4 Apn                                                                   "
"   IT=5 Afl                                                                   "
"   IT=6 <s>g,w -1                                                             "
"AFTERHAND FOR THE ARRAYS TDAIS AND TTDAIS:                                    "
"   IT=1 PRIMARY UNATTENUATED EDEP TO GAS                                      "
"   IT=2 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS                        "
"   IT=3 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS WITH GAS MATERIAL      "
"        REPLACED BY WALL MATERIAL                                             "
"   IT=4 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO WALL MATERIAL GAS WITH GAS "
"        MATERIAL REPLACED BY WALL MATERIAL                                    "
"FIRST FOR THE CAVITY SUMMARY"
DO IS=1,$STAT[
    TTDAIS(1,IS)=SCAVIS(1,IS)+SCAVIS(3,IS);
    IF(IPTSRC.EQ.1)[TTDAIS(2,IS)=SCAVIS(4,IS);]
    ELSE[           TTDAIS(2,IS)=TTDAIS(1,IS);]
    TTDAIS(3,IS)=SCAVIS(5,IS);
    TTDAIS(4,IS)=SCAVIS(6,IS);
    TEMP=SCAVIS(1,IS);
    TEMP2=SCAVIS(2,IS);
    SCAVIS(1,IS)=TEMP+TEMP2; "TOTAL EDEP"
    IF(TEMP.EQ.0.0)[
        OUTPUT IS;
        (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=1');
        DO IT=2,ITMAX[
           SCAVIS(IT,IS)=0.0;
           ]
        ] "END TEST TEMP=0"
    ELSE[
        IF(IFULL.GE.1)[
            "CONSTRUCT Ascat-1"
            SCAVIS(2,IS)=TEMP2/TEMP;
            "CONSTRUCT 1/Aatt-1"
            TEMP3=SCAVIS(3,IS);
            SCAVIS(3,IS)=TEMP3/TEMP;
            ] "END IFULL>=1
        IF(IFULL.GE.2)[
            "CONSTRUCT Apn"
            TEMP3=TEMP+TEMP3; "PRIMARY UNATTENUATED EDEP"
            IF(IPTSRC.EQ.1)[
                FLURAT=AINFLU;
                $SWITCH-TO-PARALLEL-BEAM-SOURCE;
                FLURAT=AINFLU/FLURAT;
                $RECOVER-POINT-SOURCE;
                TEMP4=SCAVIS(4,IS);
                IF(TEMP4.EQ.0.0)[
                    OUTPUT IS;
                    (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=4');
                    SCAVIS(4,IS)=0.0;
                    ]
                ELSE[
                    SCAVIS(4,IS)=TEMP3/(TEMP4/FLURAT);
                    ]
                ]
            ELSE[
                TEMP4=0.0;SCAVIS(4,IS)=1.0;
                ]
            ] "END IFULL>=2
        IF(IFULL.EQ.3)[
            TEMP5=SCAVIS(5,IS);
            IF(TEMP5.EQ.0.0)[
                OUTPUT IS;
                (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=5');
                DO IT=5,ITMAX[
                   SCAVIS(IT,IS)=0.0;
                   ]
                ] "END TEST TEMP5=0"
            ELSE[
                "CALCULATE PRIMARY UNATTENUATED EDEP WITH SOURCE"
                "DISTRIBUTION FACTORED OUT( i.e. UNSOURCED)"
                TEMP4=TEMP4+TEMP3;
                SCAVIS(5,IS)=TEMP4/TEMP5;
                "CALCULATE THE STOPPING POWER RATIO"
                SCAVIS(6,IS)=(RHO(1)/RHO(2))*TEMP5/SCAVIS(6,IS)-1.;
                ] "END ELSE ON TEST TEMP5=0"
            ] "END IFULL=3"
        ] "END ELSE ON TEST TEMP=0"
    ] "END IS DO"
"THEN FOR EACH CAVITY REGION"
DO IS=1,$STAT[
    DO IX=1,NR[
        DO IC=1,NC[
            $GET-IRL(IC,IX);
            IF(NTRACK(IRL).EQ.1)["IN THE CAVITY"
                TDAIS(IC,IX,1,IS)=DOSEIS(IC,IX,1,IS)+DOSEIS(IC,IX,3,IS);
                IF(IPTSRC.EQ.1)[
                    TDAIS(IC,IX,2,IS)=
                        TDAIS(IC,IX,1,IS)+DOSEIS(IC,IX,4,IS);]
                ELSE[
                    TDAIS(IC,IX,2,IS)=TDAIS(IC,IX,1,IS);
                    ]
                TDAIS(IC,IX,3,IS)=DOSEIS(IC,IX,5,IS);
                TDAIS(IC,IX,4,IS)=DOSEIS(IC,IX,6,IS);
                TEMP=DOSEIS(IC,IX,1,IS);
                TEMP2=DOSEIS(IC,IX,2,IS);
                DOSEIS(IC,IX,1,IS)=TEMP+TEMP2; "TOTAL EDEP"
                IF(TEMP.EQ.0.0)[
                    OUTPUT IS,IX,IC;
                    (' ***WARNING. DOSEIS=0. IS,IX,IC=',3I5,'  IT=1');
                    DO IT=2,ITMAX[
                       DOSEIS(IC,IX,IT,IS)=0.0;
                       ]
                    ] "END TEST TEMP=0"
                ELSE[
                    IF(IFULL.GE.1)[
                        "CONSTRUCT THE Ascat-1 ARRAY"
                        DOSEIS(IC,IX,2,IS)=TEMP2/TEMP;
                        "CONSTRUCT THE 1/Aatt-1 ARRAY"
                        TEMP3=DOSEIS(IC,IX,3,IS);
                        DOSEIS(IC,IX,3,IS)=TEMP3/TEMP;
                        ] "END IFULL>=1
                    IF(IFULL.GE.2)[
                        "CONSTRUCT THE Apn ARRAY"
                        TEMP3=TEMP+TEMP3; "PRIMARY UNATTENUATED EDEP"
                        IF(IPTSRC.EQ.1)[
                            TEMP4=DOSEIS(IC,IX,4,IS);
                            IF(TEMP4.EQ.0.0)[
                                OUTPUT IS;
                                    (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=4');
                                DOSEIS(IC,IX,4,IS)=0.0;
                                ]
                            ELSE[
                                DOSEIS(IC,IX,4,IS)=TEMP3/(TEMP4/FLURAT);
                                ]
                            ]
                        ELSE[TEMP4=0.0;DOSEIS(IC,IX,4,IS)=1.0;]
                        ] "END IFULL>=2
                    IF(IFULL.EQ.3)[
                        TEMP5=DOSEIS(IC,IX,5,IS);
                        IF(TEMP5.EQ.0.0)[
                            OUTPUT IS,IX,IC;
                            (' ***WARNING. DOSEIS=0. IS,IX,IC=',3I5,'  IT=5');
                            DO IT=5,ITMAX[
                               DOSEIS(IC,IX,IT,IS)=0.0;
                               ]
                            ] "END TEST TEMP5=0"
                        ELSE[
                            "CALCULATE PRIMARY UNATTENUATED EDEP WITH SOURCE"
                            "DISTRIBUTION FACTORED OUT( i.e. UNSOURCED)"
                            TEMP4=TEMP4+TEMP3;
                            DOSEIS(IC,IX,5,IS)=TEMP4/TEMP5;
                            "CALCULATE THE STOPPING POWER RATIO"
                            DOSEIS(IC,IX,6,IS)=TEMP5/DOSEIS(IC,IX,6,IS)-1.;
                            ] "END ELSE ON TEST TEMP5=0"
                        ] "END IFULL=3"
                    ] "END ELSE ON TEST TEMP=0"
                ] "END IN THE CAVITY TEST"
            ] "END IC DO"
        ] "END IX DO"
    ] "END IS DO"

"LOAD THE STEP COUNTING ARRAYS FOR THE STATISTICAL ANALYSIS"
DO IS=1,$STAT[
    ITEMP=ISTIS(IS);
    IF(ITEMP.EQ.0)[FMSIS(IS)=0.0;FNIS(IS)=0.0;FDIS(IS)=0.0;]
    ELSE[
        TEMP1=ISTIS(IS);TEMP2=IMSIS(IS);
        FDIS(IS)=TEMP1;FNIS(IS)=TEMP2;
        FMSIS(IS)=TEMP2/TEMP1;
        ]
    ITEMP=ISTCIS(IS);
    IF(ITEMP.EQ.0)[FMSCIS(IS)=0.0;FCNIS(IS)=0.0;FCDIS(IS)=0.0;]
    ELSE[
        TEMP1=ISTCIS(IS);TEMP2=IMSCIS(IS);
        FCDIS(IS)=TEMP1;FCNIS(IS)=TEMP2;
        FMSCIS(IS)=TEMP2/TEMP1;
        ]
    ITEMP=ISMIS(IS);
    IF(ITEMP.EQ.0)[FMMIS(IS)=0.0;FSMIS(IS)=0.0;FTMIS(IS)=0.0;]
    ELSE[
        TEMP1=ISMIS(IS);TEMP2=IMMIS(IS);
        FTMIS(IS)=TEMP1;FSMIS(IS)=TEMP2;
        FMMIS(IS)=TEMP2/TEMP1;
        ]
    ITEMP=ISMCIS(IS);
    IF(ITEMP.EQ.0)[FMMCIS(IS)=0.0;FSMCIS(IS)=0.0;FTMCIS(IS)=0.0;]
    ELSE[
        TEMP1=ISMCIS(IS);TEMP2=IMMCIS(IS);
        FTMCIS(IS)=TEMP1;FSMCIS(IS)=TEMP2;FMMCIS(IS)=TEMP2/TEMP1;
        ]
    ]

"FOR ISOURC=4 WE NEED THE DATA FOR CIRCLES, NOT RINGS, SO ADD IT UP"
"THIS SHOULD ONLY BE USED IF THE CAVITY HAS AN INFINITE DIAMETER"
IF((ISOURC.EQ.4).AND.(NR.GT.1))[
    DO IS=1,$STAT[
        DO IT=1,ITMAX[
            DO IX=2,NR[
                DO IC=1,NC[
                    $GET-IRL(IC,IX);
                    IF(NTRACK(IRL).EQ.1)[
                        DOSEIS(IC,IX,IT,IS)=
                        DOSEIS(IC,IX,IT,IS)+DOSEIS(IC,IX-1,IT,IS);
                        ]
                    ]
                ]
            ]
        ]
    DO IS=1,$STAT[
        DO IT=1,4[
            DO IX=2,NR[
                DO IC=1,NC[
                    $GET-IRL(IC,IX);
                    IF(NTRACK(IRL).EQ.1)[
                        TDAIS(IC,IX,IT,IS)=
                        TDAIS(IC,IX,IT,IS)+TDAIS(IC,IX-1,IT,IS);
                        ]
                    ]
                ]
            ]
        ]
    ]

"STATISTICAL ANALYSES ON THE RAW DATA"
"THESE MACROS LOAD STATISTICAL ARRAYS, CALL DATA ANALYSIS ROUTINE"
"AND UNLOAD STASTICAL ARRAY INTO MEAN VALUE AND UNCERTAINTY ARRAY"

"CALCULATE THE UNCERTAINTIES"

$ANALYZE0 FMS USING MODE 0;
$ANALYZE0 FMSC USING MODE 0;
$ANALYZE0 FN USING MODE 2;
$ANALYZE0 FD USING MODE 2;
$ANALYZE0 FCN USING MODE 2;
$ANALYZE0 FCD USING MODE 2;
$ANALYZE0 FMM USING MODE 0;
$ANALYZE0 FMMC USING MODE 0;
$ANALYZE0 FSM USING MODE 2;
$ANALYZE0 FTM USING MODE 2;
$ANALYZE0 FSMC USING MODE 2;
$ANALYZE0 FTMC USING MODE 2;

"TOTAL EDEP"
$ANALYZE3 DOSE(NC;NR;1) USING MODE 2;
$ANALYZE1 SCAV(1,1) USING MODE 2;

"Ascat, Aatt"
IF(IFULL.GE.1)[
    $ANALYZE3 TDA(1,NC/1,NR/1,1) USING MODE 2;
    $ANALYZE1 TTDA(1,1) USING MODE 2;
    $ANALYZE3 DOSE(1,NC/1,NR/2,3) USING MODE 0;
    $ANALYZE1 SCAV(2,3) USING MODE 0;
    ]

"Apn"
IF(IFULL.GE.2)[
    $ANALYZE3 TDA(1,NC/1,NR/2,2) USING MODE 2;
    $ANALYZE1 TTDA(2,2) USING MODE 2;
    $ANALYZE3 DOSE(1,NC/1,NR/4,4) USING MODE 0;
    $ANALYZE1 SCAV(4,4) USING MODE 0;
    ]

"Afl AND <s>g,w"
IF(IFULL.EQ.3)[
    $ANALYZE3 TDA(1,NC/1,NR/3,4) USING MODE 2;
    $ANALYZE1 TTDA(3,4) USING MODE 2;
    $ANALYZE3 DOSE(1,NC/1,NR/5,ITMAX) USING MODE 0;
    $ANALYZE1 SCAV(5,ITMAX) USING MODE 0;
    ]

"CONVERT DOSE FROM MEV PER REGION PER BATCH TO GRAYS PER UNIT INCIDENT FLUENCE"
"RECALL 1 MeV = 1.602E-06 erg, 1 rad=100ergs/g, 1 rad=.01 Gys"
"THE UNIT OF DOSE IS GRAYS-CM**2"
"ONLY TOTAL DOSE CATEGORY. THE REST ARE RATIOS"
FMASSC=0.0; "TOTAL CAVITY MASS"
DO IX=1,NR[
    DO IC=1,NC[
        $GET-IRL(IC,IX);
        IF(NTRACK(IRL).EQ.1)[
            FMASS=AMASS(IC,IX);
            FMASSC=FMASSC+FMASS; "SUM THE CAVITY MASS USED LATER"
            IF(FMASS.EQ.0.0)FMASS=1.0; "AVOIDS /0 FOR VACUUM"
            IF(DOSE(IC,IX,1).NE.0.0)[
                DOSE(IC,IX,1)=DOSE(IC,IX,1)*1.602E-10/(FMASS*AINFLU);
                ]
            TDA(IC,IX,1)=TDA(IC,IX,1)*1.602E-10/(FMASS*AINFLU);
            IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
            DO IT=2,4[
                IF(FLURAT = 0.0)[OUTPUT;(' ****FLURAT=0 in divisor****'//);]
                TDA(IC,IX,IT)=TDA(IC,IX,IT)*1.602E-10/(FMASS*AINFLU*FLURAT);
                ]
                ]
"JAN CHANGE: NORMALIZATION IN CASE PARR BEAM, IFULL=3 OPTION"
           IF((IFULL.EQ.3).AND.(IPTSRC.EQ.0))[
            DO IT=2,4[
                TDA(IC,IX,IT)=TDA(IC,IX,IT)*1.602E-10/(FMASS*AINFLU);
                ]
                ]
"END OF JAN CHANGE"
            TDA(IC,IX,4)=TDA(IC,IX,4)*(RHO(2)/RHO(1));
            ]
        ]
    ]
IF(FMASSC.EQ.0.0)FMASSC=1.0; "AVOIDS /0 FOR VACUUM CAVITY"
SCAV(1)=SCAV(1)*1.602E-10/(FMASSC*AINFLU);
TTDA(1)=TTDA(1)*1.602E-10/(FMASSC*AINFLU);
IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
    DO IT=2,4[TTDA(IT)=TTDA(IT)*1.602E-10/(FMASSC*AINFLU*FLURAT);]
    ]

"JAN CHANGE: NORMALIZATION IN CASE OF PAR BEAM, IFULL=3 OPTION"
IF((IFULL.EQ.3).AND.(IPTSRC.EQ.0))[
    DO IT=2,4[TTDA(IT)=TTDA(IT)*1.602E-10/(FMASSC*AINFLU);]
    ]
"END OF JAN CHANGE"

TTDA(4)=TTDA(4)*(RHO(2)/RHO(1));

:IGNORE-OTHER-SCORING:

CALL OSUMRY; "PRINT THE OUTPUT SUMRY"

:END-OF-RUN:;

;"******************************************************************************
"
"                       *** SECTION 4 ***
"
"------------------------------------------------------------------------------
"
"THE CONCLUSION"
"
"------------------------------------------------------------------------------

:END:;
OUTPUT; (//'END OF RUN',9X,' ',$); call egs_fdate(6);
OUTPUT; (//);
write(iout,'(/a,$)') 'END OF RUN          '; call egs_fdate(iout);
write(iout,'(////)');

call egs_finish;

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IF( n_job = 0 ) [
        is_finished = .true.;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET;
        CALL SRCOTO(WEIGHT);
        "ZERO THE CAVITY SUMMARY ARRAY"
        DO IT=1,ITMAX[DO IS=1,$STAT[SCAVIS(IT,IS)=0.0;]]
        goto :STATS-ANAL:;
    ]
]
#endif;

$CALL_EXIT(0);

"FORTRAN FORMAT STATEMENTS. FORMAT STATEMENT N## IS FIRST USED IN SECTION N."
%I0
100  FORMAT('1',80A1//'NRCC calculation using CAVSPHnrc(EGSnrc) '$VERSION' ',
             /' on '$MACHINE' ',T55,' ',$);
200  FORMAT(//,79('*')/
            // ,T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
            // ,79('*')/
            //'Using CAVSPHnrc(EGSnrc) '$VERSION' on '$MACHINE' ');
201  FORMAT(/'********* NEW INPUT FILE *********'/);
202  FORMAT(/'********* RESTARTED INPUT FILE ********* '/
             ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
             ' ',20X,'NEW RN SEEDS=',2(1X,I12)/);
203  FORMAT(/'********* INPUT FILE CREATION ONLY *********'/);
204  FORMAT(/'********* DATA ANALYSIS ONLY *********'/);
205  FORMAT(/'********* RANDOM NUMBERS READ FROM FILE *********'/);
206  FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/);
210  FORMAT(/'********* NOT ENOUGH TIME TO FINISH WITHIN',
       ' LIMIT OF',F8.2,' HOURS',I5,' BATCHES USED********'/
       ' ',I12,' HISTORIES RUN, ',I12,' HISTORIES ANALYZED'//);
230  FORMAT(/'DESIRED STATISTICAL ACCURACY OBTAINED.'/
            ' STATS IN CAVITY= ',F5.2,
            ' AFTER ',I2,' BATCHES');
240  FORMAT(/'*********DESIRED STATISTICAL ACCURACY OF ',F5.2,'%',
            ' NOT REACHED*********'/
            ' STATS IN CAVITY= ',F5.2,' % AFTER ',I2,' BATCHES');
250  FORMAT(/'********* Final random number seeds:',2(1X,I12),' *********');
255  FORMAT(/' FOR PARALLEL RUNS:'/
             ' ----------------- '/
             ' On ',I5,' machines '/
             ' Total cputime =',F8.1,'s (=',F8.2,' hr), cputime/machine =',
              F8.1,'s');
260  FORMAT(/'Finished simulations:time elsapsed,CPU',
             ',ratio= ',2F8.1,'(=',F5.2,'h)',F8.2);
261  FORMAT(/' Finished: time elapsed this run', F10.1/
             '           CPUtime total run    ', F10.1,'(=',F8.2,'hr)'/
             '           Ratio elapsed/CPU this run:', F8.3);
280  FORMAT(/'CPUtime/history=',F10.5,'  sec.  Histories/hour=',F12.0);
400  FORMAT(/'End of run',10X,1X////);

END; "END OF MAIN ROUTINE-CAVSPHnrc"
%C80
%I4
%Q1
%E     "cavsphnrc.mortran"
"******************************************************************************
"
"
"                               **********
"                               *        *
"                               * AUSGAB *
"                               *        *
"                               **********
"
"
"       AN AUSGAB ROUTINE TO BE USED WITH cavsphnrc.mortran
"
"       THIS ROUTINE SCORES THE DOSE AND OTHER IONISATION CAVITY PARAMETERS
"       IN A FINITE, AZIMUTHALLY SYMMETRIC CYLINDRICAL GEOMETRY WHICH THE
"       USER DEFINES VIA PLANE AND RADIUS COORDINATES. THE USER MUST SPECIFY
"       BOTH THE TARGET GEOMETRY AS WELL AS THE PLANES AND RADII BETWEEN
"       WHICH THE QUANTITIES ARE TO BE SCORED. ALL THE GEOMETRICAL CHECKS FOR
"       CROSSING 'GEOMETRICAL' OR 'DOSE' REGIONS ARE HANDLED BY THE SUBROUTINE
"       HOWFAR.
"
"       FOR IT = 1      THE TOTAL PRIMARY DOSE
"              = 2      THE TOTAL DOSE DOSE LESS THE TOTAL PRIMARY DOSE
"                       (i.e. THE SCATTER FRACTION FOR CALCULATING Ascat)
"              = 3      THE TOTAL PRIMARY UNATTENUATED DOSE LESS THE
"                       TOTAL PRIMARY DOSE (FOR CALCULATING Aatt)
"              = 4      THE TOTAL PRIMARY UNATTENUATED DOSE WITH THE SOURCE
"                       DISTRIBUTION FACTORED OUT LESS THE TOTAL PRIMARY
"                       UNATTENUATED DOSE (FOR CALCULATING Apn)
"              = 5      THE TOTAL PRIMARY UNATTENUATED DOSE TO THE CAVITY
"                       GAS WITH THE SOURCE DISTRIBUTION FACTORED OUT WITH
"                       THE ELECTRON TRANPORT TAKING PLACE IN THE CHAMBER
"                       WITH THE CAVITY FILLED WITH WALL MATERIAL (FOR
"                       CALCULATING Afl AND THE STOPPING POWER RATIO)
"              = 6      THE TOTAL PRIMARY UNATTENUATED DOSE TO THE WALL
"                       MATERIAL WITH THE SOURCE DISTRIBUTION FACTORED OUT WITH
"                       THE ELECTRON TRANPORT TAKING PLACE IN THE CHAMBER
"                       WITH THE CAVITY FILLED WITH WALL MATERIAL (FOR
"                       CALCULATING THE STOPPING POWER RATIO)
"
"
"       VERSION 01      ADAPTED FROM CAVITY(EGS3) AUSGAB      10/87  AFB
"
;"******************************************************************************
%Q0
SUBROUTINE AUSGAB(IARG);

$IMPLICIT-NONE;
;REPLACE {$SCORE-IT-MODE(#,#);} WITH
"        ====================="
 {;SCDOSE(IC,IX,{P1})=SCDOSE(IC,IX,{P1})+{P2};}

REAL*8 DEDXC,DEDXM,DELTAC,DELTAM,SRATIO,FTMP;
integer*4 ip;

$INTEGER IRL,IX,IC,IQL,LATCHL,IARG,LELKE,LGLE,IDUMMY;
$REAL WTL,FDUMMY,xsi;
;COMIN/
ELECIN,EPCONT,GEOM,MEDIA,PHOTIN,RUSROU,SCORE,SOURCE,STACK,USEFUL,USER,
 RANDOM,BOUNDS/;
"STACK OVERFLOW CHECK"
MXNP=MAX(MXNP,NP);"KEEP TRACK OF HOW DEEP STACK IS"
IF(NP.GE.$MXSTACK)["STACK AS DEEP AS ALLOWED"
OUTPUT NP,$MXSTACK;(' IN AUSGAB, NP=',I3,' ]= MAXIMUM STACK ALLOWED=',
I3,/1X,80('*')/);STOP;]

"CHECK IF PARTICLE IS LEAVING THE TRANSPORT GEOMETRY"
IRL=IR(NP);  "LOCAL REGION NUMBER"
IF(IRL.EQ.1) RETURN; "OUTSIDE THE CHAMBER"

"OBTAIN FREQUENTLY USED LOCAL VARIABLES"
$GET-IX-IC(IRL);   "LOCAL CONE AND RADIUS NUMBERS"
IQL=IQ(NP);        "LOCAL CHARGE VARIABLE"
WTL=WT(NP);        "LOCAL WEIGHT VARIABLE"
LATCHL=LATCH(NP);  "LATCHL=0 FOR PRIMARIES, 1 OTHERWISE"

IF( use_enhance | n_split > 1 ) [
    IF( edep > 0 & wtl > 0 & iarg < 5 & ntrack(irl) = 1 ) [
        "If we use cross section enhancement or photon splitting,"
        "all energy scoring is done here and the rest of ausgab is ignored  "
        "We use the technique proposed by the PENELOPE group for scoring "
        "the energy deposition. This results in a much better estimate   "
        "of the uncertainty                                              "

        ftmp = wtl*edep;
        IF( the_case = last_case ) [
            " Still the same history scoring into the cavity => update    "
            " temporary variables                                         "
            IF( latchl ~= 2 ) tmp_dose = tmp_dose + ftmp;
            IF( latchl ~= 3 ) tmp_dose1 = tmp_dose1 + ftmp;
        ]
        ELSE [
            " A new history scoring into the cavity. "
            last_case = the_case;
            cav_dose = cav_dose + tmp_dose;
            cav2_dose = cav2_dose + tmp_dose*tmp_dose;
            cav_dose1 = cav_dose1 + tmp_dose1;
            cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;
            cav_dosec = cav_dosec + tmp_dose*tmp_dose1;
            IF( latchl ~= 2 ) [ tmp_dose = ftmp; ] ELSE [ tmp_dose = 0; ]
            IF( latchl ~= 3 ) [ tmp_dose1 = ftmp;] ELSE [ tmp_dose1 = 0; ]
        ]
        return;
    ]
]

IF( use_enhance ) [ "If we use cross section enhancement, all scoring "
                    " is done here and the rest of ausgab is ignored  "

    IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23)
    [
        "A pair/Compton/photoelectric/Rayleigh event is about to take place"
        "As we have increased the photon cross section by a factor of      "
        "cs_enhance, we must split the photon into a scattering portion    "
        "(1/cs_enhance) and a nor-scattering portion (1-1/cs_enhance)      "
        "Start with placing an identical photon on the stack               "
        np = np + 1;
        IF(np + 1 > $MXSTACK) [
            OUTPUT;
            ( ' Calculation with CS-enhancement: unable to boost stack.'/
                ' Stopping.'/ 1x,80('*')/);
            stop;
        ]
        $TRANSFER PROPERTIES TO (np) FROM (np - 1);
        e(np)  =  e(np - 1);
        u(np)  =  u(np - 1);
        v(np)  =  v(np - 1);
        w(np)  =  w(np - 1);
        iq(np) = iq(np - 1);
        IF( latch(np-1)  ~= 2 ) [
          " This is either a primary photon that has not yet been attenuated "
          " away or a scattered photon. Let's decide what to do with the     "
          " unscattered fraction of that photon (which is at np-1)           "
            $RANDOMSET xsi;
            IF( cs_enhance*xsi < 1 ) [  " The photon doesn't survive. "
                IF( latch(np-1) = 3 ) [ " It is a scattered photon => kill it"
                    wt(np-1) = 0; dnear(np-1) = -1;
                ]
                ELSE [ " This is a primary => mark it as attenuated.         "
                       " From now on, all descendents of this photon will    "
                       " only contribute to the cavity dose with attenuation "
                       " and scatter removed                                 "
                    latch(np-1) = 2;
                ]
            ]
        ]
        "Adjust the weight of to be scattered photon"
        wt(np) = wt(np)/cs_enhance;
        return;
    ]


    IF( iarg = 18 | iarg = 20 | iarg = 24 |
         " A Compton/photo-absorption/Rayleigh event just occured"
        iarg = 7 | iarg = 13 | iarg = 14 ) [
         " A bremas/annihilation event just occured"
         " All scattered photons and photons originating in brems/annihilation"
         " events contribute to the scattered dose. But because all of them   "
         " have a small weight (initial weight/cs_enhance), we will play      "
         " Russian Roulette with them, using 1/cs_enhance as a surviving       "
         " probability. If they survive, their weight will become equal to the"
         " intial photon weight. In addition, we have to set their latch to 3 "
         " so that they and rheir descendents only contribute to the scattered"
         " dose.                                                              "
        $RANDOMSET xsi; xsi = xsi*cs_enhance;
        DO ip=NPold,NP [
            IF( iq(ip) = 0 ) [
                IF( latch(ip) = 2 ) [ "that's a descendent of a photon that"
                                      "has been attenuated away => kill it"
                    wt(ip) = 0; dnear(ip) = -1;
                ]
                ELSE [
                  IF( e(ip) >= pcut(irl) ) [
                    IF( xsi < 1 ) [ latch(ip) = 3; wt(ip) = wt(ip)*cs_enhance; ]
                    ELSE          [ wt(ip) = 0; dnear(ip) = -1; ]
                  ]
                  ELSE [ latch(ip) = 3; ]
                   " i.e. we don't need the Russian Roulette for photons below"
                   " threshold because they will be discarded and their energy"
                   " deposited locally anyway                                 "
                ]
            ]
        ]
        return;
    ]
    return;
]

IF( n_split > 1 ) [

    IF( iarg = 7 | iarg = 13 | iarg = 14 ) [
        IF( iifano = 1 ) [
            DO ip=NPold,NP [
                IF( iq(ip) = 0 ) [ wt(ip) = 0; e(ip) = 0; ]
            ]
            return;
        ]
        DO ip=NPold,NP [
            IF( iq(ip) = 0 ) [
                $RANDOMSET XSI;
                IF( xsi*n_split > 1) [ wt(ip) = 0; e(ip) = 0; ]
                ELSE [ latch(ip) = 3;  wt(ip) = wt(ip)*n_split; ]
            ]
        ]
        return;
    ]
]

IF((NTRACK(IRL).EQ.1).AND.(LATCHL.EQ.0))[
    "A PRIMARY HAS INTERACTED WITH THE CAVITY"
    INEED2=1; "SET FLAG ASKING FOR SECOND PASS"
    ]

IF(IARG.EQ.0)["ABOUT TO TRANSPORT A PARTICLE"
    IF(IQL.NE.0)[
        IF(LATCHL.EQ.0)[ "COUNT PRIMARY CHARGED PARTICLES ONLY"
            IF(IPASS.EQ.0)[ "FIRST PASS ONLY"
                IST=IST+1;"COUNT CHARGED PARTICLE STEPS TAKEN"
                IF(NTRACK(IRL).EQ.1) ISTC=ISTC+1;"COUNT STEPS IN CAVITY REGION"
                ]
            IF(IPASS.EQ.2)[ "THIRD PASS ONLY"
                ISM=ISM+1;"COUNT CHARGED PARTICLE STEPS TAKEN"
                IF(NTRACK(IRL).EQ.1) ISMC=ISMC+1;"COUNT STEPS IN CAVITY REGION"
                ]
            ]
        ]
    ELSE["PHOTON STEP - PLAY RUSSIAN ROULETTE?"
        IF(RUSROU.AND.(W(NP).GT.0.0))["YES, PLAY IF CROSSES RRZ "
            IF((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))["CROSSES"
                $RANDOMSET XSI;
                    IF(XSI.LT.RRCUT)[
                        "PARTICLE SURVIVES"
                        WT(NP)=WTL/RRCUT;
                        ]
                    ELSE["DISCARD PARTICLE ON NEXT CALL TO HOWFAR"
                        WT(NP)=0.0;
                        ]
                ] "END TEST IF CROSSES RUSSIAN ROULETTE PLANE"
            ] "END TEST FOR PLAYING RUSSIAN ROULETTE"
        ] "END TEST FOR PHOTON STEP"
    ] "END TEST FOR IARG = 0"

IF(IWATCH.GT.0) [CALL WATCH(IARG,IWATCH); "SIGNAL WATCH ROUTINE IF ACTIVE"]

IF (ifano = 1)
[
    IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23)
    [
        "A pair/Compton/photoelectric/pair event is about to take place"
        np = np + 1; "Boost the stack"
        IF(np + 1 > $MXSTACK)
        [
            OUTPUT;
            (
                ' Fano calculation unable to boost stack.'/
                ' Stopping.'/
                1x,80('*')/
            );
            stop;
        ]
        "Create an identical photon"
        $TRANSFER PROPERTIES TO (np) FROM (np - 1);
        e(np)  =  e(np - 1);
        u(np)  =  u(np - 1);
        v(np)  =  v(np - 1);
        w(np)  =  w(np - 1);
        iq(np) = iq(np - 1);
        return;
    ]

    "Throw away any scattered photons from the primary interaction site."
    " Now there is a stack pointer NPold which points to the particle "
    " befor the last discrete interaction. This change was necessary "
    " for the implementation of atomic relaxations. So, check all particles"
    " between NPold and NP and discard photons "
    "IF ( (iarg = 18 & NP > NPold)" " Compton has occured"
    IF (  iarg = 18               " Compton has occured"
        | iarg = 20               " After photo-absorption "
        | iarg = 24               " After Rayleigh "
        | iarg = 7                " After brems "
        | iarg = 13               " After annihilation "
        | iarg = 14)              " After annihilation at rest "
    [
        DO ip=NPold,NP [
            IF( iq(ip) = 0 ) [ wt(ip) = 0; e(ip) = 0; ]
        ]
    ]
]

IF (ifano = 2)
[
    IF (  iarg = 16               " After pair production "
        | iarg = 18               " After Compton "
        | iarg = 20)              " After photo absorption "
    [
       IF ( NTRACK(ir(np)) = 0)
       [
          DO ip=NPold,NP
          [
             IF( iq(ip) ~= 0 ) [ wt(ip) = 0; e(ip) = 0; ]
          ]
        ]
    ]
]

"SCORE THE ENERGY AS REQUIRED FOR THE DIFFERENT MODES"
"****************************************************"

IF((EDEP.NE.0.0).AND.(WTL.GT.0.0).AND.(IARG.LT.5).AND.(NTRACK(IRL).EQ.1))[
    "ENERGY HAS BEEN DEPOSITED IN THE CAVITY REGION"

    "SCORE PRIMARY AND SECONDARY ENERGY DEPOSITED"
    FTMP=WT(NP)*EDEP;

"***************************************************************************"
"                                                                           "
" Implementation of a history by history scoring scheme for the cavity dose "
" taken from the splitting implementation, January, EMH, 2002               "
"                                                                           "
"         tmp_dose  ==> total dose                                          "
"         tmp_dose1 ==> primary dose multiplied by unweighting factor       "
"                       (i.e., corrected for att. an scatt.)                "
"                                                                           "
"         expmfp = exp(di) - 1 (see macro $SELECT-PHOTON-MFP)               "
"                                                                           "
"***************************************************************************"
        IF( the_case = last_case ) [
            " Still the same history scoring into the cavity => update    "
            " temporary variables                                         "
            tmp_dose = tmp_dose + ftmp;
            IF( latchl = 0 ) [
              tmp_dose0 = tmp_dose0 + ftmp;
              tmp_dose1 = tmp_dose1 + ftmp*(expmfp+1);
            ]
            ELSE [
              tmp_dose2 = tmp_dose2 + ftmp;
            ]
        ]
        ELSE [
            " A new history scoring into the cavity. "
            last_case = the_case;

            cav_case = cav_case + 1;

            cav_dose  = cav_dose + tmp_dose;
            cav2_dose = cav2_dose + tmp_dose*tmp_dose;

            cav_dose0  = cav_dose0 + tmp_dose0;
            cav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;

            cav_dose1  = cav_dose1 + tmp_dose1;
            cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;

            cav_dose2  = cav_dose2 + tmp_dose2;
            cav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;

            cav_dosec = cav_dosec + tmp_dose*tmp_dose1;
            cav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
            cav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;

            tmp_dose = ftmp;

            IF( latchl = 0 ) [
                tmp_dose0 = ftmp ;
                tmp_dose1 = ftmp*(expmfp+1) ;
                tmp_dose2 = 0.0;
            ]
            ELSE [
                tmp_dose0 = 0.0;
                tmp_dose1 = 0.0;
                tmp_dose2 = ftmp;
            ]
        ]

"*************************************************************************"
" CONTINUE WITH USUAL SCORING SCHEME ...                                  "
"*************************************************************************"
    IF(IFULL.LE.1)[ "NO CORRELATIONS"
        "SIGNAL THE MAIN ROUTINE THAT ENERGY HAS BEEN DEPOSITED IN THE CAVITY"
        IDECAV=1;
        ]
    ELSEIF(IFULL.EQ.3)[ "???CORRELATED RUN"
        IF(IDECAV.EQ.0)[ "NOTHING HAPPENED YET"
            IF(LATCHL.EQ.0)[IDECAV=1; "PRIMARY DEPOSTION"]
            ELSE[IDECAV=2; "SECONDARY DEPOSITION"]
            ]
        ELSEIF(IDECAV.EQ.1)[ "PRIMARY DEPOSTITION OCCURED PREVIOUSLY"
            IF(LATCHL.GT.0) IDECAV=3; "PRIMARY AND SECONDARY DEPOSTION"
            ]
        ELSEIF(IDECAV.EQ.2)[ "SECONDARY DEPOSTITION OCCURED PREVIOUSLY"
            IF(LATCHL.EQ.0) IDECAV=3; "PRIMARY AND SECONDARY DEPOSTION"
            ]
        ]

    "SCORE PRIMARY AND SECONDARY ENERGY DEPOSITED"
    "FTMP=WT(NP)*EDEP;"

    IF(LATCHL.EQ.0)[ "SCORE PRIMARY DOSE"

        IF(IPASS.EQ.0)[ "FIRST PASS ONLY"
            $SCORE-IT-MODE(1,FTMP);
            IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
"JAN CHANGE Just for debugging"
"IF (ICASE.EQ.7)["
"end of change"
                OUTPUT FTMP,IRL,IARG;
                (' ***PRIMARY DOSE SCORED = ',E14.7,' MeV. IRL= ',I3,
                ' IARG= ',I3);
            ]
        ]

        IF(IFULL.GE.1)[
            "ONLY DO THIS SECTION FOR THE FULL CALCULATION.                    "
            "SCORE TOTAL ENERGY UNWEIGHTED BY PHOTON SURVIVAL PROBABILITY-1    "
            "FOR 1/Aatt-1. EXPMFP IS EXP(# OF MEAN FREE PATHS TRAVERSED)-1     "
            "USED TO UNWEIGHT THE ENERGY. EXPMFP IS CALCULATED IN PHOTON VIA   "
            "A MACRO DEFINED IN CAVSPHnrc."
            IF(IPASS.EQ.0)[ "FIRST PASS ONLY"
                $SCORE-IT-MODE(3,FTMP*EXPMFP);
                ]
            FTMP=FTMP*(1.+EXPMFP);
            IF((IPASS.EQ.0).AND.(IWATCH.GT.1).AND.(IWATCH.NE.4))[
                OUTPUT FTMP,IRL,IARG;
                (' ***PRIMARY UNATTENUATED DOSE SCORED = ',
                E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
                ]
            ] "END OF IFULL>=1 PART"
        IF((IFULL.GE.2).AND.(IPTSRC.EQ.1).AND.(IPASS.EQ.1))[
            "ON THE SECOND PASS ONLY IF A POINT SOURCE"
            $SCORE-IT-MODE(4,FTMP);
            IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
                OUTPUT FTMP,IRL,IARG;
                (' ***1st CORRELATION PRIMARY DOSE SCORED = ',
                 E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
                ]
            ]
        IF((IFULL.EQ.3).AND.(IPASS.EQ.2))[ "MATERIAL CORRELATION SCORING"
            "CALCULATE EDEP TO CAVITY MATERIAL "
            "NOTE THAT FOR IARG=0, EKE AND ELKE ARE ASSUMED TO BE "
            "EVALUATED AT THE STEP MID-POINT. THIS IS EFFECTED BY THE"
            "$DEDX-RE-EVALUATION MACRO WHICH IS ALWAYS IN FORCE WHEN "
            "IEDEP IS 0 AND THE NRCCMACP MACROS ARE LINKED IN. THIS IS"
            "THE DEFAULT FOR ALL PRESTA CODES. TRACK ENDS ARE EVALUATED"
            " a la Nahum.                                              "
            MEDIUM=2;     "CAVITY MATERIAL"
            $SET INTERVAL ELKE,EKE; "PREPARE TO INTERPOLATE IN TABLES"
            IF(IQL.EQ.-1)[ "ELECTRON"
                $EVALUATE DEDXC USING EDEDX(ELKE);
                MEDIUM=1; "RESET TO WALL MATERIAL"
                $EVALUATE DEDXM USING EDEDX(ELKE);
                SRATIO=DEDXC/DEDXM;
                ]
            ELSEIF(IQL.EQ.0)[ "PHOTON TRACK END"
                $SET INTERVAL GLE,GE;
                $EVALUATE DELTAC USING GMFP(GLE);
                MEDIUM=1; "RESET TO WALL MATERIAL"
                $EVALUATE DELTAM USING GMFP(GLE);
                SRATIO=DELTAM/DELTAC;
                ]
            ELSE[ "POSITRON"
                $EVALUATE DEDXC USING PDEDX(ELKE);
                MEDIUM=1; "RESET TO WALL MATERIAL"
                $EVALUATE DEDXM USING PDEDX(ELKE);
                SRATIO=DEDXC/DEDXM;
                ]

            $SCORE-IT-MODE(5,FTMP*SRATIO); "FACTOR FOR Afl and <s>g,w"
            $SCORE-IT-MODE(6,FTMP);        "FACTOR FOR <s>g,w"
            IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
                OUTPUT FTMP*SRATIO,IRL,IARG;
                (' ***PRIMARY DOSE SCORED TO GAS IN FILLED CAVITY= ',
                E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
                OUTPUT FTMP,IRL,IARG;
                (' ***PRIMARY DOSE SCORED TO FILLED CAVITY= ',
                E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
                ]
            ]  "END OF CORRELATION SCORING"
        ] "END OF PRIMARIES SCORING"

    ELSEIF(IPASS.EQ.0)[ "SCORE SECONDARY DOSE ON FIRST PASS"
        $SCORE-IT-MODE(2,FTMP);
        IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
            OUTPUT FTMP,IRL,IARG;
            (' ***SECONDARY DOSE SCORED = ',E14.7,' MeV. IRL= ',I3,
            ' IARG= ',I3);
            ]
        ]

] "END OF ENERGY DEPOSITED IN THE CAVITY"

"SET FLAG FOR SECONDARY INTERACTIONS"
"***********************************"

IF((IFULL.GT.0).AND.(IARG.GT.5).AND.(LATCHL.EQ.0))
[
"ONLY IF PRIMARY PARTICLES HAVE INTERACTED DISCRETELY                 "
"IF A SECONDARY PARTICLE IS CREATED ON THE SECOND PASS, GIVE IT A ZERO"
"WEIGHT SO THAT HOWFAR WILL DISCARD IT.                               "

    IF( iarg = 7 ) [  "brem has occured"

        IF( iql = 0 ) [ $EXCHANGE-STACK(NP,NP-1); ]
        latch(np-1) = 1;  "Flag the photon as a secondary"
        IF( ipass >= 1 ) [ wt(np-1) = 0; ] "To save time in correlation runs"

    ]
    ELSE IF( iarg = 18 ) [ "Compton has occured, with binding effects"
                           "taken into account, 0, 1, or more particles"
                           "may have resulted"

        "IF( NP > NPold ) [" "Secondaries were produced. We will flag the"
                           "photons but not exchange them on the stack"
            DO ip=NPold,NP [
                IF( iq(ip) = 0 ) [
                    latch(ip) = 1;
                    IF( ipass >=1 ) [ wt(ip) = 0; ] "To save time"
                ]
            ]
        "]"
        " NP = NPold means the interactiopn has been rejected and thus "
        " the emerging (unscattered) photon  is still a primary "
    ]
    ELSE IF( iarg = 9 ) [ "Moller has occured. For now there is only"
                          "one secondary. When impact ionization is implemented"
                          "the following should be changed"
        IF( e(np) < e(np-1) ) [ $EXCHANGE-STACK(NP,NP-1); ]
    ]
    ELSE IF( iarg = 13 | iarg = 14 ) ["Annihilation, flag the photons"
        latch(np)   = 1;
        latch(np-1) = 1;
        IF( ipass >= 1 ) [ wt(np) = 0; wt(np-1) = 0; ]
    ]
    ELSE IF (iarg = 20)
    [
        DO ip=NPold,NP [
            IF( iq(ip) = 0 )
            [
               latch(ip) = 1;
               IF( ipass >= 1 ) [ wt(ip) = 0; e(ip) = 0; ]
            ]
        ]
    ]
    ELSE IF( iarg = 24 ) [
        latch(np) = 1;
        IF( ipass >= 1 ) [ wt(np) = 0; ]
    ]

]

RETURN;

END;  "END OF SUBROUTINE AUSGAB"
"%U11   PICK UP ENSRC.MOR FROM THE HENHOUSE ON UNIT 11"
%I4
%C80
%Q1
%E     "cavsphnrc.mortran"
"*****************************************************************************
"
"
"                       ************
"                       *          *
"                       * GRID.MOR *
"                       *          *
"                       ************
"
"
"       A ROUTINE TO DETERMINE WHETHER OR NOT A GRID TYPE OUTPUT WILL
"       FIT ON A SINGLE PAGE WITH A VARIETY OF DIFFERENT CHOICES FOR
"       THE NUMBER OF CHARACTERS/INCH AND LINES/INCH
"
"       VARIABLES
"       =========
"
"       GRIDWD  THE WIDTH OF THE ENTIRE OUTPUT GRID IN CHARACTERS
"       GRIDHT  THE HEIGHT OF THE ENTIRE OUTPUT IN LINES
"       MXLP11  THE MAXIMUM NUMBER OF LINES ALLOWED ON THE FIRST PAGE
"       MXLP12  THE MAXIMUM NUMBER OF LINES ON SUCESSIVE PAGES
"                ABOVE TWO ARE LINES PER PAGE FOR 6 OR 8 LPI ?  D.R.
"
"       VARIABLES SET WITHIN ROUTINE AND RETURNED
"       =========================================
"
"       ICHPIN  CHARACTERS/INCH
"       ILPIN   LINES/INCH
"       FITS    TRUE IF WILL FIT ON A SINGLE PAGE ELSE FALSE
"               IF FALSE, ICHPIN=16 AND ILPIN=6 ARE SET
"
"       VERSION 01      6/84  E.F.
"               02      9/85  D.R. HANDLE CASE GRIDWD>132
"
"****************************************************************************

SUBROUTINE GRID(GRIDWD,GRIDHT,MXLP11,MXLP12,ICHPIN,ILPIN,FITS);

LOGICAL FITS;
INTEGER GRIDWD,GRIDHT,ICHPIN,ILPIN;

FITS=.TRUE.; "ASSUME IT FITS"

IF(GRIDWD.LE.96)[        ICHPIN=12;    "12 VERTICAL LINES PER INCH"]
ELSEIF(GRIDWD.LE.105)[   ICHPIN=13;    "13 VERTICAL LINES PER INCH"]
ELSEIF(GRIDWD.LE.132)[   ICHPIN=16;    "16 VERTICAL LINES PER INCH"]
ELSE[                    FITS=.FALSE.; "DOES NOT FIT, TOO WIDE"]

IF(GRIDHT.LE.MXLP11)[    ILPIN=6;      "6 HORIZONTAL LINES PER INCH"]
ELSEIF(GRIDHT.LT.MXLP12)[ILPIN=8;      "8 HORIZONTAL LINES PER INCH"]
ELSE[                    FITS=.FALSE.; "DOES NOT FIT, TOO LONG"]

RETURN;
END;"END OF SUBROUTINE GRID"

%Q1
%C80
%I2
%E     "cavsphnrc.mortran"
;"******************************************************************************
"
"                               **********
"                               *        *
"                               * HOWFAR *
"                               *        *
"                               **********
"
"       A GENERAL PURPOSE SPHERICAL GEOMETRY ROUTINE FOR USE WITH THE EGS3
"       CODE SYSTEM ADAPTED FOR USE WITH CAVSPHnrc.
"
"       FOR PARTICLE NP ON THE STACK IN REGION IR(NP), THIS ROUTINE
"       DETERMINES IF THE PARTICLE CAN GO A DISTANCE USTEP WITHOUT CHANGING
"       ZONES. IF USTEP CAUSES A ZONE CROSSING, IT IS REDUCED TO PLACE IT ON
"       THE BOUNDRY AND IRNEW IS SET TO THE ZONE NUMBER ON THE FAR SIDE OF
"       THE BOUNDARY. IF IR(NP) IS 1 THEN THE PARTICLE HAS ESCAPED THE REGION
"       OF INTEREST AND THE HISTORY IS TERMINATED.(IDISC IS SET TO 1.)
"
"
"
"
"       SOME VARIABLES
"       ==============
;"
"OUTEND =       .TRUE.  =>      PARTICLE MAY TRANSMIT OR BACKSCATTER OUT ENDS
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE END BOUNDARIES
"OUTSID =       .TRUE.  =>      PARTICLE MAY TRANSMIT OUT THE SIDES
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE SIDE BOUNDARY
"IRL    =       STARTING REGION NUMBER THE PARTICLE IS IN
"IC     =       STARTING CONICAL ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN ALPHA(IC) AND ALPHA(IC+1).
"IX     =       STARTING SPHERICAL ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN RSPH(IX-1) AND RSPH(IX).
"
"       COMMON/GEOM/
"               ALPHA(IC)       Z VALUES OF CONES
"                               1<=IC<=NC+1
"               RSPH(IRR)       RADII OF SPHERES
"                               1<=IRR<=NR
"               RSPH2(IRR)      =RSPH(IRR)**2
"               NC              # CONICAL GEOMETRICAL ZONES (NCONE+1)
"                               ZONE(I) IS BETWEEN ALPHA(I) AND ALPHA(I+1)
"               NR              # SPHERICAL GEOMETRICAL ZONES
"                               ZONE(I) IS BETWEEN RSPH(I-1) AND RSPH(I)
"               NREG            TOTAL # GEOMETRICAL ZONES =NR*NC +1
"                                       +1 FOR VACUUM ENVELOPE
%E     "cavsphnrc.mortran"
"       DEFINITIONS OF REGION NUMBER, CONICAL ZONE, SPHERICAL ZONE
"       ===========================================================
"               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
"
"
"                                       1
"
"
"       --------------------------------------------------------- RSPH(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NC | NR*NC |    IX=NR
"       | *NC+2 | *NC+3 | *NC+4 |               |       |   +1  |
"       --------------------------------------------------------- RSPH(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RSPH(2)
"       |  NC+2 |  NC+3 |  NC+4 |    . . . .    |  2NC  | 2NC+1 |    IX=2
"       --------------------------------------------------------- RSPH(1)
"..1....|...2...|...3...|...4...|...............|...NC..|..NC+1.|....IX=1..1..
;"      ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IC=1    IC=2    IC=3                   IC=NC-1  IC=NC
"
"                                       1
"
"
"
"       VERSION 1       ADAPTED FROM CAVITY(EGS3) HOWFAR      10/87  AFB
"                       THE SUBROUTINE CALLS TO CONES AND
"                       SPHERE HAVE BEEN REPLACED BY MACROS
"                       TO SPEED THINGS UP
"
"
"******************************************************************************
"
;
%E     "cavsphnrc.mortran"
"THE MACRO REPLACING THE CALL TO SPHERE
"*****************************************************************************
"
"                               ***********
"                               *         *
"                               * $SPHERE *
"                               *         *
"                               ***********
"
"MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT SPHERES,
"THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A SPHERE.
"THE SPHERES ARE ASSUMED TO BE CENTERED AT THE ORIGIN.
"
"       SOME VARIABLES
"       ==============
"
"{P1} = IX    = THE NUMBER OF THE OUTER SPHERE
"{P2} = IHITS = 1 => PARTICLE HITS THE OUTER SURFACE
"             = 0 => PARTICLE MISSES THE SURFACES
"             =-1 => PARTICLE HITS THE INNER SURFACE
"{P3} = TSPH  = DISTANCE TO SURFACE IF IT HITS
"RSPH2(IX)    = RADIUS**2 OF SPHERE
"
"FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
"FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TSPH=0.
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             88/03
"                                ADAPTED FROM SCASPH (EGS3)
"
"******************************************************************************
"
;
REPLACE {$SPHERE(#,#,#);} WITH {
B=UL*XL+VL*YL+WL*ZL;"projection of particle radio vector"
B2=B*B;             "on particle direction"
C=XL*XL+YL*YL+ZL*ZL;"distance of particle to origin"
:START-SPHERE:;
IF({P1}.NE.1)["not inner most sphere"
    CIN=C-RSPH2({P1}-1);
    IF(CIN.LT.0.0)["distance to particle smaller than inner radius"
        IRL=IRL-NC;"reset everything ..."
        IR(NP)=IRL;"reset to the corresponding zone"
        {P1}={P1}-1;"reset to correspponding spheres"
        GEOBUG=1;   "signal a bug"
        GOTO :START-SPHERE:;"try again"
    ]
    IF(B2.LT.CIN)  [{P2}=0;]
    ELSEIF(B.GE.0.)[{P2}=0;]
    ELSE["B is negative"
        {P2}=-1;
        TEST=CIN/B2;
        IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST); ]
        ELSEIF(TEST.GE.1.)    [BS=B;                   ]
        ELSE                  [BS=B*(1.+SQRT(1.-TEST));]
        "{P3}=-CIN/BS; since B is < 0.0"
        IF (BS.NE.0.0)[
          {P3}=-CIN/BS;
        ]
        ELSEIF (BS.EQ.0.0)[
          write(6,*) ' exception caught in sphere macro';
          write(6,*) ' BS= ', BS;
          stop;
        ]
        ELSE [
          write(6,*) 'BS is undefined!!! BS= ', BS;
          write(6,*) 'TEST=', TEST, ' B2=', B2, ' COUT=',CIN;
          stop;
        ]
        GOTO :END-SPHERE:;
    ]
]
COUT=C-RSPH2({P1});
IF(COUT.GT.0.0)["distance to particle larger than outer radius"
    IRL=IRL+NC;"reset everything ..."
    IR(NP)=IRL;"update zone"
    {P1}={P1}+1;""
    GEOBUG=1;
    GOTO :START-SPHERE:;
]
{P2}=1;
IF(B.EQ.0.)[{P3}=SQRT(-COUT);]
ELSE[
    TEST=COUT/B2;
    IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST); ]
    ELSEIF(TEST.GE.1.)    [BS=B;                   ]
    ELSE                  [BS=B*(1.+SQRT(1.-TEST));]
    IF(B.LE.0.)[{P3}=-BS;]
    ELSE[
       IF ((BS.NE.0.0))[
          {P3}=-COUT/BS;
       ]
       ELSEIF (BS.EQ.0.0)[
          write(6,*) ' exception caught in sphere macro';
          write(6,*) ' BS= ', BS;
       ]
       ELSE [
          write(6,*) 'BS is undefined!!! BS= ', BS;
          write(6,*) 'TEST=', TEST, ' B2=', B2, ' COUT=',COUT;
          stop;
       ]

    ]
]
:END-SPHERE:;
}

;
"THE MACRO REPLACING THE CALL TO CONES
"******************************************************************************
"
"                               **********
"                               *        *
"                               * $CONES *
"                               *        *
"                               **********
"
"PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONES WITH AXES
"ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
"IT MUST GO TO HIT ONE OF THE CONES
"
"       SOME VARIABLES
"       ==============
"
"{P1} = IC    = THE CONE NUMBER OF THE REGION THE PARTICLE IS IN
"{P2} = IHITC = 1  => PARTICLE HITS THE OUTER CONE
"             = 0  => PARTICLE MISSES BOTH CONES
"             = -1 => PARTICLE HITS THE INNER CONE
"{P3} = TCONE = DISTANCE TO THE CONE THAT IT HITS
"TANAL2(IX)   = TANGENT**2 OF CONE OPENING ANGLE
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             88/03
"                                ADAPTED FROM SCASPH (EGS3)
"
"******************************************************************************
"
"------------------------------------------------------------------------------"
"                                                                              "
"   macro below replaces GOTO statements between IF-BLOCKS avoiding compiler   "
"   warnings.                                                                  "
"                                                                              "
" {P1} => as above, cone number of the region the particle is in               "
" {P2} => +/- depending whether region number is to be increased or decreased  "
"                                                          EMH, June 5, 2002   "
"------------------------------------------------------------------------------"
;
REPLACE {$RESET REGION # #;} WITH {;
IRL = IRL {P2} 1;
IR(NP) = IRL;
{P1} = {P1} {P2} 1;
GEOBUG = 1;
GOTO :START-CONE:;
}

;
REPLACE {$CONES(#,#,#);} WITH {;
:START-CONE:;
IHITCI=0;IHITCO=0;
IF({P1}.EQ.NPLAN2)[
    IF(ZL.GT.0.)[$RESET REGION {P1} -;] "GOTO :BUG1:;"
    ELSEIF(WL.LE.0.)[;]
    ELSE[IHITCI=-1;TCONEI=-ZL/WL;]
]
ELSEIF({P1}.NE.1)[
    TANA2=TANAL2({P1}-1);
    A=UL*UL+VL*VL-TANA2*WL*WL;
    B=UL*XL+VL*YL-TANA2*WL*ZL;
    C=XL*XL+YL*YL-TANA2*ZL*ZL;
    AC=A*C;B2=B*B;
    IF(C.GE.0)[
        IF(ZL.LT.0.0)[
            IF({P1}.LT.NPLAN2)[$RESET REGION {P1} +;]"GOTO :BUG4:;"
            $RESET REGION {P1} -;
            ":BUG1:;"
            "IRL=IRL-1;"
            "IR(NP)=IRL;"
            "{P1}={P1}-1;"
            "GEOBUG=1;"
            "GOTO :START-CONE:;"
            ]
        IF(B2.LT.AC)[;]
        ELSEIF((A.GE.0.).AND.(B.GE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEI=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.GT.0.)[TCONEI=-BS/A;]ELSE[TCONEI=-C/BS;]
            ]
            TEST=TANALP({P1}-1)*(ZL+WL*TCONEI);
            IF(TEST.LT.0.)[;]ELSE[IHITCI=-1;]
        ]
    ]
    ELSEIF(TANALP({P1}-1)*ZL.GE.0.)[
        IF(ZL.GT.0.0)[$RESET REGION {P1} -;]"GOTO :BUG1:"
        IF((A.LE.0.).AND.(B.LE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEI=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.LE.0.)[TCONEI=-BS/A;]ELSE[TCONEI=-C/BS;]
            ]
            IHITCI=-1;
        ]
    ]
    ELSE[
        GOTO :SKIP-THIS:;
        IF((A.LT.0.).AND.(B.GT.0.))[
            TEST=AC/B2;
            IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            ELSEIF(TEST.GE.1.)[BS=B;]
            ELSE[BS=B*(1.+SQRT(1.-TEST));]
            TCONEI=-BS/A;
            IHITCI=-1;
        ]
        ELSE[;]
:SKIP-THIS:;
    ]
]
IF({P1}.EQ.NPLAN1)[
    IF(ZL.LT.0.)[$RESET REGION {P1} +;]"GOTO :BUG4:;"
    ELSEIF(WL.GE.0.)[;]
    ELSE[IHITCO=1;TCONEO=-ZL/WL;]
]
ELSEIF({P1}.NE.NC)[
    TANA2=TANAL2({P1});
    A=UL*UL+VL*VL-TANA2*WL*WL;
    B=UL*XL+VL*YL-TANA2*WL*ZL;
    C=XL*XL+YL*YL-TANA2*ZL*ZL;
    AC=A*C;B2=B*B;
    IF(C.GE.0)[
        IF(ZL.GT.0.0)[
           IF({P1}.GT.NPLAN1)[$RESET REGION {P1} -;]"GOTO :BUG1:"
           $RESET REGION {P1} +;"GOTO :BUG4:;"
        ]
        IF(B2.LT.AC)[;]
        ELSEIF((A.GE.0.).AND.(B.GE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEO=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.GT.0.)[TCONEO=-BS/A;]ELSE[TCONEO=-C/BS;]
            ]
            TEST=TANALP({P1})*(ZL+WL*TCONEO);
            IF(TEST.LT.0.)[;]ELSE[IHITCO=1;]
        ]
    ]
    ELSEIF(TANALP({P1})*ZL.GE.0.)[
        IF(ZL.LT.0.0)[
            $RESET REGION {P1} +;
            ":BUG4:;"
            "IRL=IRL+1;"
            "IR(NP)=IRL;"
            "{P1}={P1}+1;"
            "GEOBUG=1;"
            "GOTO :START-CONE:;"
        ]
        IF((A.LE.0.).AND.(B.LE.0.))[;]
        ELSE[
            IF(B.EQ.0.)[TCONEO=SQRT(-C/A);]
            ELSE[TEST=AC/B2;
                IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
                ELSEIF(TEST.GE.1.)[BS=B;]
                ELSE[BS=B*(1.+SQRT(1.-TEST));]
                IF(B.LE.0.)[TCONEO=-BS/A;]ELSE[TCONEO=-C/BS;]
            ]
            IHITCO=1;
        ]
    ]
    ELSE[
        GOTO :END-CONE:;
        IF((A.LT.0.).AND.(B.GT.0.))[
            TEST=AC/B2;
            IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            ELSEIF(TEST.GE.1.)[BS=B;]
            ELSE[BS=B*(1.+SQRT(1.-TEST));]
            TCONEO=-BS/A;
            IHITCO=1;
        ]
        ELSE[;]
    ]
]
:END-CONE:;
IF((IHITCI.EQ.-1).AND.(IHITCO.EQ.1))[
    IF(TCONEI.LE.TCONEO)[{P2}=IHITCI;{P3}=TCONEI;]
    ELSE[{P2}=IHITCO;{P3}=TCONEO;]
]
ELSEIF(IHITCI.EQ.-1)[{P2}=IHITCI;{P3}=TCONEI;]
ELSEIF(IHITCO.EQ.1)[{P2}=IHITCO;{P3}=TCONEO;]
ELSE[{P2}=0;]
}
;
"******************************************************************************
"
"The following is the $CALL-HOWNEAR macro for PRESTA-II
"That way, need to modify ELECTR is removed"
"hownear is defined in srcsph.mortran"
REPLACE {$CALL-HOWNEAR(#);} WITH {
   call hownear({P1},x(np),y(np),z(np),ir(np));
}
;
%E     "cavsphnrc.mortran"
%Q0
SUBROUTINE HOWFAR;

$IMPLICIT-NONE;

;
"MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
REPLACE {$SET NEW REGION(#,#);} WITH {;
  IF({P1}.LE.USTEP)[USTEP={P1};IRNEW={P2};]
  RETURN;
}

;COMIN/EPCONT,STACK,GEOM,SCORE,MISC/;

COMMON/IBUG/ICBUG;

LOGICAL OUTSID;INTEGER GEOBUG,ICBUG;

$INTEGER IRL,IX,IC,IHITS,IHITC,IHITCO,IHITCI;
$REAL    UL,VL,WL,XL,YL,ZL,A,B,B2,C,COUT,CIN;
$REAL    TCONE,TSPH,RL,RHOL,RHOL2,DNTMP;
$REAL    TCONEI,TCONEO,TEST,AC,BS,TANA2;

"DISCARD ZERO WEIGHT PARTICLES"
IF(WT(NP).EQ.0.0)[IDISC=1;RETURN;]

OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"

GEOBUG=0; "SET THE GEOMETRY BUG INDICATOR FLAG TO OFF"

IRL=IR(NP); "LOCAL REGION NUMBER"

"DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY"
IF(IRL.EQ.1)[IDISC=1;RETURN;]

$GET-IX-IC(IRL); "GET CONICAL AND SPHERICAL ZONES NUMBERS"

UL=U(NP);VL=V(NP);WL=W(NP);XL=X(NP);YL=Y(NP);ZL=Z(NP); "LOCAL VARIABLES"

IF(NC.GT.1)[
"write(6,*) 'shouldn''t be here, no cones in the problem yet';"
"write(6,*) 'NC= ', NC;"
    "SEARCH ONLY IF CONES ARE DEFINED"
    $CONES(IC,IHITC,TCONE);"GET DISTANCE TO CONE"
        "IHITC  =  1 => HITS OUTER CONE"
        "       =  0 => MISSES BOTH CONES"
        "       = -1 => HITS INNER CONE"
    ]
ELSE[
    "NO CONES IN THE PROBLEM"
    IHITC=0;
    ]

$SPHERE(IX,IHITS,TSPH);"GET DISTANCE TO SPHERE"
"       IHITS   =  1 => HITS OUTER SPHERE"
"               =  0 => MISSES BOTH SPHERES"
"               = -1 => HITS INNER SPHERE"

"QUICK EXIT TO ELECTR IF A GEOMETRY ERROR WAS FOUND"
IF(GEOBUG.EQ.1) [
    USTEP=0.0;
    IF(IRL.GT.NREG) IRL=1;
    IRNEW=IRL;
    DNEAR(NP)=0.0;
    RETURN;
    ]

IF(IX+IHITS.GT.NR) OUTSID=.TRUE.; "FLAG IF LEAVES THE GEOMETRY"

"THIS CODING CAUSES THE DISTANCE TO THE SURFACE TO BE SLIGHTLY INCREASED"
"TO ALLOW SOME PENETRATION INTO THE NEXT REGION. THE AMOUNT OF INCREASE"
"IS SCALED TO E-6 OF THE DISTANCE FROM THE ORIGIN TO MAKE IT EFFECTIVE"
"EVERYWHERE IN THE GEOMETRY. ."
IF(IHITC.NE.0)[TCONE=TCONE*1.000005+0.000005;]
IF(IHITS.NE.0)[TSPH= TSPH *1.000005+0.000005;]

"CALCULATE DNEAR <= this is done in subroutine electr!!!"
"IF((IDNEAR.EQ.0).AND.(IQ(NP).NE.0))["
"    RHOL2 = XL*XL + YL*YL;missing in older version  EMH 01/2002"
"    RL    = SQRT( RHOL2 + ZL*ZL );                             "
"    DNTMP=RSPH(IX)-RL;"
"    IF(IX.NE.1)[DNTMP=AMIN1(DNTMP,RL-RSPH(IX-1));]"
"    IF(NC.NE.1)["
"        RHOL = SQRT( RHOL2 ); missing in old version, EMH 01/2002"
"        IF(IC.NE.NC)["
"           DNTMP=AMIN1(DNTMP,REAL(ABS(COSALP(IC)*(RHOL-TANALP(IC)*ZL))));"
"            ]"
"        IF(IC.NE.1)["
"            DNTMP=AMIN1(DNTMP,REAL(ABS(COSALP(IC-1)*(RHOL-TANALP(IC-1)*ZL))));"
"            ]"
"        ]"
"    DNEAR(NP)=DNTMP;"
"    ]"
"ELSE[DNEAR(NP)=0.0;]"

"DO MOST PROBABLE CASE FIRST WHERE A CONE AND A SPHERE CAN BE HIT"

IF((IHITC.NE.0).AND.(IHITS.NE.0))[
    IF(TCONE.LT.TSPH)[
        "HITS CONE FIRST"
        $SET NEW REGION(TCONE,IRL+IHITC);
        ]
    ELSEIF(TSPH.LT.TCONE)[
        "HITS SPHERE FIRST"
        IF(OUTSID)[$SET NEW REGION(TSPH,1);]
        ELSE[$SET NEW REGION(TSPH,IRL+NC*IHITS);]
        ]
    ELSE[
        "ODD CASE TSPH=TCONE:HITS CONE AND SPHERE TOGETHER"
        IF(OUTSID)[$SET NEW REGION(TSPH,1);]
        ELSE[$SET NEW REGION(TSPH,IRL+IHITC+NC*IHITS);]
        ]
    ]

"DO ODD OR NO CONE CASE-PARTICLE CAN HIT SPHERE BUT NOT CONE"

ELSE[
    IF(OUTSID)[$SET NEW REGION(TSPH,1);]
    ELSE[$SET NEW REGION(TSPH,IRL+NC*IHITS);]
    ]

"AT THIS STAGE ALL GEOMETRICAL POSSIBILITIES HAVE BEEN CHECKED AND CONTROL"
"HAS ALREADY BEEN TRANSFERRED TO EGS"

END; "END OF SUBROUTINE HOWFAR"

%I4
%C80
%Q1
%E     "cavsphnrc.mortran"
"******************************************************************************
"
"
"                               **************
"                               *            *
"                               * INPUTS.MOR *
"                               *            *
"                               **************
"
"
"       AN INPUT FILE USED WITH CAVSPHnrc. THE INPUTS ARE DEFINED AS THEY ARE
"       INPUT. CONSIDERABLE DEFAULTING AND ERROR CHECKING IS DONE.
"
"       VERSION 1       AFB    10/87            ADAPTED FROM CAVITY(EGS3)
"       VERSION 2       A.M.   04/98            New input routine (get_inputs)
;
"******************************************************************************
"
SUBROUTINE INPUTS;

$IMPLICIT-NONE;

;COMIN/BOUNDS,
CHARS,EDGE,ELECIN,GEOM,IODAT1,IODAT2,IODAT3,IODAT4,MEDIA,MISC,
RUSROU,SCORE,SOURCE,SPECTR,USEFUL,USER,RANDOM,GetInput,
COMPTON-DATA,ET-Control,EGS-VARIANCE-REDUCTION, EGS-IO/;

"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
"REPLACE {$NMAX} WITH {120}"
"REPLACE {$NVALUE} WITH {120}"
REPLACE {$GET_INPUT(#);} WITH  "Used to get only one input"
{
"{P1}=Array index of the value_sought"
NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT;
}
;
REPLACE {$GET_INPUTS(#,#);} WITH  "Used to get many inputs"
{
NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT;
}
;
"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"
"INTEGER IDAT,INEXT,IWATCH,ISTORE,IRESTART,IOOPTN;"
INTEGER INEXT;
"REAL TIMMAX;"

INTEGER ITERSE;
"INTEGER NCASE, IFULL;                               Monte Carlo input"
"REAL STATLM;                                        Monte Carlo input"

REAL CAVRAD, ELERAD, CAVLNG, WALLTH;                "Cavity input"

"INTEGER IQIN, comment out this one=>ISOURC, MODEIN;source input"
INTEGER MODEIN;                                     "source input"
REAL TEMP1,TEMP2,TEMP3,TEMP4;                       "source input"

"INTEGER IDORAY, IDOPES;                             transport control"
INTEGER IFLUOR;                                     "transport control"
INTEGER IC, IREGLO, IREGHI;                         "transport control"
INTEGER IFARCE;                                     "transport control"
INTEGER IESTEP;                                     "transport control"
"REAL SMAX, ECUTIN, PCUTIN;                          transport control"
REAL SMAX;                                          "transport control"
REAL FESTEP;                                        "transport control"

"INTEGER MONOEN;"

REAL ADDING;
INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM;

INTEGER IZ, JJ;

$INTEGER jrng1,jrng2,ITMAX,IT,IX;

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
INTEGER NUM_TITLE,

"I/O Contol"
        NUM_IWATCH,
        NUM_STRAND,
        NUM_IRESTART,
        NUM_OUTOPTS,
        NUM_STORE,

"M-C Input"
        NUM_HIST,
        NUM_SEEDS,
        NUM_MXTIME,
        NUM_IFULL,
        NUM_STATLM,
        NUM_IFANO,

"Cavity inputs"
        NUM_ITERSE,
        NUM_WALLTH,
        NUM_CAVRAD,
        NUM_CAVLNG,
        NUM_ELERAD,
        NUM_WALMAT,
        NUM_ELEMAT,
        NUM_NCAVREG,
        NUM_RNUMCAV,

"Tranport Control"
        NUM_SMAX,
        NUM_ECUT,
        NUM_PCUT,
        NUM_RAYLEIGH,
        NUM_IREJCT,
        NUM_HOWFAR,
        NUM_ESAVEIN,
        NUM_IDOPES,
        NUM_IFLUOR,
        NUM_FLUIZ,
        NUM_FREGSTART,
        NUM_FREGSTOP,
        NUM_RRPARAM,
        NUM_RRMINPL,
        NUM_RRMAXPL,
        NUM_RRMINRA,
        NUM_RRMAXRA,
        NUM_RUSROU,
        NUM_RUSFRAC,
        NUM_XTRANSF,
        NUM_FORCE,
        NUM_STRTFRC,
        NUM_STPFRC,
        NUM_NESTEP,
        NUM_NSMAX,
        NUM_ADJEREG,
        NUM_FRAKESTEP,
        num_cs_enhance,
        num_compton,i_bound_compton,
        num_spin,i_spin;

$INTEGER my_unit, egs_open_datfile;

"---------------------------------------------------------------------------"
IVAL=0;  "number of the value_sought"

ERROR_FLAG=0;   "Initialization of bad input flag"
DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"

"*********************************************************"
"* set up the values_sought(i) and echo inputs to screen *"
"*********************************************************"
"*********"
"* TITLE *"
"*********"
IVAL=IVAL+1;
NUM_TITLE=IVAL;
VALUES_SOUGHT(IVAL)='TITLE';
TYPE(IVAL)=2;
NVALUE(IVAL)=1;

DELIMETER='NONE';
$GET_INPUT(NUM_TITLE);

$SKIP-LINE;$SKIP-LINE;
OUTPUT;(' *** INPUT CARD I01 ***');
READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
WRITE (*,:FMT:) (TITLE(I),I=1,79);
:FMT: FORMAT ('TITLE: ',79A1);
$SKIP-LINE;

"************************"
"* INPUT/OUTPUT CONTROL *"
"************************"
IVAL=IVAL+1;
NUM_IWATCH=IVAL;
VALUES_SOUGHT(IVAL)='IWATCH';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='INTERACTIONS';
ALLOWED_INPUTS(IVAL,2)='STEPS';
ALLOWED_INPUTS(IVAL,3)='DEPOSITED';
ALLOWED_INPUTS(IVAL,4)='GRAPH';

IVAL=IVAL+1;
NUM_STRAND=IVAL;
VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='LAST';
ALLOWED_INPUTS(IVAL,2)='ALL DEPOSITED';
ALLOWED_INPUTS(IVAL,3)='ALL';

IVAL=IVAL+1;
NUM_IRESTART=IVAL;
VALUES_SOUGHT(IVAL)='IRESTART';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='FIRST';
ALLOWED_INPUTS(IVAL,1)='RESTART';
ALLOWED_INPUTS(IVAL,2)='MAKE';
ALLOWED_INPUTS(IVAL,3)='ANALYZE';
ALLOWED_INPUTS(IVAL,4)='FOR GRAPHICS';
ALLOWED_INPUTS(IVAL,5)='PARALLEL';       " ADDED BY JT, DEC.98 "

IVAL=IVAL+1;
NUM_OUTOPTS=IVAL;
VALUES_SOUGHT(IVAL)='OUTPUT OPTIONS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='SHORT';
ALLOWED_INPUTS(IVAL,1)='CAVITY DETAILS';

IVAL=IVAL+1;
NUM_STORE=IVAL;
VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='YES';
ALLOWED_INPUTS(IVAL,1)='NO';

DELIMETER='I/O CONTROL';
$GET_INPUTS(NUM_IWATCH,NUM_STORE);

OUTPUT;(' *** INPUT CARD IO2 ***');
IWATCH=VALUE(NUM_IWATCH,1);
ISTORE=VALUE(NUM_STRAND,1);
IRESTART=VALUE(NUM_IRESTART,1);
IOOPTN=VALUE(NUM_OUTOPTS,1);
IDAT=VALUE(NUM_STORE,1);
OUTPUT IWATCH,ISTORE,IRESTART,IOOPTN,IDAT;
    (/' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T60,I12/
    ' DO NOT STORE(0) OR STORE(1,2,3) INITIAL RANDOM #:',T60,I12/
    ' FIRST RUN(0),RESTARTED(1),MAKE(2),ANALYZE(3),GRAPHICS(4):',T60,I12/
    ' OUTPUT OPTION: CAVITY SUMMARY(0) PLUS REGION DETAIL(1):',T60,I12/
    ' STORE RAW DATA(0) OR NOT(1):',T60,I12/);

$SKIP-LINE;

IF((IRESTART.EQ.2).OR.(IDAT.EQ.1))[INEXT=0;]ELSE[INEXT=1;]
IF(IRESTART.EQ.4) [
    IDAT=1;   "DO NOT STORE OUTPUT IN THIS CASE TO AVOID BIASING"
    ISTORE=0; "DO NOT STORE THE STARTING RANDOM NUMBERS EITHER"
]

"                       MONTE CARLO CONTROL INPUT
"                       *************************
IVAL=IVAL+1;
NUM_HIST=IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=100;
VALUE_MAX(IVAL)=999999999;
DEFAULT(IVAL)=20000;

IVAL=IVAL+1;
NUM_SEEDS=IVAL;
VALUES_SOUGHT(IVAL)='INITIAL RANDOM NO. SEEDS';
NVALUE(IVAL)=2;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=1;
VALUE_MAX(IVAL)=999999999;
DEFAULT(IVAL)=1;

IVAL=IVAL+1;
NUM_MXTIME=IVAL;
VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=1000;
DEFAULT(IVAL)=0.99;

IVAL=IVAL+1;
NUM_IFULL=IVAL;
VALUES_SOUGHT(IVAL)='IFULL';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='DOSE AND STOPPERS';
ALLOWED_INPUTS(IVAL,1)='AATT AND ASCAT';
ALLOWED_INPUTS(IVAL,2)='AP';
ALLOWED_INPUTS(IVAL,3)='AFL AND <S>G/W';

IVAL=IVAL+1;
NUM_STATLM=IVAL;
VALUES_SOUGHT(IVAL)='STATISTICAL ACCURACY SOUGHT';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0;
VALUE_MAX(IVAL)=100.0;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_IFANO=IVAL;
VALUES_SOUGHT(IVAL)='PHOTON REGENERATION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='YES';

DELIMETER='MONTE CARLO INPUTS';
$GET_INPUTS(NUM_HIST,NUM_IFANO);

"************"
"* CARD MC1 *"
"************"
OUTPUT;(/,' *** INPUT CARD MC1 ***');
NCASE=VALUE(NUM_HIST,1);
TIMMAX=VALUE(NUM_MXTIME,1);
IFULL=VALUE(NUM_IFULL,1);
STATLM=VALUE(NUM_STATLM,1);
ifano=VALUE(NUM_IFANO,1);

" CHECK THAT IFULL<2 UNTIL THIS IS FIXED -- JT "
"IF(IFULL.GE.2)["
IF(IFULL.GE.2)[
   OUTPUT; (/' THE IFULL OPTION SELECTED IS NOT YET AVAILABLE',T60/
          ' FOR THE SPHERICAL GEOMETRY.  CHOOSE EITHER DOSE',T60/
          ' AND STOPPERS OR AATT AND ASCAT.  FOR THIS RUN',T60/
          ' IFULL HAS BEEN SET TO THE LATTER.'/);
   IFULL=1;
]

"Random number initializations"
IF( i_parallel > 0 ) jrng2 = jrng2 - 1 + i_parallel;
$RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',jrng1,jrng2);
$INITIALIZE RNG USING jrng1 AND jrng2;


OUTPUT NCASE,jrng1,jrng2,TIMMAX,IFULL,STATLM,ifano;
    (/' # OF HISTORIES:',T60,I12/
     $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
    ' MAXIMUM CPU TIME ALLOWED:',T60,F10.2,'HRS'/
    ' SCORING OPTION IFULL (0,1,2,3):',T60,I12/
    ' STATISTICAL ACCURACY DESIRED:',T60,F10.1,'%'/
    ' REGENERATION OPTION IFANO (0,1,2):',T60,I12);

IF (ERROR_FLAG=1) [GOTO :FINISHED:;]

"                SPHERICAL GEOMETRY AND MATERIAL INPUT
"                ***************************************
CALL GEOMSPH;
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMSPH************';
   GOTO :FINISHED:;
]

"SET THE GEOMETRY FLAG FOR THE CAVITY"
DO J=1,NREG [NTRACK(J)=0;]  "ASSUME IT IS NON-CAVITY EVERYWHERE"


"SET THE CAVITY FLAG FOR THE CAVITY REGIONS"

DO J=1, numcavreg [NTRACK(cavreg(J))=1;]

"                       SOURCE CONFIGURATION INPUT
"                       **************************
"************"
"* CARD SC1 *"
"************"
"EXECUTED FROM SUBROUTINE SRCSPH(ERROR_FLAG)"
CALL SRCSPH;  "Get source data"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE SRCSPH************';
   GOTO :FINISHED:;
]
"the call to srcsph reads the data into svtmp's (source commonblock) "
"the call to srcini will do the actual initialization               "
"based on the numbers in svtmp (transferred as parameters to srcini)"
"following line is to comply with g77 compiler                      "
"call of an entry in a subroutine was not allowed by g77            "
"see also the few changes in SRCSPH                                  "
"Jan S. Oct 2, 1996                                                 "
CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0);


"*********************************************************"
" what follows was taken from cavrznrc, EMH, January, 2002"
"*********************************************************"

"************"
"* CARD TC1 *"
"************"
"EXECUTED FROM SUBROUTINE ENSRC(ERROR_FLAG)"
IF (ISOURC=21.OR.ISOURC=22) [MONOEN=0;]
             "no need to input monoen for source 21,22"
ELSE [CALL ENSRC;] "Get data re-source energies"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
   GOTO :FINISHED:;
]

$SKIP-LINE;

"*************************************************************************"
"                transport parameters section                             "
"*************************************************************************"

call get_transport_parameter(6); " This will scan the input file for
                                 " transport parameter input and then
                                 " output all settings to unit 6

ECUTIN=ecut(1);
PCUTIN=pcut(1);
SMAX=smaxir(1);

"*************************************************************************"
"                variance reduction section                               "
"*************************************************************************"



IVAL=IVAL+1;
NUM_IREJCT=IVAL;
VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_ESAVEIN=IVAL;
VALUES_SOUGHT(IVAL)='ESAVEIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.0;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

ival = ival + 1;
num_cs_enhance = ival;
values_sought(ival) = 'CS ENHANCEMENT FACTOR';
nvalue(ival) = 1;
type(ival) = 1;
value_min(ival) = 0;
value_max(ival) = 1e6;
default(ival) = 0.5;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_IREJCT,num_cs_enhance);

"************"
"* CARD TC2 *"
"************"
OUTPUT;(' *** INPUT CARD TC2 ***');
IREJCT=VALUE(NUM_IREJCT,1);
ESAVEIN=VALUE(NUM_ESAVEIN,1);
cs_enhance = value(num_cs_enhance,1);
IF( cs_enhance > 1 ) [ use_enhance = .true.; ]
ELSE [ use_enhance = .false.; ]

OUTPUT IREJCT; ( / ' Range rejection is On(1) or Off(0):',T60,I12);
IF(IREJCT > 0) [
    OUTPUT ESAVEIN;
    (' ESAVEIN cutoff value(total) for range rejection:', T60,F10.4,' MeV'/);
   IF (ESAVEIN = 0.0 ) [
     OUTPUT;(/'**********************************************************'/
              '   Have asked for range rejection but left ESAVEIN=0.0    '/
              '        There will be no range rejection'/
              '**********************************************************'/);
   ]
   DO i=1,NREG [i_do_rr(i) = 1; e_max_rr(i) = ESAVEIN;]
   "note  e_max_r is total energy"
   "above two arrays needed for each region for EGSnrc RANGE-DISCARD macro"
]

IVAL=IVAL+1;
NUM_RUSROU=IVAL;
VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e30;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_RUSFRAC=IVAL;
VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e30;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

IVAL=IVAL+1;
NUM_XTRANSF=IVAL;
VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-1.e30;
VALUE_MAX(IVAL)=1.e30;
DEFAULT(IVAL)=0.0;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_RUSROU,NUM_XTRANSF);

"*************"
"* CARD TC2C *"
"*************"
OUTPUT;(' *** INPUT CARD TC2C ***');
RRZ=VALUE(NUM_RUSROU,1);
RRCUT=VALUE(NUM_RUSFRAC,1);
CEXPTR=VALUE(NUM_XTRANSF,1);
RUSROU=.FALSE.;IF(RRZ+RRCUT.NE.0.0)RUSROU=.TRUE.;
IF(RUSROU)[
    OUTPUT RRZ,RRCUT;
    (/' RUSSIAN ROULETTE WILL BE PLAYED'/
    ' RUSSIAN ROULETTE PLANE:',T30,E14.7/
    ' SURVIVAL PROBABILITY:',T30,E14.7/)
]
ELSE [OUTPUT;(' RUSSIAN ROULETTE WILL NOT BE PLAYED'/);]
IF (CEXPTR = 0) [OUTPUT;(' NO PATHLENGTH BIASING TO BE DONE'/);]
ELSE [OUTPUT CEXPTR;(' CEXPTR PARAMATER:',T30,E14.7/);]

IVAL=IVAL+1;
NUM_FORCE=IVAL;
VALUES_SOUGHT(IVAL)='PHOTON FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
DEFAULT(IVAL)=0;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';
IVAL=IVAL+1;
NUM_STRTFRC=IVAL;
VALUES_SOUGHT(IVAL)='START FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

IVAL=IVAL+1;
NUM_STPFRC=IVAL;
VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(NUM_STPFRC)=0;
VALUE_MAX(NUM_STPFRC)=NREG+1;
DEFAULT(NUM_STPFRC)=1;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_FORCE,NUM_STPFRC);

"************"
"* CARD TC3 *"
"************"
OUTPUT;(' *** INPUT CARD TC3 ***');
IFARCE=VALUE(NUM_FORCE,1);
NFMIN=VALUE(NUM_STRTFRC,1);
NFMAX=VALUE(NUM_STPFRC,1);
IF (IFARCE=0) [
      IFORCE=0;NFMIN=0;NFMAX=0;
      OUTPUT;(' NO INTERACTION FORCING IS IN EFFECT'/);
]
ELSEIF (IFARCE=1) [
    IFORCE=1;
    IF (NFMAX.LT.NFMIN) NFMAX=NFMIN;
    OUTPUT NFMIN,NFMAX;
    (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
    ' # INTERACTIONS'/);
]
IQINC=IQIN; "NEEDED TO TURN OFF FASTSTEP FOR INCIDENT ELECTRONS"
            "WHEN FORCING INTERACTIONS"
$SKIP-LINE;

IVAL=IVAL+1;
VALUES_SOUGHT(IVAL)='PHOTON SPLITTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(ival)=1;
VALUE_MAX(ival)=$MXSTACK-2;
DEFAULT(ival)=1;
$GET_INPUT(ival);
IF( error_flags(ival) = 0 ) [

    n_split = value(ival,1);
    IF( n_split > 1 ) [
        IF( ifull > 1 ) [
            OUTPUT;
            (//' ******** Photon splitting only for ifull = 0,1,4! ******'//);
            n_split = 1;
        ]
        ELSE [
            OUTPUT n_split;
            (//' ****** Calculation with photon splitting ********** '/
             '   n_split = ',i4//);
            iifano = ifano;
        ]
    ]
]

IF( use_enhance ) [
    OUTPUT cs_enhance;
    (//' ************** Calculation with CS enhancement *******************'/,
       '    photon forcing, exp. transform, etc. input will be ignored! '/,
       '    IFULL will be set to 1! (i.e. Ascat and Aatt) '//,
       '    Using cs_enhance = ',f10.4,/
     ' ******************************************************************'///);
    ifull = 1; IFORCE=0;NFMIN=0;NFMAX=0; n_split = 1;
]



"                        SCORING ARRAY INITIALISATION
"                        ****************************
"

"CALCULATE THE NUMBER OF DOSE COMPONENTS"
IF(    IFULL.EQ.0)[ITMAX=2;]      "SCORE DOSE ONLY"
ELSEIF(IFULL.EQ.1)[ITMAX=3;]      "SCORE Ascat, Aatt AS WELL"
ELSEIF(IFULL.EQ.2)[ITMAX=4;]      "SCORE Apn as well"
ELSEIF(IFULL.EQ.3)[ITMAX=$MAXIT;] "SCORE Afl AND <s>g,w AS WELL"

NCASEO=0;NCASET=0;TMCPUO=0; "SET PREVIOUS RUN COUNTERS"

IF(IRESTART.EQ.0.OR.IRESTART.EQ.5)[ "FRESH START, SET EVERYTHING TO ZERO"
    "IRESTART=5 AS WELL, CHANGED BY JT, NOV.98"

    /cav_dose, cav_dose0, cav_dose1, cav_dose2/ =0;
    /cav2_dose,cav2_dose0,cav2_dose1,cav2_dose2/=0;
    /cav_dosec,cav_dosec01,cav_dosec02/         =0;

    DO IS=1,$STAT[
        /ISTIS(IS),ISTCIS(IS),IMSIS(IS),IMSCIS(IS),IMMIS(IS),IMMCIS(IS)/=0;
        /ISMIS(IS),ISMCIS(IS)/=0;  "ADDED BY JT, DEC.98"
        DO IT=1,ITMAX[
            DO IX=1,NR[
                DO IC=1,NC[
                    DOSEIS(IC,IX,IT,IS)=0.0;
                ]
            ]
        ]
    ]
]
ELSEIF((IRESTART.NE.2).AND.(IRESTART.NE.4))[
    "RESTART OR STATS ANALYSIS ONLY, READ OLD DATA FROM UNIT 4"
    "OPEN UNIT 4 AS AN OLD FILE"

    OUTPUT;(' About to read the previous .egsdat file');
    my_unit = egs_open_datfile(4,0,1,'.egsdat');

    read(my_unit,*,end=:EOFA:) cav_dose,  cav_dose0,
                               cav_dose1, cav_dose2;
    read(my_unit,*,end=:EOFA:) cav2_dose, cav2_dose0,
                               cav2_dose1,cav2_dose2;
    read(my_unit,*,end=:EOFA:) cav_dosec, cav_dosec01,
                                          cav_dosec02;
    DO IS=1,$STAT[
        READ(my_unit,*,END=:EOFA:) ISTIS(IS),ISTCIS(IS),
                             IMSIS(IS),IMSCIS(IS),
                             ISMIS(IS),ISMCIS(IS),
                             IMMIS(IS),IMMCIS(IS);
        READ(my_unit,*,END=:EOFA:)
            (((DOSEIS(IC,IX,IT,IS),IT=1,$MAXIT),IX=1,NR),IC=1,NC);
        ]
        $RETRIEVE RNG STATE FROM UNIT my_unit;
        READ(my_unit,*,END=:EOFA:)NCASEO,TMCPUO;
        CLOSE(UNIT=my_unit);
    ]

IF(IRESTART.EQ.3)[NCASE=0;]

NCASET=NCASE+NCASEO;

:FINISHED: CONTINUE;
"************************"
"* Check for any errors *"
"************************"
IF(ERROR_FLAG.EQ.0) [
   OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   DO J=1,5[$SKIP-LINE;]

   RETURN; "NORMAL RETURN"
]

IF (ERROR_FLAG=1) [
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   WRITE(15,*) '************************************************';
   WRITE(15,*) '*********** INPUTS NOT ACCOMPLISHED ************';
   WRITE(15,*) '************************************************';
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   OUTPUT;(/' INPUT DATA IS NOT CORRECT!');
   RETURN; "ERROR RETURN"
]
"BAD DATA FILE, STOP AND PRINT MESSAGE
:EOFA:;OUTPUT;(/' End of  file before all of egsdat file read in');

ERROR_FLAG=1;
RETURN; "END OF DAT FILE RETURN"

END; "END OF SUBROUTINE INPUTS

%Q1
%I4
%C80
%E     "cavsphnrc.mortran"
"***************************************************************************
"
SUBROUTINE ISUMRY;
"
"
"                AFB      87/12/11     VAX/IBM COMPATIBLE VERSION CODED
"
"*************************************************************************

;
REPLACE {$IRL} WITH {IC+1+NC*(IX-1)}

"THIS IS A GENERAL MACRO ROUTINE TO PLOT A NON-ROTATED GRID OF THE INPUT"
"VARIABLES BETWEEN THE CONICAL REGIONS #1 AND #2 AND BETWEEN THE"
"SPHERICAL REGIONS #3 AND #4"
;
REPLACE {$WRITE-INP(#,#/#,#);} WITH
{
;
NR1={P3}-1;NR2={P4};
IREPT=NR2-NR1;
DO IX=NR1,NR2[
    IF(IX.EQ.NR1)[WRITE(IOUT,:4110:) RSPH(IX);]
    ELSEIF(IX.EQ.NR1+1)[WRITE(IOUT,:4111:) RSPH(IX);]
    ELSEIF(IX.EQ.NR1+2)[WRITE(IOUT,:4112:) RSPH(IX);]
    ELSEIF(IX.EQ.NR1+3)[WRITE(IOUT,:4113:) RSPH(IX);]
    ELSEIF(IX.EQ.NR1+4)[WRITE(IOUT,:4114:) RSPH(IX);]
    ELSEIF(IX.EQ.NR1+5)[WRITE(IOUT,:4115:) RSPH(IX);]
    ELSEIF(IX.EQ.NR1+6)[WRITE(IOUT,:4116:) RSPH(IX);]
    ]
DO IC={P1},{P2}[
    IF(IC.EQ.1)[WRITE(IOUT,416) 0.0;]ELSE[WRITE(IOUT,416)ALPHA(IC-1);]
    IXI=1;
    DO IX=1,IREPT[
        IXI=IXI+1;
        IF(IX.EQ.1)[WRITE(IOUT,:4170:);]
        ELSEIF(IX.EQ.2)[WRITE(IOUT,:4171:);]
        ELSEIF(IX.EQ.3)[WRITE(IOUT,:4172:);]
        ELSEIF(IX.EQ.4)[WRITE(IOUT,:4173:);]
        ELSEIF(IX.EQ.5)[WRITE(IOUT,:4174:);]
        ELSEIF(IX.EQ.6)[WRITE(IOUT,:4175:);]
        ]
    IF(IXI.EQ.1)[WRITE(IOUT,:4180:)IC;]
    ELSEIF(IXI.EQ.2)[WRITE(IOUT,:4181:)IC;]
    ELSEIF(IXI.EQ.3)[WRITE(IOUT,:4182:)IC;]
    ELSEIF(IXI.EQ.4)[WRITE(IOUT,:4183:)IC;]
    ELSEIF(IXI.EQ.5)[WRITE(IOUT,:4184:)IC;]
    ELSEIF(IXI.EQ.6)[WRITE(IOUT,:4185:)IC;]
    ELSEIF(IXI.EQ.7)[WRITE(IOUT,:4186:)IC;]
    DO IX=1,IREPT[
        IF(IX.EQ.1)[WRITE(IOUT,:4220:);]
        ELSEIF(IX.EQ.2)[WRITE(IOUT,:4221:);]
        ELSEIF(IX.EQ.3)[WRITE(IOUT,:4222:);]
        ELSEIF(IX.EQ.4)[WRITE(IOUT,:4223:);]
        ELSEIF(IX.EQ.5)[WRITE(IOUT,:4224:);]
        ELSEIF(IX.EQ.6)[WRITE(IOUT,:4225:);]
        ]
    DO IX={P3},{P4}[
        MEDIUM=MED($IRL);
        IF(NTRACK($IRL).EQ.1)[MTYPE(1,IX)=ASTER;]ELSE[MTYPE(1,IX)=BLANK;]
        IF(MEDIUM.EQ.0)[
            MTYPE(2,IX)=VCHAR;MTYPE(3,IX)=ACHAR;MTYPE(4,IX)=CCHAR;
            MTYPE(5,IX)=UCHAR;MTYPE(6,IX)=UCHAR;MTYPE(7,IX)=MCHAR;
            ]
        ELSE[DO ICHARS=1,6[MTYPE(ICHARS+1,IX)=MEDIA(ICHARS,MEDIUM);]]
        ]
    DO IX={P3},{P4}[
        IF(IX.EQ.{P3})[WRITE(IOUT,:4270:)$IRL,(MTYPE(J,IX),J=1,7);]
        ELSEIF(IX.EQ.{P3}+1)[WRITE(IOUT,:4271:)$IRL,(MTYPE(J,IX),J=1,7);]
        ELSEIF(IX.EQ.{P3}+2)[WRITE(IOUT,:4272:)$IRL,(MTYPE(J,IX),J=1,7);]
        ELSEIF(IX.EQ.{P3}+3)[WRITE(IOUT,:4273:)$IRL,(MTYPE(J,IX),J=1,7);]
        ELSEIF(IX.EQ.{P3}+4)[WRITE(IOUT,:4274:)$IRL,(MTYPE(J,IX),J=1,7);]
        ELSEIF(IX.EQ.{P3}+5)[WRITE(IOUT,:4275:)$IRL,(MTYPE(J,IX),J=1,7);]
        ]
    DO IX={P3},{P4}[
        IF(IX.EQ.{P3})[WRITE(IOUT,:4320:) AMASS(IC,IX);]
        ELSEIF(IX.EQ.{P3}+1)[WRITE(IOUT,:4321:) AMASS(IC,IX);]
        ELSEIF(IX.EQ.{P3}+2)[WRITE(IOUT,:4322:) AMASS(IC,IX);]
        ELSEIF(IX.EQ.{P3}+3)[WRITE(IOUT,:4323:) AMASS(IC,IX);]
        ELSEIF(IX.EQ.{P3}+4)[WRITE(IOUT,:4324:) AMASS(IC,IX);]
        ELSEIF(IX.EQ.{P3}+5)[WRITE(IOUT,:4325:) AMASS(IC,IX);]
        ]
    ]
IF({P2}.EQ.NC)[WRITE(IOUT,416)180.;]ELSE[WRITE(IOUT,416)ALPHA({P2});]
IXI=1;
DO IX=1,IREPT[
    IXI=IXI+1;
    IF(IX.EQ.1)[WRITE(IOUT,:4170:);]
    ELSEIF(IX.EQ.2)[WRITE(IOUT,:4171:);]
    ELSEIF(IX.EQ.3)[WRITE(IOUT,:4172:);]
    ELSEIF(IX.EQ.4)[WRITE(IOUT,:4173:);]
    ELSEIF(IX.EQ.5)[WRITE(IOUT,:4174:);]
    ELSEIF(IX.EQ.6)[WRITE(IOUT,:4175:);]
    ]
IF(IXI.EQ.1)[WRITE(IOUT,:4180:)IC;]
ELSEIF(IXI.EQ.2)[WRITE(IOUT,:4181:)IC;]
ELSEIF(IXI.EQ.3)[WRITE(IOUT,:4182:)IC;]
ELSEIF(IXI.EQ.4)[WRITE(IOUT,:4183:)IC;]
ELSEIF(IXI.EQ.5)[WRITE(IOUT,:4184:)IC;]
ELSEIF(IXI.EQ.6)[WRITE(IOUT,:4185:)IC;]
ELSEIF(IXI.EQ.7)[WRITE(IOUT,:4186:)IC;]
DO IX=NR1,NR2[
    IF(IX.EQ.NR1)[WRITE(IOUT,:4720:)IX;]
    ELSEIF(IX.EQ.NR1+1)[WRITE(IOUT,:4721:)IX;]
    ELSEIF(IX.EQ.NR1+2)[WRITE(IOUT,:4722:)IX;]
    ELSEIF(IX.EQ.NR1+3)[WRITE(IOUT,:4723:)IX;]
    ELSEIF(IX.EQ.NR1+4)[WRITE(IOUT,:4724:)IX;]
    ELSEIF(IX.EQ.NR1+5)[WRITE(IOUT,:4725:)IX;]
    ELSEIF(IX.EQ.NR1+6)[WRITE(IOUT,:4726:)IX;]
    ]
WRITE(IOUT,474);
WRITE(IOUT,406);
}

;
INTEGER*4 BOXWD,BOXHT;   "WIDTH/HEIGHT IN CHARACTERS/LINES OF EACH DATA"
                         "BOX, ONE BOX BEING ASSOCIATED WITH ONE GEOMETRICAL"
                         "REGION"

INTEGER*4 GRIDWD,GRIDHT; "SAME IDEA BUT FOR ENTIRE GRID INCLUDING LABELS"

LOGICAL FITS;                         "IF FITS TRUE THEN THE OUTPUT WILL FIT"
                                      "ON A SINGLE SHEET"
$TYPE MTYPE(7,$MAXRC);   "TEMPORARY STORAGE TO PRINT OUT CHARACTER STRINGS"

COMIN/
BOUNDS,CHARS,EDGE,ELECIN,ET-Control,GEOM,IODAT1,IODAT2,IODAT3,IODAT4,
PRINTC,MEDIA,MISC,RUSROU,SCORE,SOURCE,SPECTR,
THRESH,USEFUL,USER,RANDOM/;
"added ET-control to give proper access to ESTEPR, even though we do not"
"ever use it at this point, we were prining out garbage before"
"Note it is initialized in HATCH to unity via a macro in egsnrc.macros"
"For the grid output defaults"
CHARACTER*4 CDSTBL($MXREG),CTRTBL($MXREG),CABSRB($MXREG);
CHARACTER*4 CAVTRACK($MXREG); "for identifying a cavity region"

"WRITE THE HEADER"
write(iout,110) title;
call egs_fdate(iout);
110  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
  ' *',T80, '*'/
  ' *',T34,'************',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'* CAVSPHnrc*',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'************',T80,'*'/
  ' *',T80, '*'/
  ' *   Spherical-geometry EGSnrc user-code for scoring cavity details',
   T80,'*'/
  ' *',T80, '*'/
  ' *   CAVSPHnrc was developed by the National Research Council of Canada',
                                                                      T80,'*'/
  ' *',T80, '*'/
  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
                                                                       T80,'*'/
  ' *             running on '$MACHINE' ',T80,'*'/
  ' *',T80, '*'/
  ' *',  T53,' ',$);
write(iout,111);
111 FORMAT('  *'/1X,79('*'));

"Print info about transport parameter settings"
call show_transport_parameter(iout);

"MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS"
WRITE(IOUT,200) NCASE,NCASET;
IF(IQIN = 0 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''photons'')');
IF(IQIN = -1) WRITE(IOUT,'(T20,''Incident Charge'',T60,''electrons'')');
IF(IQIN = 1 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''positrons'')');
IF(IQIN = 2 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''all'')');
IF(IQIN = 3 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''e- & e+'')');

IF(MONOEN = 0 & ISOURC ~= 21 & ISOURC ~= 22)[ WRITE(IOUT,201) EIN; ]
                                        ELSE[ CALL ENSRCO;]

IF(IFORCE ~= 0)[WRITE(IOUT,230)NFMIN,NFMAX;]ELSE[WRITE(IOUT,231);]
IF(IREJCT > 0)[
   " WRITE(IOUT,242);IF(IREJCT = 2)WRITE(IOUT,243);"
    WRITE(IOUT,2421) z_cavity_min, z_cavity_max, r_cavity_max;
2421 FORMAT(T20,'Range rejection on a region by region basis'/
      T20,'Also globally to region between z=',F10.4,' &',F10.4,' cm'/
      T20,'     and inside radius=', F12.4,' cm');
    WRITE(IOUT,2422) ESAVEIN;
2422 FORMAT(T20,'Range rejection only for electrons < ESAVEIN=',
    F10.3,' MeV');
]
ELSE[WRITE(IOUT,244);]
WRITE(IOUT,260) TIMMAX,STATLM;
write(iout,'(19x,a,$)') 'Initial RNG state:    ';
$SHOW-RNG-STATE(iout); write(iout,*);
IF(RUSROU)[WRITE(IOUT,265)RRZ,RRCUT;]
IF(CEXPTR.NE.0)[WRITE(IOUT,266)CEXPTR;]
IF(ifano = 1) [
  OUTPUT; ('  *** REGENERATION REQUESTED (IFANO SET TO 1) ! *** ');
  WRITE(iout,*) '  *** REGENERATION REQUESTED (IFANO SET TO 1) ! *** ';
]
ELSEIF(ifano = 2) [
  OUTPUT; ('  *** ELECTRONS SET IN MOTION IN WALL WILL BE ELIMINATED *** '/
           '  (IFANO SET TO 2) ! *** ');
  WRITE(iout,*)'  *** ELECTRONS SET IN MOTION IN WALL WILL BE ELIMINATED *** ';
  WRITE(iout,*)'  (IFANO SET TO 2) ! *** ';
]
ELSE [
  OUTPUT; (T20,'  *** NO REGENERATION REQUESTED (IFANO SET TO 0) ! *** ');
  WRITE(iout,'(T20,''** No regeneration requested (IFANO set to 0)! ** '')');
]

"EK0=EIN;"
"$PRESTA-INPUT-SUMMARY; OUTPUT THE PRESTA INPUT VARIABLES"
"taken out input-summary at upgrade to PRESTA-II"
"MATERIAL INPUT SUMMARY"
"====================="

WRITE(IOUT,300) NMED;
DO I=1,NMED[
WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP(I);]

CALL SRCOUT;

"       PRINT A GRID OF THE ZONE DEPENDENT VARIABLES"
"       ============================================"

"SET BOX DIMENSIONS"
BOXWD=18;BOXHT=4;
"SET GRID DIMENSIONS"
GRIDWD=BOXWD*NR+15;
GRIDHT=BOXHT*NC+3;

"DECIDE ON STRAIGHT VERSUS ROTATED OUTPUT AND SET PRINTER CONTROLS"
ICHPIN=12;ILPIN=6;    "INITIALIZATION OF CHARS/INCH AND LINES/INCH"
MXLP11=43;MXLP12=65;  "MAXIMUM GRID HEIGHTS ALLOWABLE FOR 6 AND 8 LINES"
                      "PER INCH RESPECTIVELY ON FIRST PAGE BELOW TITLES"

"CALL ROUTINE GRID WHICH RETURNS 'FITS' AND 'ICHPIN' AND 'ILPIN'"
CALL GRID (GRIDWD,GRIDHT,MXLP11,MXLP12,ICHPIN,ILPIN,FITS);

"PRINT HEADER AND GLOBAL INFORMATION"
"CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"
"WRITE(IOUT,100)TITLE,TIMEN,DATEN;"
WRITE(IOUT,399);

"PICK LEFT MARGIN"
IF(FITS)[ICENTR=4*ICHPIN;ITLEFT=MAX0(ICENTR+1-((NR*18)+15)/2,2);]
ELSE[ITLEFT=3;]

WRITE(IOUT,400);

WRITE(IOUT,406);WRITE(IOUT,406);  "LEAVE TWO BLANK LINES"

IF(FITS)["THE INPUT SUMMARY FITS ON ONE PAGE"
    WRITE(IOUT,406);
    $WRITE-INP(1,NC/1,NR);
    ]
ELSE["THE INPUT SUMMARY WON'T FIT ONTO ONE PAGE => SPLIT GRID"
    NHRST=(NR-1)/6+1;      "NUMBER OF HORIZONTAL SHEETS AT 6 RADIAL"
                           "BINS/PAGE"
    NROW1=(41-3)/BOXHT;    "NUMBER OF ROWS THAT WILL FIT ON FIRST PAGE"
    NROW=(66-3)/BOXHT;     "NUMBER OF ROWS THAT WILL FIT ON SUBSEQUENT"
                           "PAGES, I.E, THOSE WITHOUT LIST OF GLOBALS"
    NVRST=(NC-NROW1)/NROW; "NUMBER OF VERTICAL PAGES NEEDED AFTER FIRST"
    IF(NVRST*NROW+NROW1.LT.NC)[NVRST=NVRST+1;]
    ITTOP1=((66-25)-(NROW1*BOXHT+3))/2; ITTOP2=((66-1)-(NROW*BOXHT+3))/2;
    "PRECEEDING LINE CENTERS THE OUTPUT VERTICALLY ON THE PAGE"
    "INITIALIZE VARIABLES TO KEEP LEFT AND RIGHT MOST SPH. NOS. ON PAGE"
    IF(NR.LT.6)[IHRSTR=NR;]ELSE[IHRSTR=6;]
    IHRSTL=1;
    DO IHRST=1,NHRST[
        "IVRSTB, GREATEST CONICAL REGION NUMBER TO APPEAR ON THE PAGE"
        IVRSTB=NROW1;
        IF(IHRST.EQ.1)[DO L=1,ITTOP1+1[WRITE(IOUT,406);]]
        ELSE[
            WRITE(IOUT,408);
            "WRITE(IOUT,100) TITLE,TIMEN,DATEN;"
            WRITE(IOUT,399);
            WRITE(IOUT,400);
            DO L=1,ITTOP1+1[WRITE(IOUT,406);]
            ]
        $WRITE-INP(1,IVRSTB/IHRSTL,IHRSTR);
        DO IVRST=1,NVRST[
            IVRSTT=IVRSTB+1;
            IF(IVRST.EQ.NVRST)[IVRSTB=NC;]
            ELSE[IVRSTB=IVRSTB+NROW;]
            WRITE(IOUT,408);
            IF(ITTOP2.GE.1)[DO L=1,ITTOP2[WRITE(IOUT,406);]]
            $WRITE-INP(IVRSTT,IVRSTB/IHRSTL,IHRSTR);
            ]
        IHRSTL=IHRSTR+1;
        IF(IHRST+1.EQ.NHRST)[IHRSTR=NR;]
        ELSE[IHRSTR=IHRSTR+6;]
        ]   "END OF DO LOOP"
    ]   "END OF DOESN'T FIT"

"CALL PRNTER(13,6,IOUT,0);"

RETURN;
%I0
"FORMATS"
"100    FORMAT('1',80A1//'CALN USING CAVSPHnrc(EGSnrc) '$VERSION' ',"
"             /'ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);"
200    FORMAT(' ',79('*')/
             /,T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/
             /,79('*')/
             //T20,'MAX # OF HISTORIES TO RUN',T58,I12/
             ' ',T20,'MAX # OF HISTORIES TO ANALYZE',T58,I12/
             ' ',T20,'INCIDENT CHARGE',T63,I2);
201    FORMAT(' ',T20,'INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)');
210    FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,'DEFAULT');
211    FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,F5.3);
220    FORMAT(' ',T20,'MAXIMUM GLOBAL ELECTRON STEP SIZE',
                     T60,1PE10.3,' (cms)'/
             ' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF',
                     T56,0PF9.3,' (MeV)'/
             ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF',
                     T56,F9.3,' (MeV)');
230    FORMAT(' ',T20,'MIN/MAX PHOTON STEP FORCED',T60,I6,'/',I6);
231    FORMAT(' ',T20,'PHOTON FORCE INTERACTION SWITCH',T60,'OFF');
242    FORMAT(' ',T20,'RANGE REJECTION SWITCH OUTSIDE CAVITY',T60,'ON');
243    FORMAT(' ',T20,'RANGE REJECTION SWITCH INSIDE CAVITY',T60,'ON');
244    FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'OFF');
250    FORMAT(' ',T20,'RANGE REJECTION PARAMETERS:'/
             ' ',T20,F9.3,' (MeV) TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7/
             ' ',T20,F9.3,' (MeV) TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7);
255    FORMAT(T20,'CAVITY REGION IS DEFINED INTERIOR TO RADII',I3,' and',I3);
258    FORMAT(' ',T20,' ZONAL DISCARD OF CHARGE PARTICLES BELOW',
             T57,F9.3,' (MeV) kinetic energy');
260    FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (hrs)'/
             ' ',T20,'STATS IN CAVITY OBJECTIVE',T59,F6.3,' %'/
             ' ',T20,'1ST INITIAL RANDOM NUMBER SEED',T57,I12/
             ' ',T20,'2ND INITIAL RANDOM NUMBER SEED',T57,I12);
265    FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'/
            T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4);
266    FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/T25,
            'VARIABLE FOR FORWARD GOING PHOTNS: ',T60,F10.3);
267    FORMAT(' ',T20,'DISCARD ALL ELECTRONS BELOW:',T60,F7.3/T25,
            'IF TOO FAR FROM CLOSEST BOUNDRY');
270    FORMAT(' ',T20,'RAYLEIGH (COHERENT) SCATTERING',T60,'OFF');
271    FORMAT(' ',T20,'RAYLEIGH (COHERENT) SCATTERING',T60,'ON');
272    FORMAT(' ',T20,'PHOTOELECTRON ANGULAR SAMPLING',T60,'OFF');
273    FORMAT(' ',T20,'PHOTOELECTRON ANGULAR SAMPLING',T60,'ON');
288    FORMAT(' ',T20,'*** WARNING *** DNEAR CALLS REDUCTION AND RANGE',
            ' REJECTION BOTH INVOKED');
300    FORMAT(' ',79('*')/
             // ,T20,'MATERIAL SUMMARY   ',I1,' MATERIALS USED'/
             // ,79('*')/
             //'# MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',4X,'AP(MeV)',
                 9X,'UE(MeV)',4X,'UP(MeV)'/
             ' - --------  ----------------',6X,'-------',4X,'-------',
                 9X,'-------',4X,'-------');
305  FORMAT(T22,' REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3);
306  FORMAT(T20,' REGIONS WITH FLUORESCENT X-RAYS FOLLOW: ');
307  FORMAT(T20,' FLUORESCENT X-RAYS ARE DISCARDED');
310    FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3));
399    FORMAT(// ,' ZONAL VARIABLES-NONROTATED OUTPUT'/' ',
            '*********************************');
400    FORMAT(// ,'#IRL/X/MED/ : #IRL = GEOMETRY REGION NUMBER'/
            ' ',18X,'X = "*" IF CAVITY REGION'/
            ' ',18X,'MEDIUM, FIRST 6 CHARACTERS ONLY'/
            ' ','MASS',13X,': MASS OF THE REGION IN GRAMS');
401    FORMAT(// ,'#IRL/X/MED/ : #IRL = GEOMETRY REGION NUMBER'/
            ' ',18X,'X = "*" IF DOSE SCORING REGION'/
            ' ',18X,'MEDIUM, FIRST 6 CHARACTERS ONLY'/
            ' ','THICK',12X,': THICKNESS OF REGION IN g/cm**2');
406    FORMAT(' ');
408    FORMAT('1');
:4110: FORMAT(' ',3X,F9.4);
:4111: FORMAT('+',T20,3X,F9.4);
:4112: FORMAT('+',T38,3X,F9.4);
:4113: FORMAT('+',T56,3X,F9.4);
:4114: FORMAT('+',T74,3X,F9.4);
:4115: FORMAT('+',T92,3X,F9.4);
:4116: FORMAT('+',T110,3X,F9.4);
416    FORMAT(' ',F9.4,'|');
:4170: FORMAT('+',T12,17('-'),'|');
:4171: FORMAT('+',T30,17('-'),'|');
:4172: FORMAT('+',T48,17('-'),'|');
:4173: FORMAT('+',T66,17('-'),'|');
:4174: FORMAT('+',T84,17('-'),'|');
:4175: FORMAT('+',T102,17('-'),'|');
:4180: FORMAT(' ',T12,'(',I2,')');
:4181: FORMAT('+',T30,'(',I2,')');
:4182: FORMAT('+',T48,'(',I2,')');
:4183: FORMAT('+',T66,'(',I2,')');
:4184: FORMAT('+',T84,'(',I2,')');
:4185: FORMAT('+',T102,'(',I2,')');
:4186: FORMAT('+',T120,'(',I2,')');
:4220: FORMAT(' ',T11,'|',17X,'|');
:4221: FORMAT('+',T29,'|',17X,'|');
:4222: FORMAT('+',T47,'|',17X,'|');
:4223: FORMAT('+',T65,'|',17X,'|');
:4224: FORMAT('+',T83,'|',17X,'|');
:4225: FORMAT('+',T101,'|',17X,'|');
:4270: FORMAT(' ',T11,'| #',I3,'/',A1,'/',6A1,'/  |');
:4271: FORMAT('+',T29,'| #',I3,'/',A1,'/',6A1,'/  |');
:4272: FORMAT('+',T47,'| #',I3,'/',A1,'/',6A1,'/  |');
:4273: FORMAT('+',T65,'| #',I3,'/',A1,'/',6A1,'/  |');
:4274: FORMAT('+',T83,'| #',I3,'/',A1,'/',6A1,'/  |');
:4275: FORMAT('+',T101,'| #',I3,'/',A1,'/',6A1,'/  |');
:4320: FORMAT(' ',10X,'|',T12,' MASS ',1PE10.3,' |');
:4321: FORMAT('+',T30,' MASS ',1PE10.3,' |');
:4322: FORMAT('+',T48,' MASS ',1PE10.3,' |');
:4323: FORMAT('+',T66,' MASS ',1PE10.3,' |');
:4324: FORMAT('+',T84,' MASS ',1PE10.3,' |');
:4325: FORMAT('+',T102,' MASS ',1PE10.3,' |');
:4370: FORMAT(' ',10X,'|',T12,' THICK ',1PE10.3,' |');
:4371: FORMAT('+',T30,' THICK ',1PE10.3,'|');
:4372: FORMAT('+',T48,' THICK ',1PE10.3,'|');
:4373: FORMAT('+',T66,' THICK ',1PE10.3,'|');
:4374: FORMAT('+',T84,' THICK ',1PE10.3,'|');
:4375: FORMAT('+',T102,' THICK ',1PE10.3,'|');
:4720: FORMAT(' ',T10,'(',I2,')',14X);
:4721: FORMAT('+',T28,'(',I2,')',14X);
:4722: FORMAT('+',T46,'(',I2,')',14X);
:4723: FORMAT('+',T64,'(',I2,')',14X);
:4724: FORMAT('+',T82,'(',I2,')',14X);
:4725: FORMAT('+',T100,'(',I2,')',14X);
:4726: FORMAT('+',T118,'(',I2,')');
474    FORMAT(' ');

END; "LAST LINE OF SUBROUTINE ISUMRY"
%C80
%Q1
%I4
%E     "cavsphnrc.mortran"
"*************************************************************************
"
SUBROUTINE OSUMRY;
"
"************************************************************************

COMIN/GEOM,IODAT1,IODAT2,IODAT3,IODAT4,PRINTC,SCORE,SOURCE,USER/;
COMIN/CH-Steps/;

REAL*4 KSCT,KATT,KWLL,KPN,KFL,KSCTUN,KATTUN,KWLLUN,KPNUN,KFLUN;

"SET UP THE PRINTER"
ICHPIN=12; "12 CHARACTERS/INCH"
ILPIN=6;   "6 LINES/INCH"
IPAGE=0;   "NO PAGE THROW"
"CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"

"WRITE(IOUT,100)TITLE,DATEN,TIMEN; HEADER"

"PRINT # CHARGED PARTICLE STEPS/# TIMES MS SWITCHED OFF/RATIO"
IMS=FN;IST=FD;WRITE(IOUT,200) IST,FDUN,IMS,FNUN,FMS,FMSUN;

"PRINT # CHARGED PARTICLE STEPS IN DOSE REGION/# TIMES MS SWITCHED OFF/RATIO"
IMSC=FCN;ISTC=FCD;WRITE(IOUT,210) ISTC,FCDUN,IMSC,FCNUN,FMSC,FMSCUN;

write(6,*);
write(6,*) ' Total number of p-II steps: ',count_pII_steps;
write(6,*) ' Total number of steps:      ',count_all_steps;
write(6,*);

IF(IFULL.EQ.3)["PRINT STEPS OUTPUT FOR THE CORRELATED PART OF THE RUN"

    "PRINT # CHARGED PARTICLE STEPS/# TIMES MS SWITCHED OFF/RATIO"
    IMS=FSM;IST=FTM;WRITE(IOUT,220) IST,FTMUN,IMS,FSMUN,FMM,FMMUN;

    "PRINT # CHARGED PARTICLE STEPS IN DOSE REGION/# TIMES MS SWITCHED OFF/RATIO
    IMSC=FSMC;ISTC=FTMC;WRITE(IOUT,230) ISTC,FTMCUN,IMSC,FSMCUN,FMMC,FMMCUN;

    ]

"PRINT WARNING IF IDNEAR WAS SET"
IF(IDNEAR.EQ.0) WRITE(IOUT,150);

"THE CAVITY SUMMARY"
"******************"

IF(numcavreg.EQ.1)[WRITE(IOUT,300);]ELSE[WRITE(IOUT,301)numcavreg;]

"******************"
"history by history"
"     EMH Jan. 2002"
"******************"
"IF( use_enhance | n_split > 1 ) ["

    cav2_dose = cav2_dose/cav_dose;
    IF (iifano = 1) [
       write(iout,'(/t20,a)')
         'This calculation was performed using regeneration ';
       write(iout,'(t20,a/)')
         '================================================= ';
       write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
        'D/Awall (grays/incident fluence): ',cav_dose,' +/-  ',
         100*cav2_dose,'%';
       return;
    ]

    IF( use_enhance ) [
        write(iout,'(/t20,a)')
          'This calculation was performed using CS enhancement ';
        write(iout,'(t20,a,f10.2)')
          '  enhancement factor was ',cs_enhance;
        write(iout,'(t20,a)')
          '=================================================== ';
    ]
    ELSEIF ( n_split > 1 ) [
        write(iout,'(/t20,a)')
          'This calculation was performed using photon splitting ';
        write(iout,'(t20,a,i6)') '  splitting number was ',n_split;
        write(iout,'(t20,a)')
          '===================================================== ';
    ]
    ELSE [
        write(iout,'(/t20,a)')
          'Results using history by history scoring scheme';
        write(iout,'(t20,a)')
          '===================================================== ';
    ]

    write(iout,'(//a,T50,1PE11.4,a,0PF6.3,a)')
         'TOTAL DOSE (GRAYS/INCIDENT FLUENCE):',cav_dose,
         ' +/-  ',100*cav2_dose,'%';
IF( ifull > 0 ) [
   cav2_dose1 = cav2_dose1/cav_dose1;
   cav_dosec = cav_dosec/cav_dose/cav_dose1;

   write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
     'Total dose/Awall (grays/incident fluence): ',cav_dose1,' +/-  ',
      100*cav2_dose1,'%';
   cav_dosec = cav2_dose*cav2_dose + cav2_dose1*cav2_dose1 - 2*cav_dosec;
   IF( cav_dosec > 0 ) cav_dosec = sqrt(cav_dosec);
   write(iout,'(a,t50,0pf8.5,a,f6.3,a)')
      'Awall: ',cav_dose/cav_dose1,'    +/-  ',100*cav_dosec,'%';

   IF( use_enhance | n_split > 1 ) return;

"******************"
"history by history"
"******************"
   corr_02 = corr_02/(cav_dose0+cav_dose2);

   cav2_dose0 = cav2_dose0/cav_dose0;
   cav2_dose2 = cav2_dose2/cav_dose2;

   cav_dosec01 = cav_dosec01/cav_dose0/cav_dose1;
   cav_dosec02 = cav_dosec02/cav_dose0/cav_dose2;

   cav_dosec01 = cav2_dose0*cav2_dose0 + cav2_dose1*cav2_dose1 - 2*cav_dosec01;
   cav_dosec02 = cav2_dose0*cav2_dose0 + cav2_dose2*cav2_dose2 - 2*cav_dosec02;

   IF( cav_dosec01 > 0 ) cav_dosec01 = sqrt(cav_dosec01);
   IF( cav_dosec02 > 0 ) cav_dosec02 = sqrt(cav_dosec02);

"... we had rel.error(x), get now rel.error(1+x)"
   cav_dosec02 = cav_dosec02/(1 + cav_dose0/cav_dose2);


   write(iout,'(a,t50,f8.5,a,f6.3,a)')
      'Aatt: ',cav_dose0/cav_dose1,'    +/-  ',100*cav_dosec01,'%';

   write(iout,'(a,t50,f8.5,a,f6.3,a)')
      'Ascat: ',1+cav_dose2/cav_dose0,'    +/-  ',100*cav_dosec02,'%';

   write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
     'Dpr + Dsec: ',cav_dose2+cav_dose0,' +/-  ',100*corr_02,'%';

   write(iout,'(//t20,a)')
      '===================================================== ';
]
"******************"
"end of changes for"
"inclusion of the  "
"history by history"
"scoring scheme.   "
"    EMH March 2002"
"******************"



IF (ifano.eq.1)
[
 write(iout,*) 'This calculation was performed using regeneration ';
]

IF (ifano.eq.2)
[
 write(iout,*) 'This calculation was performed eliminating electrons';
 write(iout,*) 'originating in the cavity wall.';
]


write(iout,'(//)');
write(iout,'(/t20,a)')
  'Results using a batch scoring scheme';
write(iout,'(t20,a)')
  '===================================================== ';

"THE TOTAL DOSE"
WRITE(IOUT,310)SCAV(1),SCAVUN(1);

IF(IFULL.GE.1)[
    "CALCULATE Ascat, Aatt, Awall, DOSE/Awall"

    "Ascat: SCAV(2)=Ascat-1"
    ASCT=1.+SCAV(2);
    IF((SCAV(2).EQ.0.0).OR.(SCAVUN(2).EQ.99.9))["BAD STATS"
        ASCTUN=ABS(SCAV(2));
        ]
    ELSE["CALCULATE FIRST ORDER STATS"
        ASCTUN=SCAV(2)*SCAVUN(2)/100.;
        ]
    WRITE(IOUT,320)ASCT,ASCTUN;

    "Aatt: SCAV(3)=1/Aatt-1"
    IF(SCAV(3).EQ.-1.0)["HIGHLY IMPROBABLE CASE"
        AATT=1.;AATTUN=0.;
        ]
    ELSE[
        AATT=1./(SCAV(3)+1.);
        IF((SCAV(3).EQ.0.0).OR.(SCAVUN(3).EQ.99.9))["BAD STATS"
            AATTUN=ABS(1.-AATT);
            ]
        ELSE["CALCULATE FIRST ORDER STATS"
            AATTUN=(SCAV(3)*SCAVUN(3)/100.)*AATT**2;
            ]
        ]
    WRITE(IOUT,330)AATT,AATTUN;

    "Awall: Awall = Ascat * Aatt"
    AWLL=ASCT*AATT;
    "CALCULATE FIRST ORDER STATS"
    AWLLUN=AWLL*SQRT((ASCTUN/ASCT)**2+(AATTUN/AATT)**2);
    WRITE(IOUT,340)AWLL,AWLLUN;

    "TOTAL DOSE/Awall"
    TDAW=TTDA(1);TDAWUN=TTDAUN(1);
    WRITE(IOUT,350)TDAW,TDAWUN;

    ] "END OF IFULL >= 1"

IF(IFULL.GE.2)[
    "CALCULATE Apn, AND DOSE/(Awall*Apn)"

    IF(IPTSRC.EQ.1)[ "FOR POINT SOURCES"
        "Apn: SCAV(4)=Apn"
        IF(SCAV(4).EQ.0.0)["HIGHLY IMPROBABLE CASE"
            APN=1.;APNUN=0.;
            ]
        ELSE[
            APN=SCAV(4);
            IF((SCAV(4).EQ.0.0).OR.(SCAVUN(4).EQ.99.9))["BAD STATS"
                APNUN=ABS(SCAV(4));
                ]
            ELSE["CALCULATE FIRST ORDER STATS"
                APNUN=ABS(SCAV(4)*SCAVUN(4)/100.);
                ]
            ]
        WRITE(IOUT,360)APN,APNUN;
"JAN CHANGE: COMMENTED LINES AWAY AND MOVED SECTION TO BELOW"
"ALSO IN CASE OF NON-PT SOURCE UNWEIGHED DOSE MUST BE ACCURATE"
        "TOTAL DOSE/(Awall*Apn)"
        "TDAA=TTDA(2);TDAAUN=TTDAUN(2);"
        "WRITE(IOUT,370)TDAA,TDAAUN;"
        ]
    ELSE[
        TDAA=TDAW;TDAAUN=TDAWUN;
        ]
"JAN CHANGE MOVED FROM JUST ABOVE"
   "TOTAL DOSE/(Awall*Apn=1)"
    TDAA=TTDA(2);TDAAUN=TTDAUN(2);
    WRITE(IOUT,370)TDAA,TDAAUN;
"END OF JAN CHANGE"
    ] "END OF IFULL >= 2"

IF(IFULL.EQ.3)[

    "CALCULATE Afl, TOTAL DOSE/(Awall*Apn*<s>g,w*Afl), AND <s>g,w"
    "Afl: SCAV(5)=Afl"
    AFL=SCAV(5);
    IF((SCAV(5).EQ.0.0).OR.(SCAVUN(5).EQ.99.9))["BAD STATS"
        AFLUN=ABS(SCAV(5));
        ]
    ELSE[ "CALCULATE FIRST ORDER STATS"
        AFLUN=ABS(SCAV(5))*SCAVUN(5)/100.;
        ]
    WRITE(IOUT,380) AFL,AFLUN;

    "TOTAL DOSE/(Awall*Apn*Afl)"
    TDA3=TTDA(3);TDA3UN=TTDAUN(3);
    WRITE(IOUT,390)TDA3,TDA3UN;

    "<s>g,w: SCAV(6)=<s>g,w -1"
    SRAT=1.+SCAV(6);
    IF((SCAV(6).EQ.0.0).OR.(SCAVUN(6).EQ.99.9))["BAD STATS"
        SRATUN=ABS(SCAV(6));
        ]
    ELSE[ "CALCULATE FIRST ORDER STATS"
        SRATUN=ABS(SCAV(6))*SCAVUN(6)/100.;
        ]
    WRITE(IOUT,395) SRAT,SRATUN;

    "TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
    TDAS=TTDA(4);TDASUN=TTDAUN(4);
    WRITE(IOUT,396)TDAS,TDASUN;

    ] "END OF IFULL = 3"

"OUTPUT Kscat,Katt,Kwall,Kpn,Kfl THE INVERSES OF THE Ai's"
IF(IFULL.GT.0)[
    KSCT=1./ASCT;KSCTUN=ASCTUN/ASCT**2;WRITE(IOUT,321)KSCT,KSCTUN;
    KATT=1./AATT;KATTUN=AATTUN/AATT**2;WRITE(IOUT,331)KATT,KATTUN;
    KWLL=1./AWLL;KWLLUN=AWLLUN/AWLL**2;WRITE(IOUT,341)KWLL,KWLLUN;
    IF(IPTSRC.EQ.1)[ "FOR POINT SOURCES ONLY"
        KPN=1./APN;KPNUN=APNUN/APN**2;WRITE(IOUT,361)KPN,KPNUN;
        ]
    ]
IF(IFULL.EQ.3)[
    KFL=1./AFL;KFLUN=AFLUN/AFL**2;WRITE(IOUT,381)KFL,KFLUN;
    ]

"THE DETAILED OUTPUT FOR EACH CAVITY ZONE"
"****************************************"

IF((IOOPTN.EQ.1).AND.(numcavreg.GT.1))[
    "ONLY IF REQUESTED AND MORE THAN ONE CAVITY ZONE"

    WRITE(IOUT,400) numcavreg;

    "PRINT THE TABLE HEADER"
    IF(IFULL.EQ.0)[
        WRITE(IOUT,410);
        ]
    ELSEIF(IFULL.GT.0)[
        "SET UP THE PRINTER"
        ICHPIN=16; "16 CHARACTERS/INCH"
        ILPIN=6;   "6 LINES/INCH"
        IPAGE=0;   "NO PAGE THROW"
        "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"

        IF(IFULL.EQ.1)[WRITE(IOUT,420);]ELSE[WRITE(IOUT,421)];
        ]

    "LOOP OVER THE CAVITY ZONES"
    DO I=1,numcavreg[
        IRL=cavreg(I);
        $GET-IX-IC(IRL);
        IF(IFULL.GE.1)[
            "CALCULATE Ascat, Aatt, Awall, DOSE/Awall"

            "Ascat: DOSE(IC,IX,2)=Ascat-1"
            ASCT=1.+DOSE(IC,IX,2);
            IF((DOSE(IC,IX,1).EQ.0.0).OR.(DOSEUN(IC,IX,1).EQ.99.9))["BAD STATS"
                ASCTUN=ABS(DOSE(IC,IX,2));
                ]
            ELSE["CALCULATE FIRST ORDER STATS"
                ASCTUN=DOSE(IC,IX,2)*DOSEUN(IC,IX,2)/100.;
                ]

            "Aatt: DOSE(IC,IX,3)=1/Aatt-1"
            IF(DOSE(IC,IX,3).EQ.-1.0)["HIGHLY IMPROBABLE CASE"
                AATT=1.;AATTUN=0.;
                ]
            ELSE[
                AATT=1./(DOSE(IC,IX,3)+1.);
                IF((DOSE(IC,IX,3).EQ.0.0).OR.(DOSEUN(IC,IX,3).EQ.99.9))[
                    "BAD STATS"
                    AATTUN=ABS(DOSE(IC,IX,3));
                    ]
                ELSE["CALCULATE FIRST ORDER STATS"
                    AATTUN=(DOSE(IC,IX,3)*DOSEUN(IC,IX,3)/100.)*AATT**2;
                    ]
                ]

            "Awall: Awall = Ascat * Aatt"
            AWLL=ASCT*AATT;
            "CALCULATE FIRST ORDER STATS"
            AWLLUN=AWLL*SQRT((ASCTUN/ASCT)**2+(AATTUN/AATT)**2);

            "TOTAL DOSE/Awall"
            TDAW=TDA(IC,IX,1);TDAWUN=TDAUN(IC,IX,1);

            ] "END OF IFULL >= 1"

        IF(IFULL.GE.2)[
        "CALCULATE Apn, AND DOSE/(Awall*Apn)"

            IF(IPTSRC.EQ.1)[ "FOR POINT SOURCES"
                "Apn: DOSE(IC,IX,4)=Apn"
                IF(DOSE(IC,IX,4).EQ.0.0)["HIGHLY IMPROBABLE CASE"
                    APN=1.;APNUN=0.;
                    ]
                ELSE[
                    APN=DOSE(IC,IX,4);
                    IF((DOSE(IC,IX,4).EQ.0.0).OR.(DOSEUN(IC,IX,4).EQ.99.9))[
                        "BAD STATS"
                        APNUN=ABS(DOSE(IC,IX,4));
                        ]
                    ELSE["CALCULATE FIRST ORDER STATS"
                        APNUN=ABS(DOSE(IC,IX,4)*DOSEUN(IC,IX,4)/100.);
                        ]
                    ]

                "TOTAL DOSE/(Awall*Apn)"
                TDAA=TDA(IC,IX,2);TDAAUN=TDAUN(IC,IX,2);
                ]
            ELSE[
                APN=1.;APNUN=0.;TDAA=TDAW;TDAAUN=TDAWUN;
                ]

            ] "END OF IFULL >= 2"

         IF(IFULL.EQ.3)[

            "CALCULATE Afl, TOTAL DOSE/(Awall*Apn*<s>g,w*Afl), AND <s>g,w"

            "Afl: DOSE(IC,IX,5)=Afl"
            AFL=DOSE(IC,IX,5);
            IF((DOSE(IC,IX,5).EQ.0.0).OR.(DOSEUN(IC,IX,5).EQ.99.9))["BAD STATS"
                AFLUN=ABS(DOSE(IC,IX,5));
                ]
            ELSE[ "CALCULATE FIRST ORDER STATS"
                AFLUN=ABS(DOSE(IC,IX,5))*DOSEUN(IC,IX,5)/100.;
                ]

            "TOTAL DOSE/(Awall*Apn*Afl)"
            TDA3=TDA(IC,IX,3);TDA3UN=TDAUN(IC,IX,3);

            "<s>g,w: DOSE(IC,IX,6) = <s>g,w -1"
            SRAT=1.+DOSE(IC,IX,6);
            IF((DOSE(IC,IX,6).EQ.0.0).OR.(DOSEUN(IC,IX,6).EQ.99.9))["BAD STATS"
                SRATUN=ABS(DOSE(IC,IX,6));
                ]
            ELSE[ "CALCULATE FIRST ORDER STATS"
                SRATUN=ABS(DOSE(IC,IX,6))*DOSEUN(IC,IX,6)/100.;
                ]

            "TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
            TDAS=TDA(IC,IX,4);TDASUN=TDAUN(IC,IX,4);

            ] "END OF IFULL = 3"

        "PRINT OUT RESULTS FOR EACH ZONE"

        IF(IFULL.EQ.0)[
            WRITE(IOUT,430)
                IRL,IC,IX,                     "POSITION"
                DOSE(IC,IX,1),DOSEUN(IC,IX,1); "TOTAL DOSE"
                ]

        ELSEIF(IFULL.EQ.1)[
            WRITE(IOUT,440)
                IRL,IC,IX,                     "POSITION"
                DOSE(IC,IX,1),DOSEUN(IC,IX,1), "TOTAL DOSE"
                ASCT,ASCTUN,                   "Ascat"
                AATT,AATTUN,                   "Aatt"
                AWLL,AWLLUN,                   "Awall"
                TDAW,TDAWUN;                   "TOTAL DOSE/Awall"
            ]

        ELSEIF(IFULL.EQ.2)[
            WRITE(IOUT,445)
                IRL,IC,IX,                     "POSITION"
                DOSE(IC,IX,1),DOSEUN(IC,IX,1), "TOTAL DOSE"
                ASCT,ASCTUN,                   "Ascat"
                AATT,AATTUN,                   "Aatt"
                AWLL,AWLLUN,                   "Awall"
                TDAW,TDAWUN,                   "TOTAL DOSE/Awall"
                APN, APNUN,                    "Apn"
                TDAA,TDAAUN;                   "TOTAL DOSE/(Awall*Apn)"
            ]
        ELSEIF(IFULL.EQ.3)[
            WRITE(IOUT,450)
                IRL,IC,IX,       "POSITION"
                DOSE(IC,IX,1),   "TOTAL DOSE"
                ASCT,            "Ascat"
                AATT,            "Aatt"
                AWLL,            "Awall"
                TDAW,            "TOTAL DOSE/Awall"
                APN,             "Apn"
                TDAA,            "TOTAL DOSE/(Awall*Apn)"
                AFL,             "Afl"
                TDA3,            "TOTAL DOSE/(Awall*Apn*Afl)"
                SRAT,            "<s>g,w"
                TDAS,            "TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
                DOSEUN(IC,IX,1), "UNCERTAINTY IN TOTAL DOSE"
                ASCTUN,          "UNCERTAINTY IN Ascat"
                AATTUN,          "UNCERTAINTY IN Aatt"
                AWLLUN,          "UNCERTAINTY IN Awall"
                TDAWUN,          "UNCERTAINTY IN TOTAL DOSE/Awall"
                APNUN,           "UNCERTAINTY IN Apn"
                TDAAUN,          "UNCERTAINTY IN TOTAL DOSE/(Awall*Apn)"
                AFLUN,           "UNCERTAINTY IN Afl"
                TDA3UN,          "UNCERTAINTY IN TOTAL DOSE/(Awall*Apn*Afl)"
                SRATUN,          "UNCERTAINTY IN <s>g,w"
                TDASUN;          "UNCERTAINTY TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
       ]


    ] "END OF LOOP OVER CAVITY ZONES"
]     "END OF DETAILED SUMMARY"

"RESET UP THE PRINTER"
ICHPIN=12; "12 CHARACTERS/INCH"
ILPIN=6;   "6 LINES/INCH"
IPAGE=0;   "NO PAGE THROW"
"CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"

RETURN;
%I0
"FORMATS"
150  FORMAT(// ,T5,'*** WARNING ***  IDNEAR=0, ABOVE RESULTS',
            ' INCOMPLETE (NOT ALL STEPS COUNTED)');
200  FORMAT(// ,T8,'# PRIMARY CHARGED PARTICLE STEPS',T51,
             I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'# OF TIMES MSCAT SWITCHED OFF',T51,
             I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
210  FORMAT(// ,T8,'# PRIMARY CHARGED PARTICLE STEPS IN CAVITY REGION'
             ,T51,I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'# TIMES MSCAT SWITCHED OFF IN CAVITY REGION.'
             ,T51,I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
220  FORMAT(// ,T8,'STEP COUNTING RESULTS FOR WALL MATERIAL IN THE CAVITY'/
             // ,T8,'# PRIMARY CHARGED PARTICLE STEPS',T51,
             I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'# OF TIMES MSCAT SWITCHED OFF',T51,
             I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
230  FORMAT(// ,T8,'# PRIMARY CHARGED PARTICLE STEPS IN CAVITY REGION'
             ,T51,I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'# TIMES MSCAT SWITCHED OFF IN CAVITY REGION.'
             ,T51,I12,' +/- ',0PF5.2,'%'/
             ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
300  FORMAT(// ,T20,'SUM OF RESULTS FOR THE CAVITY: 1 REGION'/
            ' ',T20,'***************************************');
301  FORMAT(// ,T20,'SUM OF RESULTS FOR THE CAVITY: ',I2,' REGIONS'/
            ' ',T20,'*****************************************');
310  FORMAT(//'TOTAL DOSE (GRAYS/(INCIDENT FLUENCE):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
320  FORMAT(' Ascat:',T50,F8.5,'   +/- ',F8.5);
321  FORMAT(//'Kscat:',T50,F8.5,'   +/- ',F8.5);
330  FORMAT(' Aatt :',T50,F8.5,'   +/- ',F8.5);
331  FORMAT(' Katt :',T50,F8.5,'   +/- ',F8.5);
340  FORMAT(' Awall:',T50,F8.5,'   +/- ',F8.5);
341  FORMAT(' Kwall:',T50,F8.5,'   +/- ',F8.5);
350  FORMAT(' TOTAL DOSE/Awall:',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
360  FORMAT(//'Apn  :',T50,F8.5,'   +/- ',F8.5);
361  FORMAT(' Kpn  :',T50,F8.5,'   +/- ',F8.5);
370  FORMAT(' TOTAL DOSE/([Apn]*Awall):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
380  FORMAT(//'Afl  :',T50,F8.5,'   +/- ',F8.5);
381  FORMAT(' Kfl  :',T50,F8.5,'   +/- ',F8.5);
390  FORMAT(' TOTAL DOSE/(Afl*[Apn]*Awall):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
395  FORMAT(//'<s>g,w  :',T50,F8.5,'   +/- ',F8.5);
396  FORMAT(' TOTAL DOSE/(Afl*[Apn]*Awall*<s>g,w):',
              T50,1PE11.4,' +/-  ',0PF5.2,'%');
400  FORMAT(// ,T20,'DETAILED RESULTS FOR EACH OF THE ',I4,' CAVITY REGIONS'/
            ' ',T20,'****************************************************');
410  FORMAT(//'Z# C# S#     Total Dose     '/
            ' -- -- -- -------------------');
420  FORMAT(//'Z# C# S#',
            '     Total Dose   ',
            '      Ascat      ',
            '       Aatt      ',
            '      Awall      ',
            '  Total Dose/Awall',
            '       Apn       ',
            ' T Dose/(Awall*Apn)'/
            ' -- -- --',
            '     ----------   ',
            '      -----      ',
            '       ----      ',
            '      -----      ',
            '  ----------------',
            '       ---       ',
            ' ------------------');
421  FORMAT(//'Z# C# S#',
            ' Total Dose',
            '   Ascat  ',
            '   Aatt   ',
            '   Awall  ',
            ' Dose/Awall',
            '    Apn   ',
            ' D/(Aw*Apn)',
            '    Afl   ',
            ' D/AwApnAfl',
            '  <s>g,w  ',
            ' D/AwApAf*s'/
            ' -- -- --',
            ' ----------',
            '   -----  ',
            '   ----   ',
            '   -----  ',
            ' ----------',
            '    ---   ',
            ' ----------',
            '    ---   ',
            ' ----------',
            '  ------  ',
            ' ----------');
430  FORMAT(' ',I2,2(1X,I2),1X,1PE11.4,' +/-',0PF5.2,'%');
440  FORMAT(' ',I2,2(1X,I2),
                1X,1PE11.4,'(',0PF5.2,'%)',
                3(F8.5,'(',F7.5,')'),
                1X,1PE11.4,'(',0PF5.2,'%)');
445  FORMAT(' ',I2,2(1X,I2),
                1X,1PE11.4,'(',0PF5.2,'%)',
                3(F8.5,'(',F7.5,')'),
                1X,1PE11.4,'(',0PF5.2,'%)',
                F8.5,'(',F7.5,')',
                1X,1PE11.4,'(',0PF5.2,'%)');
450  FORMAT(' ',I2,2(1X,I2),
                1X,1PE11.4,
                3(1X,F8.5,1X),
                1X,1PE11.4,
                1X,F8.5,1X,
                1X,1PE11.4,
                1X,F8.5,1X,
                1X,1PE11.4,
                1X,F8.5,1X,
                1X,1PE11.4/
            ' ','ERRORS = ',
                4X,'(',0PF5.2,'%)',
                3(1X,'(',F7.5,')'),
                4X,'(',0PF5.2,'%)',
                1X,'(',F7.5,')',
                4X,'(',0PF5.2,'%)',
                1X,'(',F7.5,')',
                4X,'(',0PF5.2,'%)',
                1X,'(',F7.5,')',
                4X,'(',0PF5.2,'%)');

END; "END OF SUBROUTINE OSUMRY"

subroutine initialize_range_rejection;

implicit none;

COMIN/ELECIN,GEOM,MISC,USER,MEDIA/;

$INTEGER irl,medium,cavity_medium,ix,IC,neke,lelke,lelec,qel;
$REAL    elke,elke_min,elke_max,rhof,rhof_min,range,max_range,si,sip;
$REAL    eke,ekei,elkei,elktmp,dedxmid,aux,fedep;
$INTEGER lelktmp,j;

write(6,*);
write(6,*) '  initialize_range_rejection';
write(6,*) '  ==========================';
write(6,*);

lelec = -1; qel = 0;
cavity_medium = 0;
"Determin first the cavity medium and check for possible errors"
DO irl = 2,nreg
[
    medium = med(irl);
    IF( ntrack(irl) = 1 ) [
        IF( cavity_medium = 0 ) [
            cavity_medium = medium;
            write(6,*) ' Cavity medium is med # ',cavity_medium;
        ]
        ELSE [
            IF( medium ~= cavity_medium ) [
                write(6,*)
                  ' Warning: cavity composed of several media: ',medium;
                write(6,*)
                  ' Turning off range rejection! ';
                irejct = 0;
                return;
            ]
        ]
    ]
]


" Now determine smallest cylinder encloding the cavity "
" (non-cavity regions composed of cavity material are counted as cavity"
" I think we can safely say that the cavity is bound by the rsph coords.
"
r_cavity_min = 1E10;
r_cavity_max = -1e10;
DO irl = 2,nreg
[
    medium = med(irl);
    IF( ntrack(irl) = 1 | medium = cavity_medium ) [
        $GET-IX-IC(irl);
        IF( RSPH(IX-1) < r_cavity_min ) [ r_cavity_min = rsph(ix-1); ]
        IF( RSPH(IX) > r_cavity_max ) [ r_cavity_max = rsph(ix); ]
    ]
]
IF ( R_CAVITY_MIN.GT.RSPH(IX) ) [ R_CAVITY_MIN = 0.0; ]

write(6,*) '  The smallest spheres enclosing the cavity are defined by: ';
write(6,*) r_cavity_min,' < r < ',r_cavity_max;
write(6,*);

IF( nmed = 1 ) [
    write(6,*) '  There is only one medium in the simulation => ';
    write(6,*) '      no additional range-rejection can be done!';
    return;
]

" Now prepare an array for range calculation in the medium with the "
" mallest stopping power (excluding the cavity material)            "
" First determine energy window. We assume that the PEGS data has been "
" checked to cover the necessary energy range                          "
elke_min = -1e10;
elke_max = 1e10;
DO medium = 1,nmed [
  IF( medium ~= cavity_medium ) [
      neke = meke(medium);
      elke = (1 - eke0(medium))/eke1(medium);
      IF( elke > elke_min ) [ elke_min = elke; ]
      elke = (neke - eke0(medium))/eke1(medium);
      IF( elke < elke_max ) [ elke_max = elke; ]
  ]
]
write(6,*) ' Range rejection data will be calculated for ';
write(6,*) Exp(elke_min),' < E < ',Exp(elke_max);

"Then determine the minimum density scaling factor (rhof)"
rhof_min = 1e10;
DO irl = 2,nreg
[
    medium = med(irl); $SET-RHOF;
    IF( rhof < rhof_min ) [ rhof_min = rhof; ]
]
write(6,*) ' rhof_min = ',rhof_min;
write(6,*);

rhof = rhof_min;
eker1 = ($MXRANGE-1)/(elke_max - elke_min);
eker0 = $MXRANGE - eker1*elke_max;
"write(6,*) ' eker1 eker0: ',eker1,eker0;
"write(6,*);

" Calculate maxium range for 1st table energy "
elke = (1-eker0)/eker1;
eke = Exp(elke);
max_range = -1e10;
DO medium=1,nmed[
    IF( medium ~= cavity_medium ) [
        $SET INTERVAL elke,eke;
        IF( lelke < 1 ) [ lelke = 1; ]
        $COMPUTE-RANGE;
        IF( range > max_range ) [ max_range = range; ]
    ]
]
si = 1.02*max_range;

DO j=1,$MXRANGE-1
[
    elke = (j+1-eker0)/eker1;
    eke = Exp(elke);
    max_range = -1e10;
    DO medium=1,nmed[
        IF( medium ~= cavity_medium ) [
            $SET INTERVAL elke,eke;
            $COMPUTE-RANGE;
            IF( range > max_range ) [ max_range = range; ]
        ]
    ]
    sip = 1.02*max_range;  "A safety factor"
    rangerr1(j) = (sip - si)*eker1;
    rangerr0(j) = sip - rangerr1(j)*elke;
    "write(6,'(4g15.6)') eke,sip,rangerr0(j),rangerr1(j);"
    si = sip;
]
rangerr1($MXRANGE) = rangerr1($MXRANGE-1);
rangerr0($MXRANGE) = rangerr0($MXRANGE-1);

return;
end;

subroutine range_rejection(elke,x,y,z,ir,iq,idisc);

implicit none;

$INTEGER ir,iq,idisc;
$REAL    elke,x,y,z;

COMIN/GEOM,USER/;

$REAL    r2,r,zl,rl,tperp,range;
$INTEGER lelke;

idisc = 0;  "No range discard
IF( ntrack(ir) = 1 ) [ return; ]  "No additional rejection in the cavity
r2 = x*x + y*y + z*z;
IF( r2 >= r_cavity_min*r_cavity_min & r2 <= r_cavity_max*r_cavity_max ) [
    return;
]
r  = Sqrt(r2);
IF( r < r_cavity_min ) [ rl = r_cavity_min - r; ]
ELSE [ rl = r - r_cavity_max; ]

lelke = eker1*elke + eker0;
range = rangerr1(lelke)*elke + rangerr0(lelke);
IF( range <= rl ) [ idisc = 50 + 49*iq; ]

return; end;


"****************************************************************************"

subroutine combine_results(file_name);

"****************************************************************************"
implicit none;
character*(*) file_name;

;COMIN/SCORE,RANDOM,IODAT2,IODAT4,GEOM,SOURCE/;
"******************************************************* ADDED BY JT, DEC.98"
"*                Variables for post-processing parallel run               *"
"***************************************************************************"
$INTEGER   TMPIST,TMPISTC,TMPIMS,TMPIMSC;      "T> temporary variables
$INTEGER   TMPISM,TMPISMC,TMPIMM,TMPIMMC;      "T> temporary variables
$INTEGER   TMPNCASE;                           "T>temp variable for NCASE
$REAL      TMPDOSE($MAXCDOSE,$MAXRADII,$MAXIT);"T> temporary dose array
$REAL      TMPTMCPU;                           "T>dummy variable for TIMCPU

"$INTEGER   DATCOUNT;                           T>number of .egs4dat files"
"datcount used to be a local variable that holds the number of parallel"
"jobs if irestart=5. As now data file reading from parallel runs is done"
"in a separate routine, it must go into a common block as it is used in"
"main."

"extra components added    "
"to obtain Aatt and Ascat  "
"with a history by history "
"scoring scheme            "
"            EMH March 2002"
real*8 tcav_dose,tcav2_dose,tcav_dose1,tcav2_dose1,tcav_dosec;
real*8 tcav_dose0,tcav2_dose0,tcav_dose2,tcav2_dose2,tcav_dosec01,tcav_dosec02;
"***************************************************************************"

$INTEGER my_unit,egs_get_unit,iout,ic,ix,it,lnblnk1,irl;
$LOGICAL first_time;
data first_time/.true./, iout/1/;
save first_time,iout;

IF( first_time ) [

      OUTPUT ;(/1X,'Summing the following .egsdat files');
      OUTPUT ; (1X,'------------------------------------'/);
      WRITE(IOUT,'(/1X,''Summing the following .egsdat files'')');
      WRITE(IOUT,'(1X,''------------------------------------''/)');

      datcount=0;
      /TMCPUO,NCASEO/=0;
      /cav_dose, cav_dose0, cav_dose1, cav_dose2/ =0;
      /cav2_dose,cav2_dose0,cav2_dose1,cav2_dose2/=0;
      /cav_dosec,cav_dosec01,cav_dosec02/         =0;
      first_time = .false.;

      DO IS=1,$STAT[
        ISTIS(IS)=0; ISTCIS(IS)=0;
        IMSIS(IS)=0; IMSCIS(IS)=0;
        ISMIS(IS)=0; ISMCIS(IS)=0;
        IMMIS(IS)=0; IMMCIS(IS)=0;

        DO IC=1,NC[
         DO IX=1,NR[
          DO IT=1,$MAXIT[
             DOSEIS(IC,IX,IT,IS)=0.0;
          ]
         ]
        ]
      ]

]

my_unit = egs_get_unit(4);
WRITE(IOUT,'(A)') $cstring(file_name);
WRITE(6,'(A)') $cstring(file_name);
open(my_unit,file=file_name,status='old',err=:EOF_RS1:);

read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav_dose, tcav_dose0,
                                            tcav_dose1, tcav_dose2;
read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav2_dose,tcav2_dose0,
                                            tcav2_dose1,tcav2_dose2;
read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav_dosec,tcav_dosec01,
                                            tcav_dosec02;

cav_dose =cav_dose +tcav_dose; cav_dose0=cav_dose0+tcav_dose0;
cav_dose1=cav_dose1+tcav_dose1;cav_dose2=cav_dose2+tcav_dose2;

cav2_dose  = cav2_dose  + tcav2_dose;
cav2_dose0 = cav2_dose0 + tcav2_dose0;
cav2_dose1 = cav2_dose1 + tcav2_dose1;
cav2_dose2 = cav2_dose2 + tcav2_dose2;

cav_dosec   = cav_dosec   + tcav_dosec;
cav_dosec01 = cav_dosec01 + tcav_dosec01;
cav_dosec02 = cav_dosec02 + tcav_dosec02;


DO IS=1,$STAT[
   READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
       TMPIST,TMPISTC,TMPIMS,TMPIMSC,
       TMPISM,TMPISMC,TMPIMM,TMPIMMC;
   ISTIS(IS)=ISTIS(IS)+TMPIST;
   ISTCIS(IS)=ISTCIS(IS)+TMPISTC;
   IMSIS(IS)=IMSIS(IS)+TMPIMS;
   IMSCIS(IS)=IMSCIS(IS)+TMPIMSC;
   ISMIS(IS)=ISMIS(IS)+TMPISM;
   ISMCIS(IS)=ISMCIS(IS)+TMPISMC;
   IMMIS(IS)=IMMIS(IS)+TMPIMM;
   IMMCIS(IS)=IMMCIS(IS)+TMPIMMC;

   READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
       (((TMPDOSE(IC,IX,IT),IT=1,$MAXIT),IX=1,NR),IC=1,NC);
   DO IC=1,NC[
      DO IX=1,NR[
         DO IT=1,$MAXIT[
            DOSEIS(IC,IX,IT,IS)=DOSEIS(IC,IX,IT,IS)+TMPDOSE(IC,IX,IT);
         ]
      ]
   ]
]"End of IS loop"

$RETRIEVE RNG STATE FROM UNIT my_unit;
READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TMPNCASE,TMPTMCPU;

write(6,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;
write(iout,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;

TMCPUO=TMCPUO+TMPTMCPU; NCASEO=NCASEO+TMPNCASE;

datcount=datcount+1;

CLOSE(UNIT=my_unit);
return;

:EOF_RS1:;
WRITE(6,*) 'failed to open file';
return;

:EOF_RS3:;
write(6,*) 'failed to read file';
close(my_unit); return; end;
