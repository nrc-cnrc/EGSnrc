%C80
"#############################################################################"
"                                                                             "
"  EGSnrc flurznrc application                                                "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Alex Bielajew, 1983                                       "
"                                                                             "
"  Contributors:    Dave Rogers                                               "
"                   Eric Fox                                                  "
"                   Charlie Ma                                                "
"                   J. Borg                                                   "
"                   Aaron Merovitz                                            "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                   Ernesto Mainegra-Hing                                     "
"                   Reid Townson                                              "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Parts of the EGS code that originate from SLAC are distributed by NRC      "
"  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  A large number of people have been involved with the development of EGS    "
"  over the years. Many details are in the manual. The authors want to point  "
"  out the central role of Ralph Nelson of SLAC in the development of EGS     "
"  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
"  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
"  code development. Hideo Hirayama was involved with the development of EGS4 "
"  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
"  developments on EGS4. As well many others and users from around the world  "
"  have assisted in developing and making available the code, in particular   "
"  Robert D. Stewart.                                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  This code simulates the passage of an electron or photon beam in a finite, "
"  right cylindrical geometry with azimuthal symmetry. An arbitrary number    "
"  of user-defined geometrical planes and radii define physical region        "
"  boundaries at which the material may or may not change.                    "
"                                                                             "
"  Dave Rogers, 2012:                                                         "
"                                                                             "
"  made changes in the primary scoring of e-. These changes made it work with "
"  eii and relaxation.                                                        "
"                                                                             "
"  Fixed bug in first bin of plots of spectra. Changes are in PLOTSN. Error   "
"  basically ignored the ECUTIN and PCUTIN values if the user defaulted them  "
"  to 0(for histograms) and was just wrong and picking up a random value for  "
"  the point plots.                                                           "
"                                                                             "
"  Fixed bug whereby electrons created by Bhabha scattering were not being    "
"  flagged as secondaries as they should have been.                           "
"                                                                             "
"  IPRIM=2, include bremsstrahlung secondaries does not handle annihilation   "
"  the same as brems events. It probably should. Have not fixed since assume  "
"  no one ever uses since sprrznrc handles these calns now.                   "
"                                                                             "
"  Iwan Kawrakow, 2003:                                                       "
"                                                                             "
"  Changes since Rev 1.31 in RCS:                                             "
"  - replaced date and time calls to the egsnrc date and time routines        "
"  - fixed occurences of local variables assumed to be static.                "
"                                                                             "
"#############################################################################"


%L
%I4
!INDENT F2;
%C80
%Q1
;
REPLACE {$VERSION} WITH {
,' ',}
"23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
"******************************************************************************
"
"                               ********************
"                               *                  *
"                               * flurznrc.mortran *
"                               *                  *
"                               ********************
"
"
"       This code simulates the passage of an electron or photon beam in a
"       finite, right cylindrical geometry with azimuthal symmetry.
"       An arbitrary number of user-defined geometrical planes and radii
"       define physical region boundaries at which the material may or may not
"       change.
"       The fluence spectra are scored or by summing the track lengths in a zone
"       bounded by planes and radii.
"
"Geometry as in DOSRZnrc
"       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
"       ===========================================================
"         Z axis = axis of rotation runs across page shown as .......
"
"
"       --------------------------------------------------------- RCYL(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
"       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
"       --------------------------------------------------------- RCYL(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RCYL(2)
"       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
"       --------------------------------------------------------- RCYL(1)
"..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
;"      ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
"

"       UNIT ASSIGNMENTS
"       UNIT 1   OUTPUT LISTING FILE
"       UNIT 2   STORE RANDOM NUMBER SEEDS IS ISTORE = 1
"       UNIT 4   TEMPORARY DATA STORAGE FILE - EITHER READ IN OR CREATED
"       UNIT 5   PROMPTS FOR INTERACTIVE INPUT AND ECHOS FILE INPUT
"       UNIT 6   INPUT CONTROL FILE (KEYBOARD FOR INTERACTIVE INPUT)
"       UNIT 12  EGS PICKS UP THE PEGS4 DATA SET FROM THIS UNIT
"       UNIT 15  EGS WARNING AND ERROR MESSAGE FILES
"       UNIT 17  output spectra for use bu ensrc with other codes
"       UNIT 23  standard plotting file in xmgr format
"       UNIT 42  input full phase space file from BEAM
"
"******************************************************************************
%E    "Start input description"
"******************************************************************************
"*******************************************************************************
"   Instructons for use of input routines
"
"   Input is via the routine get_inputs which has extensive documentation
"   at the top of its source code.
"
"   Inputs are all in the format: name of value_sought= value
"   where the name of value_sought must match that expected by the
"   program. The = sign must have no blanks on its immediate left and
"   at least one on its immediate right..
"
"   The value_sought must be the first thing on a line but blanks are
"     allowed before it.
"
"   Various inputs are only sought between certain delimeter strings
"     which are defined below (eg :start I/O control: :stop I/O control:)
"     If not specified, the whole file is searched for a requested value_sought.
"     Delimeter strings are enclosed by colons.
"     Note that within delimeter strings, order of inputs does not matter.
"
"   If a requested quantity is not found, this is noted in $input.errors
"     and this file is printed at the end of the log file.
"
"   A semi-colon implies the end of input for this quantity but is
"     not mandatory.  However, this means they cannot be used in titles.
"   A # sign indicated everything else on the line is a comment (and
"     cannot be used in titles.
"   Case is not important in the names of the quantites.
"
"   Commas separate multiple values for a given quantity and a comma
"     at the end of a line implies there is more input on the next line.
"   Values can extend over as many lines as needed. Use commas to imply
"     there are more values on the next line.
"
"   Blank lines and blanks in general are ignored.
"   tabs are NOT allowed when character input is being sought,
"   including tabs used to put # to the right after a character input. Use
"   blanks instead.
"
"   The maximum record length is 256 characters.
"
"   There is a routine morph_flurz which takes an old format input file
"     and translates it.
"
"   There should be a file morph_template.egs4inp which can be used
"     and which defines most options.
"
"   One drawback of this system is that there is a disconnect between
"     the internal variable name used and the value_sought strings.
"     In the input description variables listed in [ ] braces are
"     the internal variable names associated with this input.
"


"*******************************************************************************
"*  LEGEND       LEGEND        LEGEND       LEGEND        LEGEND       LEGEND  *
"*******************************************************************************
"* (1)  *  Integers between parentheses indicate the numerical value of        *
"*      *  the input allowed input at hand.  These are for reference only,     *
"*      *  and should never be used in an actual input file.                   *
"*      *  E.g.:  ITERSE= Groups                                               *
"*      *                                                                      *
"* (M)  *  The 'M' indicates that the variable at hand has multiple            *
"*      *  input capability.  One may assign an arbitrary number of            *
"*      *                                                                      *
"*      *  values to that input.                                               *
"*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
"*      *                                                                      *
"* (M2) *  The 'M' with an integer beside it means that the variable           *
"*      *  has that number of inputs.                                          *
"*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
"*      *                                                                      *
"* (I)  *  Regular (one number) integer input value.                           *
"*      *  E.g.:  SOURCE NUMBER= 0                                             *
"*      *                                                                      *
"* (R)  *  Regular (one number) real input value.                              *
"*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
"*      *                                                                      *
"* (C)  *  Regular (one string) character input value.                         *
"*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
"*      *                                                                      *
"*******************************************************************************
"      Note that everywhere ; is treated as the end of the input =>not
"      allowed in titles.
"      Similarly everything from # on in a line is ignored so it cannot
"      be in a title.
"*******************************************************************************
;
"                                TITLE
"                                *****
"*******************************************************************************
"
"CARD TI1
"
"       TITLE          (C)  TITLE OF THE INPUT FILE (FORMAT= '80A1')
;
"*******************************************************************************
"*******************************************************************************
"                       INPUT/OUTPUT CONTROL INPUT
"                       **************************
"*******************************************************************************
"
" I/O DELIMETERS:    :start I/O control:
"                    :stop I/O control:
"
"
"  IWATCH= off         (0)  for normal output
"        = interactions(1)  output on every discrete interaction
"        = steps       (2)  output on every electron/photon step as well
"        = deposited   (3)  prints out only when energy is deposited
"        = graph       (4)  prints out file for graphics
"
"  STORE INITIAL RANDOM NUMBERS
"        = no          (0)  do not store the initial random numbers
"        = last        (1)  store the initial random number for the last history
"        = all         (2)  store all the initial random numbers
"
"  IRESTART
"        = first       (0)  first run for this data set
"        = restart     (1)  restart of a previous run
"        = analyze     (3)  just read in the raw data and do the statistical
"                           analysis
"        = start-RNS   (4)  read starting random numbers from a file (e.g. for
"                           output to a graphics package)
"        = parallel    (5)  post-process parallel runs (all files
"                           named <filenamebase>_w#)
"
"  PRINT FLUENCE SPECTRA
"        = all         (0)  print fluence spectra for all
"        = specified   (2)  print spectra only for those regions
"                           specified by 'LIST FLUENCE START REGION'
"                           and 'LIST FLUENCE STOP REGION'.
"        = none        (3)  no fluence spectra printed
"
"  STORE DATA ARRAYS
"        = yes         (0)  Store data arrays for re-use
"        = no          (1)  don't store them
"
"  LIST FLUENCE START REGION    (only if  PRINT FLUENCE SPECTRA= specified)
"                      (M)  lower (starting) numbers defining the regions for
"                           which spectra are to be printed in listing file.
"
"  LIST FLUENCE STOP REGION    (only if  PRINT FLUENCE SPECTRA= specified)
"                      (M)  higher (final) numbers defining the regions for
"                           which spectra are to be printed in listing file.
"  IPRIMARY
"         = total fluence             (0) score total fluence spectra  only
"         = electron primaries        (1) score e+- primaries
"                                         separately as well include brem
"                                         generated e- as primaries
"                                         In photon beam, 1st generation e- are
"                                         primaries
"         = include brem secondaries  (2) score electron primaries but include
"                                         those generated by brem as
"                                         secondaries.  It should be called
"                                         include brem as secondaries
"         = photon primaries          (3) primaries are all first generation
"                                         photons,including brem.
"                                         secondaries include all scattered
"                                         photons and annihilation photons.
"         = electron secondaries      (4) score electron secondaries.

"
"  SLOTE           (R)  = 0.0 => read in energy bins for output,
"                       = -999   set up $EBIN bins, top 10% linear for SPR calc
"                       < 0      set up -SLOTE equal log bins
"                       else set up equal bins of slote. If too many bins
"                       are requested, SLOTE is doubled until the number of
"                       bins needed to cover the spectrum is < or = $EBIN
"
"-------------------------------------------------------------------------------
"
"  (IF SLOTE=0.0)
"
"  TOPS OF ENERGY BINS (M)  tops of output bins in MeV
"                           starting with the lowest,
"                           end with value < or = last value
"
;
"*******************************************************************************
;
"                       MONTE CARLO CONTROL INPUT
"                       *************************
"*******************************************************************************
"
" MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
"                            :stop Monte Carlo inputs:
"
"  NUMBER OF HISTORIES         (I)  # histories to run
"                                   (min:100, defaults to 20 000)
"
"  INITIAL RANDOM NO. SEEDS=  INTGER1, INTEGER2
"                  User-code can use RANLUX or RANMAR, depending on selection
"                  Default is RANLUX
"            RANLUX
"                  INTEGER1 is the luxury level, use 1 to 4, 4 taking longest
"                           default is 1 (set by $DEFAULT-LL in ranlux.macros)
"                  INTEGER2 selects the independent sequence to use, it
"                           can be from 1 to 1073741824 (2**30)
"            RANMAR
"                  INTEGER1 is a seed between 1 and 31328 (0 =>default 1802)
"                  INTEGER2 is a seed between 1 and 30081 (0 =>default 9937)
"                    Selection of unique INTEGER2 values guarantees independent
"                    sequences.
"            Note:
"               After the seeds are first input and used for initialization,
"               the variables jrng1 and jrng2 are just pointers used by the RNG
"
"  MAX CPU HOURS ALLOWED       (I)  MAX CPU TIME ALLOWED IN HOURS, DEFAULT=999
"
"*******************************************************************************
;
"                       CYLINDRICAL GEOMETRY INPUT
"                       **************************
"*******************************************************************************
"
" GEOMRZ DELIMETERS:    :start geometrical inputs:
"                       :stop geometrical inputs:
"
"  METHOD OF INPUT
"        = Groups         (0)   INPUT GROUPS OF SLABS OF EQUAL THICKNESS
"        = Individual     (1)   VERBOSE INPUT OF THE GEOMETRY AND MEDIA.
"
"------------------------------------------------------------------------------
"
" Information defining depth boundaries along z axis (all dimensions cm)
"
" Only if  METHOD OF INPUT=  Groups
"
"  Z OF FRONT FACE        (R)   START OF FIRST SLAB (REAL)
"  NSLAB                  (M)   # PLANAR SLABS IN A GROUP (INTEGERS)
"  SLAB THICKNESS         (M)   THICKNESS OF EACH SLAB IN THE GROUP (REALS)
"
"  Only if  METHOD OF INPUT=  Individual
"
"  Z OF FRONT FACE        (R)   START OF FIRST SLAB (REAL)
"  DEPTH BOUDARIES        (M)   GEOMETRICAL Z-PLANE COORDINATES (REALS)
"
"------------------------------------------------------------------------------
"
" Information defining radial boundaries
"
"  RADII                  (M)   RADII OF CYLINDERS DEFINING THE GEOMETRY (REALS)
"
"*******************************************************************************
;
"                                MATERIAL INPUT
"                                **************
"*******************************************************************************
"
"  MEDIA                  (M)   TYPE OF MATERIAL (FMT='24A1')
"
"  Define which media in which regions, numbering in order given above.
"
"  DESCRIPTION BY= Regions(0)   USING THE IRL REGION NUMBER
"                = Planes (1)   USING THE IX, IZ PLANES
"
" If DESCRIPTION BY= Regions
"
"  MEDNUM                 (M)   THE MATERIAL NUMBER (INTEGERS)
"                               (MEDNUM=0 TO SKIP)
"  START REGION           (M)   INITIAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"  STOP REGION            (M)   FINAL GEOMETRICAL ZONE(IRL) (INTEGERS)
"                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
" If DESCRIPTION BY= Planes
"
"  MEDNUM                 (M)   THE MATERIAL NUMBER (INTEGERS)
"                               (MEDNUM=0 TO SKIP)
"  START ZSLAB            (M)   INITIAL ZSLAB (IZ) (INTEGERS)
"  STOP ZSLAB             (M)   FINAL ZSLAB (IZ) (INTEGERS)
"  START RING             (M)   INITIAL radial ring(IX) (INTEGERS)
"  STOP RING              (M)   FINAL radial ring(IX) (INTEGERS)
"                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
"                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
"                                           MEDNUM=1 FOR REGION=2,NREG
"
"*******************************************************************************
;
"                             SOURCE INPUT(check latest version of srcrz)
"                            **************
"*******************************************************************************
" SOURCE DELIMETERS:    :start source inputs:
"                       :stop source inputs:
"
"FOR ALL SOURCES
"                                      Charge of the incident beam
"  INCIDENT PARTICLE= electron   (-1)  electrons
"                     photon     (0)   photons
"                     positron   (1)   positrons
"
"  (for SOURCE 21,22,23)  all    (2)  include all of the particles
"                                     in the phase space file
"                                     [IQIN]
"                    charged     (3)  include e+ and e-
"
"  SOURCE NUMBER                 (I)   number of the source
"                                      [ISOURC]
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  0 <<<<<<<<
"
"     PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS) ""toc:
"
"
"  SOURCE OPTIONS            (M4)  RBEAM, UINC, VINC, WINC
"
"               RBEAM          radius of parallel beam in cm
"                              (defaults to max radius of geometry)
"               UINC           incident x-axis direction cosine
"               VINC           incident y-axis direction cosine
"               WINC           incident z-axis direction cosine
"                              NOTE: (UINC,VINC,WINC)
"                              get automatically normalized
"                              defaults to (0.0,0.0,1.0)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  1 <<<<<<<<
"
"     POINT SOURCE ON AXIS INCIDENT FROM THE FRONT    ""toc:
"
"  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, 0, 0
"
"               DISTZ          distance of the point source from the
"                              front of the target in cm (DEFAULT 100.)
"               RBEAM          radius of the beam at the front of the
"                              target in cm (defaults to MAX radius)
"
"------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  2 <<<<<<<<
"
"        BROAD PARALLEL BEAM INCIDENT FROM FRONT (+VE Z-AXIS) ""toc:
"               WITH UNIT AREA BEAM AND LARGE SCORING AREA
"
"  SOURCE OPTIONS          (M4)  0, 0, 0, 0
"
"------------------------------------------------------------------------------
;
"
"                     >>>>>>>> SOURCE  3 <<<<<<<<
"
"     UNIFORM ISOTROPICALLY RADIATING DISK OF FINITE SIZE   ""toc:
"            (MUST BE ALLOWED FOR IN THE GEOMETRICAL DEFINITIONS)
"
"  SOURCE OPTIONS                (M4)  RMINBM, RBEAM, ZSMIN, ZSMAX
"
"               RMINBM,RBEAM           inner and outer radii of source region
"                                      must be inside geometry
"               ZSMIN,ZSMAX            min and max z values for source
"
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  4 <<<<<<<<
"
"     FOR CENTRAL AXIS FLUENCE VS BEAM RADIUS      ""toc:
"
"  SOURCE OPTIONS            (M4)  RCAXIS, 0, 0, 0
"
"               RCAXIS       radius of central axis scoring zone (cm)
"
"        NOTE: this source option treats the cylindrical radii input
"              above as beam radii. the largest radius must be infinite
"              and the phantom must be homogeneous (at least in each layer)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  10 <<<<<<<<
"
"     PARALLEL BEAM INCIDENT FROM THE SIDE (+VE Y-AXIS)    ""toc:
"
"  SOURCE OPTIONS           (M4)  XBEAM, ZBEAM, 0, 0
"
"               XBEAM             half-width of the rectangular beam in cm
"                                 (defaults to max radius)
"               ZBEAM             half-height of the rectangular beam in cm
"                                 (defaults to max)
"
"-------------------------------------------------------------------------------
"
"
"                     >>>>>>>> SOURCE  11 <<<<<<<<
"
"     POINT SOURCE INCIDENT FROM THE SIDE     ""toc:
"
"
"  SOURCE OPTIONS                (M4)  DISTRH, XBEAM, ZBEAM, 0
"
"               DISTRH                 distance of the source from the middle
"                                      of the target in cm (defaults to 100.)
"               XBEAM                  half-width of the beam at the center of
"                                      the target in cm (defaults to max radius)
"               ZBEAM                  half-height of the beam at the center of
"                                      the target in cm (defaults to max)
"
"-------------------------------------------------------------------------------
;
"
"                     >>>>>>>> SOURCE  12 <<<<<<<<
"
"   POINT SOURCE OFF AXIS         ""toc:
"
"  SOURCE OPTIONS                (M4)  DISTRH, DISTZ, 0, 0
"
"               DISTRH                 distance of the point source off the
"                                      Z-axis.
"               DISTZ                  perpendicular distance of the
"                                      point source away from the front face.
"                                      a negative value is permitted.
"
"                                      DISTZ > 0
"                                      point located in front of front face
"
"                                      0 > DISTZ > -(ZPLANE(NPLANE)-ZPLANE(1))
"                                      point located between front and rear face
"
"                                      DISTZ < -(ZPLANE(NPLANE)-ZPLANE(1))
"                                      point located rear of rear plane
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  13 <<<<<<<<
"
"        PARALLEL BEAM FROM ANY ANGLE     ""toc:
"
"  SOURCE OPTIONS                (M4)  UINC, VINC, WINC, 0
"
"               UINC                   incident x-axis direction cosine
"               VINC                   incident y-axis direction cosine
"               WINC                   incident z-axis direction cosine
"
"                 NOTE: (UINC,VINC,WINC) get automatically normalized
"                       default is (0.0,0.0,1.0)
"
"
"------------------------------------------------------------------------------
"                     >>>>>>>> SOURCE  14 <<<<<<<<
"
"   POINT SOURCE ON AXIS INCIDENT FROM THE FRONT WITH ALL   ""toc:
"    EVENTS INSIDE RMINBM NOT FOLLOWED (A FUDGE FOR COLLIMATOR STUDIES)
"
"  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, RMINBM, IGNORED
"
"               DISTZ                  distance of the point source from the
"                                      front of the target in cm
"                                      (defaults to 100.)
"               RBEAM                  radius of the beam at the front of the
"                                      target in cm (defaults to max radius)
"               RMINBM                 below this radius, all histories are
"                                      terminated by the source routines by
"                                      giving them zero weight.
"                                      The howfar routines must check for this.
"
"-------------------------------------------------------------------------------
;
"
"
"
"                     >>>>>>>> SOURCE  15 <<<<<<<<
"
"  POINT SOURCE OFF AXIS. The same as source 12 but uses an alternative
"  implementation for sampling points on the surface of the RZ-geomtry. The
"  motivation for implementing this source was to check that source 12 is OK
"  and to check the effect of varying weights from the source on the
"  statistical uncertainty (contrary to source 12, source 16 produces
"  essentially  constant weights if the geometry-to-source distance is large
"  compared to the geometry dimension, a typical situation for ion chamber
"  simulations)
"
"  SOURCE OPTIONS                (M4)  DIST, ANGLE, IGNORED, IGNORED
"
"             DIST                     distance of the centre of the geometry
"                                      to the source in cm.
"             ANGLE                    angle of rotation around the x-axis.
"                                      (because of the cylindrical symetry,
"                                      rotations around the x-axis and y-axis
"                                      are indistinguishable). 0 degrees
"                                      corresponds to a source above the front
"                                      face (i.e. the same as source 1), 90
"                                      degrees to a source from the side
"                                      (i.e. the same as source 11).
"                                      The source MUST be outside the geometry,
"                                      otherwise the initialization routine
"                                      will abort execution.
"
"           Note that if you are not actually rotating about the center of the
"           geometry, you must calculate the angle and distance as if you
"           were.
"
"-------------------------------------------------------------------------------
;
"
"                     >>>>>>>> SOURCE  16 <<<<<<<<
"
"           EXTENDED (CIRCULAR OR RECTANGULAR)  SOURCE OFF AXIS.
"
"  SOURCE OPTIONS                (M4)  DIST, ANGLE, TMP1, TMP2
"
"            DIST                      distance of geometry centre to source
"                                      centre in cm.
"
"            ANGLE                     angle of rotation around the x-axis
"                                      (see comments/explanations to source 15)
"
"            TMP1, if TMP2 <= 0        radius of the source (i.e., the emitting
"        or  TMP2, if TMP1 <= 0        position is picked uniformly within the
"                                      circle).
"
"            TMP1 and TMP2, if both    half-sizes of the radiating rectangle
"            >= 0                      in x- and y-directions before rotation,
"                                      i.e., initially x and y are picked
"                                      within the rectangle and z is set to
"                                      -DIST + geometry centre. Then a rotation
"                                      around the x-axis is performed.
"       In all cases the source plane is perpendicular to the line joining
"       it to the center of the geometry.   Note that this introduces a
"       slight error if the center of your geometry is not the true point
"       of rotation.
"
"       Note: if TEMP1 <= 0 and TEMP2 <= 0, source 16 becomes a point-source
"             off-axis, i.e. the same as source 12 and 15.
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  20 <<<<<<<<
"
"   RADIAL DISTRIBUTION INPUT      ""toc:
"
"  MODEIN= Local                 (0)   if radial distribution is to be input
"                                      locally through the .egs4inp file
"        = External              (1)   if the distribution is to be input
"                                      via an external file
"
"                        -----------------------------
" ONLY IF MODEIN= Local
"
"  NRDIST                        (I)   # radial bins in distribution histogram
"  RDISTF                        (M)   top of radial bin.
"                                      should be values for 1 to NRDIST.
"  RPDF                          (M)   Probability of initial particle being
"                                      in this bin.
"                                      Probability doesn't need to be normalized
"                                      but it should be in units cm**-2
"                                      Should be values for 1 to NRDIST.
"  RDIST IOUTSP= None            (0)   No distribution data in output summary
"              = Include         (1)   include distribution data output summary
"
"                        -----------------------------
"  ONLY IF MODEIN= External
"
"  RDIST FILENAME                (C)   filename(with ext) contains
"                                      distribution information
"
"  RDIST IOUTSP= None            (0)   No distribution data in output summary
"              = Include         (1)   include distribution data output summary
"
"-------------------------------------------------------------------------------
;
"
"                     >>>>>>>> SOURCE  21 <<<<<<<<
"
"    FULL BEAM PHASE-SPACE BEAM DATA, INCIDENT ON FRONT FACE    ""toc:
"
"  SOURCE OPTIONS                (M4)  IMODE, 0, 0, 0
"
"               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
"                                  2=> 8 variables/record: the above + ZLAST
"
"  FILSPC                        (C)   filename (with ext) contains
"                                      phase space information
"                                      (maximum of 80 characters)
"                                      (assigned to unit 42)
"
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  22 <<<<<<<<
"
"    FULL BEAM PHASE-SPACE BEAM DATA FROM ANY ANGLE, INSIDE OR OUTSIDE   ""toc:
"
"    PARTICLES ARE READ IN FROM A BEAM PHASE SPACE and placed on a plane
"    described by the SOURCE OPTIONS inputs (see below). Then it is checked
"    whether they are already inside the geometry. If yes, the region index
"    is determined and the shower intiated. If not, it is checked whether
"    the particle trajectory will intersect the geometry (assuming that the
"    geometry is surrounded by vacuum). If not, the particle is rejected and
"    the next one taken from the phase-space file. If yes, the particle
"    is placed on the entry point and the shower is initiated.
"
"  SOURCE OPTIONS                (M4)  IMODE, DIST, ANGLE, ZOFFSET
"
"               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
"                                  2=> 8 variables/record: the above + ZLAST
"               DIST               Perpendicular distance of the phase-space
"                                  plane to the point of rotation in cm.
"               ANGLE              Angle of rotation in degrees. The rotation
"                                  is performed around an axis that is parallel
"                                  to the x-axis and passes through the point
"                                  (x,y,z)=(0,0,ZOFFSET).
"               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
"                                  the centre of the geometry is taken as
"                                  the point of rotation (but note that
"                                  the maximum value allowed by the input
"                                  routine is 1e6, so that |ZOFFSET| must
"                                  be between 1e4 and 1e6 to use the centre
"                                  of the geometry automatically).
"
"    Examples:
"       - to place a phase-space on the upper z-face of the geometry,
"         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
"         This is the same as source 21
"       - to place a phase space on the lower z-face of the geometry,
"         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
"       - to have a phase file incident from, say, 60 degrees with
"         a distance to the centre of the geometry of 30 cm, use
"         DIST=30, ANGLE=60, ZOFFSET=9999.
"   etc.
"
"  FILSPC                        (C)   filename (with ext) contains
"                                      phase space information
"                                      (maximum of 80 characters)
"                                      (assigned to unit 42)
"-------------------------------------------------------------------------------
"
"                     >>>>>>>> SOURCE  23 <<<<<<<<
"
"    BEAM TREATMENT HEAD SIMULATION AS SOURCE INCIDENT FROM AND ANGLE,  ""toc:
"    INSIDE OR OUTSIDE PHANTOM                                          ""toc:
"
"    PARTICLES ARE READ DIRECTLY FROM A BEAM SIMULATION COMPILED AS A
"    SHARED LIBRARY.  Particles are read at the scoring plane in
"    the BEAM simulation (although no phase space file is scored) and are
"    tranlated/rotated by the inputs DIST, ANGLE, XOFFSET, YOFFSET, ZOFFSET,
"    described below.  Then it is checked
"    whether they are already inside the geometry. If yes, the region index
"    is determined and the shower intiated. If not, it is checked whether
"    the particle trajectory will intersect the geometry (assuming that the
"    geometry is surrounded by vacuum). If not, the particle is rejected and
"    the next one taken from the BEAM simulation (more histories are run in
"    the BEAM simulation if required).  If yes, the particle
"    is placed on the entry point and the shower is initiated.
"
"  BEAM CODE                     (C)  The name of the accelerator code being
"                                     used as a source including the BEAM_
"                                     prefix (ie BEAM_accelname).  This code
"                                     must have been compiled as a shared
"                                     library (see the BEAM manual for more
"                                     details) and exist as
"                                     libBEAM_accelname.so (for Linux/Unix) or
"                                     libBEAM_accelname.dll (for Windows) in
"                                     directory $EGS_HOME/bin/config.
"
"  INPUT FILE                    (C)  The name of a working input file
"                                     (no .egsinp extension) for
"                                     the BEAM code BEAM_accelname.  This
"                                     input file must specify output of a
"                                     phase space file at one scoring plane.
"                                     Particles that would have been scored
"                                     in the phase space file are extracted
"                                     and used as the incident particles in
"                                     the DOSXYZ simulation instead.  The
"                                     input file must exist in the directory
"                                     $EGS_HOME/BEAM_accelname.
"
"  PEGS FILE                     (C)  The name of the pegs4 data set (no
"                                     .pegs4dat extension) used
"                                     by BEAM_accelname with the input file
"                                     specified by INPUT FILE.  The pegs4
"                                     data set must exist in either
"                                     $HEN_HOUSE/pegs4/data or in
"                                     $EGS_HOME/pegs4/data.
"
"  WEIGHT WINDOW                 (M2)  MIN_WEIGHT_23, MAX_WEIGHT_23
"
"               MIN_WEIGHT_23         Min. weight of particles to use from
"                                     the BEAM simulation (defaults to -1E30)
"               MAX_WEIGHT_23         Max. weight of particles to use from
"                                     the BEAM simulation (defaults to 1E30)
"
"  SOURCE OPTIONS                (M5)  DIST, ANGLE, ZOFFSET, XOFFSET, YOFFSET
"
"               DIST               Perpendicular distance of the phase-space
"                                  plane to the point of rotation in cm.
"               ANGLE              Angle of rotation in degrees. The rotation
"                                  is performed around an axis that is parallel
"                                  to the x-axis and passes through the point
"                                  (x,y,z)=(0,0,ZOFFSET).
"               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
"                                  the centre of the geometry is taken as
"                                  the point of rotation (but note that
"                                  the maximum value allowed by the input
"                                  routine is 1e6, so that |ZOFFSET| must
"                                  be between 1e4 and 1e6 to use the centre
"                                  of the geometry automatically).
"               XOFFSET,YOFFSET    X and Y offset of scoring plane in BEAM
"                                  simulation (cm).  Offsets are applied before
"                                  rotating the source.
"
"    Examples:
"       - to have BEAM simulation incident on the upper z-face of the geometry,
"         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
"         This is the same as source 21
"       - to have BEAM simulation incident on the lower z-face of the geometry,
"         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
"       - to have BEAM simulation incident from, say, 60 degrees with
"         a distance to the centre of the geometry of 30 cm, use
"         DIST=30, ANGLE=60, ZOFFSET=9999.
"
"*******************************************************************************
;
"
" Source Energy Inputs (not required if ISOURC=21,22 -full phase space )
"
"  Input from ensrc.mortran
"
" ENSRC DELIMETERS:  :start source inputs:
"                    :stop source inputs:
"
"
"  INCIDENT ENERGY
"        = monoenergetic  (0)  if monoenergetic beam
"        = spectrum       (1)  if energy spectrum to be used
"
"           ---------------------------------------
"
"  If INCIDENT ENERGY= Monoenergetic:
"
"     INCIDENT KINETIC ENERGY(MEV)   (I)
"                                   kinetic energy of the incident beam in MeV
"                                   (defaults to 1.25)
"
"           ---------------------------------------
"
"  If INCIDENT ENERGY= Spectrum:
"
"                   SPEC FILENAME   (C)  filename (with ext)
"                                   contains spectrum information
"
"                                   FILE FORMAT:
"                                   TITLE      spectrum title  (80 char)
"                                   NENSRC, ENMIN, MODE
"                                   NENSRC     # energy bins in spec. histogram
"                                   ENMIN      lower energy of first bin
"                                   MODE       =0, assumes cts/bin
"                                              =1  assumes cts/MeV
"                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
"                                   top of energy bin and probability of
"                                   initial particle being in this bin.
"                                   probability does not need to be normalized
"
"                   SPEC IOUTSP
"                        = none     (0)  no spectrum data in output summary
"                        = include  (1)  include spectrum data in output summary
;
"*******************************************************************************
;
"*******************************************************************************
"                       TRANSPORT CONTROL INPUT
"                       ***********************
"
"                         MC TRANSPORT PARAMETER
"                         **********************
"
"  All input associated with selection of various transport parameter
"  is not crucial for the execution as there are default values set.
"  Therefore, if some of the input options in this section are
"  missing/misspelled, this will be ignored and defualt parameter assumed
"  As the transport parameter input routine uses get_inputs, a lot
"  of error/warning messages may be produced on UNIT 15, though.
"  If you don't have the intention of changing default settings,
"  simply ignore the error messages.
"
"  The delimeters are
"
"               :start mc transport parameter:
"               :stop mc transport parameter:
"
"  Currently, the following options are available (except for a few entries,
"  case does not matter):
"
"       Global ECUT=     Set a global (in all regions) electron transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AE(medium) will be used.
"                        [ ECUT ]
"       Global PCUT=     Set a global (in all regions) photon transport
"                        cut off energy (in MeV). If this imput is missing,
"                        AP(medium) will be used.
"                        [ PCUT ]
"       Global SMAX=     Set a global (in all regions) maximum step-size
"                        restriction for electron transport (in cm).
"                        If missing, no geometrical step-size restrictions will
"                        be employed. Note that if you use the default
"                        EGSnrc electron-step algorithm, no SMAX-restriction
"                        is necessary. Option is useful for transport in low
"                        density materials (air) when PRESTA behaviour is
"                        turned on (see below)
"                        [ SMAXIR ]
"       ESTEPE=          Set the maximum fractional energy loss per step.
"                        Note that this is a global option only, no
"                        region-by-region setting is possible. If missing,
"                        the defualt is 0.25 (25%)
"                        [ ESTEPE ]
"       XImax=           Maximum first elastic scattering moment per step.
"                        Default is 0.5, NEVER use value greater than 1 as
"                        this is beyond the range of MS data available.
"                        [ XIMAX ]
"       Boundary crossing algorithm=
"                        There are two selections possible: EXACT, means
"                        the algorithm will cross boundaries in a single
"                        scattering (SS) mode, the distance from a boundary
"                        at which the transition to SS mode is made is
"                        determined by 'Skin depth for BCA' (see below).
"                        The second option is PRESTA-I, if selected boundaries
"                        will be crossed a la PRESTA, i.e. with lateral
"                        correlations turned off and MS forced at boundaries.
"                        Default is EXACT.
"                        [ bca_algorithm, exact_bca ]
"       Skin depth for BCA=
"                        Determines the distance from a boundary (in elastic
"                        MFP) at which the algorithm will go into single
"                        scattering mode (if EXACT boundary crossing) or
"                        swith off lateral correlations (if PRESTA-I boundary
"                        crossing). Default value is 3 for EXACT or
"                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
"                        for a definition of BLCMIN). Note that if you choose
"                        EXACT boundary crossing and set Skin depth for BCA
"                        to a very large number (e.g. 1e10), the entire
"                        calculation will be in SS mode. If you choose
"                        PRESTA-I boundary crossing and make Skin depth for BCA
"                        large, you will get default EGS4 behavious (no PRESTA)
"                        [ skindepth_for_bca ]
"       Electron-step algorithm=
"                        PRESTA-II (the default), the name is
"                        used for historical reasons
"                        or PRESTA-I
"                        Determines the algorithm used to take into account
"                        lateral and longitudinal correlations in a
"                        condensed history step.
"                        [ transport_algorithm ]
"       Spin effects=    Off, On, default is On
"                        Turns off/on spin effects for electron elastic
"                        scattering. Spin On is ABSOLUTELY necessary for
"                        good backscattering calculations. Will make a
"                        even in `well conditioned' situations (e.g. depth
"                        dose curves for RTP energy range electrons).
"                        [ spin_effects ]
"       Brems angular sampling= Simple, KM, default is KM
"                        If Simple, use only the leading term of the Koch-Motz
"                        distribution to determine the emission angle of
"                        bremsstrahlung photons. If On, complete
"                        modified Koch-Motz 2BS is used (modifications
"                        concern proper handling of kinematics at low energies,
"                        makes 2BS almost the same as 2BN at low energies).
"                        [ IBRDST ]
"       Brems cross sections= BH, NIST, default is BH
"                        If BH is selected, the Bethe-Heitler bremsstrahlung
"                        cross sections (Coulomb corrected above 50 MeV)
"                        will be used. If NIST is selected, the NIST brems
"                        cross section data base (which is the basis for
"                        the ICRU radiative stopping powers) will be employed.
"                        Differences are negligible for E > ,say, 10 MeV,
"                        but signifficant in the keV energy range.
"       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
"                        gryzinski or penelope.  If set to On or ik, then
"                        use Kawrakow's theory to derive EII cross-sections.
"                        If set to casnati, then use the cross-sections of
"                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
"                        Similar for kolbenstvedt, gryzinski and penelope.
"                        This is only of interest in kV X-ray calculations.
"                        Note that the user can supply their own EII
"                        cross-section data as well. The requirement is that
"                        the file eii_suffix.data exists in the $HEN_HOUSE/data
"                        directory, where suffix is the name specified.
"                        Entry case-sensitive except for Off, On or ik.
"                        [ eii_flag ]
"       Bound Compton scattering=  On, Off, Simple or norej
"                        If Off, Compton scattering will be treated with
"                        Klein-Nishina, with On Compton scattering is
"                        treated in the Impuls approximation. Default is On.
"                        With Simple, the impulse approximation incoherent
"                        scattering function will be used (i.e., no Doppler
"                        broadenning). With norej the actual total bound
"                        Compton cross section is used and there are no
"                        rejections at run time.
"                        Make sure to turn on for low energy applications,
"                        not necessary above, say, 1 MeV.
"                        [ IBCMP ]
"       Pair angular sampling= Off, Simple or KM
"                        If off, pairs are set in motion at an angle m/E
"                        relative to the photon direction (m is electron rest
"                        energy, E the photon energy). Simple turns on
"                        the leading term of the angular distribution
"                        (this is sufficient for most applications),
"                        KM (comes from Koch and Motz) turns on using 2BS
"                        from the article by Koch and Motz.
"                        Default is Simple, make sure you always use Simple or
"                        KM
"                        [ IPRDST ]
"       Pair cross sections= BH (default) or NRC.  If set to BH, then use
"                        Bethe-Heitler pair production cross-sections.  If set
"                        to NRC, then use NRC pair production cross-sections
"                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
"                        of interest at low energies, where the NRC cross-
"                        sections take into account the assymmetry in the
"                        positron-electron energy distribution.
"                        [ pair_nrc ]
"       Photon cross sections= Photon cross-section data.  Current options are
"                        si (Storm-Israel--the default), epdl (Evaluated Photon
"                        Data Library), xcom and pegs4.  Allows the use of
"                        photon cross-sections other than from the PEGS4 file
"                        unless the pegs4 option is specified.
"                        Note that the user can supply their own cross-section
"                        data as well. The requirement is that the files
"                        photon_xsections_photo.data,
"                        photon_xsections_pair.data,
"                        photon_xsections_triplet.data, and
"                        photon_xsections_rayleigh.data exist in the
"                        $HEN_HOUSE/data directory, where photon_xsections
"                        is the name specified.
"                        Hence this entry is case-sensitive.
"                        [ photon_xsections ]
"       Photon cross-sections output= Off (default) or On.  If On, then
"                        a file $EGS_HOME/user_code/inputfile.xsections is
"                        output containing photon cross-section data used.
"                        [ xsec_out ]
"       Compton cross sections= Bound Compton cross-section data.  User-
"                        supplied bound Compton cross-sections in the file
"                        $HEN_HOUSE/data/comp_xsections_compton.data, where
"                        comp_xsections is the name supplied for this input.
"                        This is only used if Bound Compton scattering= Simple
"                        and is not available on a region-by-region basis
"                        (see below).  The default file (ie in the absence
"                        of any user-supplied data) is compton_sigma.data.
"                        [ comp_xsections ]
"       Photoelectron angular sampling= Off or On
"                        If Off, photo-electrons get the direction of the
"                        `mother' photon, with On, Sauter's furmula is
"                        used (which is, striktly speaking, valid only for
"                        K-shell photo-absorption).
"                        If the user has a better approach, replace the macro
"                            $SELECT-PHOTOELECTRON-DIRECTION;
"                        The only application that
"                        I encountered until now where this option made a
"                        small difference was a big ion chamber (cavity size
"                        comparable with electron range) with high-Z walls
"                        in a low energy photon beam.
"                        Default is On
"                        [ IPHTER ]
"       Rayleigh scattering= Off, On, custom
"                        If On, turn on coherent (Rayleigh) scattering,
"                        even if no Rayleigh data in PEGS4 file.
"                        Default is Off. Should be turned on for low energy
"                        applications. If custom, user must provide media names
"                        and form factor files for each medium.
"                        [ IRAYLR ]
"       ff media names = A list of media names (must match media found in
"                        PEGS4 data file) for which the user is going to
"                        provide custom Rayleigh form factor data.
"                        [ iray_ff_media($MXMED) ]
"       ff file names = A list of names of files containing the Rayleigh
"                       form factor data for the media specified by
"                       the ff media names = input above.  Full directory
"                       paths must be given for all files, and for each medium
"                       specified, iray_ff_media(i), there must be a
"                       corresponding file name, iray_ff_file(i).  For
"                       example files, see the directory
"                       $HEN_HOUSE/data/molecular_form_factors.
"                       [ iray_ff_file($MXMED) ]
"       Atomic relaxations= Off, On
"                        Default is On. The effect of using On is twofold:
"                        - In photo-electric absorption events, the element
"                          (if material is mixture) and the shell the photon
"                          is interacting with are sampled from the appropriate
"                          cross seections
"                        - Shell vacancies created in photo-absorption events
"                          are relaxed via emission of fluorescent X-Rays,
"                          Auger and Koster-Cronig electrons.
"                         Make sure to turn this option on for low energy
"                         applications.
"                         [ IEDGFL ]
"
"       Atomic relaxations, Rayleigh scattering,
"       Photoelectron angular sampling and Bound Compton scattering
"                         can also be turned On/Off on a region-by-region
"                         basis. To do so, put e.g.
"
"       Atomic relaxations= On in Regions   or
"       Atomic relaxations= Off in regions
"
"                         in your input file. Then use

"       Bound Compton start region=
"       Bound Compton stop region=
"                or
"       Rayleigh start region=
"       Rayleigh stop region=
"                or
"       Relaxations start region=
"       Relaxations stop region=
"                or
"       PE sampling start region=
"       PE sampling stop region=
"
"                         each followed by a lost of of one or more
"                         start and stop regions separated by commas.
"                         Example:
"        Atomic relaxations= On in Regions
"        Relaxations start region=  1, 40
"        Relaxations stop region=  10, 99
"                         will first turn off relaxations everywhere and
"                         then turn on in regions 1-10 and 40-99.
"                         Note that input is checked against min. and max.
"                         region number and ignored if
"                         start region < 1 or stop_region > $MXREG or
"                         start region > stop region.
"
"                         ECUT, PCUT and SMAX can also be set on a
"                         region-by-region basis. To do so, iclude
"                         in your input file
"
"         Set XXXX=              f_value1, f_value2, ...
"         Set XXXX start region= i_value1, i_value2, ...
"         Set XXXX stop region=  j_value1, j_value2, ...
"
"                         where XXXX is ECUT, PCUT or SMAX ,
"                         f_value1, f_value2,... are the desired values for XXXX
"                         and i_value_i and j_value_i are the start and
"                         stop regions.
"
"
"*******************************************************************************
;
"
"                    VARIANCE REDUCTION
"                    ******************
"
"  Delimeter:       :start variance reduction:
"                   :stop variance reduction:
"
"  BREM SPLITTING
"         = Off            (0)   no bremsstrahlung splitting
"         = On             (1)   there is bremsstrahlung spliting
"
"  NUMBER OF BREMS PER EVENT
"                          (I)   number of brems / event if splitting on
"
"  CHARGED PARTICLE RUSSIAN ROULETTE
"         = Off        (0)  Do not play Russian Roulette with charged particles
"         = On         (1)  Play Russian Roulette with charged particles with
"                           probability of survival=PROB_RR=1/nbr_split.
"                           [I_PLAY_RR]
"
"  ELECTRON RANGE REJECTION
"         = off        (0)  No electron range rejection
"         = on         (1)  Do electron range rejection. All charged particles
"                           without enough range to escape the local region
"                           are terminated if E < ESAVEIN.
"                           [IREJCT]
"
"      We could/should? reinstitute the old approach by searching all
"      regions outside the region of interest, finding the one with the
"      greatest range and then use that range as a test against the distance
"      to the region of interest.
"      This has been implemented in CAVRZnrc
"
"
"  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
"                           electron  when E< ESAVEIN and RANGE < CDIST
"                           where CDIST is closest distance to region of
"                           interest specified below. This ignores brem
"                           losses below ESAVEIN.
"                           This parameter must be input even if not used.
"
" If ELECTRON RANGE REJECTION= on
"========================================================================
"  FOLLOWING IS NOT USED  - leave in until decide what to do
"========================================================================
"  RANGE REJECTION PARAMETERS
"                 (M5)   CRANGE(1,1),CRANGE(2,1),ERANGE,CRANGE(1,2),CRANGE(2,2)
"
"               COEFFICIENTS OF A 2-PIECE LOGARITHMIC FIT TO THE ELECTRON
"               CSDA RANGE USED TO DISCARD ELECTRONS THAT CANNOT REACH THE
"               RANGE REJECTION REGION.
"               THE ELECTRON RESIDUAL RANGE IS COMPUTED IN HOWFAR AS
"               RANGE=EXP(CRANGE(1,I)+CRANGE(2,I)*ELKE)/RHO
"               WHERE  I=1 FOR EKE>ERANGE, ELSE I=2.
"               DEFAULT VALUES FOR CRANGE,ERANGE ARE FOR CARBON
"               WITH ERANGE=200keV FROM B&S '64. THE RANGE SHOULD ALWAYS
"               BE OVERESTIMATED WITH THE CLOSEST FIT BEING AT THE ENERGY
"               WHERE MOST OF THE ELECTRONS ARE EXPECTED TO BE.
;
"
"  RANGE REJECTION MINIMUM PLANE   (I)  MIN. IZ BOUNDARY FOR RANGE REJECTION
"
"  RANGE REJECTION MAXIMUM PLANE   (I)  MAX. IZ BOUNDARY FOR RANGE REJECTION
"
"  RANGE REJECTION MINIMUM RADIUS  (I)  MIN. IX BOUNDARY FOR RANGE REJECTION
"
"  RANGE REJECTION MAXIMUM RADIUS  (I)  MAX. IX BOUNDARY FOR RANGE REJECTION
"========================================================================
"========================================================================
"
"  PHOTON FORCING
"        = Off         (0)    NORMAL PHOTON TRANSPORT (NO FORCING)
"        = On          (1)    FORCE PHOTON INTERACTIONS EXPLICITLY
"                             MUST SET START AND STOP FORCING IN THIS CASE
"
"  START FORCING       (I)    NUMBER OF PHOTON INTERACTION/HISTORY AT WHICH
"                             TO START FORCING PHOTON INTERACTIONS
"
"  STOP FORCING AFTER  (I)    NUMBER OF PHOTON INTERACTION/HISTORY AFTER WHICH
"                             TO STOP FORCING PHOTON INTERACTIONS
"
"                             STOP FORCING AFTER > OR = START FORCING
"
"*******************************************************************************
;
"                             PLOT CONTROL INPUTS
"                             *******************
"*******************************************************************************
"
"  PLOT CONTROL DELIMETERS:   :start plot control:
"                             :stop plot control:
"
"   PLOTTING
"          = Off         (0)   NO PLOTS OR PLOT FILES TO BE PREPARED
"          = On          (1)   PLOTTING TO BE PREPARED OR PRINTED
"
"
"  ONLY IF   PLOTTING= On
"
"  EXTERNAL PLOT TYPE
"          = Point       (1)   POINT PLOT ON EXTERNAL PLOTTER
"          = Histogram   (2)   HISTOGRAM ON EXTERNAL PLOTTER
"          = Both        (3)   BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
"
"
"  DRAW FLUENCE PLOTS
"          = none       (1,0)  PLOT TOTAL FLUENCE (As a minimum)
"          = all        (1,1)  PLOT TOTAL AND PRIAMRIES
"          = primaries  (0,1)  PLOT PRIMARIES ONLY
"          = total      (1,0)  PLOT TOTAL FLUENCE (The minimum)
"
"
"  PLOTS FOR ELECTRONS
"          = Off         (0)   DON'T GENERATE PLOTS FOR ELECTRONS
"          = On          (1)   GENERATE PLOTS FOR ELECTRONS
"
"  PLOTS FOR PHOTONS
"          = Off         (0)   DON'T GENERATE PLOTS FOR PHOTONS
"          = On          (1)   GENERATE PLOTS FOR PHOTONS
"
"  PLOTS FOR POSITRONS
"          = Off         (0)   DON'T GENERATE PLOTS FOR POSITRONS
"          = On          (1)   GENERATE PLOTS FOR POSITRONS
"
"  PLOTS FOR E- AND E+
"          = Off         (0)   DON'T GENERATE PLOTS FOR E- AND E+
"          = On          (1)   GENERATE PLOTS FOR E- AND E+
"
"  START SPECTRAL PLOT IN REGION
"                      (M)  LOWER (STARTING) NUMBERS DEFINING THE REGIONS FOR
"                           WHICH SPECTRA ARE TO BE PRINTED IN .SPECTRA FILE.
"
"  STOP SPECTRAL PLOT IN REGION
"                      (M)  HIGHER (FINAL) NUMBERS DEFINING THE REGIONS FOR
"                           WHICH SPECTRA ARE TO BE PRINTED IN .SPECTRA FILE.
"
"   PLOT RADIAL REGION IX  (M)  RADIAL PLANE NUMBERS TO PLOT
"                               (= 0 FOR NO PLOTS)
"
"   PLOT PLANAR REGION IZ  (M)  PLANAR SLAB NUMBERS TO PLOT
"                               (= 0 FOR NO PLOTS)
"
"******************************************************************************"
;
"                          END OF INPUTS
"                          *************
"
"*******************************************************************************
"*******************************************************************************
;
"
"                       USER DEFINED MACROS
"                       *******************
"-----------------------------------------------------------------------------"
" need to redefine $PLTDIM to get high resolution

REPLACE{$PLTDIM} WITH {1000};  "Unique array dimension for XVGRPLOT and PLOTSN"
"above overrides 300 default in egsnrc.macros                                 "
"-----------------------------------------------------------------------------"

REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}

" Why do we need to put things into 1000 different places !!!!! "
" That sort of thing should be replaced in the machine dependent macro "
" file and NOT IN EVERY SINGLE USER CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!! "
" Whoever put the replacement below: use your brain before doing things "
" LONG_INT is already defined in egsnrc.macros. "
"REPLACE {$LONG_INT} WITH {INTEGER*8}""used for variables that store no. of"
"                                    ""histories to allow > 2.15x10^9 histories"
"                                    ""to be run.  If your compiler gives you"
"                                    ""problems with this, change to INTEGER*4"

REPLACE {$ONE-EPS} WITH {0.9999}"USED TO KEEP THE BEAM INSIDE THE TARGET"
REPLACE {$NSWTCH} WITH {7}      "# OF NRC SWITCHES FOR CONTROLLING SCATTERING"
REPLACE {$MXMED} WITH {6}       "#MEDIA"
REPLACE {$NBATCH} WITH {10}     "# OUTPUT BATCHES"
REPLACE {$NCASEMIN} WITH {10}  "min. no. of histories"
REPLACE {$MXSTACK} WITH {150}   "MAXIMUM STACK"
REPLACE {$MAXZREG} WITH {500}    "MAX # OF FLUENCE SCORING PLANAR ZONES
REPLACE {$MAXRADII} WITH {4}    "MAX # OF FLUENCE SCORING RADIAL ZONES"
REPLACE {$MAXRZ} WITH {$MAXZREG} "MAX($MAXZREG,$MAXRADII)"
REPLACE {$EBIN} WITH {$PLTDIM}  "# OF ENERGY BINS, reset $PLTDIM if needed"
REPLACE {$NENSRC} WITH {500}    "MAX # OF POINTS IN ENERGY DISTRIBUTION"
REPLACE {$MXRDIST} WITH {4}     "# OF POINTS IN RADIAL DISTRIBUTION FIT"
REPLACE {$MAXIT} WITH {2}       "MAX # OF FLUENCE COMPONENTS TO BE SCORED"
"                                 (1) TOTAL FLUENCE"
"                                 (2) PRIMARY or secondary FLUENCE"
REPLACE {$MAXZPLANE} WITH {{COMPUTE $MAXZREG+1}}
"                                MAX # OF PLANAR BOUNDARIES"
REPLACE {$MAXCMPTS} WITH {12}   "MAX # OF COMPONENTS IN SUBROUTINE GRID"
REPLACE {$MXREG} WITH {{COMPUTE $MAXRADII*($MAXZPLANE-1) +1}}
                                "# REGIONS=$MAXRADII*($MAXZPLANE-1)+1(VAC)"
REPLACE {$MXDATA} WITH {{COMPUTE $MAXIT*$EBIN*$MAXRADII*($MAXZPLANE-1) }}
"                                MAXIMUM DATA POINTS FOR ANALYSIS"
REPLACE {$MAXBRSPLIT} WITH {200} "MAX BREM SPLITTING NUMBER"
;
"below required to use phase space macros"
REPLACE {$MAX_SC_PLANES} WITH {1};

"The following is used to pass the parameters associated with bremsstrahlung
"splitting.  These are for use with the `old' system which was used with EGS4

REPLACE {;COMIN/BREMPR_addition/;} WITH {
   ;COMMON /BREMPR_addition/IBRSPL;
   $INTEGER IBRSPL;         "flag set to 1 if brem splitting used"
!   COMIN BREMPR_addition is defined in FLURZnrc.mortran;
}
;APPEND {;COMIN/BREMPR_addition/;} TO {;COMIN/BREMPR/;}

"The above is left in place since we will still use IBRSPL as a flag"
"for printing etc but it is no longer needed by subroutine BREMS where"
"the splitting is done using the varaible nbr_split which "
"replaces the old NBRSPL"

"This MACRO changes integers of three digits"
"or less into a character string."
"In each case, 48 must be added to the digit we are"
"converting into ASCII since '0' is ASCII # 48."
"Aaron Merovitz, Jan 1998"
REPLACE {$CONVERT_INT(#)_TO_CHAR(#);} WITH {
;
"{P1} is the integer value < 1000"
"{P2} is the character string returned"
      NEGVAL=.FALSE.;
      IF ({P1} < 0) [
         NEGVAL=.TRUE.;
         {P1} = ABS({P1});
      ]
      IF (({P1} = MOD({P1},1000)))[
            CHECK=1;
            IF ({P1} = MOD({P1},10)) [
                IF (NEGVAL) [{P2}='-'//CHAR({P1}+48);]
                ELSE [{P2}=CHAR({P1}+48);]
                CHECK=0;
            ]
            IF ((CHECK ~= 0) & ({P1} = MOD({P1},100))) [
                a(1)=CHAR(({P1}/10)+48);
                inte=(MOD({P1},10)+48);
                a(2)=CHAR(inte);
                IF (NEGVAL) [{P2}='-'//a(1)//a(2);]
                ELSE [{P2}=a(1)//a(2);]
                CHECK=0;
            ]
            IF (CHECK ~= 0) [
                a(1)=CHAR(({P1}/100)+48);
                inte=(MOD({P1},100)/10+48);
                a(2)=CHAR(inte);
                inte=MOD({P1},10)+48;
                a(3)=CHAR(inte);
                IF (NEGVAL) [{P2}='-'//a(1)//a(2)//a(3);]
                ELSE [{P2}=a(1)//a(2)//a(3);]
            ]
      ]
      ELSE [{P2}='3max';]
}

APPEND {;COMIN/GEOM/;} TO {$COMIN-ELECTR;}

;"MACRO USED FOR FORCING INTERACTIONS IN THE GEOMETRY"
"USED BY EGSnrc FOR VARIANCE REDUCTION"
"NOTE FORCING OPTION HAS NOW BEEN IMPLEMENTED WHICH GIVES BOTH"
"THE PRIMARY PHOTON FLUENCE AND THE ELECTRON FLUENCE CORRECTLY FOR A "
"PHOTON BEAM!                                                   CMa"
REPLACE {$SELECT-PHOTON-MFP;} WITH
"==========================="

{;$RANDOMSET RNNO35;IF(RNNO35 = 0.0) RNNO35=1.E-30;
IF(IFORCE = 0)["photon interaction forcing option not chosen"
    DPMFP=-LOG(RNNO35);
    ]
ELSE[
    IF(NP_INC(NP) = 0)[NFTIME=NFTIME+1;
        "a new photon. Check if it should be forced to interact. "
        IF((NFTIME > NFMAX) | (NFTIME < NFMIN))[
            "photon interaction forcing not quired in these cases"
            DPMFP=-LOG(RNNO35);
            ]
        ELSE["force this photon to interact in the cylinder"
            NP_INC(NP)=1; "flag, NOW doing photon interaction forcing   "
            NP=NP+1;"create a photon which carries the remaining weight."
            "Note that this newly created photon will be transported    "
            "first in this new photon interaction forcing scheme.       "
            U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);WT(NP)=WT(NP-1);
            E(NP)=E(NP-1);X(NP)=X(NP-1);Y(NP)=Y(NP-1);Z(NP)=Z(NP-1);
            IQ(NP)=IQ(NP-1);IR(NP)=IR(NP-1);LATCH(NP)=LATCH(NP-1);

"           IF(IFPB = 0 & NFTIME = 1 & MONOEN = 0 & NP = 2)[  "
            IF(MAFORC = 1)[
                "changed by CMa because all the checks don't work if we   "
                "have a parallel beams of electrons or positrons.         "
                "MAFORC=1 means that the particle is from the source. This"
                "removes the bug for e-, e+ parallel beams!!!!!!          "
                MAFORC=0; "do it only once for the source photon          "
                WT(NP)=1.-WT(NP-1);"WT(NP-1) calculated in the MAIN.      "
                "The photon on top carries the remaining weight.          "
                GOTO :FASTSTEP:;"IFPB IN COMIN USER-VARIANCE-REDUCTION    "
                ]
            DUMU=USTEP;
   "        DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);"
   "        commented out by CMa, no longer needed"
            IRODUM=IROLD;IRNDUM=IRNEW;
   "        IRDUM=IR(NP);"
            MEDDUM=MEDIUM;
            IDUM=IDISC;
            PATHL=0.0;MEDTMP=0;
            LOOP[
                USTEP=VACDST;IROLD=IR(NP);MEDIUM=MED(IROLD);
                IF(MEDIUM=0)["vacuum"
                    DELTAP=0.;
                ]
                ELSE[
                    IF(MEDTMP ~= MEDIUM)[
                       MEDTMP=MEDIUM;
                       $SET INTERVAL GLE,GE;
                       $EVALUATE DELTAP USING GMFP(GLE);
                    ]
                    IF(IRAYLR(IROLD) = 1)[
                       $EVALUATE COHFAC USING COHE(GLE);
                    ]
                    ELSE[COHFAC=1.0;
                    ]
                ]
                CALL HOWFAR;
                "only add to pathl if not a vacuum"
                IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
                IF(IRNEW = 1) EXIT;
                IR(NP)=IRNEW;
                X(NP)=X(NP)+USTEP*U(NP);
                Y(NP)=Y(NP)+USTEP*V(NP);
                Z(NP)=Z(NP)+USTEP*W(NP);
                ]
            U(NP)=U(NP-1);V(NP)=V(NP-1);W(NP)=W(NP-1);
            E(NP)=E(NP-1);X(NP)=X(NP-1);Y(NP)=Y(NP-1);Z(NP)=Z(NP-1);
            IQ(NP)=IQ(NP-1);IR(NP)=IR(NP-1);LATCH(NP)=LATCH(NP-1);
            "recover the position, etc. of this new photon"
"           X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;"
"           no longer needed"
            USTEP=DUMU;
            IROLD=IRODUM;IRNEW=IRNDUM;
"           IR(NP)=IRDUM;"
            MEDIUM=MEDDUM;
            IDISC=IDUM;
            "we now calculate the weighting factor for the photon that is"
            "forced to interact in the cylinder.                         "
            IF(PATHL.LE.1.0E-3)[GWAIT(NP-1)=PATHL*(1.-0.5*PATHL);]
            ELSE[GWAIT(NP-1)=1.-EXP(-PATHL);]
            GWTOLD=WT(NP-1);
            WT(NP-1)=GWTOLD*GWAIT(NP-1);
            "we now calculate the weighting factor for the photon that will"
            "carry the remaining weight.                                   "
            GWAIT(NP)=1.-GWAIT(NP-1);
            WT(NP)=GWTOLD*GWAIT(NP);

            :FASTSTEP:;
            "This photon cannot interact inside the cylinder but will go   "
            "through the cylinder so as to make the photon fluence right.  "
            DPMFP=1.0E30;"set the point of interaction at infinity.        "
            ]
        ] "end of NP_INC(NP) = 0 case"

    ELSE["NP_INC(NP)=1, now transport the photon that is forced to         "
        "interact in the cylinder"
        NP_INC(NP)=0; "re-set the flag"
        EPSLON=RNNO35*GWAIT(NP);
        IF(EPSLON.LE.1.0E-3)[
             DPMFP=EPSLON*(1.+0.5*EPSLON);
             ]
         ELSE[
             ARG=1./(1.-EPSLON);
             DPMFP=LOG(ARG);
             ]
        ] "end of NP_INC(NP) = 1 case"
    ]"end of IFORCE = 1 case"
}

";THIS MACRO SETS THE PARAMETERS FOR FORCING THE INITIAL INCIDENT PHOTON TO
"INTERACT IN THE GEOMETRY FOR THE FRONTAL PARALLEL BEAM CASE. IT IS MUCH
"FASTER THAN THE GENERALIZED CODING IN THE $SELECT-MEAN-FREE-PATHS MACRO

REPLACE {$SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-MONOENERGETIC-BEAM;} WITH
"       ==============================================================="
{;IF((IFPB = 0) & (IFORCE = 1))[
    GLE=LOG(EIN);
    DO IX=1,NR[
        PATHL=0.0;
        DO IZ=1,NZ[
            $GET-IRL(IZ,IX);MEDIUM=MED(IRL);
            IF(MEDIUM=0)["vacuum"
                DELTAP=0.;
            ]
            ELSE[
                $SET INTERVAL GLE,GE;
                $EVALUATE DELTAP USING GMFP(GLE);
                IF(IRAYLR(IRL) = 1)[
                   $EVALUATE COHFAC USING COHE(GLE);
                ]
                ELSE[
                   COHFAC=1.0;
                ]
            ]
            IF(DELTAP~=0)[ "only add to pathl if not a vacuum"
               DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP);
               PATHL=PATHL+DELTAP;
            ]
        ]
        IF(PATHL.LE.1.0E-3)[GWATE(IX)=PATHL*(1.-0.5*PATHL);]
        ELSE[GWATE(IX)=1.-EXP(-PATHL);]
    ]
  ]
}

;"macro that gets the geometrical zones from the geometry number"
REPLACE {$GET-IX-IZ(#);} WITH {;IX=({P1}-2)/NZ+1;IZ={P1}-1-NZ*(IX-1);}

;"macro that gets the geometry number from the planar and radial zones"
REPLACE {$GET-IRL(#,#);} WITH {;IRL={P1}+NZ*({P2}-1)+1;}

"BELOW SUPERSEDES COMPUTE-RANGE MACRO IN egsnrc.macros"

;
" **** RANGE REJECTION MACRO****"
"QUICK CALCULATION TO DISCARD ELECTRONS THAT WON'T REACH THE DOSE ZONE."
"THIS IS A ONE MEDIUM CALCULATION AT PRESENT."
"ONLY DO THIS FOR CHARGED PARTICLES NOT IN THE TRACKING REGION."
REPLACE {$USER-RANGE-DISCARD;} WITH {
;
IF((IREJCT > 0) & (MED(IRL) > 0) & (IQ(NP) ~= 0))[
    ZL=Z(NP);RL=SQRT(X(NP)**2+Y(NP)**2);IGEOM=NTRACK(IRL);
    CDIST = 0.0;  "Fixed bug for spectra in central region DR/CMA Jan 94"
                  "need to set CDIST when inside region of interest"
    IF(IGEOM = 10)[CDIST=ZMINR-ZL;]
    ELSEIF(IGEOM = 20)[CDIST=RL-RMAXR;]
    ELSEIF(IGEOM = 30)[CDIST=ZL-ZMAXR;]
    ELSEIF(IGEOM = 40)[CDIST=MIN(ZL-ZMINR,ZMAXR-ZL,RMINR-RL);]
    ELSEIF(IGEOM = 50)[CDIST=SQRT((RL-RMAXR)**2+(ZMINR-ZL)**2);]
    ELSEIF(IGEOM = 60)[CDIST=SQRT((RL-RMAXR)**2+(ZL-ZMAXR)**2);]
    ELSEIF(IGEOM = 70)[CDIST=SQRT((RL-RMINR)**2+(ZMINR-ZL)**2);]
    ELSEIF(IGEOM = 80)[CDIST=SQRT((RL-RMINR)**2+(ZL-ZMAXR)**2);]
    IF(CDIST >=RANGE) [IDISC=1;go to :USER-ELECTRON-DISCARD:;]
]
}


"******************************************************************************
;"THE FOLLOWING MACROS MAKE THE STATISTICAL ANALYSIS EASY. THEY ARE
"CODED IN GENERAL FASHION AND MAY BE USEFUL FOR OTHER USER CODES.

REPLACE {$SCORE(#,#:#)} WITH {;

"Scoring macro used in AUSGAB for SCSTP,SCFLU,SCFLEP"
"{P1}{P2}=scoring array (eg SCFLU(IB,IZ,IX,IQL,IT))"
"{P3}=quantity to be scored (eg BINFR(IB)*WTTVST)"

"If the (primary) history number, NHSTRY, is the same as the history"
"that last scored the quantity of interest in this voxel, {P1}_LAST{P2},"
"then {P3} is added to a temporary array, {P1}_TMP{P2}.  Otherwise, we add"
"{P1}_TMP{P2} to {P1}{P2}, {P1}_TMP{P2}*{P1}_TMP{P2} to {P1}2{P2},"
"set {P1}_TMP{P2}={P3}, and set {P1}_LAST{P2}=NHSTRY."

IF(NHSTRY={P1}_LAST{P2})[
  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
]
ELSE[
  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
  {P1}_TMP{P2}={P3};
  {P1}_LAST{P2}=NHSTRY;
]
;
}

REPLACE {$SCORET(#,#,#:#:#)} WITH {;

"Scoring macro used in AUSGAB for SCTFLU,SCEAVE,SCTLEP and SCELEP"
"{P1}{P3} and {P2}{P3}= scoring arrays of interest (eg SCTFLU(IZ,IX,IQL,IT)"
"                       and SCEAVE(IZ,IX,IQL,IT)"
"{P4}=quantity to be scored in {P1}{P3} (ie WTTVST)"
"{P5}=quantity to be scored in {P2}{P3} (ie WTEKIN)"

"If the (primary) history number, NHSTRY, is the same as the history"
"that last scored the quantities of interest in this voxel, {P1}_LAST{P3},"
"then {P4} is added to {P1}_TMP{P3} and {P5} is added to {P2}_TMP{P3}."
"Otherwise, we add {P1}_TMP{P3} to {P1}{P3}, {P1}_TMP{P3}^2 to"
"{P1}2{P3}, add {P2}_TMP{P3} to {P2}{P3}, {P2}_TMP{P3}^2"
"to {P2}2{P3}, and {P1}_TMP{P3}*{P2}_TMP{P3} to"
"{P2}_COV{P3}.  Then, we set {P1}_TMP{P3}={P4}, {P2}_TMP{P3}={P5}"
"and {P1}_LAST{P3}=NHSTRY."

IF(NHSTRY={P1}_LAST{P3})[
  {P1}_TMP{P3}={P1}_TMP{P3} + {P4};
  {P2}_TMP{P3}={P2}_TMP{P3} + {P5};
]
ELSE[
  {P1}{P3}={P1}{P3}+{P1}_TMP{P3};
  {P1}2{P3}={P1}2{P3} + {P1}_TMP{P3}*{P1}_TMP{P3};
  {P2}{P3}={P2}{P3}+{P2}_TMP{P3};
  {P2}2{P3}={P2}2{P3} + {P2}_TMP{P3}*{P2}_TMP{P3};
  {P2}_COV{P3}={P2}_COV{P3}+{P1}_TMP{P3}*{P2}_TMP{P3};
  {P1}_TMP{P3}={P4};
  {P2}_TMP{P3}={P5};
  {P1}_LAST{P3}=NHSTRY;
]
;
}

REPLACE {$ANALYZE(#,#:#)} WITH {;

"Macro to analyze uncertainty:"
"{P1}{P2}=scoring array (eg SCFLU(IB,IZ,IX,IQL,IT))"
"{P3}=quantity to normalize by (eg incident no. of particles)"

"Calculates the uncertainty on {P1}{P2}/{P3}.  The "
"uncertainty is stored in {P1}2{P2} and is expressed as a percentage of"
"{P1}{P2}/{P3} (max 99.9%).  Note that you must define the REAL*8 variable"
"SCORE_TEMP in any subroutine where this macro is used.  This macro"
"is only used in the analysis of no. of steps."

SCORE_TEMP={P1}{P2}/{P3};
{P1}2{P2}={P1}2{P2}/{P3};
{P1}2{P2}=({P1}2{P2}-SCORE_TEMP*SCORE_TEMP)/({P3}-1);
IF({P1}2{P2}>=0.) {P1}2{P2}= SQRT({P1}2{P2});
IF(SCORE_TEMP~=0.)[
    {P1}2{P2}=100*{P1}2{P2}/SCORE_TEMP;
    IF( {P1}2{P2} > 99.9 ) [ {P1}2{P2} = 99.9; ]
]
ELSE[
    {P1}2{P2}=99.9;
]
;
}

"******************************************************************************

"                       COMMON BLOCK DEFINITIONS
"                       ************************

"       ================"
"THE DATA ARRAY IS A GENERAL PURPOSE ARRAY TO TRANSPORT DATA BETWEEN"
"THE MAIN PROGRAM AND THE STATISTICS SUBROUTINE. ASSINGMENTS TO     "
"THE ARRAY ARE MADE IN THE $ANALYZE MACROS                          "

;"GEOMETRICAL INFORMATION
REPLACE {;COMIN/GEOM/;} WITH
"       =============="
{;COMMON/GEOM/ZPLANE($MAXZPLANE),RCYL(0:$MAXRADII),
CYRAD2($MAXRADII),NTRACK($MXREG),NZ,NR,NREG,NPLANE;
$REAL ZPLANE,RCYL,CYRAD2;
$INTEGER NTRACK,NZ,NR,NREG,NPLANE;}
"NTRACK(IRL)= integer array which indicates which boundary to do
"             range rejection against in region IRL
"ZPLANE(IZ)= Z coordinate of plane IZ
"RCYL(IX)= outer radius of cylinder IX
"CYRAD2(IX)= RCYL(IX)**2
"NZ= number of planar slabs
"NR= number of cylinders
"NREG= number of regions in geometry (=NZ*NR+1)
"NPLANE= number of planes in geometry (=NZ+1)

;"THREE COMMONS FOR INPUT AND OUTPUT"
REPLACE {;COMIN/IODAT1/;} WITH
"       ================="
{;
CHARACTER*1 TITLE(80);
COMMON/IODAT1/TITLE;
}
"
"TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES
"DATEN,TIMEN : MACHINE VARIABLES FOR TIME AND DATE

;
REPLACE {;COMIN/IODAT2/;} WITH {
"       ================"
   ;COMMON/IODAT2/ NCASE,NCASEO,NCASET,TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN,
   IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP($MXREG),IVAL,DATCOUNT;
$REAL TMCPUO,TIMMAX,EIN,ECUTIN,PCUTIN;
$INTEGER IRSTRT,IDAT,IQIN,NESTEP,NSMAX,IPRNTP,IPRTSP,IVAL,DATCOUNT;
$LONG_INT NCASE,NCASEO,NCASET;
}
"TMCPUO        CPU TIME USED IN PREVIOUS SESSIONS
"TIMMAX        MAXIMUM ALLOWED CPU HOURS FOR A GIVEN CALCULATION
"EIN           KINETIC ENERGY OF THE EXTERNAL BEAM
"ECUTIN        GLOBAL ECUT FOR THIS SIMULATION
"PCUTIN        GLOBAL PCUT FOR THIS SIMULATION
"IDAT          = 0 STORE DATA ARRAYS FOR RE-USE
"              = 1 DON'T STORE THEM
"NCASE         NUMBER OF HISTORIES REMAINING TO BE DONE
"NCASEO        NUMBER OF HISTORIES DONE IN PREVIOUS SESSIONS
"NCASET        NUMBER OF HISTORIES ALREADY DONE
"IRSTRT      = 0 => INITIAL RUN
"              = 1 => RESTARTED RUN
"              = 3 => DATA ANALYSIS ONLY
"              = 4 => READ RANDOM NUMBER SEEDS FROM UNIT 2
"              = 5 => PARALLEL POST-PROCESSING
"IQIN          CHARGE OF THE EXTERNAL BEAM
"NESTEP        NUMBER OF REGIONS TO ALTER ESTEPE
"NSMAX         NUMBER OF REGIONS TO ALTER SMAX
"IVAL          counter used with get_inputs
"IPRNTP        =0 => print fluence spectra for all particles
"              =1 => print condensed fluence spectra for photons
"              =2 => print fluence spectra only for specified regions
"              =3 => no fluence spectra output
"IPRTSP(IRL)   set to 0 to print fluence spectrum in region IRL, set to 1
"              to not print it
"DATCOUNT      no. of files used for parallel analysis (IRSTRT=5)
;
"PRINTER CONTROLS"
REPLACE {;COMIN/PRINTC/;} WITH {
;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
$INTEGER       ICHPIN,ILPIN,IOUT,IPAGE;
"Added type declaration, IK, Jan 5 2000"
}
"       =================
"ICHPIN  NUMBER OF CHARACTERS PER INCH
"ILPIN   NUMBER OF LINES PER INCH
"IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
"IPAGE   =1 => PAGE THROW
;

;"COMMON USED FOR PLOTTING"
REPLACE {;COMIN/PLOTC/;} WITH
"       ================"
{;COMMON/PLOTC/IPLOT($MXREG),IPLOTR($MAXRADII),IPLOTZ($MAXZPLANE),
IPLTIQ(4),IPLTTP(2),IPLT  ,IPLTPL,IPLPHB;
$INTEGER IPLOT,IPLOTR,IPLOTZ,IPLTIQ,IPLTTP,IPLT,IPLTPL,IPLPHB;}
"IPLOT(IRL) = 1 to plot fluence spectrum in region IRL
"IPLOTR(IX) = 0 NO PLOTS FOR CYLINDRICAL DOSE REGION IX
"           = 1 PLOTS FOR CYLINDRICAL DOSE REGION IX
"IPLOTZ(IX) = 0 NO PLOTS FOR PLANAR DOSE SLAB IZ
"           = 1 PLOTS FOR PLANAR DOSE SLAB IZ
"IPLTIQ(IQL) = 1 to plot for electrons (IQL=1), photons (IQL=2),
"              positrons (IQL=3) and/or charged particles (IQL=4)
"IPLTTP(1)  = 1 to plot total fluence plots
"IPLTTP(2)  = 1 to plot primary/secondary fluence plots
"IPLT       = 1 plotting files will be created
"           = 0 plotting files will not be created
"IPLPHB     = 1  POINT PLOT ON EXTERNAL PLOTTER
"           = 2  HISTOGRAM ON EXTERNAL PLOTTER
"           = 3  BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER


;"COMMON USED FOR SCORING IN AUSGAB
REPLACE {;COMIN/SCORE/;} WITH
"       ==============="
{;COMMON/SCORE/ SCFLU($EBIN,$MAXZPLANE,$MAXRADII,3,$MAXIT),
SCFLU2($EBIN,$MAXZPLANE,$MAXRADII,3,$MAXIT),
SCEAVE($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCEAVE2($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCEAVE_COV($MAXZPLANE,$MAXRADII,3,$MAXIT),SCSTP,SCSTP2,PIISTP,
SCELEP($MAXZPLANE,$MAXRADII,$MAXIT),
SCELEP2($MAXZPLANE,$MAXRADII,$MAXIT),
SCELEP_COV($MAXZPLANE,$MAXRADII,$MAXIT),
SCFLEP($EBIN,$MAXZPLANE,$MAXRADII,$MAXIT),
SCFLEP2($EBIN,$MAXZPLANE,$MAXRADII,$MAXIT),
SCTFLU($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCTFLU2($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCTLEP($MAXZPLANE,$MAXRADII,$MAXIT),
SCTLEP2($MAXZPLANE,$MAXRADII,$MAXIT),
SCSTP_LAST,SCFLU_LAST($EBIN,$MAXZPLANE,$MAXRADII,3,$MAXIT),
SCFLEP_LAST($EBIN,$MAXZPLANE,$MAXRADII,$MAXIT),
SCTFLU_LAST($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCTLEP_LAST($MAXZPLANE,$MAXRADII,$MAXIT),
IHSTRY,SCFLU_TMP($EBIN,$MAXZPLANE,$MAXRADII,3,$MAXIT),
SCEAVE_TMP($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCSTP_TMP,SCELEP_TMP($MAXZPLANE,$MAXRADII,$MAXIT),
SCFLEP_TMP($EBIN,$MAXZPLANE,$MAXRADII,$MAXIT),
SCTFLU_TMP($MAXZPLANE,$MAXRADII,3,$MAXIT),
SCTLEP_TMP($MAXZPLANE,$MAXRADII,$MAXIT),
BINTOP($EBIN),SLOTE,ECUTMX,PCUTMX,EBINW($EBIN,3),
VOLUME($MAXZREG,$MAXRADII),MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP;
REAL*8 SCFLU,SCFLU2,SCEAVE,SCEAVE2,SCEAVE_COV,SCSTP,SCSTP2,
       SCELEP,SCELEP2,SCELEP_COV,SCFLEP,SCFLEP2,SCTFLU,SCTFLU2,SCTLEP,
       SCTLEP2,PIISTP;
$LONG_INT SCSTP_LAST,SCFLU_LAST,SCFLEP_LAST,SCTFLU_LAST,SCTLEP_LAST,IHSTRY;
$REAL SCFLU_TMP,SCEAVE_TMP,SCSTP_TMP,SCELEP_TMP,SCFLEP_TMP,
      SCTFLU_TMP,SCTLEP_TMP,BINTOP,SLOTE,
      ECUTMX,PCUTMX,EBINW,VOLUME;
$INTEGER MXNP,IPRIM,ISTORE,MAXIB,IWATCH,IOUTSP;}
"SCFLU(IB,IZ,IX,IQL,IT) = stores fluence for particles of type IQL
"                      in energy bin IB and voxel IZ,IX.  IT=1 for primaries.
"                      IT=2 for secondaries.
"SCFLU2(IB,IZ,IX,IQL,IT) = stores fluence squared for particles of type IQL
"                      in bin IB and voxel IZ,IX.  Eventually holds
"                      uncertainty on SCFLU(IB,IZ,IX,IQL,IT).
"SCEAVE(IZ,IX,IQL,IT) = stores energy of particles IQL crossing voxel
"                     IZ,IX.  IT same as SCFLU.
"SCEAVE2(IZ,IX,IQL,IT) = stores energy squared of particles IQL crossing voxel
"                     IZ,IX.  Eventually holds uncertainty in
"                     SCEAVE(IZ,IX,IQL,IT)
"SCSTP               = no. of charged particle steps
"SCSTP2              = no. of charged particle steps squared.  Eventually holds
"                      uncertainty in SCSTP.
"SCELEP(IZ,IX,IT)    = stores energy of charged particles crossing voxel IZ,IX.
"                      IT same as above.
"SCELEP2(IZ,IX,IT)   = stores energy squared of charged particles crossing
"                      voxel IZ,IX.  Eventually stores uncertainty in SCELEP
"SCFLEP(IB,IZ,IX,IT) = stores fluence of charged particles in energy bin IB in
"                      voxel IZ,IX.  IT same as above.
"SCFLEP2(IB,IZ,IX,IT)= stores fluence squared of charged particles in energy
"                      bin IB in voxel IZ,IX.  Eventually stores uncertainty
"                      in SCFLEP
"SCTFLU(IZ,IX,IQL,IT)= stores total fluence of particle type IQL in voxel
"                      IZ,IX.  IT same as above.
"SCTFLU2(IZ,IX,IQL,IT)= stores total fluence squared of particle type IQL in
"                       voxel IZ,IX.  Eventually uncertainty in SCTFLU.
"SCTLEP(IZ,IX,IT)    = stores total fluence of charged particles crossing voxel
"                      IZ,IX.  IT same as above.
"SCTLEP2(IZ,IX,IT)   = stores total fluence squared of charged particles
"                      crossing voxel IZ,IX.  Eventually uncert. in SCTLEP
"SCEAVE_COV(IZ,IX,IQL,IT) = stores sum of SCEAVE_TMP(IZ,IX,IQL,IT)*
"                           SCTFLU_TMP(IZ,IX,IQL,IT) for calculating
"                           covariance in SCEAVE/SCTFLU
"SCELEP_COV(IZ,IX,IT) = stores sum of SCELEP_TMP(IZ,IX,IT)*
"                       SCTLEP_TMP(IZ,IX,IT) for covariance in
"                       SCELEP/SCTLEP
"PIISTP              = no. of PRESTA-II steps from previous runs
"SCSTP_LAST          = last primary history to score charged particle step
"SCFLU_LAST(IB,IZ,IX,IQL,IT) = last primary history to score fluence from
"                              particle of charge IQL in energy bin IB in
"                              voxel IZ,IX.  IT same as above.
"SCFLEP_LAST(IB,IZ,IX,IT)   = last prim. history to score charged particle
"                             fluence in voxel IZ,IX.  IT same as above.
"SCTFLU_LAST(IZ,IX,IQL,IT)  = last prim. history to score fluence/energy
"                             from particle of charge IQL in voxel IZ,IX.
"                             IT same as above
"SCTLEP_LAST(IZ,IX,IT) = last prim. history to score fluence/energy from a
"                        charged particle in voxel IZ,IX.  IT same as above
"SCFLU_TMP(IB,IZ,IX,IQL,IT) = temporary variable for SCFLU(IB,IZ,IX,IQL,IT)
"SCEAVE_TMP(IZ,IX,IQL,IT) = temporary variable for SCEAVE(IZ,IX,IQL,IT)
"SCSTP_TMP
"SCELEP_TMP(IZ,IX,IT)
"SCFLEP_TMP(IB,IZ,IX,IT)    more temporary variables
"SCTFLU_TMP(IZ,IX,IQL,IT)
"SCTLEP_TMP(IZ,IX,IT)
"BINTOP(IB) = max energy of bin IB
"SLOTE = 0.0 => read user input BINTOP values
"      > 0.0 => energy bin width
"      < 0.0 => use -SLOTE equal log bins up to maximum energy
"      = -999 => use $EBIN energy bins, all logarithmic except for those
"                covering the top 10% of the energy spectrum, which are
"               linear
"ECUTMX = max. value of ECUT(IRL)
"PCUTMX = max. value of PCUT(IRL)
"EBINW(IB,IQL) = kinetic energy bin width for particle IQL
"VOLUME(IZ,IX) = volume of region defined by IZ,IX
"MXNP = max. depth of stack
"IPRIM = 0 => score total fluence only
"      = 1 => score e- primaries separately + include bremsstrahlung photons
"             as primaries
"      = 2 => score e- primaries separately + include e- generated
"             by brem as secondaries
"      = 3 => score first generation photons including brems as
"             primaries, secondaries are all scatterd photons and
"             annihilation photons
"      = 4 => score e- secondaries separately
"ISTORE = 0 => do not store every initial random number
"       = 1 => store initial random number for last history
"       = 2 => store all initial random numbers
"IHSTRY = history counter
"MAXIB = index of max. energy bin
"IWATCH = 0 => normal output
"       = 1 => output at every interaction
"       = 2 => output at every step
"       = 3 => output only when energy is deposited
"       = 4 => prints out graphics file for EGS_Windows
"IOUTSP = 0 to not output a summary of incident energy spectrum
"       = 1 to output a summary of incident energy spectrum

;
"COMMONS USED FOR NON-MONOENERGETIC BEAM DATA                             "
"       NOTE MONOEN IS PASSED IN USER                                     "
"                                                                         "
REPLACE {$NENSRC} WITH {500}     "MAX # OF POINTS IN ENERGY DISTRIBUTION  "
"        =======                                                          "
REPLACE {$INVDIM} WITH {1000}    "DIMENSION CONTROLS GRID SIZE FOR INVERSE"
"        =======                                                          "
;
REPLACE {;COMIN/SPECTR/;} WITH
"       ================="
{;
COMMON/SPECTR/
CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
NENSRC;
$REAL CDFINV,ENSRCD,SRCPDF,SRCCDF;
$INTEGER NENSRC;
}
"CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
"SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
"SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
"NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION
;
REPLACE {;COMIN/USER/;} WITH
"       =============="
{;
;COMMON/USERVR/
CEXPTR,GWAIT($MXSTACK),DUMU,NP_INC($MXSTACK),MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,
ISOURC,IFPB,IQINC,MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP,
PATHL,DELTAP,GWTOLD,EPSLON,ARG;
$REAL CEXPTR,GWAIT,DUMU,PATHL,DELTAP,GWTOLD,EPSLON,ARG;
$INTEGER NP_INC,MAFORC,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,
         MONOEN,IRODUM,IRNDUM,MEDDUM,IDUM,MEDTMP;
"COMIN/USER-VARIANCE-REDUCTION"
"    CEXPTR       C VARIABLE FOR EXPONENTIAL PATHLENGTH TRANSFORMATION"
"    GWAIT($MXSTACK) WEIGHT ADJUSTMENT IN FORCING INTERACTIONS MACRO  "
"    NP_INC($MXSTACK) FLAG FOR DOING PHOTON INTERACTION FORCING       "
"    MAFORC       FLAG FOR FAST CALCULATIONS IN PHOTON FORCING        "
"    IFORCE       ONLY FORCE PHOTON INTERACTIONS IF THIS IS NON-ZERO  "
"    NFMIN,NFMAX,NFTIME  FOR FORCE PHOTON INTERACTIONS MACRO          "
"    ISOURC       IDENTIFIES SOURCE TYPE"
"    IFPB         FLAGS IF ISOURC = 0,2 OR 4                          "
"    IQINC        INCIDENT CHARGE                                     "
"    MONOEN = 0 IF MONOENERGETIC BEAM, = ELSE IF SOURCE DIST'N INPUT  "
"    DUMU  stores USTEP in photon forcing macro"
"    IRODUM stores IROLD in photon forcing macro"
"    IRNDUM stores IRNEW in photon forcing macro"
"    MEDDUM stores MEDIUM in photon forcing macro"
"    IDUM   stores IDISC in photon forcing macro"
"    MEDTMP stores MEDIUM in photon forcing macro"
"    PATHL = number of mean free paths through forcing volume"
"    DELTAP = incremental number of mean free paths"
"    GWTOLD stores particle weight in photon forcing macro"
"    EPSLON stores a probability in photon forcing macro"
"    ARG = 1./(1.-EPSLON) "

;
;
COMMON/USERRR/
CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,
EKETST,ELKETS,ZL,RL,CDIST,IGEOM,IRANGE,MINZ,MAXZ,MINR,MAXR,IREJCT;
$REAL CRANGE,ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN,EKETST,ELKETS,ZL,RL,CDIST;
$INTEGER MINZ,MAXZ,MINR,MAXR;
$INTEGER IREJCT,IRANGE,IGEOM;
"                                                                            "
"COMMON USED FOR RANGE REJECTION                                             "
"ERANGE        ENERGY BOUNDARY FOR TWO-PIECE RANGE FIT USED FOR RANGE DISCARD"
"Z/RMINR/MAX   PLANE/CYLINDER COORDINATES OF THE MIN/MAX PLANES/CYLINDERS    "
"              FOR RANGE REJECTION                                           "
"ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                        "
"MIN/MAX/Z/R   MIN/MAX PLANE/CYLINDER NUMBERS OF RANGE REJECTION REGION      "
"IREJCT        = 0 => NO ELECTRON RANGE REJECTION                            "
"              = 1 => DO ELECTRON RANGE REJECTION OUTSIDE CAVITY             "
"              = 2 => ON SECOND PASS, DO IT IN THE CAVITY AS WELL            "
"EKETST,ELKETS are not used"
"ZL,RL         store Z(NP), R(NP) of particle"
"CDIST         = distance to region boundary for range rejection "
"FOR THE REMAINING VARIABLES SEE DOCUMENTATION IN SUBROUTINE INPUTS          "
}
;

;"END OF MACRO DEFINITIONS

"                       DATA DECLARATIONS
"                       *****************

$IMPLICIT-NONE;
"
"***************************************************************************"
"*             Variables passed to the subroutine GET_INPUTS               *"
"***************************************************************************"

INTEGER MAKE_IT_AN_INT;
"***************************************************************************"
CHARACTER*80 TEXT;

$DECLARE_TIMING_VARIABLES;

$LONG_INT ITEMP,JCASE;

$INTEGER NETADJ,I,ITMAX,IB,
         IZ,IX,IQL,IT,NBATCH,IRL,J,LGLE,ISUMX,JJ,I1,I2,I3,I4,I5,
         IBATCH,IBTCH,NOSCAT,ICASE,IFLDIF,NDATA,
         IERR;
$REAL
ELEPIS($MAXZPLANE,$MAXRADII,$MAXIT,$STAT),
FLEPIS($EBIN,$MAXZPLANE,$MAXRADII,$MAXIT,$STAT),
TFLUIS($MAXZPLANE,$MAXRADII,3,$MAXIT,$STAT),
TLEPIS($MAXZPLANE,$MAXRADII,$MAXIT,$STAT),
GWATE($MAXRADII),FMSIS($STAT),FDIS($STAT),FNIS($STAT),
TIMEB,TIMCPU,ETIMETOT,EKMAX,DEPTH,
RLOW2,COHFAC,ECUTMN,EK0,BATCHT,RATIO,TEMP1,TEMP2,FNORM;

$REAL EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;
$INTEGER IRIN,NRCFLG;

CHARACTER*1 CONTINU;

;COMIN/
BOUNDS,BREMPR, EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,CH-Steps,
PRINTC,MEDIA, MISC,PHOTIN,PLOTC,RANDOM,SCORE,SOURCE,SPECTR,STACK,
THRESH,UPHIOT,USEFUL,USER,GetInput,EGS-VARIANCE-REDUCTION,RWPHSP,EGS-IO/;

"variables for writing to .egsdat file after completing a batch"
REAL*8 TSCSTP,TSCSTP2,TSCFLU,TSCFLU2,TSCEAVE,TSCEAVE2,TSCEAVE_COV,TSCTFLU,
       TSCTFLU2, TSCFLEP,TSCFLEP2,TSCELEP,TSCELEP2,TSCELEP_COV,TSCTLEP,
       TSCTLEP2;

"some variables for estimating uncertainty"
$REAL SCORE_NORM_NUM,SCORE_TEMP;

external combine_results;

" I/O units "
$INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit;

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.

$HAVE_C_COMPILER(#);

#ifdef HAVE_C_COMPILER;
$REAL   part_flu, part2_flu, current_result, current_uncertainty;
$LONG_INT n_run,n_tot,n_last;
$INTEGER  n_job;
$LOGICAL first_time;
#endif;

$LOGICAL is_finished;

"                       START OF EXECUTABLE CODE
"                       ************************

call egs_init;

IVAL = 0; "initialize pointer for get_inputs routine"
;
$SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"

OUTPUT $MAXRZ, $MAXZPLANE,$MAXRADII, $EBIN, $MXMED;
(/' FLURZnrc, $MAXRZ=',I3,' $MAXZPLANE=',I3,' $MAXRADII=',I3,
 ' $EBIN=',I4,'  $MXMED=',I3//);

"Check that the macro $MAXRZ has been properly assigned"
IF ($MAXRZ < MAX($MAXZREG,$MAXRADII)) [
   OUTPUT ;(//'   ***ERROR***');
   OUTPUT; ('The macro defining $MAXRZ must make it >=',
                                ' MAX($MAXZREG,$MAXRADII)'/
            ' It  does not do this so you must change and recompile'//);
   STOP
]

:START-THE-CASE:


"******************************************************************************
"
"                       *** SECTION 1 ***
"
"------------------------------------------------------------------------------
"
"READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
"
"------------------------------------------------------------------------------

"==================="
CALL INPUTS;
"==================="

IF(ERROR_FLAG=1) GO TO :END:; "CHECK FOR END-OF-FILE AND EXIT IF ENCOUNTERED


IOUT=1; "OUTPUT FORTRAN UNIT NUMBER"

IF(IPRIM = 0)[ITMAX=1;]ELSE[ITMAX=$MAXIT;] "# OF FLUENCE COMPONENTS"
             "MAXIT is 2 currently"

IF(ISTORE > 0)[ "store random number state to a file"
    rng_unit = egs_open_file(2,0,1,'.egsrns');
]
ELSEIF(IRSTRT.EQ.4)[ "RN'S READ FROM A FILE"
    rng_unit = egs_open_datfile(2,0,1,'.egsrns');
]

IF(IRSTRT=5)["post-processing for parallel run"

    call egs_combine_runs(combine_results,'.egsdat');

    NBATCH=0;      "DON'T WANT IT TO RUN ANY HISTORIES"
    NCASET=NCASEO; "To prevent a wrong normalization if some of the "
                   "parallel runs not available, IK, Jan 21 1999"
] "end of IRSTRT = 5, PARALLEL POST-PROCESSING"
ELSE [
    IF(NCASE/$NBATCH=0)[NCASE=$NBATCH;]
    JCASE=NCASE/$NBATCH; NCASE=JCASE*$NBATCH;"NUMBER OF HISTORIES PER BATCH
]


MXNP=0; "reset the maximum stack indicator"
IHSTRY=NCASEO; "reset the number of histories counter"

NPLANE=NZ+1; "NUMBER OF PLANAR BOUNDARIES"
IF(IQIN = 0)[EI=EIN;]ELSE[EI=EIN+RM;] "TOTAL ENERGY"

"GET RANGE REJECTION BOUNDARY COORDINATES USED BY HOWFAR"

ZMINR=ZPLANE(MINZ);ZMAXR=ZPLANE(MAXZ);RMAXR=RCYL(MAXR);
IF(MINR = 0)[RMINR=0.0;]ELSE[RMINR=RCYL(MINR);]

"SET THE GEOMETRY FLAGS FOR THE DIFFERENT REGIONS"
IF(IREJCT = 1)[
  DO IZ=1,NZ[
    DO IX=1,NR[
      $GET-IRL(IZ,IX);
        IF(IZ < MINZ)[ "FRONT FACE"
          IF(IX.LE.MINR)[NTRACK(IRL)=70;]
          ELSEIF(IX.LE.MAXR)[NTRACK(IRL)=10;]
          ELSE[NTRACK(IRL)=50;] "OUTER FRONT FACE"
        ]
        ELSEIF(IZ >=MAXZ)[ "BACK END"
          IF(IX.LE.MINR)[NTRACK(IRL)=80;]
          ELSEIF(IX.LE.MAXR)[NTRACK(IRL)=30;]
          ELSE[NTRACK(IRL)=60;] "OUTER BACK END"
        ]
        ELSE[ "MIDDLE REGION"
          IF(IX.LE.MINR)[NTRACK(IRL)=40;]
          ELSEIF(IX.LE.MAXR)[NTRACK(IRL)=0;] "IMPORTANCE REGION"
          ELSE[NTRACK(IRL)=20;]
        ]
    ]"end loop over IX"
  ]"end loop over IZ"
]"end IREJECT=1 block"
ELSE[DO IZ=1,NZ[DO IX=1,NR[$GET-IRL(IZ,IX);NTRACK(IRL)=0;]]]

"SET UP AUSGAB CALLS"
IAUSFL(1)=1;DO J=2,$MXAUS[IAUSFL(J)=0;] "NORMAL EXECUTION -only call prior"
"                                    to transport step"

"  IPRIMARY
"         = total fluence             (0) score total fluence spectra  only
"         = electron primaries        (1) score e+- primaries
"                                         separately as well include brem
"                                         generated e- as primaries
"                                         In photon beam, 1st generation e- are
"                                         primaries
"         = include brem secondaries  (2) score electron primaries but include
"                                         those generated by brem as
"                                         secondaries.  It should be
"                                         include brem as secondaries
"         = photon primaries          (3) primaries are all first generation
"                                         photons,including brem.
"                                         secondaries include all scattered
"                                         photons and annihilation photons.
"         = electron secondaries      (4) score electron secondaries.

IF(IPRIM=1 | IPRIM=2 | IPRIM=4)[ "need to distinguish e- primary vs secondary"
   IAUSFL(10)=1;   "call ausgab after Moller has occured"
   IAUSFL(12)=1;   "call ausgab after Bhabha has occured"
   "so can tag knock-ons created by Moller and Bhabha interactions"
   "following not needed, these are caught in ausgab after Moller/Bhabha"
   "/IAUSFL(26),IAUSFL(27),IAUSFL(28)/=1;" "call if relaxation particle created"
   "do we need a call after photoel event?"
   " -not when e- incident since any photon must be a brems or annih and     "
   "     thus already flagged as a secondary"
   "     above not exactly correct if eii on since fluorescent photons can be"
   "     created and then these can create e-.  But we are already flagging
   "     those photons as secondaries after eii so it works.
   "  For these IP values for incident photons, photoelectrons and other e- "
   "       are considered primaries so we don't need to flag after pe event "
   "       But fluorescent photons should be considered secondaries.
   "       However these options are for incident e- in general so we ignore
   "       this possibility
   "For e+ incident, annihilation photons are to be flagged as"
   "secondaries, not primaries. So need following for case of e+ in a"
   "phase space file or just an e+ source (IQIN is in comin IODAT2"
   IF(IQIN >= 1) [/IAUSFL(14),IAUSFL(15)/=1;"after e+ annih in flight & rest";]
]
IF(IPRIM = 2)[IAUSFL(8)=1; "after brems so can tag brem photons as secondaries"
   /IAUSFL(14),IAUSFL(15)/=1; "after e+ annihilation in flight or rest"
]
"should we be tagging annihilation photons with bremsstrahlung or in"
"next bit as a photon secondary?"
IF(IPRIM=3)["need to distinguish photon primaries from secondaries"
  /IAUSFL(17),IAUSFL(19),IAUSFL(21),IAUSFL(25) /=1;"tag all photon scatter"
  "17 after pair, 19 after compt, 21 after photo, 25 after Rayleigh"
]

write(6,'(/a)')
'************************ IAUSFL values ************************** ';
DO j=1,28 [
  IF( iausfl(j).ne.0 ) write(6,'(i3,$)') j;
]
write(6,'(/a//)')
'***************************************************************** ';

"HATCH CALL PREPARATION AND EXECUTION"
"===================================="

DUNIT=1; "set length units to cm"
" ******* IK: using wrapper subroutines for date and time.
" Was:
"CALL TIME(TIMEN);""A DEC SPECIFIC ROUTINE RETURNING THE TIME OF DAY"
"OUTPUT TIMEN;(/' CALL TO HATCH AT  ',$TIMEN_FORMAT);
"
"CALL HATCH;" "INPUT THE PEGS GENERATED DATA"
"
"CALL TIME(TIMEN);OUTPUT TIMEN;(/' HATCH COMPLETED AT ',$TIMEN_FORMAT);
OUTPUT; (/' CALL TO HATCH AT  ',$);
call egs_time(6); write(6,*);
CALL HATCH; "INPUT THE PEGS GENERATED DATA"
OUTPUT; (/' HATCH COMPLETED AT ',$);
call egs_time(6); write(6,*);

IF(MONOEN = 0 & ISOURC~=21 & ISOURC~=22 & ISOURC~=23)[
           "MONOENERGETIC INPUT BEAM"
    IF(IQIN = 0)[EI=EIN;]ELSE[EI=EIN+RM;]
    EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
]
ELSEIF (MONOEN = 1) [ "ENERGY SPECTRUM"
    CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
    EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
]
ELSEIF(ISOURC=21|ISOURC=22|ISOURC=23) ["FULL PHASE-SPACE INFORMATION PROVIDED"
    EKMAX=EKSRCM; "MAXIMUM KINETIC ENERGY IN THE FILE"
]


"CHECK THAT THE DATA FILE HAD DATA DOWN TO THE REQUESTED PARTICLE CUTOFFS"
DO I=1,NMED[
   IF((EKMAX > UP(I)) | (EKMAX > UE(I)-RM))[
      OUTPUT I,EKMAX,UP(I),UE(I);
      (//1X,50('*')//
      ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MEV'/
      ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MEV'//
      1X,50('*')//);
      GOTO :START-THE-CASE:; "TRY TO READ NEXT DATA SET"
   ]
]

"SET MAXIMUM ENERGY LOSS/ELECTRON STEP IF REQUESTED"
"   now done in PRESTA-INPUTS"

"CALCULATE THE VOLUME OR DEPTH FOR ISOURC=2,4,  OF EACH GEOMETRICAL ZONE"
DO IZ=1,NZ [DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ);
  DO IX=1,NR [
    IF(ISOURC = 2  |  ISOURC = 4)[VOLUME(IZ,IX)=DEPTH;]
    ELSE[
      IF(IX = 1)[RLOW2=0.0;]ELSE[RLOW2=CYRAD2(IX-1);]
      VOLUME(IZ,IX)=PI*DEPTH*(CYRAD2(IX)-RLOW2);
    ]
  ]
]

"GET ONE-TIME ONLY CONSTANTS THAT MAY VARY DEPENDING ON THE SOURCE"
CALL SRCOTO(WEIGHT);

IF(IFPB = 0 & IFORCE ~= 0 & IQIN = 0 & MONOEN = 0)[
  $SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-MONOENERGETIC-BEAM;
]


ECUTMN = 1.E10;
DO I=2,NREG [
  IF(MED(I)~= 0)[
    ECUTMN=MIN(ECUTMN,ECUT(I));
  ]
] "NEED MINIMUM ECUT FOR PRESTA"
EK0=EIN; "NOTE EIN IS SET AS MAXIMUM ENERGY FOR A SPECTRUM TOO"

$PRESTA-INPUTS;

"INITIALIZE DATA ARRAYS FOR FLUORESCENT X-RAYS IF NEEDED"
ISUMX=0;
DO JJ=1,NREG[ISUMX=ISUMX+IEDGFL(JJ); "NON-ZERO IF X-RAYS ANYWHERE"]
IF(ISUMX ~= 0) [CALL EDGSET(2,NREG);]
"NOTE THE ABOVE WILL PRODUCE LOTS OF EXTRA OUTPUT AND SHOULD BE"
"CLEANED UP"

CALL ISUMRY; "PRINT THE SUMMARY OF INPUTS"


"SET CLOCK AT THE BEGINNING OF SIMULATIONS"
$SET_ELAPSED_CPUTIME(CPUT1);
$INITIALIZE_ELAPSED_TOTAL_TIME;
ETIMETOT=0;
TIMEB=0;
NETADJ=0;


"******************************************************************************
"
"                       *** SECTION 2 ***
"
"------------------------------------------------------------------------------
"
"LOOP THROUGH THE NUMBER OF HISTORIES. CALCULATE CONSTANTS THAT MAY CHANGE FOR
"EACH HISTORY AND DO THE SIMULATION
"
"------------------------------------------------------------------------------

WRITE(IOUT,200); "PRINT HEADER FOR EXECUTION MESSAGES"

"PRINT EXECUTION MODE"
IF(IRSTRT = 0)[WRITE(6,201);WRITE(IOUT,201);]
ELSEIF(IRSTRT = 1)[
    WRITE(6,202) NCASE,NCASEO;
    write(6,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(6); write(6,*);
    WRITE(IOUT,202) NCASE,NCASEO;
    write(iout,'(21x,a,$)') 'New RNG state: ';
    $SHOW-RNG-STATE(iout); write(iout,*);
]
ELSEIF(IRSTRT = 3)[WRITE(6,204);WRITE(IOUT,204);GO TO :END-SIM:;]
ELSEIF(IRSTRT = 4)[WRITE(6,206);WRITE(IOUT,206);]
ELSEIF(IRSTRT = 5)[WRITE(6,205);WRITE(IOUT,205);GO TO :END-SIM:;]

"Open file for data storage, if requested "
"The file is opened in the temporary working directory"
IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');

IF(IWATCH ~= 0) CALL WATCH(-99,IWATCH);  "INITIALIZE WATCH ROUTINE"

DO I1=1,$MXSTACK[NP_INC(I1)=0;]
"INITIALIZE PHOTON INTERACTION FORCING FLAG  -- CMa"

"IK: New parallel processing implementation. Only used if there is a
"    working C compiler.
#ifdef HAVE_C_COMPILER;
;
n_tot = ncaseo; first_time = .true.; is_finished = .false.;
/part_flu,part2_flu/=0;
"I'm not sure what is a good quantity to put into the job control file =>"
"just use 0 for now"

:start_parallel_loop:;

IF( n_parallel > 0 ) [  "Job is part of a parallel run "

    call egs_pjob_control(ncase,n_run,n_left,n_tot,part_flu,part2_flu,
                          current_result, current_uncertainty);
    IF( n_run = 0 ) [
        write(6,'(//a,a//)') '****** No histories left in job control file',
                      '       => end simulation';
        goto :END-SIM:;
    ]
    jcase = n_run/$NBATCH;
    IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
    IF( first_time ) [
        first_time = .false.; n_last = n_run;
        write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
    ]
    ELSE [
        write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
        write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
  '      current result including previous runs and other parallel jobs: ',
         current_result, ' +/- ',current_uncertainty,' %',
  '      will run another ',n_run,' histories';
    ]
]
#endif;

"DIVIDE RUN INTO BATCHES. EXECUTION
"STOPS IF THERE IS NOT ENOUGH TIME TO DO ANOTHER BATCH.

DO IBATCH=1,$NBATCH[IBTCH=IBATCH;
  IF(IBATCH = 1)[
    OUTPUT;
  (' BATCH #',2X,'TIME-ELAPSED',2X,'TOTAL CPUTIME',2X,'RATIO',2X,' RNG STATE');
    OUTPUT; (' ',4X,'1',11X,'0.0',10X,'0.0',6X,'0.00',2X,$);
    $PRINT-RNG-STATE(6,'(i4,2i3,i2)');
    $FLUSH_UNIT(6);
  ]
  ELSE[
    $SET_ELAPSED_CPUTIME(CPUT2);
    $SET_ELAPSED_TOTAL_TIME(TIMEB);
    ETIMETOT=ETIMETOT+TIMEB;
    $SET_ELAPSED_CPUTIME(CPUT2);
    TIMCPU=CPUT2-CPUT1;
    " ******* IK: using wrapper subroutines for date and time.
    " Was:
    " CALL TIME(TIMEN);
    OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU;
    (' ',3X,I2,3X,F11.1,2X,F11.1,2X,F8.2,2X,$);
    $PRINT-RNG-STATE(6,'(i4,2i3,i2)');
    $FLUSH_UNIT(6);

    "CHECK THERE IS TIME LEFT FOR ANOTHER BATCH"
    BATCHT=TIMCPU/dble(IBATCH-1);"TIME PER BATCH SO FAR"
    IF(TIMCPU+1.1*BATCHT > TIMMAX*3600.)[
          "NOT ENOUGH TIME FOR ANOTHER BATCH"
          "PRINT MESSAGE AND EXIT SIMULATION LOOP"
          WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
          WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
          GO TO :END-SIM:;
    ]
  ]

  DO ICASE=1,JCASE[

    IF( ISOURC ~= 23 ) IHSTRY=IHSTRY+1; "increment history counter"
      " For source 23 ihstry is set in srchst "
    NFTIME=0; "reset the photon forced interaction counter"

    IF(IRSTRT=4) [
      $RETRIEVE RNG STATE FROM UNIT rng_unit;
    ]

    "store initial random #s for each history if requested"
    IF(ISTORE = 1)[
      "overwrite previous random numbers"
      $STORE RNG STATE ON UNIT rng_unit;
    ]
    ELSEIF(ISTORE.EQ.2)[
      "STORE THE INITIAL RANDOM NUMBER SEED"
      $PUT RNG STATE ON UNIT rng_unit;
    ]

    "calculate the history dependent constants that may change depending on
    "the source type
    CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);

    "calculate the initial energy if a distribution is to be used"
         IF(MONOEN ~= 0 & ISOURC ~= 21 & ISOURC~=22 & ISOURC~=23)[
            "if MONEN is equal to 0, it is monoenergetic"
            "if ISOURC=21,22 full phase space data will be used"
            CALL ENSRCH(EIN);  "returns k.e. from distribution;"
            IF(IQIN = 0)[EI=EIN;]
            ELSE[EI=EIN+RM;]  "total energy"
            "there was a check that the data file had data over the energy"
            "range required, its location will eventually be in ENSRC.MOR"
         ]
         ELSEIF(ISOURC = 21|ISOURC = 22|ISOURC = 23)[EI=EIN;]
    "IF ISOURC=21,22,23 TOTAL ENERGY IS RETURNED FROM ROUTINE SRCRZ. CMa"


         "SET PHOTON WEIGHT IF PHOTONS ARE TO BE FORCED TO INTERACT IN THE "
         "TARGET IN THE FRONTAL PARALLEL BEAM CASE"
         "IF(IFORCE = 1 & IFPB = 0 & MONOEN = 0)[ CHANGED BY CMa"
         "DUE TO A PROBLEM WITH E-, E+ PARALLEL BEAMS BECAUSE THE CHARGE OF"
         "THE PARTICLE WAS NOT CHECKED. WE NEED A FLAG TO DISTINGUISH THE"
         "SOURCE PHOTON (SEE BELOW).                                  CMa"
    ;
    IF(IFORCE = 1 & IFPB = 0 & MONOEN = 0 & IQIN = 0)[
      MAFORC=1;"flag for fast calculations in photon forcing   CMa"
      GWAIT(1)=GWATE((IRIN-2)/NZ+1);WEIGHT=GWAIT(1);
    ]
    ELSE[MAFORC=0;"set the flag to 0 so that we won't do it for e-,e+ beams"]
    " FOR INPUT ENERGY SPECTRUM, DETAILED FORCING MACRO IS USED"

    LATCHI =0;
    "    USED TO = NRCFLG  PASSED IN COMIN STACK"
    "    BUT NEED = 0 TO IMPLY A PRIMARY - NRCFLG NOT USED?"

    IF((IWATCH ~= 0) & (IWATCH ~= 4))[
      OUTPUT 1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,WEIGHT;
            (' INITIAL SHOWER VALUES',T36,':',I3,F9.3,2I4,3F8.3,
            3F7.3,I10,1PE10.3);
         ]"ALL INITIAL SHOWER VARIABLES ARE SET, CALL THE SHOWER ROUTINE"

    CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);

         IF(IWATCH > 0) CALL WATCH(-1,IWATCH);
         "TO SIGNAL THE END OF A HISTORY"
  ] "END ICASE LOOP"

"succesful completion of a batch. delete the raw data from the last batch"
"and record the new batch only if requested"
IF(IDAT = 0)[

    "overwrite any data already in the .egsdat file"
    rewind(data_unit);

    TSCSTP=SCSTP+SCSTP_TMP;
    TSCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
    WRITE(data_unit,*) TSCSTP,TSCSTP2;

    DO IX=1,NR[
       DO IZ=1,NZ[
          DO IT=1,ITMAX[
             DO IQL=1,3[
                DO IB=1,MAXIB[
                   TSCFLU=SCFLU(IB,IZ,IX,IQL,IT)+
                                           SCFLU_TMP(IB,IZ,IX,IQL,IT);
                   TSCFLU2=SCFLU2(IB,IZ,IX,IQL,IT)+
                                           SCFLU_TMP(IB,IZ,IX,IQL,IT)*
                                           SCFLU_TMP(IB,IZ,IX,IQL,IT);
                   WRITE(data_unit,*)TSCFLU,TSCFLU2;
                ]
                TSCEAVE=SCEAVE(IZ,IX,IQL,IT)+
                                     SCEAVE_TMP(IZ,IX,IQL,IT);
                TSCEAVE2=SCEAVE2(IZ,IX,IQL,IT)+
                                      SCEAVE_TMP(IZ,IX,IQL,IT)*
                                      SCEAVE_TMP(IZ,IX,IQL,IT);
                TSCEAVE_COV=SCEAVE_COV(IZ,IX,IQL,IT)+
                         SCEAVE_TMP(IZ,IX,IQL,IT)*SCTFLU_TMP(IZ,IX,IQL,IT);
                TSCTFLU=SCTFLU(IZ,IX,IQL,IT)+
                                     SCTFLU_TMP(IZ,IX,IQL,IT);
                TSCTFLU2=SCTFLU2(IZ,IX,IQL,IT)+
                                     SCTFLU_TMP(IZ,IX,IQL,IT)*
                                     SCTFLU_TMP(IZ,IX,IQL,IT);
                WRITE(data_unit,*)TSCEAVE,TSCEAVE2,TSCEAVE_COV,TSCTFLU,TSCTFLU2;
             ]
             DO IB=1,MAXIB[
                TSCFLEP=SCFLEP(IB,IZ,IX,IT)+
                                SCFLEP_TMP(IB,IZ,IX,IT);
                TSCFLEP2=SCFLEP2(IB,IZ,IX,IT)+
                                SCFLEP_TMP(IB,IZ,IX,IT)*
                                SCFLEP_TMP(IB,IZ,IX,IT);
                WRITE(data_unit,*)TSCFLEP,TSCFLEP2;
             ]
             TSCELEP=SCELEP(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT);
             TSCELEP2=SCELEP2(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)*
                                             SCELEP_TMP(IZ,IX,IT);
             TSCELEP_COV=SCELEP_COV(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)*
                                              SCTLEP_TMP(IZ,IX,IT);
             TSCTLEP=SCTLEP(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT);
             TSCTLEP2=SCTLEP2(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT)*
                                                  SCTLEP_TMP(IZ,IX,IT);
             WRITE(data_unit,*)TSCELEP,TSCELEP2,TSCELEP_COV,TSCTLEP,TSCTLEP2;
          ]
       ]
    ]
]"END OF CONDITIONAL DATA STORAGE"

$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=CPUT2-CPUT1+TMCPUO;
IF(IDAT = 0)[
    $PUT RNG STATE ON UNIT data_unit;
    WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD,PIISTP+count_pII_steps;
]

] "end of simulations"

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]

#endif;

:END-SIM:;

"add unscored portions of _TMP arrays"
SCSTP=SCSTP+SCSTP_TMP;
SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
DO IX=1,NR[
   DO IZ=1,NZ[
      DO IT=1,ITMAX[
         DO IQL=1,3[
            DO IB=1,MAXIB[
                   SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)+
                                           SCFLU_TMP(IB,IZ,IX,IQL,IT);
                   SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)+
                                           SCFLU_TMP(IB,IZ,IX,IQL,IT)*
                                           SCFLU_TMP(IB,IZ,IX,IQL,IT);
            ]
            SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)+
                                     SCEAVE_TMP(IZ,IX,IQL,IT);
            SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)+
                                      SCEAVE_TMP(IZ,IX,IQL,IT)*
                                      SCEAVE_TMP(IZ,IX,IQL,IT);
            SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)+
                                     SCEAVE_TMP(IZ,IX,IQL,IT)*
                                      SCTFLU_TMP(IZ,IX,IQL,IT);
            SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)+
                                     SCTFLU_TMP(IZ,IX,IQL,IT);
            SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)+
                                     SCTFLU_TMP(IZ,IX,IQL,IT)*
                                     SCTFLU_TMP(IZ,IX,IQL,IT);
         ]
         DO IB=1,MAXIB[
            SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)+
                                SCFLEP_TMP(IB,IZ,IX,IT);
            SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)+
                                SCFLEP_TMP(IB,IZ,IX,IT)*
                                SCFLEP_TMP(IB,IZ,IX,IT);
         ]
         SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT);
         SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)*
                                             SCELEP_TMP(IZ,IX,IT);
         SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)+SCELEP_TMP(IZ,IX,IT)*
                              SCTLEP_TMP(IZ,IX,IT);
         SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT);
         SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)+SCTLEP_TMP(IZ,IX,IT)*
                                             SCTLEP_TMP(IZ,IX,IT);
      ]
   ]
]

write(6,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(6); write(6,'(a)') '  *********';
write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
$SHOW-RNG-STATE(iout); write(iout,'(a)') '  *********';

$SET_ELAPSED_TOTAL_TIME(TIMEB);
ETIMETOT=ETIMETOT+TIMEB;
$SET_ELAPSED_CPUTIME(CPUT2);
TIMCPU=CPUT2-CPUT1+TMCPUO;
RATIO=ETIMETOT/TIMCPU;
IF(IRSTRT=3)["just analyzing data--no elapsed time"
  WRITE(IOUT,255)TMCPUO,TMCPUO/3600;
  WRITE(6,255)TMCPUO,TMCPUO/3600;
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSEIF(IRSTRT=5)["output time results for parallel runs"
  WRITE(IOUT,256)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(6,256)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
  WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
  WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
]
ELSE[
  IF(RATIO ~= 0.0)["i.e. we have correct elapsed time"
   WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
   WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
  ]
  ELSE[
   WRITE(IOUT,270) TIMCPU,TIMCPU/3600.;
   WRITE(6,270) TIMCPU,TIMCPU/3600.;
  ]
  IF(IHSTRY ~= 0  &  TIMCPU ~= 0.0)[
   "this should always happen"
   WRITE(IOUT,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
   WRITE(6,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
  ]
]

"******************************************************************************
"
"                       *** SECTION 3 ***
"
"------------------------------------------------------------------------------

"STATISTICAL AND OTHER DATA HANDLING AND CALL THE OUTPUT SUMMARY ROUTINE"

"------------------------------------------------------------------------------

:STATS-ANAL:;

"NORMALIZE THE TRACK-LENGTH TO FLUENCE/MEV/INCIDENT FLUENCE"
IF(ISOURC=21|ISOURC=22)[
"normalize to number of incident particles from primary source
   AINFLU=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
"we estimate the total number of particles from the primary source (original"
"non-phase space source) by taking the ratio of the total number of"
"particles read from the phase source in this simulation to the total number"
"of particles in the phase space source and multiply this by the number of"
"particles from the primary source that were used to obtain this phase space"
"source."
   SCORE_NORM_NUM=AINFLU;
]
ELSEIF(ISOURC=23)[
   AINFLU=dble(IHSTRY);
   SCORE_NORM_NUM=AINFLU;
]
ELSE[
   SCORE_NORM_NUM=dble(IHSTRY);
   "adjust AINFLU according to actual no. of histories run"
   AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);
]

"for ISOURC=4 we need the data for circles, not rings, so add it up"
IF(ISOURC = 4  &  NR > 1)[
  DO IX=2,NR[
           DO IZ=1,NZ[
              DO IT=1,ITMAX[
                 DO IQL=1,3[
                    DO IB=1,MAXIB[
                       SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)+
                                              SCFLU(IB,IZ,IX-1,IQL,IT);
                       SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)+
                                              SCFLU2(IB,IZ,IX-1,IQL,IT);
                    ]
                    SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)+
                                          SCEAVE(IZ,IX-1,IQL,IT);
                    SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)+
                                          SCEAVE2(IZ,IX-1,IQL,IT);
                    SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)+
                                             SCEAVE_COV(IZ,IX-1,IQL,IT);
                    SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)+
                                         SCTFLU(IZ,IX-1,IQL,IT);
                    SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)+
                                         SCTFLU2(IZ,IX-1,IQL,IT);
                 ]
                 DO IB=1,MAXIB[
                    SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)+
                                        SCFLEP(IB,IZ,IX-1,IT);
                    SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)+
                                        SCFLEP2(IB,IZ,IX-1,IT);
                 ]
                 SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)+SCELEP(IZ,IX-1,IT);
                 SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)+SCELEP2(IZ,IX-1,IT);
                 SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)+
                                      SCELEP_COV(IZ,IX-1,IT);
                 SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)+SCTLEP(IZ,IX-1,IT);
                 SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)+SCTLEP2(IZ,IX-1,IT);
              ]
           ]
  ]
]

"CALCULATE BIN WIDTHS"
"NEED MAXIMUM ECUT FOR FIRST BIN"
ECUTMX=0.0;  PCUTMX = 0.0; IFLDIF = 0;
DO I=1,NREG[
   IF(ECUT(I) ~= 0.0  &  ECUT(I) ~= ECUTMX  & ECUTMX ~=0.0)[IFLDIF=1;]
   "ABOVE IS TO CHECK IF WE HAVE USED DIFFERENT ECUTS IN REGIONS"
   ECUTMX = MAX (ECUT(I),ECUTMX);  PCUTMX = MAX (PCUT(I),PCUTMX);
]
IF(IFLDIF = 1)[
  OUTPUT;(/' *** NORMALIZATION PROBLEMS IN FIRST BIN(/MeV)',
  ' SINCE DIFFERENT ECUTS USED - HAVE USED MAXIMUM EVERYWHERE**'/);
  WRITE(IOUT,500)ECUTMX;
]

IF(SLOTE > 0.0)["EQUAL BIN WIDTHS"
   /EBINW(1,1),EBINW(1,3)/ = SLOTE - (ECUTMX-PRM);
   IF(EBINW(1,1) <= 0.0)[/EBINW(1,1),EBINW(1,3)/=1.E10;]
   "above in case large ECUT means electron bins don't exist"
   EBINW(1,2) = SLOTE - PCUTMX;
   IF(EBINW(1,2) <= 0.0)[EBINW(1,2)=1.E10;]  "changed Nov 1, 1994 DR"
   DO IB = 2,MAXIB[
      /EBINW(IB,1),EBINW(IB,2),EBINW(IB,3)/=SLOTE;
   ]
]

ELSE ["SLOTE=0.0 and SLOTE<0 CASE"
   /EBINW(1,1),EBINW(1,3)/ = BINTOP(1) - (ECUTMX-PRM);
   EBINW(1,2) = BINTOP(1) - PCUTMX;
   DO IB = 2,MAXIB[DO IQL=1,3[
      EBINW(IB,IQL) = BINTOP(IB)-BINTOP(IB-1) ;
      IF(EBINW(IB,IQL) <= 0.0)[EBINW(IB,IQL)=1.E10;]
]]]

"STATISTICAL ANALYSES ON THE RAW DATA and do normalizations"
$ANALYZE(SCSTP, :SCORE_NORM_NUM);
DO IX=1,NR[
   DO IZ=1,NZ[
      DO IT=1,ITMAX[
         DO IQL=1,3[
            DO IB=1,MAXIB[
                   $ANALYZE(SCFLU,(IB,IZ,IX,IQL,IT):SCORE_NORM_NUM);
                   SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)/
                                       (AINFLU*VOLUME(IZ,IX)*EBINW(IB,IQL));
            ]
            $ANALYZE(SCTFLU,(IZ,IX,IQL,IT):SCORE_NORM_NUM);
            $ANALYZE(SCEAVE,(IZ,IX,IQL,IT):SCORE_NORM_NUM);
            "now, calculate uncertainty on SCEAVE/SCTFLU"
            SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)/SCORE_NORM_NUM-
                                 SCTFLU(IZ,IX,IQL,IT)*SCEAVE(IZ,IX,IQL,IT)/
                                  (SCORE_NORM_NUM**2);
            SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)/
                                 (SCTFLU(IZ,IX,IQL,IT)*SCEAVE(IZ,IX,IQL,IT)/
                                  (SCORE_NORM_NUM**2)*(SCORE_NORM_NUM-1));
            SCEAVE2(IZ,IX,IQL,IT)=(SCEAVE2(IZ,IX,IQL,IT)/100.)**2+
                                  (SCTFLU2(IZ,IX,IQL,IT)/100.)**2-
                                  2*SCEAVE_COV(IZ,IX,IQL,IT);
            IF(SCEAVE2(IZ,IX,IQL,IT)>0.)SCEAVE2(IZ,IX,IQL,IT)=
                                         SQRT(SCEAVE2(IZ,IX,IQL,IT))*100;
            IF(SCEAVE2(IZ,IX,IQL,IT)>99.9) SCEAVE2(IZ,IX,IQL,IT)=99.9;
            IF(SCTFLU(IZ,IX,IQL,IT)~=0.)[
                 SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)/
                                      SCTFLU(IZ,IX,IQL,IT);
            ]
            SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)/(AINFLU*VOLUME(IZ,IX));
         ]
         DO IB=1,MAXIB[
            $ANALYZE(SCFLEP,(IB,IZ,IX,IT):SCORE_NORM_NUM);
            SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)/
                                (AINFLU*VOLUME(IZ,IX)*EBINW(IB,1));
         ]
         $ANALYZE(SCELEP,(IZ,IX,IT):SCORE_NORM_NUM);
         $ANALYZE(SCTLEP,(IZ,IX,IT):SCORE_NORM_NUM);
         "now, calculate uncertainty on SCELEP/SCTLEP"
         SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)/SCORE_NORM_NUM-
                              SCELEP(IZ,IX,IT)*SCTLEP(IZ,IX,IT)/
                              (SCORE_NORM_NUM**2);
         SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)/
                              (SCELEP(IZ,IX,IT)*SCTLEP(IZ,IX,IT)/
                               (SCORE_NORM_NUM**2)*(SCORE_NORM_NUM-1));
         SCELEP2(IZ,IX,IT)=(SCELEP2(IZ,IX,IT)/100.)**2+
                           (SCTLEP2(IZ,IX,IT)/100.)**2-
                            2*SCELEP_COV(IZ,IX,IT);
         IF(SCELEP2(IZ,IX,IT)>0.)SCELEP2(IZ,IX,IT)=SQRT(SCELEP2(IZ,IX,IT))*100;
         IF(SCELEP2(IZ,IX,IT)>99.9) SCELEP2(IZ,IX,IT)=99.9;
         IF(SCTLEP(IZ,IX,IT)~=0.)[
                SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)/SCTLEP(IZ,IX,IT);
         ]
         SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)/(AINFLU*VOLUME(IZ,IX));
      ]
   ]
]

CALL OSUMRY; "PRINT THE OUTPUT SUMRY"

:END-OF-RUN:;

"******************************************************************************
"
"                       *** SECTION 4 ***
"
"------------------------------------------------------------------------------
"
"THE CONCLUSION"
"
"------------------------------------------------------------------------------

:END:;
" ******* IK: using wrapper subroutines for date and time.
" Was:
"CALL DATE(DATEN);CALL TIME(TIMEN);
"OUTPUT DATEN,TIMEN;(/' END OF FILE READ',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//);
"OUTPUT DATEN,TIMEN;(/' END OF RUN',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT//);
OUTPUT; (/' END OF RUN',9X,' ',$); call egs_fdate(6); write(6,'(//)');

IF (ERROR_FLAG=1) [
   OUTPUT ;(//' **********  ERRORS AND WARNING MESSAGES  ********** '//);
]

rewind (i_errors);
9998 CONTINUE;
     READ (i_errors, END=9999, FMT='(A80)') TEXT;
     WRITE (*,'(A79)') TEXT;
     GOTO 9998;
9999 CONTINUE;
backspace(i_errors);
" ******* IK: using wrapper subroutines for date and time.
" Was:
" WRITE(15 , 400) DATEN,TIMEN;
" WRITE(IOUT,400) DATEN,TIMEN;
write(i_errors,400); call egs_fdate(i_errors); write(i_errors,*);
write(iout,400);     call egs_fdate(iout);     write(iout,*);

call egs_finish;

#ifdef HAVE_C_COMPILER;
;
IF( n_parallel > 0 & ~is_finished ) [
    call egs_pjob_finish(n_job);
    IF( n_job = 0 ) [
        is_finished = .true.;
        call egs_combine_runs(combine_results,'.egsdat');
        NCASET=NCASEO;  IHSTRY=NCASET;
        CALL SRCOTO(WEIGHT);
        goto :STATS-ANAL:;
    ]
]
#endif;

call SRCEND;

$CALL_EXIT(0);

200   FORMAT(' ',79('*')//
           T20,'EXECUTION INFORMATION AND WARNING MESSAGES'//
           1x,79('*')//' Using FLURZnrc(EGSnrc) '$VERSION' ') ;

" ******* IK: using wrapper subroutines for date and time.
" Was: 400   FORMAT(/' End of run',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT/);
400   FORMAT(/' End of run',10X,$);

"FORTRAN format statements. format statement N## is first used in section N."
%F
%I0
201   FORMAT(/' ********* NEW INPUT FILE *********'/)
202   FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
     1' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
     2' ',20X,'NEW RN SEEDS=',$)
204   FORMAT(/' ********* DATA ANALYSIS ONLY *********'/)
205   FORMAT(/' ********* POST-PROCESSING PARALLEL RUNS **********'/)
206   FORMAT(/'********* RANDOM NUMBERS READ FROM UNIT 2 *********'/)
210   FORMAT(/' ********* NOT ENOUGH TIME to finish within',
     1' limit of',F8.2,' hours',I5,' batches used********',/10X,
     2' ',I12,' Histories run, ',I12,' Histories analyzed'//)
220   FORMAT(I12,' ',I12)
250   FORMAT(/' ********* FINAL RANDOM NUMBER SEED: ',2I12,' *********')
255   FORMAT(/' FOR OLD RUN:'/
     1' ----------- '/
     2' TOTAL CPUTIME =',F8.1,'s (=',F5.2,' hr)')
256   FORMAT(/' FOR PARALLEL RUNS:'/
     1' ----------------- '/
     2' ON ',I5,' MACHINES '/
     3' TOTAL CPUTIME =',F8.1,'s (=',F8.2,' hr), CPUTIME/MACHINE =',
     4F8.1,'s')
260   FORMAT(/'FINISHED:  TIME ELAPSED, CPUTIME',
     1',RATIO= ',2F8.1,'(=',F5.2,'hr)',F8.2)
270   FORMAT(/' FINISHED SIMULATIONS: CPUTIME=',F8.1,'(=',F5.2,' hr)')
280   FORMAT(/' CPUTIME / history =',F10.5,' sec.          # histories',
     1' / hour =',F12.0/)
500   FORMAT(//' NORMALIZATION PROBLEMS IN FIRST BIN(/MeV) SINCE',
     X' DIFFERENT ECUTS ARE USED IN DIFFERENT REGIONS '/
     X'   MAXIMUM ECUT=',F10.3,' USED EVERYWHERE***'//)
%M
%I4

END; "end of main routine-FLURZnrc"
%C80
%I4
%Q1
%E    "start of AUSGAB"
"******************************************************************************
"
"
"                               **********
"                               *        *
"                               * AUSGAB *
"                               *        *
"                               **********
"
"
"
"               VERSION 01      83/7/26         A.F.B.
"                             85/3/27         D.W.O.R.  CORRECT IPRIM=1,ADD 2
"                             85/11/22        D.W.O.R.  CORRECTED IPRIM=2
"               VERSION 02    90/2/18         D.W.O.R.  DISTRIBUTED PATH-LENGTH
"                                                       OVER ENERGY BINS
"               VERSION 3     90/7/6          DWOR      IPRIM=3 option
"               VERSION 4     90/10/09        DWOR      IPRIM = 4 option
"               VERSION 5     91/10/21        DWOR      fixed IPRIM=3 to work
"                                                           with fluorescence
"               VERSION 6     94/12/8                   fixed IPRIM=3 to work
"                                                           with Rayleigh
"                             12/11/15        DWOR      fixed so primary
"                                                       scoring worked better
"                                                       with eii/relaxation
"
"******************************************************************************

SUBROUTINE AUSGAB(IARG);

$IMPLICIT-NONE;

;COMIN/BOUNDS,BREMPR,EPCONT,GEOM,SCORE,STACK,USEFUL,RANDOM,
EGS-VARIANCE-REDUCTION,SOURCE/;

$INTEGER IARG,IQL,IRL,IB,IBTOP,NBIN,IBDOWN,IBB,I,IX,IZ;

$REAL BINFR($EBIN), "fraction of pathlength in each bin"
      WEIGHT,WTTVST,EKEMID,EKIN,WTEKIN,FRSUM,BINBOT;

MXNP=MAX(MXNP,NP);"keep track of how deep stack is"
                  "MXNP not printed, it should be"

IQL=IQ(NP); "local variable"

"  IPRIMARY
"         = total fluence             (0) score total fluence spectra  only
"         = electron primaries        (1) score e+- primaries
"                                         separately as well include brem
"                                         generated e- as primaries
"                                         In photon beam, 1st generation e- are
"                                         primaries
"         = include brem secondaries  (2) score electron primaries but include
"                                         those generated by brem as
"                                         secondaries.  It should be
"                                         include brem as secondaries
"         = photon primaries          (3) primaries are all first generation
"                                         photons,including brem.
"                                         secondaries include all scattered
"                                         photons and annihilation photons.
"         = electron secondaries      (4) score electron secondaries.

IF(IPRIM=1 | IPRIM=2 | IPRIM=4) ["If scoring prim/sec e fluence as well"
    IF(IARG = 7)["a brem has occured - only called if IPRIM=2"
      "flag photons as secondary so any e- will be too since IPRIM=2"
      "this means any e- created by these brems photons are secondaries"
      DO I=NPold+1,NP["need loop in case we used brem splitting"
        LATCH(I)=1;
      ]
      "Note that if we have photons incident, brems will still be  "
      " secondary since e-/e+ are "
    ]
    ELSEIF(IARG = 9)["a Moller occured, flag the lower energy E as secondary"
       "when moller routine is called, an electron impact ionization followed"
       "by a relaxation may occur. If it only leaves energy below threshold"
       "it is possible that we are left with the primary electron only, in "
       "which case NP=NPold"
       "At the other extreme, on can have a series of fluorescent photons "
       "and Koster/Kronig or Auger e- from NPold to NP. We need to flag"
       "all of them as secondaries"
       IF(NP = NPold) ["no Moller or eii above threshold occured"
          "so we don't set LATCH"
          continue;
       ]
       ELSE [
          DO I = NPold+1,NP ["Flag all particles except the primary which"
              "is at NPold, as secondaries"
              LATCH(I)=1;
         ]
       ]
    ] "end of block from call after Moller"

    ELSEIF(IARG = 11) ["a Bhabha occured, need to flag e- as secondary"
       "this assumes there is no eii for e+"
       IF(IQ(NP) = -1) [LATCH(NP)=1;]
       ELSE [LATCH(NP-1)=1;]
   ]  "end of after Bhabha block"

   ELSEIF(IARG = 13 | IARG = 14) ["after annihilation at rest or flight"
      DO I=NPold,NP [LATCH(I) = 1;]  "need loop for splitting case"
   ]
] "end of setting flags for IPRIM=1,2,4"

ELSEIF(IPRIM=3)["flag scattered photons as secondaries"
    IF(IARG=16)["pair production"
      "FLAG as secondaries in case of annihilation photons"
      "i.e. as long as not e+ incident, then annihilation photons"
      "are treatd as secondaries since the e+ is"
      IF(NP>NPold | (NP=NPold & i_survived_rr > 0))["at least one e- or e+"
         DO I=NPold,NP [LATCH(I)=1; ]
      ]
    ]
    ELSEIF(IARG=18)["A compton occurred"
      IF(NP>NPold | (NP=NPold & i_survived_rr > 0))[
         DO I=NPold,NP[ "flag compton e- and photon and any particles"
           LATCH(I)=1;  "from relaxation events"
         ]
      ]
    ]
    ELSEIF(IARG=20)[" A photoelectric event has occured"
      IF(NP >= NPold & (IQ(NPold)=-1 | i_survived_rr > 0))[
         "the photoelectric event occurred and we will flag"
         "the photoelectron--if it has not been eliminated through"
         "russian roulette--and any particles from relaxation events"
         DO I = NPold,NP[ "flag compton e- and photon and any particles"
           LATCH(I)=1;  "from relaxation events"
         ]
       ]
    ]
    ELSEIF(IARG=24)["a Rayleigh scattering just occured"
       LATCH(NP)=1;  "there is only the photon"
    ]
]"end of IPRIM=3"

"end of flag setting via latch"

IF(IWATCH > 0) CALL WATCH(IARG,IWATCH);

IRL=IR(NP); "local region number"
IF(IRL = 1) RETURN; "outside the geometry"

$GET-IX-IZ(IRL);

"score the total curved pathlength in the volume"

IF(IARG = 0)["transport step about to happen"
   IQL=IQL+2; "1 for e-, 2 for photons, 3 for e+"
   WEIGHT=WT(NP);
   WTTVST=WEIGHT*TVSTEP; "total curved pathlength times weight"

   "weight times kinetic energy averaging for charged particles"
   IF(IQL ~= 2)[EKIN=E(NP)-RM; EKEMID=EKIN - 0.5*EDEP;  "average step energy"
               "changed from using EKE since EKE not set in vacuum"
       "now, score step"
       $SCORE(SCSTP, :1);    "counting number of charged particle steps"
   ]
   ELSE [EKIN=E(NP);"for photons" EKEMID=EKIN;]

   WTEKIN=WTTVST*EKEMID;

   "Find the energy bin the particle's initial energy belongs to"

   IF(SLOTE > 0.0)["equal bin case"
        IB=MIN0(int(EKIN/SLOTE+0.999),MAXIB); "0.999 since FORTRAN truncates"
        IF((IB >=1) | (IB <= MAXIB)) GO TO :FOUND-IB:;
   ]
   ELSE[ "search for top of the bin -recall bins go from lowest to highest"
       DO IB=1,MAXIB [ IF(EKIN <= BINTOP(IB)) GO TO :FOUND-IB:;]
       "we get here if it doesnt find it"
       IF(EKIN-BINTOP(MAXIB) < 1.E-5*BINTOP(MAXIB))[
          "roundoff problems - ignore it"
          IB=MAXIB;GO TO :FOUND-IB:;
       ]
   ]
   "falls through to here if not found"
   OUTPUT IB,EKIN,BINTOP(MAXIB),SLOTE;
   (/' ********* IB out of range, IB=',I12,'*********'/'  EKIN=',F15.6,
    '     BINTOP(MAXIB)=',F15.6,'    SLOTE=',F10.5//);
    STOP;

   :FOUND-IB:;
   IBTOP = IB;   "this is top of bin which initial energy is in"

   "assume that even for SLOTE>0, BINTOP array is filled"

   "now assign fractions of pathlength to various energy bins crossed"
   "during each step  -  for photons this is trivial"
   "NBIN is the number of bins crossed, BINFR(I) is fraction of pathlength"
   "to be assigned to I-th bin, starting from bin initial energy is in"

   IF(EDEP = 0.0)["photon or e in vacuum case" NBIN = 1; BINFR(1) = 1.0;]
   ELSE [
     "e- and e+ case   find what energy bins spread over"
     FRSUM=0.0; "sum of bin fractions so far"
     DO IB = 1,IBTOP[
        "IB is the region in which energy is deposited, counting down, starting"
        "from bin IBTOP for IB =1 to bin 1 for IB = IBTOP                      "
        "IBDOWN is the actual bin being considered, IBTOP to 1                 "
        IBDOWN = IBTOP - IB +1;

        IF(IBDOWN=1)[
          BINBOT=ECUT(IRL)-PRM;
        ] ELSE[BINBOT=BINTOP(IBDOWN-1);]

        IF(IB=1)["bin with initial energy" BINFR(IB)=(EKIN-BINBOT)/EDEP;]
        ELSE [ BINFR(IB) = (BINTOP(IBDOWN) - BINBOT)/EDEP;]
        "above lines allocate fraction of pathlength in this bin in         "
        "proportion to fraction of energy deposited in this bin             "
        "i.e. assumes stopping power isn't changing dramatically            "
        "    note that BINFR may be too large if the final energy is in this"
        "    bin, but it will be reduced to the correct value below         "

        IF( (BINFR(IB) >= 1.0 - FRSUM)  |  IBDOWN=1 |
            (BINBOT<=ECUT(IRL)-PRM) )[
           "this must be the last bin - "
           "first condition is true if the final energy in the  "
           "step is greater than BINBOT, second condition means there"
           "are no more bins, last condition is true if all other bins"
           "have BINTOP < cutoff kinetic energy"
           "in first and last cases, we must correct BINFR            "

           "final energy or transport cut-off is in this bin"
           IF( (BINFR(IB) >= 1.0-FRSUM) |
               (BINBOT    <= ECUT(IRL)-PRM ) )[
                BINBOT = max(ECUT(IRL)-PRM,EKIN-EDEP);
                IF (IB>1)[
                   BINFR(IB) =(BINTOP(IBDOWN) - BINBOT)/EDEP;
                ]
                ELSE [
                   BINFR(IB) =(EKIN - BINBOT)/EDEP;
                ]
           ]
           NBIN = IB;
           GO TO :FINISHED_FINDING_BIN_FRACTIONS:;
        ]
        ELSE ["not finished yet" FRSUM = FRSUM + BINFR(IB);]

     ]"end of IB loop"
     :FINISHED_FINDING_BIN_FRACTIONS:
   ]"end of non-photon block else"

   IF(IWATCH=2)[OUTPUT NBIN,((IBTOP-IBB+1),BINTOP(IBTOP-IBB+1),BINFR(IBB),
             IBB=1,NBIN);(' AUSGAB: pathlength spread over', I3,' bins'/
             (' BINTOP(',I3,')=',F12.3,'  BINFR=',F8.4) );]

   FRSUM=0.;
   DO IB = 1,NBIN[
      IBDOWN= IBTOP - IB + 1;
      "score pathlength for all cases first   i.e. total fluence"
      $SCORE(SCFLU,(IBDOWN,IZ,IX,IQL,1):BINFR(IB)*WTTVST);
      IF(IQL~=2)[
          "add it to fluence of all charged particles"
          $SCORE(SCFLEP,(IBDOWN,IZ,IX,1):BINFR(IB)*WTTVST);
      ]
      IF( (IPRIM=1|IPRIM=2|IPRIM=3) & (LATCH(NP)=0))[
         "score primaries only"
         $SCORE(SCFLU,(IBDOWN,IZ,IX,IQL,2):BINFR(IB)*WTTVST);
         IF(IQL~=2)[
          $SCORE(SCFLEP,(IBDOWN,IZ,IX,2):BINFR(IB)*WTTVST);
         ]
      ]
      IF(IPRIM = 4  &  LATCH(NP) ~= 0)[
         "score secondaries only"
         $SCORE(SCFLU,(IBDOWN,IZ,IX,IQL,2):BINFR(IB)*WTTVST);
         IF(IQL~=2)[
          $SCORE(SCFLEP,(IBDOWN,IZ,IX,2):BINFR(IB)*WTTVST);
         ]
      ]
      FRSUM=FRSUM+BINFR(IB);
   ]"end of IB loop"
   "add to total fluence and total energy of primaries with charge IQL"
   "?? surely this should say all particles, not primaries "
   $SCORET(SCTFLU,SCEAVE,(IZ,IX,IQL,1):FRSUM*WTTVST:WTEKIN);
   IF(IQL~=2)[
      "add it to total fluence and total energy of primary charged particles"
      $SCORET(SCTLEP,SCELEP,(IZ,IX,1):FRSUM*WTTVST:WTEKIN);
   ]
   "do same for secondaries  ?? surely this should say primaries"
   IF( (IPRIM=1|IPRIM=2|IPRIM=3) & (LATCH(NP)=0))[
      $SCORET(SCTFLU,SCEAVE,(IZ,IX,IQL,2):FRSUM*WTTVST:WTEKIN);
      IF(IQL~=2)[
        $SCORET(SCTLEP,SCELEP,(IZ,IX,2):FRSUM*WTTVST:WTEKIN);
      ]
   ]
   IF(IPRIM = 4  &  LATCH(NP) ~= 0)[
      $SCORET(SCTFLU,SCEAVE,(IZ,IX,IQL,2):FRSUM*WTTVST:WTEKIN);
      IF(IQL~=2)[
        $SCORET(SCTLEP,SCELEP,(IZ,IX,2):FRSUM*WTTVST:WTEKIN);
      ]
   ]
]"end of IARG = 0 scoring block"
RETURN;
END; "END OF SUBROUTINE AUSGAB"


%C80
%Q1
%E    "start of HOWFAR"
"*******************************************************************************
"
"                               **********
"                               *        *
"                               * HOWFAR *
"                               *        *
"                               **********
"
"       A GENERAL PURPOSE CYLINDRICAL GEOMETRY ROUTINE FOR USE WITH THE EGSnrc
"       CODE SYSTEM ADAPTED FOR USE WITH CAVITY.
"
"       FOR PARTICLE NP ON THE STACK IN REGION IR(NP), THIS ROUTINE
"       DETERMINES IF THE PARTICLE CAN GO A DISTANCE USTEP WITHOUT CHANGING
"       ZONES. IF USTEP CAUSES A ZONE CROSSING, IT IS REDUCED TO PLACE IT ON
"       THE BOUNDARY AND IRNEW IS SET TO THE ZONE NUMBER ON THE FAR SIDE OF
"       THE BOUNDARY. IF IR(NP) IS 1 THEN THE PARTICLE HAS ESCAPED THE REGION
"       OF INTEREST AND THE HISTORY IS TERMINATED.(IDISC IS SET TO 1.)
"
"
"
"
"       SOME VARIABLES
"       ==============
"
"OUTEND =       .TRUE.  =>      PARTICLE MAY TRANSMIT OR BACKSCATTER OUT ENDS
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE END BOUNDARIES
"OUTSID =       .TRUE.  =>      PARTICLE MAY TRANSMIT OUT THE SIDES
"       =       .FALSE. =>      PARTICLE STAYS WITHIN THE SIDE BOUNDARY
"IRL    =       STARTING REGION NUMBER THE PARTICLE IS IN
"IZ     =       STARTING PLANAR ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN ZPLANE(IZ) AND ZPLANE(IZ+1).
"IX     =       STARTING CYLINDRICAL ZONE NUMBER THE PARTICLE IS IN.
"               THE PARTICLE IS BETWEEN RCYL(IX-1) AND RCYL(IX).
"
"       COMMON/GEOM/
"               NTRACK(NREG)    PARAMETER RELATED TO RANGE REJECTION
"                               SET IN MAIN IF IREJECT=1
"               ZPLANE(IZ)      Z VALUES OF PLANES
"                               1<=IZ<=NZ+1
"               RCYL(IRR)       RADII OF CYLINDERS
"                               1<=IRR<=NR
"               CYRAD2(IRR)     =RCYL(IRR)**2
"               NZ              # PLANAR GEOMETRICAL ZONES
"                               ZONE(I) IS BETWEEN ZPLANE(I) AND ZPLANE(I+1)
"               NR              # CYLINDRICAL GEOMETRICAL ZONES
"                               ZONE(I) IS BETWEEN RCYL(I-1) AND RCYL(I)
"               NREG            TOTAL # GEOMETRICAL ZONES =NR*NZ +1
"                                       +1 FOR VACUUM ENVELOPE
%E    "flurznrc.mortran"
"       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
"       ===========================================================
"               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
"
"
"                                       1
"
"
"       --------------------------------------------------------- RCYL(NR)
"       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
"       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
"       --------------------------------------------------------- RCYL(NR-1)
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       --------------------------------------------------------- RCYL(2)
"       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
"       --------------------------------------------------------- RCYL(1)
"..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       ---------------------------------------------------------
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       |   .   |   .   |   .   |               |   .   |   .   |
"       ---------------------------------------------------------
"       |       |       |       |    . . . .    |       |       |
"       |       |       |       |               |       |       |
"       ---------------------------------------------------------
"         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
"
"                                       1
"
"
"
"       VERSION 1       ADAPTED FROM THE DOSERZ HOWFAR          83/7/26
"       VERSION 2       THE SUBROUTINE CALLS TO PLANES AND      1/89  AFB
"                       CYLINDER HAVE BEEN REPLACED BY MACROS
"                       TO SPEED THINGS UP
"
"
"******************************************************************************
"
;
"THE MACRO REPLACING THE CALL TO CYLNDR
"*****************************************************************************
"
"                               ***********
"                               *         *
"                               * $CYLNDR *
"                               *         *
"                               ***********
"
"MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
"A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
"OF THE STANDARD NRCC DISTRIBUTION
"
"FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT CYLINDERS,
"THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A CYLINDER.
"THE CYLINDERS ARE ASSUMED TO BE ALIGNED AND CENTERED ALONG THE Z-AXIS.
"
"       SOME VARIABLES
"       ==============
"
"{P1} = ICYL  = THE NUMBER OF THE OUTER CYLINDER
"{P2} = IHITC = 1 => PARTICLE HITS THE OUTER SURFACE
"             = 0 => PARTICLE MISSES THE SURFACES
"             =-1 => PARTICLE HITS THE INNER SURFACE
"{P3} = TCYL  = DISTANCE TO SURFACE IF IT HITS
"CYRAD2(ICYL) = RADIUS**2 OF THE OUTER CYLINDER
"
"THIS CODE IS OPTIMIZED FOR SPEED, NOT SIZE.
"
"FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
"FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TCYL=0.
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
"
"
"******************************************************************************
"
REPLACE {$CYLNDR(#,#,#);} WITH {
;
U1=U(NP);V1=V(NP);A=U1*U1+V1*V1;
IF(A = 0.0)[{P2}=0;{P3}=1.0E30;]
ELSE[
    X1=X(NP);Y1=Y(NP);B=X1*U1+Y1*V1;B2=B*B;
    C=X1*X1+Y1*Y1;
    COUT=C-CYRAD2({P1});
    IF(COUT > 0.0)[
        IF(IWATCH > 0)[OUTPUT COUT;(' COUT=',E11.3);]
        COUT=0.0;
        ]
    IF(B > 0.0)[{P2}=1;
        IF(COUT/B2 > -1.0E-3)[{P3}=-0.5*COUT/B;]
        ELSE[{P3}=-COUT/(SQRT(B2-A*COUT)+B);]
        ]
    ELSEIF(B < 0.0)[{P2}=1;
        IF(COUT/B2 > -1.0E-3)[{P3}=-2.*B/A*(1.-0.25*A*COUT/B2);]
        ELSE[{P3}=(SQRT(B2-A*COUT)-B)/A;]
        IF({P1} ~= 1)[
            CIN=C-CYRAD2({P1}-1);
            IF(CIN < 0.0)[
                IF(IWATCH > 0)[OUTPUT CIN;(' CIN=',E11.3);]
                CIN=0.0;
                ]
            RAD=B2-A*CIN;
            IF(RAD >=0.0)[
                {P2}=-1;
                IF(CIN/B2 < 1.0E-3)[{P3}=-0.5*CIN/B;]
                ELSE[{P3}=CIN/(SQRT(RAD)-B);]
                ]
            ]
        ]
    ELSE[
        {P2}=1;
        {P3}=SQRT(-COUT/A);
        ]
    ]
;
}
;

"THE MACRO REPLACING THE CALL TO PLANES
"******************************************************************************
"
"                               ***********
"                               *         *
"                               * $PLANES *
"                               *         *
"                               ***********
"
"PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
"A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
"OF THE STANDARD NRCC DISTRIBUTION
"
"FOR A PARTICLE TRAVELLING INSIDE TWO PARALLEL, INFINITE PLANES WITH NORMALS
"ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
"IT MUST GO TO HIT ONE OF THE PLANES
"
"       SOME VARIABLES
"       ==============
"
"{P1}           =       THE NUMBER OF THE INNER PLANE (LESSER Z-COORDINATE)
"                       IT MUST BE  >= 1
"{P2}           =       THE NUMBER OF THE OUTER PLANE (GREATER Z-COORDINATE)
"                       IT MUST BE  >= 2
"{P3} = IHITP   =       1  => PARTICLE HITS THE OUTER PLANE
"               =       0  => PARTICLE MISSES BOTH PLANES
"               =       -1 => PARTICLE HITS THE INNER PLANE
"{P4} = TPLANE  =       DISTANCE TO THE PLANE THAT IT HITS
"ZPLANE(IPLANE) =       Z-COORDINATE OF THE OUTER PLANE
"
"MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
"
"
"******************************************************************************
"
;
REPLACE {$PLANES(#,#,#,#);} WITH {
;
WL=W(NP);
IF (WL > 0.0) [{P3}=1;{P4}=(ZPLANE({P2})-Z(NP))/WL;]
ELSEIF (WL < 0.0) [{P3}=-1;{P4}=(ZPLANE({P1})-Z(NP))/WL;]
ELSE[{P3}=0;{P4}=1.0E30;]
;
}

%E     "subroutine HOWFAR"
SUBROUTINE HOWFAR;

$IMPLICIT-NONE;

"MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
REPLACE {$SET NEW REGION(#,#);} WITH
{;IF(#1.LE.USTEP)[USTEP=#1;IRNEW=#2;RETURN;]}

;COMIN/EPCONT,STACK,GEOM,SCORE,MISC/;

$INTEGER IQL,IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW;
$REAL WL,TPLANE,U1,V1,A,TCYL,X1,Y1,B,B2,C,COUT,CIN,RAD;

LOGICAL OUTEND,OUTSID;

"DISCARD ZERO WEIGHT PARTICLES"
IF(WT(NP) = 0.0)[IDISC=1;RETURN;]

OUTEND=.FALSE.;OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"
IQL=IQ(NP);IRL=IR(NP); "LOCAL VARIABLES"

"DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY"
IF (IRL = 1)[IDISC=1;RETURN;]

$GET-IX-IZ(IRL); "GET PLANAR AND CYLINDRICAL ZONES NUMBERS"

$PLANES(IZ,IZ+1,IHITP,TPLANE);"GET DISTANCE TO PLANE"
        "IHITP  =1=>HITS GREATER Z PLANE"
        "       =0=>MISSES BOTH PLANES"
        "       =-1=>HITS LESSER Z PLANE"
$CYLNDR(IX,IHITC,TCYL);"GET DISTANCE TO CYLINDER"
"       IHITC   = 1=>HITS OUTER CYLINDER"
"               = 0=>MISSES BOTH CYLINDERS"
"               =-1=>HITS INNER CYLINDER"

IZNEW=IZ+IHITP; "GET NEW PLANAR REGION"
IF((IZNEW < 1) | (IZNEW > NZ)) OUTEND=.TRUE.; "FLAG IF LEAVES BY THE ENDS"
IXNEW=IX+IHITC; "GET NEW CYLINDRICAL REGION"
IF(IXNEW > NR) OUTSID=.TRUE.; "FLAG IF LEAVES BY THE SIDES"


"DO MOST PROBABLE CASE FIRST WHERE A PLANE AND A CYLINDER CAN BE HIT"

IF((IHITP ~= 0) & (IHITC ~= 0))[
IF(TPLANE < TCYL)["HITS PLANE FIRST"
IF(OUTEND)[$SET NEW REGION(TPLANE,1);]
ELSE[$SET NEW REGION(TPLANE,IRL+IHITP);]]
ELSEIF(TCYL < TPLANE)["HITS CYLINDER FIRST"
IF(OUTSID)[$SET NEW REGION(TCYL,1);]
ELSE[$SET NEW REGION(TCYL,IRL+NZ*IHITC);]]
ELSE["ODD CASE TCYL=TPLANE:HITS PLANE AND CYLINDER TOGETHER"
IF(OUTEND | OUTSID)[$SET NEW REGION(TCYL,1);]
ELSE[$SET NEW REGION(TCYL,IRL+IHITP+NZ*IHITC);]]]

"DO ODD CASE-PARTICLE CAN HIT PLANE BUT NOT CYLINDER"

ELSEIF(IHITP ~= 0)[
IF(OUTEND)[$SET NEW REGION(TPLANE,1);]
ELSE[$SET NEW REGION(TPLANE,IRL+IHITP);]]

"DO ODD CASE-PARTICLE CAN HIT CYLINDER BUT NOT PLANE"

ELSE[
IF(OUTSID)[$SET NEW REGION(TCYL,1);]
ELSE[$SET NEW REGION(TCYL,IRL+NZ*IHITC);]]

"AT THIS STAGE ALL GEOMETRICAL POSSIBILITIES HAVE BEEN CHECKED AND CONTROL"
"HAS ALREADY BEEN TRANSFERRED TO EGS"

END; "END OF SUBROUTINE HOWFAR"

%E    "start of INPUTS"
"******************************************************************************
"
"
"                               ******************
"                               *                *
"                               * inputs.mortran *
"                               *                *
"                               ******************
"
"
"       Routine to get inputs for FLURZnrc and echo to terminal
"       It uses other routines extensively (transport, geomrz etc)
"
"
"       Input file is read from unit 5
"        The prompts and input are echoes to unit 6 for listing
"
"
"
"******************************************************************************
"
SUBROUTINE INPUTS;

$IMPLICIT-NONE;

"Declaration of COMIN blocks
"***************************
;COMIN/BOUNDS,
BREMPR,EDGE,ELECIN,GEOM,IODAT1,IODAT2,MEDIA,MISC,PLOTC,RANDOM,
SCORE,SOURCE,SPECTR,USER,ET-Control,GetInput,COMPTON-DATA,USEFUL,
EGS-VARIANCE-REDUCTION,EGS-IO/;

$INTEGER jrng1,jrng2,IRL,ILOW,IHIGH,IB,LINBIN,VAL,ITMAX,IT,IQL,IX;
$REAL DELLIN,RATIO,GAP,SMAX;

"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
;
"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"
INTEGER INEXT;
REAL STATLM;                                        "Monte Carlo input"

INTEGER MODEIN;                       "source input"
REAL TEMP1,TEMP2,TEMP3,TEMP4;                       "source input"

INTEGER IDNEAR;                              "transport control"
INTEGER IFLUOR;                             "transport control"
INTEGER IZ, IREGLO, IREGHI;                         "transport control"
INTEGER IESTEP;                                     "transport control"
REAL FESTEP;                        "transport control"

REAL ADDING;
INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM;

"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
INTEGER NUM_TITLE,

"I/O Contol"
        NUM_IWATCH,
        NUM_STRAND,
        NUM_IRSTRT,
        NUM_PLSTF,
        NUM_STORE,
        NUM_STARTR,
        NUM_STOPR,
        NUM_SLOTE,
        NUM_TOPEBIN,

"M-C Input"
        NUM_HIST,
        NUM_SEEDS,
        NUM_MXTIME,
        NUM_IPRIM,
        NUM_BREMDIST,
        NUM_BREMSPLIT,
        NUM_BREMPEVEN,
        NUM_I_PLAY_RR,
        NUM_ESAVEIN,

"Tranport Control"
        NUM_ESTEPE,
        NUM_SMAX,
        NUM_RAYLEIGH,
        NUM_IREJCT,
        NUM_HOWFAR,
        NUM_SAVELE,
        NUM_IFLUOR,
        NUM_FLUIZ,
        NUM_FREGSTART,
        NUM_FREGSTOP,
        NUM_RRPARAM,
        NUM_RRMINPL,
        NUM_RRMAXPL,
        NUM_RRMINRA,
        NUM_RRMAXRA,
        NUM_FORCE,
        NUM_STRTFRC,
        NUM_STPFRC,
        NUM_NESTEP,
        NUM_NSMAX,
        NUM_ADJEREG,
        NUM_FRAKESTEP;

$INTEGER my_unit, egs_open_datfile;
"---------------------------------------------------------------------------"
I=0;  "number of the value_sought"

ERROR_FLAG=0;   "Initialization of bad input flag"

DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"

OUTPUT $MAXRADII,$MAXZPLANE;
(//' FLURZnrc '$VERSION' ON '$MACHINE' '/
T20,'Maximum number of radial and depth zones=',2I4);

"*********************************************************"
"* set up the values_sought(IVAL) and echo inputs to screen *"
"*********************************************************"
"*********"
"* TITLE *"
"*********"
IVAL = IVAL + 1;
NUM_TITLE = IVAL;
VALUES_SOUGHT(IVAL)='TITLE';
TYPE(IVAL)=2;
NVALUE(IVAL)=1;

DELIMETER='NONE';
$GET_INPUT(NUM_TITLE);

OUTPUT;(//' *** INPUT CARD I01 ***');
READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
WRITE (*,:FMT:) (TITLE(I),I=1,79);
:FMT: FORMAT ('TITLE: ',79A1/);

"************************"
"* INPUT/OUTPUT CONTROL *"
"************************"
IVAL = IVAL + 1;
NUM_IWATCH = IVAL;
VALUES_SOUGHT(IVAL)='IWATCH';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='INTERACTIONS';
ALLOWED_INPUTS(IVAL,2)='STEPS';
ALLOWED_INPUTS(IVAL,4)='GRAPH';

IVAL = IVAL + 1;
NUM_STRAND = IVAL;
VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='NO';
ALLOWED_INPUTS(IVAL,1)='LAST';
ALLOWED_INPUTS(IVAL,2)='ALL';

IVAL = IVAL + 1;
NUM_IRSTRT = IVAL;
VALUES_SOUGHT(IVAL)='IRESTART';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='FIRST';
ALLOWED_INPUTS(IVAL,1)='RESTART';
ALLOWED_INPUTS(IVAL,3)='ANALYZE';
ALLOWED_INPUTS(IVAL,4)='START-RNS';
ALLOWED_INPUTS(IVAL,5)='PARALLEL';

IVAL = IVAL + 1;
NUM_PLSTF = IVAL;
VALUES_SOUGHT(IVAL)='PRINT FLUENCE SPECTRA';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='ALL';
ALLOWED_INPUTS(IVAL,1)='CONDENSED';
ALLOWED_INPUTS(IVAL,2)='SPECIFIED';
ALLOWED_INPUTS(IVAL,3)='NONE';

IVAL = IVAL + 1;
NUM_STORE = IVAL;
VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='YES';
ALLOWED_INPUTS(IVAL,1)='NO';

IVAL = IVAL + 1;
NUM_IPRIM = IVAL;
VALUES_SOUGHT(IVAL)='IPRIMARY';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='TOTAL FLUENCE';
ALLOWED_INPUTS(IVAL,1)='ELECTRON PRIMARIES';
ALLOWED_INPUTS(IVAL,2)='INCLUDE BREM SECONDARIES';
ALLOWED_INPUTS(IVAL,3)='PHOTON PRIMARIES';
ALLOWED_INPUTS(IVAL,4)='ELECTRON SECONDARIES';

DELIMETER='I/O CONTROL';
$GET_INPUTS(NUM_IWATCH,NUM_IPRIM);
IPRNTP=VALUE(NUM_PLSTF,1);

IF (IPRNTP=2) [
   IVAL = IVAL + 1;
   NUM_STARTR = IVAL;
   VALUES_SOUGHT(IVAL)='LIST FLUENCE START REGION';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=2;
   VALUE_MAX(IVAL)=$MXREG;
   DEFAULT(IVAL)=1;

   IVAL = IVAL + 1;
   NUM_STOPR = IVAL;
   VALUES_SOUGHT(IVAL)='LIST FLUENCE STOP REGION';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=2;
   VALUE_MAX(IVAL)=$MXREG;
   DEFAULT(IVAL)=$MXREG;

   $GET_INPUTS(NUM_STARTR,NUM_STOPR);
]

OUTPUT;(' *** INPUT CARD IO2 ***');
IWATCH=VALUE(NUM_IWATCH,1);
ISTORE=VALUE(NUM_STRAND,1);
IRSTRT=VALUE(NUM_IRSTRT,1);
IDAT=VALUE(NUM_STORE,1);
IPRIM=VALUE(NUM_IPRIM,1);
OUTPUT IWATCH,ISTORE,IRSTRT,IPRNTP,IDAT,IPRIM;
(/' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T60,I12/
' DO NOT STORE(0) OR STORE(1,2) INITIAL RANDOM #s:',T60,I12/
' FIRST RUN(0),RESTARTED(1),ANALYZE(3),READ RNS(4),'/
'   PARALLEL(5):',T60,I12/
' LIST ALL(0), SHORT PHOT(1),SPECIFIED REGIONS(2), NONE(>2):',T60,I12/
' STORE DATA(0) OR NOT(1):',T60,I12/
' OUTPUT TOTAL(0),PRIMARIES(1(brem),2(no brem),3(unscattered)),SEC(4):'
  ,T70,I2/);
IF (IDAT = 1) [INEXT=0;] ELSE [INEXT=1;]
IF (IRSTRT=4)[
    IDAT=1;   "do not store output in this case to avoid biasing"
    ISTORE=0; "do not store the starting random numbers either"
]

"Region numbers for printing in listing files is done below GEOMRZ."
DO J=1, $MXREG [IPRTSP(J)=0;] "DEFAULT PRINT ALL"


"                       MONTE CARLO CONTROL INPUT
"                       *************************
IVAL = IVAL + 1;
NUM_HIST = IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=100;
VALUE_MAX(IVAL)=4.611686e18; "This is the largest integer handled=2^62"
DEFAULT(IVAL)=20000;

IVAL = IVAL + 1;
NUM_MXTIME = IVAL;
VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=1000;
DEFAULT(IVAL)=999.0;

DELIMETER='MONTE CARLO INPUTS';
$GET_INPUTS(NUM_HIST,NUM_MXTIME);

$RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',jrng1,jrng2);

IF( i_parallel > 0 ) jrng2 = jrng2 - 1 + i_parallel;

$INITIALIZE RNG USING jrng1 AND jrng2;

"************"
"* CARD MC1 *"
"************"
OUTPUT;(/,' *** INPUT CARD MC1 ***');
NCASE=VALUE(NUM_HIST,1);
TIMMAX=VALUE(NUM_MXTIME,1);

IF(IWATCH=0 & NCASE<$NCASEMIN)[NCASE=$NCASEMIN;]

OUTPUT NCASE,jrng1,jrng2,TIMMAX;
(/' # of histories:',T60,I12/
  $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
' maximum cpu time allowed:',T60,F10.2,'HRS'/
);

IF (ERROR_FLAG=1) [GOTO :FINISHED:;]

"                CYLINDRICAL GEOMETRY AND MATERIAL INPUT
"                ***************************************
"EXECUTED FROM SUBROUTINE GEOMRZ(ERROR_FLAG)"
"============="
CALL GEOMRZ;
"============="

IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMRZ************';
   GOTO :FINISHED:;
]

"This is done here because NREG is needed from geomrz..."
IF(IPRNTP=2)[
   OUTPUT;(/'***** SPECTRUM OUTPUT IN LISTING FILE *****');
   DO IRL=2, NREG [IPRTSP(IRL)=1;] "DEFAULT PRINT NOTHING"
   DO J=1, NVALUE(NUM_STARTR) [
      ILOW=VALUE(NUM_STARTR,J);
      IHIGH=VALUE(NUM_STOPR,J);
      IF (ILOW>NREG) [ILOW=NREG;]
      IF (IHIGH>NREG) [IHIGH=NREG;]
      IF (ILOW>IHIGH) [IHIGH=ILOW;]
      IF (ILOW=IHIGH) [
         OUTPUT ILOW;(' Print spectrum in region',I3);
         IPRTSP(ILOW) = 0;
      ]
      ELSE [
         DO IRL= ILOW, IHIGH [IPRTSP(IRL)=0;]
         OUTPUT ILOW,IHIGH;(' Print spectra in regions',I4,' TO',I4);
      ]
   ]
]


"                       SOURCE CONFIGURATION INPUT
"                       **************************
"=================================
CALL SRCRZ;  "Get source data"
"=================================

IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************';
   GOTO :FINISHED:;
]
"This is needed for the correlation version of srcrz"
"after jans"
CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0);


IF (ISOURC=21|ISOURC=22|ISOURC=23) [MONOEN=0;]
  "no need to input monoen for source 21"
ELSE [CALL ENSRC;] "Get data re-source energies"
IF (ERROR_FLAG=1) [
   WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
   GOTO :FINISHED:;
]

"
"      Start of inputs for transport control delimeter
"      ===============================================

call get_transport_parameter(6);

"ECUTIN and PCUTIN are not set so here we make the approiximation that they"
"are given by ECUT(2) and PCUT(2), which is fine as long as they are not"
"varying"
ecutin = ecut(2);
pcutin = pcut(2);
smax   = smaxir(2);

"                       ENERGY BIN INPUT
"                       ****************
" actually retrieves this from the I/O section of input, but put here
" because it needs EIN from the source input and ECUTIN from the
" transport control input

IVAL = IVAL + 1;
NUM_SLOTE = IVAL;
VALUES_SOUGHT(IVAL)='SLOTE';
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=-10000.0;
VALUE_MAX(IVAL)=10000.0;
DEFAULT(IVAL)=1.25;

DELIMETER='I/O CONTROL';
$GET_INPUT(NUM_SLOTE);
SLOTE=VALUE(NUM_SLOTE,1);

IF (SLOTE > 0.) [
   "CHECK NOT TOO MANY BINS REQUESTED"
   :START: MAXIB=int(EIN/SLOTE+0.999);
   IF (MAXIB > $EBIN) [
      OUTPUT SLOTE, EIN, MAXIB, $EBIN;
         (/' **************************************************'/
           ' For SLOTE =', F10.4,' MeV and maximum energy', F10.3,' MeV'/
           ' one needs', I5,' bins and the max available is',I5/
           ' So increase bin width by 2');
      SLOTE=2.*SLOTE;GOTO :START:;
   ]
   OUTPUT MAXIB,SLOTE; (' ',I3,' energy bins of width',1PE10.3,
    ' MeV granted for spectral outputs'/);
   "set up BINTOP array needed within AUSGAB to allocate across bins"
   "recall MAXIB was set so just greater than max input covered."
   DO IB=1,MAXIB [BINTOP(IB) =SLOTE*dble(IB);]
]
ELSEIF (SLOTE = -999) ["set up linear/log bins for SPR calcns"
                       "use all bins available"
                       "10% of bins cover top 10% of spectrum"
                       "rest are equal logarithmic"
   LINBIN = int(float($EBIN)/10. + 0.5); "no of bins to cover 10%"
   DELLIN = (EIN - (ECUTIN-PRM))*0.10/dble(LINBIN);
   OUTPUT LINBIN,DELLIN;(/' ***SLOTE=-999***', I4,' BINS OF',F10.4,' MEV'/);
   MAXIB = $EBIN; BINTOP(MAXIB) = EIN;
   DO I =1,linbin[
     BINTOP(MAXIB-I) = EIN-(dble(I)*DELLIN);]
   "now set up logarithmic bins"
    RATIO=(BINTOP(MAXIB-LINBIN)/(ECUTIN-PRM))**(1./dble(MAXIB-LINBIN));
    BINTOP(1) = (ECUTIN - PRM)*RATIO;
    DO IB = 2,MAXIB-LINBIN[
      BINTOP(IB) = BINTOP(IB-1)*RATIO;]
    OUTPUT MAXIB,ECUTIN,(BINTOP(IB),IB=1,MAXIB);(/I4,' SPR ENERGY ',
    'BINS STARTING AT',F10.4,' MeV'/(3X,5F12.4));
]
ELSEIF (SLOTE < 0.0) [ "SET UP -SLOTE EQUAL LOGARITHMIC BINS"
    MAXIB = -SLOTE;  "GET NUMBER OF BINS TO USE"
    IF(MAXIB > $EBIN) [MAXIB = $EBIN; OUTPUT MAXIB;(/' ****NUMBER OF BINS',
             ' ASKED FOR REDUCED TO MAX OF ', I4,' ****');]
    "  maximum energy in problem is EIN, and we use electron lowest"
    "  energy to set the bins equally from ECUTIN to EIN"
    RATIO = (EIN /(ECUTIN-PRM))**(1./dble(MAXIB));
    BINTOP(1) = (ECUTIN-PRM)*RATIO;
    DO IB=2,MAXIB-1 [
           BINTOP(IB) = RATIO * BINTOP(IB-1);]
    BINTOP(MAXIB) = EIN; "TO AVOID ROUND-OFF ERRORS"
    OUTPUT MAXIB,ECUTIN,(BINTOP(IB),IB=1,MAXIB);(/I4,' LOGARITHMIC ENERGY ',
    'BINS STARTING AT',F10.4,' MeV'/(3X,5F12.4));
]
IF (SLOTE = 0.0) [
   IVAL = IVAL + 1;
   NUM_TOPEBIN = IVAL;
   VALUES_SOUGHT(IVAL)='TOPS OF ENERGY BINS';
   NVALUE(IVAL)=0;
   TYPE(IVAL)=1;
   VALUE_MIN(IVAL)=1.e-20;
   VALUE_MAX(IVAL)=100000.0;
   DEFAULT(IVAL)=1.25;
   $GET_INPUT(NUM_TOPEBIN);
   MAXIB = NVALUE(NUM_TOPEBIN);
   DO J=1, NVALUE(NUM_TOPEBIN) [BINTOP(J)=VALUE(NUM_TOPEBIN,J);]
   GAP = (BINTOP( NVALUE(NUM_TOPEBIN) ) - EIN)/EIN;
   "assumes EIN set - will find out if not!"
   IF ( GAP < 0.0  & GAP >-0.1)[BINTOP(NVALUE(NUM_TOPEBIN)) = EIN;
                    OUTPUT EIN; (T30,'TOP BIN ADJUSTED TO COVER:', F10.1);]
   ELSEIF (GAP < -0.1)[OUTPUT;(//' *******MAXIMUM ENERGY BIN IS LESS THAN 90%',
                      ' OF MAXIMUM INPUT ENERGY -ASSUMED INTENTIONAL*****'//);]

   OUTPUT NVALUE(NUM_TOPEBIN),(BINTOP(J),J=1,NVALUE(NUM_TOPEBIN));
   (/' Read a total of',I4,' energy bin tops'/ (5F15.4) );
]

$SKIP-LINE;

"*************************************************************************"
"                variance reduction section                               "
"*************************************************************************"


IVAL = IVAL + 1;
NUM_BREMSPLIT = IVAL;
VALUES_SOUGHT(IVAL)='BREM SPLITTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL = IVAL + 1;
NUM_BREMPEVEN = IVAL;
VALUES_SOUGHT(IVAL)='NUMBER OF BREMS PER EVENT';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=$MAXBRSPLIT;
DEFAULT(IVAL)=$MAXBRSPLIT;

IVAL = IVAL + 1;
NUM_I_PLAY_RR = IVAL;
VALUES_SOUGHT(IVAL)='CHARGED PARTICLE RUSSIAN ROULETTE';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL = IVAL + 1;
NUM_IREJCT = IVAL;
VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL=IVAL+1;
NUM_ESAVEIN=IVAL;
VALUES_SOUGHT(IVAL)='ESAVEIN';
NVALUE(IVAL)=1;
TYPE(IVAL)=1;
VALUE_MIN(IVAL)=0.;
VALUE_MAX(IVAL)=EIN+PRM;  "EIN is max k.e. of particles set in srcrz"
                         "for ISOURC 21,22 and ine ensrc for the others"
DEFAULT(IVAL)=EIN+PRM;  "defaults to max energy in case too high "
                          " a value is input, => still do range rej"

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_BREMSPLIT,NUM_ESAVEIN);

IBRSPL=VALUE(NUM_BREMSPLIT,1);
nbr_split =VALUE(NUM_BREMPEVEN,1);
IF(IBRSPL = 1)[
    "default bremsstrahlung splitting to maximum"
    IF((nbr_split  <= 0) | (nbr_split  > $MAXBRSPLIT)) nbr_split =$MAXBRSPLIT;
]
ELSE ["no bremsstrahlung splitting" nbr_split = 1;]
"note the above is needed since BREMS only checks nbr_split, not IBRSPL"

I_PLAY_RR=VALUE(NUM_I_PLAY_RR,1);
IF(I_PLAY_RR = 1)[PROB_RR=1./dble(nbr_split);]
ELSE[PROB_RR=1.;]

IREJCT=VALUE(NUM_IREJCT,1);
ESAVEIN=VALUE(NUM_ESAVEIN,1);

OUTPUT IBRSPL,nbr_split,I_PLAY_RR,PROB_RR,IREJCT,ESAVEIN;
(
    /
    ' Bremsstrahlung splitting OFF(0) or ON(1):'          ,T60,I12/
    ' Each bremsstrahlung split into:'                    ,T60,I12//
    ' Charged particle Russian Roulette OFF(0) or ON(1):'  ,T60,I12/
    ' Probability of survival:'                           ,T60,F10.4//
    ' Without(0) or with(1) range rejection:'             ,T60,I12/
    ' ESAVE cutoff value for range rejection with dnear:' ,T60,F10.4,' MeV'/

);

IVAL = IVAL + 1;
NUM_FORCE = IVAL;
VALUES_SOUGHT(IVAL)='PHOTON FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
DEFAULT(IVAL)=0;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';

IVAL = IVAL + 1;
NUM_STRTFRC = IVAL;
VALUES_SOUGHT(IVAL)='START FORCING';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(IVAL)=0;
VALUE_MAX(IVAL)=NREG;
DEFAULT(IVAL)=1;

IVAL = IVAL + 1;
NUM_STPFRC = IVAL;
VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
NVALUE(IVAL)=1;
TYPE(IVAL)=0;
VALUE_MIN(NUM_STPFRC)=0;
VALUE_MAX(NUM_STPFRC)=NREG+1;
DEFAULT(NUM_STPFRC)=1;

DELIMETER='VARIANCE REDUCTION';
$GET_INPUTS(NUM_FORCE,NUM_STPFRC);

"************"
"* CARD TC3 *"
"************"
OUTPUT;(' *** INPUT CARD TC3 ***');
IFORCE=VALUE(NUM_FORCE,1);
NFMIN=VALUE(NUM_STRTFRC,1);
NFMAX=VALUE(NUM_STPFRC,1);
IF(IFORCE = 0) [
    NFMIN=0;NFMAX=0;
    OUTPUT;(/' NO INTERACTION FORCING IS IN EFFECT'/);
]
ELSE [
    IF (NFMAX < NFMIN) NFMAX=NFMIN;
    OUTPUT NFMIN,NFMAX;
    (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
    ' # INTERACTIONS'/);
]
$SKIP-LINE;

"                       PLOTTING CONTROLS
"                       *****************

"INPUT CARDS FOR PLOTTING ROUTINE
CALL PLOTSN;


IF (ERROR_FLAG=1) [GOTO :FINISHED:;]
"
"                        SCORING ARRAY INITIALISATION
"                        ****************************
"
IF(IPRIM = 0)[ITMAX=1;]ELSE[ITMAX=$MAXIT;]
NCASEO=0;NCASET=0;
IF(IRSTRT = 0 | IRSTRT = 5)[ "FRESH START, SET EVERYTHING TO ZERO"
                             "or parallel post-processing"
 NNREAD=0;
 PIISTP=0.;
 SCSTP=0.;SCSTP2=0.;SCSTP_LAST=0;
 DO IX=1,NR[
           DO IZ=1,NZ[
              DO IT=1,ITMAX[
                 DO IQL=1,3[
                    DO IB=1,MAXIB[
                       SCFLU(IB,IZ,IX,IQL,IT)=0.;
                       SCFLU2(IB,IZ,IX,IQL,IT)=0.;
                       SCFLU_LAST(IB,IZ,IX,IQL,IT)=0;
                    ]
                    SCEAVE(IZ,IX,IQL,IT)=0.;
                    SCEAVE2(IZ,IX,IQL,IT)=0.;
                    SCEAVE_COV(IZ,IX,IQL,IT)=0.;
                    SCTFLU(IZ,IX,IQL,IT)=0.;
                    SCTFLU2(IZ,IX,IQL,IT)=0.;
                    SCTFLU_LAST(IZ,IX,IQL,IT)=0;
                 ]
                 DO IB=1,MAXIB[
                    SCFLEP(IB,IZ,IX,IT)=0.;
                    SCFLEP2(IB,IZ,IX,IT)=0.;
                    SCFLEP_LAST(IB,IZ,IX,IT)=0;
                 ]
                 SCELEP(IZ,IX,IT)=0.;
                 SCELEP2(IZ,IX,IT)=0.;
                 SCELEP_COV(IZ,IX,IT)=0.;
                 SCTLEP(IZ,IX,IT)=0.;
                 SCTLEP2(IZ,IX,IT)=0.;
                 SCTLEP_LAST(IZ,IX,IT)=0;
              ]
           ]
 ]
]
ELSEIF(IRSTRT ~= 4)[
             "RESTART OR STATS ANALYSIS ONLY, READ OLD DATA FROM UNIT 4"
  OUTPUT;(/'   START READING OLD DATA FILE');

  "OPEN UNIT 4 AS AN OLD FILE"
  my_unit = egs_open_datfile(4,0,1,'.egsdat');

  READ(my_unit,*,END=:EOF2:) SCSTP,SCSTP2;
  DO IX=1,NR[
           DO IZ=1,NZ[
              DO IT=1,ITMAX[
                 DO IQL=1,3[
                    DO IB=1,MAXIB[
                       READ(my_unit,*)SCFLU(IB,IZ,IX,IQL,IT),
                                      SCFLU2(IB,IZ,IX,IQL,IT);
                    ]
                    READ(my_unit,*)SCEAVE(IZ,IX,IQL,IT),SCEAVE2(IZ,IX,IQL,IT),
                            SCEAVE_COV(IZ,IX,IQL,IT),SCTFLU(IZ,IX,IQL,IT),
                            SCTFLU2(IZ,IX,IQL,IT);
                 ]
                 DO IB=1,MAXIB[
                    READ(my_unit,*)SCFLEP(IB,IZ,IX,IT),SCFLEP2(IB,IZ,IX,IT);
                 ]
                 READ(my_unit,*)SCELEP(IZ,IX,IT),SCELEP2(IZ,IX,IT),
                                SCELEP_COV(IZ,IX,IT),SCTLEP(IZ,IX,IT),
                                SCTLEP2(IZ,IX,IT);
              ]
           ]
  ]
  $RETRIEVE RNG STATE FROM UNIT my_unit;
  READ(my_unit,*,END=:EOF2:) NCASEO,TMCPUO,NNREAD,PIISTP;
  CLOSE(UNIT=my_unit);
]
IF(IRSTRT = 3)[NCASE=0;]
NCASET=NCASE+NCASEO;

:FINISHED: CONTINUE;
"************************"
"* Check for any errors *"
"************************"
IF(ERROR_FLAG = 0) [
   OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
   WRITE (15,*) ' *************************************************';
   WRITE (15,*) ' ';
   WRITE (15,*) ' ';
   DO J=1,5[$SKIP-LINE;]

   RETURN; "NORMAL RETURN"
]

IF (ERROR_FLAG=1) [
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   WRITE(15,*) '************************************************';
   WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********';
   WRITE(15,*) '************************************************';
   WRITE(15,*) ' ';
   WRITE(15,*) ' ';
   OUTPUT;(/' FLURZnrc input file is not correct! - look for error message');
   RETURN; "ERROR RETURN"
]

"BAD DATA FILE, STOP AND PRINT MESSAGE
:EOFA:;OUTPUT;(/' END OF USER DATA FILE READ BEFORE DAT FILE IN');
ERROR_FLAG=1;
RETURN; "END OF DAT FILE RETURN"

:EOF2:;
"BAD INPUT DATA FILE FOR ANALYSIS"
OUTPUT;(' UNEXPECTED EOF ON SAVED DATA FILE- TAKE CARE OF PRESTA INPUT');
ERROR_FLAG=1;
RETURN;

:no_dat_file:
OUTPUT;(' Error trying to open the egsdat file: Is it there?'//);
ERROR_FLAG=1;
RETURN;

END; "END OF SUBROUTINE INPUTS


%Q1
%I4
%E    "start of ISUMMARY"
"*******************************************************************************
"
SUBROUTINE ISUMRY;
"
"*******************************************************************************

$IMPLICIT-NONE;

;
COMIN/
BOUNDS,BREMPR,EDGE,ELECIN,ET-Control,GEOM,IODAT1,IODAT2,
MEDIA,MISC,RANDOM,SCORE,SOURCE,SPECTR,THRESH,USEFUL,USER,
EGS-VARIANCE-REDUCTION/;

$INTEGER IOUT,J,MXREG,I;
$REAL SMAX,EK0;

"For the grid output defaults"
CHARACTER*4 CDSTBL($MXREG),CTRTBL($MXREG),CABSRB($MXREG);

IOUT=1; "OUTPUT ON FORTRAN UNIT 1"

"write the header"
WRITE (IOUT, *) '\f'; "page break"


" ******* IK: using wrapper subroutines for date and time.
" Was:
" CALL DATE(DATEN);CALL TIME(TIMEN);
" WRITE(IOUT,100) TITLE,TIMEN,DATEN;
" 100  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
"  ' *',T80, '*'/
"  ' *',T34,'************',T80,'*'/
"  ' *',T34,'*          *',T80,'*'/
"  ' *',T34,'* FLURZnrc *',T80,'*'/
"  ' *',T34,'*          *',T80,'*'/
"  ' *',T34,'************',T80,'*'/
"  ' *',T80, '*'/
"  ' *            Cylindrical-geometry fluence-scoring EGSnrc user-code ',
"     T80,'*'/
"  ' *',T80, '*'/
"  ' *   FLURZnrc was developed by the National Research Council of Canada',
"                                                                      T80,'*'/
"  ' *',T80, '*'/
"  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
"  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
"                                                                       T80,'*'/
"  ' *             running on '$MACHINE' ',T80,'*'/
"  ' *',T80, '*'/
"  ' *',  T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT,T80,'*'/1X,79('*'));
write(iout,100) title; call egs_fdate(iout);
write(iout,'(T80,"*"/1X,79("*"))');
100 FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
  ' *',T80, '*'/
  ' *',T34,'************',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'* FLURZnrc *',T80,'*'/
  ' *',T34,'*          *',T80,'*'/
  ' *',T34,'************',T80,'*'/
  ' *',T80, '*'/
  ' *            Cylindrical-geometry fluence-scoring EGSnrc user-code ',
     T80,'*'/
  ' *',T80, '*'/
  ' *   FLURZnrc was developed by the National Research Council of Canada',
                                                                      T80,'*'/
  ' *',T80, '*'/
  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
                                                                       T80,'*'/
  ' *             running on '$MACHINE' ',T80,'*'/
  ' *',T80, '*'/
  ' *',  T56,$);


"Print info about transport parameter settings"
call show_transport_parameter(iout);



"MONTE CARLO TRANSPORT AND SCATTER CONTROLS"
"=========================================="
WRITE(IOUT,200) NCASE,NCASET,IQIN;
IF(MONOEN = 0 & (ISOURC<21 | ISOURC>23)) [WRITE (IOUT,201) EIN;]
ELSEIF(MONOEN=1)[CALL ENSRCO;]
ELSEIF(ISOURC=21|ISOURC=22|ISOURC=23)[WRITE (IOUT,202) EIN;]
IF(ESTEPE = 0.0)[WRITE(IOUT,210);]ELSE[WRITE(IOUT,211)ESTEPE;]
WRITE(IOUT,220) SMAX,ECUTIN,PCUTIN;
IF(IFORCE ~= 0)[WRITE(IOUT,230)NFMIN,NFMAX;]ELSE[WRITE(IOUT,231);]
IF(IPRIM=0)[WRITE(IOUT,235);]ELSE[WRITE(IOUT,236) IPRIM;]
IF(IREJCT = 1)[WRITE(IOUT,242);WRITE(IOUT,250)
ECUTIN-RM,ERANGE,(CRANGE(J,1),J=1,2),ERANGE,EIN,(CRANGE(J,2),J=1,2);
WRITE(IOUT,255) MINZ,MAXZ,MINR,MAXR;]
ELSE[WRITE(IOUT,243);]
MXREG=$MXREG;
WRITE(IOUT,260) TIMMAX;
write(iout,'(21x,a,$)') 'Initial RNG state:           ';
$SHOW-RNG-STATE(iout); write(iout,*);

DO I=1,NREG[
  IF(IRAYLR(I)=1)[
     WRITE(IOUT,270);
     EXIT;
  ]
  IF(I=NREG)[
     WRITE(IOUT,275);
  ]
]
IF(IBRDST = 0)[WRITE(IOUT,277);]ELSE[WRITE(IOUT,278);]
IF(IBRSPL = 0)[WRITE(IOUT,279);]
ELSE[WRITE(IOUT,281) nbr_split;]

IF(I_PLAY_RR = 0)[WRITE(IOUT,314);]
ELSE[WRITE(IOUT,315) PROB_RR;]

IF(NESTEP = 0)[WRITE(IOUT,282);]
ELSEIF(NESTEP = NREG)[WRITE(IOUT,283);]
ELSE[WRITE(IOUT,284)NESTEP;]
IF(NSMAX = 0)[WRITE(IOUT,285);]
ELSEIF(NSMAX = NREG)[WRITE(IOUT,286);]
ELSE[WRITE(IOUT,287)NSMAX;]


EK0=EIN;
$PRESTA-INPUT-SUMMARY;

"MATERAL INPUT SUMMARY"
"====================="
WRITE(IOUT,300) NMED;
DO I=1,NMED[
WRITE(IOUT,310) I,(MEDIA(J,I),J=1,18),RHO(I),AE(I),AP(I);]

CALL GEOMRZ_ISUMRY(IOUT);

"DESCRIBE SOURCE"
CALL SRCOUT;

"PRINT A MATERIAL GRID OF THE ZONE DEPENDENT VARIABLES"
"====================================================="
"Set defaults for non-used variables"
CDSTBL(1)='0';CTRTBL(1)='0';CABSRB(1)='0';
"Make the material grid"
CALL MATERIALGRID(NR, NZ, VOLUME, 2, ECUT, PCUT,
                  RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB);
RETURN;

"FORMATS"
%F
%I0
200   FORMAT(/' ',79('*')//
     1       ,T20,'MONTE CARLO TRANSPORT  AND SCATTER CONTROLS'/
     2       /' ',79('-')/
     3       /' ',T20,'Max # of histories to run',T53,I12/
     4       ' ',T20,'Max # of histories to analyze',T53,I12/
     5       ' ',T20,'Incident charge',T63,I2)
201   FORMAT(' ',T20,'Incident kinetic energy',T57,F9.3,' (MeV)')
202   FORMAT(' ',T20,'Max. incident kinetic energy',T57,F9.3,' (MeV)')
210   FORMAT(' ',T20,'Fractional electron energy/step',T60,'default')
211   FORMAT(' ',T20,'Fractional electron energy/step',T60,F5.3)
220   FORMAT(' ',T20,'Maximum global electron step size',
     1               T60,1PE10.3,' (cm)'/
     2       ' ',T20,'Global electron transport cut-off',
     3               T56,0PF9.4,' (MeV)'/
     4       ' ',T20,'Global photon transport cut-off',
     5               T56,F9.4,' (MeV)')
230   FORMAT(' ',T20,'Min/max photon step forced',T60,I6,'/',I6)
235   FORMAT(T20,'Total fluence only scored')
236   FORMAT(T20,'Score secondary fluence, IPRIM=',I2)
231   FORMAT(' ',T20,'Photon interaction forcing switch',T60,'Off')
242   FORMAT(' ',T20,'Range rejection switch',T60,'On')
243   FORMAT(' ',T20,'Range rejection switch',T60,'Off')
250   FORMAT(' ',T20,'Range rejection parameters:'/
     1     ' ',T20,F9.3,' (MeV) TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7/
     2     ' ',T20,F9.3,' (MeV) TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7)
255   FORMAT(T20,'DISCARDS e- EXTERIOR TO PLANES',T58,I3,' and',I3/
     1       ' ',T30,'AND CYLINDERS',T58,I3,' and',I3)
260   FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (hrs)'/
     1       ' ',T20,'Initial RNG seeds: ',5x,$)
270   FORMAT(T20,'Rayleigh(coherent) scattering included')
275   FORMAT(T20,'Rayleigh scattering not included')
277   FORMAT(T20,'EGS4 default bremsstrahlung angular sampling')
278   FORMAT(T20,'Koch and Motz bremsstrahlung angular sampling')
279   FORMAT(T20,'Bremsstrahlung splitting',T60,'OFF')
281   FORMAT(T20,'Bremsstrahlung splitting',T60,'ON'/T20,
     1'Initially, each bremsstrahlung photon split into ',I4,' photons')
282   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'NONE')
283   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'ALL')
284   FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,I2)
285   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'NONE')
286   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'ALL')
287   FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,I2)
300   FORMAT(/' ',79('*')/
     1       /' ',T20,'Material summary:   ',I2,' material(s) used'/
     2       /' ',79('-')/
     3       /' ',4X,'#',7X,'Material',20X,'density(g/cm**3)',
     4               3X,'AE(MeV)',4X,'AP(MeV)'/)
305   FORMAT(T22,'REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3)
306   FORMAT(T20,'REGIONS WITH FLUORESCENT X-RAYS FOLLOW: ')
307   FORMAT(T20,'FLUORESCENT X-RAYS ARE DISCARDED')
310   FORMAT(' ',4X,I1,8X,18A1,11X,1PE10.3,5X,0PF9.3,2X,F9.3)
314   FORMAT(T20,'Charged particle Russian Roulette',T60,'OFF')
315   FORMAT(T20,'Charged particle Russian Roulette',T60,'ON'/T20,
     1           'With probability of survival =',T60,F9.3)
%M
%I4
END; "LAST LINE OF SUBROUTINE ISUMRY"
%Q1
%E    "start of OSUMRY"
"*******************************************************************************
"
SUBROUTINE OSUMRY;
"
"*******************************************************************************

$IMPLICIT-NONE;

;
COMIN/BREMPR,GEOM,IODAT1,IODAT2,PRINTC,PLOTC,SCORE,SOURCE,USER,
EGS-VARIANCE-REDUCTION,CH-Steps/;

$LONG_INT IMS;
$INTEGER IX,IZ,IQL,IPRIM1,NPERPG,IPERPG,IP,ILINE,IB;
$REAL ZLOW,ZHIGH,RLOW,ETOP;

REPLACE {$IRL} WITH {IZ+1+NZ*(IX-1)}

"for the grid output"
INTEGER NCOMP;
$REAL RESULTS($MAXZREG, $MAXRADII, $MAXCMPTS),
     UNCRTY($MAXZREG, $MAXRADII, $MAXCMPTS),
     RADIAL_BINS($MAXRADII),DEPTH_BINS($MAXZPLANE);
CHARACTER*60 EXPLANATIONS($MAXCMPTS);
CHARACTER*4 LABELS($MAXCMPTS);

"Print out final brem splitting number"
IF(IBRSPL = 1)[WRITE(IOUT,90) nbr_split;]

"PRINT # CHARGED PARTICLE STEPS"
IF(ISOURC=21|ISOURC=22)[
  WRITE(IOUT,1001) SCSTP,SCSTP2,
  SCSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC),SCSTP2,
                   (count_pII_steps+PIISTP)/SCSTP,SCSTP2;
]
ELSE[
   WRITE(IOUT,1001) SCSTP,SCSTP2,SCSTP/dble(IHSTRY),SCSTP2,
                   (count_pII_steps+PIISTP)/SCSTP,SCSTP2;
]

"         PRINT SUMMARY OF TOTALS FOR EACH ZONE"
"         ====================================="
"subroutine ZONEGRID: A. Merovitz, Feb. 98"
IF(NREG > 2) [ "not needed if only one geometrical zone"
   "1) Set up the arrays"
   DO IX=1, NR [
      DO IZ=1, NZ [
         RESULTS(IZ,IX,1)=SCTFLU(IZ,IX,1,1);
         RESULTS(IZ,IX,2)=SCEAVE(IZ,IX,1,1);
         RESULTS(IZ,IX,3)=SCTFLU(IZ,IX,2,1);
         RESULTS(IZ,IX,4)=SCEAVE(IZ,IX,2,1);
         RESULTS(IZ,IX,5)=SCTFLU(IZ,IX,3,1);
         RESULTS(IZ,IX,6)=SCEAVE(IZ,IX,3,1);
         RESULTS(IZ,IX,7)=SCTFLU(IZ,IX,1,2);
         RESULTS(IZ,IX,8)=SCEAVE(IZ,IX,1,2);
         RESULTS(IZ,IX,9)=SCTFLU(IZ,IX,2,2);
         RESULTS(IZ,IX,10)=SCEAVE(IZ,IX,2,2);
         RESULTS(IZ,IX,11)=SCTFLU(IZ,IX,3,2);
         RESULTS(IZ,IX,12)=SCEAVE(IZ,IX,3,2);
         UNCRTY(IZ,IX,1)=SCTFLU2(IZ,IX,1,1);
         UNCRTY(IZ,IX,2)=SCEAVE2(IZ,IX,1,1);
         UNCRTY(IZ,IX,3)=SCTFLU2(IZ,IX,2,1);
         UNCRTY(IZ,IX,4)=SCEAVE2(IZ,IX,2,1);
         UNCRTY(IZ,IX,5)=SCTFLU2(IZ,IX,3,1);
         UNCRTY(IZ,IX,6)=SCEAVE2(IZ,IX,3,1);
         UNCRTY(IZ,IX,7)=SCTFLU2(IZ,IX,1,2);
         UNCRTY(IZ,IX,8)=SCEAVE2(IZ,IX,1,2);
         UNCRTY(IZ,IX,9)=SCTFLU2(IZ,IX,2,2);
         UNCRTY(IZ,IX,10)=SCEAVE2(IZ,IX,2,2);
         UNCRTY(IZ,IX,11)=SCTFLU2(IZ,IX,3,2);
         UNCRTY(IZ,IX,12)=SCEAVE2(IZ,IX,3,2);
      ] "end do IZ"
   ] "end do IX"
   "2) Determine the number of components"
   IF(IPRIM ~= 0) [NCOMP = 12;] ELSE [NCOMP = 6;]

   "3) Set up the bin indicators"
   DO IX=1,NR+1 [RADIAL_BINS(IX)=RCYL(IX-1);]
   DO IZ=1,NZ+1 [DEPTH_BINS(IZ)=ZPLANE(IZ);]

   "4) Set up the labels and the explanations"
   IF ((ISOURC ~=3)&(ISOURC ~=21)&(ISOURC ~=22)&(ISOURC ~=23)) [
   EXPLANATIONS(1)='total electron fluence/incident fluence(incl. secondaries)';
   EXPLANATIONS(3)='total photon fluence/incident fluence(incl. secondaries)';
   EXPLANATIONS(5)='total positron fluence/incident fluence(incl. secondaries)';
   ]
   ELSE [
   EXPLANATIONS(1)='total electron fluence/source particle(incl. secondaries)';
   EXPLANATIONS(3)='total photon fluence/source particle(incl. secondaries)';
   EXPLANATIONS(5)='total positron fluence/source particle(incl. secondaries)';
   ]
   EXPLANATIONS(2)='average total electron energy';
   EXPLANATIONS(4)='average total photon energy';
   EXPLANATIONS(6)='average total positron energy';
   LABELS(1)='Te-:';LABELS(2)='E1 :';LABELS(3)='Tph:';LABELS(4)='E2 :';
   LABELS(5)='Te+:';LABELS(6)='E3 :';
   IF (IPRIM ~=4) [
      EXPLANATIONS(7)='primary electron fluence';
      EXPLANATIONS(8)='average primary electron energy';
      EXPLANATIONS(9)='primary photon fluence';
      EXPLANATIONS(10)='average primary photon energy';
      EXPLANATIONS(11)='primary positron fluence';
      EXPLANATIONS(12)='average primary positron energy';
      LABELS(7)='Pe-:'; LABELS(8)='E4 :'; LABELS(9)='Pph:';
      LABELS(10)='E5 :'; LABELS(11)='Pe+:'; LABELS(12)='E6 :';
   ]
   ELSE [
   EXPLANATIONS(7)='secondary electron fluence';
   EXPLANATIONS(8)='average secondary electron energy';
   EXPLANATIONS(9)='secondary photon fluence';
   EXPLANATIONS(10)='average secondary photon energy';
   EXPLANATIONS(11)='secondary positron fluence';
   EXPLANATIONS(12)='average secondary positron energy';
   LABELS(7)='Se-:';LABELS(8)='E4 :';LABELS(9)='Sph:';
   LABELS(10)='E5 :';LABELS(11)='Se+:';LABELS(12)='E6 :';
   ]
   "5) Make the grid"
   CALL ZONEGRID(NR, NZ, 0, 1, NZ, RESULTS, UNCRTY, NCOMP, RADIAL_BINS,
                 DEPTH_BINS, LABELS, EXPLANATIONS);
] "END OF TEST FOR NREG>2"

"                     PRINT FLUENCE SPECTRA TO LISTING FILE   "
"                     ====================================    "
IF(IPRNTP = 0 | IPRNTP = 2) [ "OUTPUT TABLES OF FLUENCE"
 write(iout,'(''\f'')'); "this is the same as call prnter(...ipage=1)"
 "IPAGE=1;ICHPIN=13;ILPIN=6;CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE); page throw"
  IF(IPRIM = 0) [IPRIM1=1;]  ELSE [IPRIM1 = 2;]
  NPERPG = MAX(1, 66/(MAXIB+15)); "#SPECTRA PER PAGE"
  IPERPG=-1; "WILL COUNT HOW MANY SPECTRA ON CURRENT PAGE"
  "WRITE(IOUT,205) TITLE,DATEN,TIMEN;
  DO IP=1,IPRIM1 [
    " ******* IK: using wrapper subroutines for date and time.
    " Was: WRITE(IOUT,205) TITLE,DATEN,TIMEN;
    write(iout,205) title; call egs_fdate(iout); write(iout,*);
    DO IZ=1,NZ [
      ZLOW=ZPLANE(IZ);ZHIGH=ZPLANE(IZ+1);
      DO IX=1,NR [
        IF(IPRTSP($IRL)=0) [ "PRINT ONLY IF FLAG IS STILL ZERO"
          IF(IX = 1)[RLOW=0.;]ELSE[RLOW=RCYL(IX-1);]
          IPERPG=IPERPG+1;" NUMBER OF SPECTRA ALREADY ON PAGE"
          IF(IPERPG = NPERPG)[ "PAGE FULL"
            write(iout,'(''\f'')'); "this is the same as call prnter(ipage=1)"
            "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);page throw"
            " ******* IK: using wrapper subroutines for date and time.
            " Was:
            "WRITE(IOUT,205) TITLE,DATEN,TIMEN; IPERPG=0;
            write(iout,205) title; call egs_fdate(iout); write(iout,*);
            IPERPG=0;
          ]
          WRITE(IOUT,200) ZLOW,ZHIGH,$IRL; "HEADER RE DEPTH ZONE"
          IF(ISOURC ~= 2  &  ISOURC ~= 4)[ WRITE(IOUT,201) RLOW,RCYL(IX);]
          ELSEIF(ISOURC = 2) [WRITE(IOUT,202);]
          ELSEIF(ISOURC = 4) [WRITE(IOUT,203) RBEAM,RCYL(IX);"IX=1 ONLY"]

          IF(ISOURC ~= 3 & ISOURC ~= 21 & ISOURC~=22 & ISOURC~=23)[
            IF(IP = 1)[WRITE(IOUT,210);]
            ELSE[
              IF(IPRIM ~=4)[WRITE(IOUT,211);]ELSE[WRITE(IOUT,2115);]
           ]
          ]
          ELSE ["ISOURC=3, OR ISOURC=21,22,23"  IF(IP = 1)[WRITE(IOUT,208);]
               ELSE [IF(IPRIM ~=4)[WRITE(IOUT,209);]ELSE[WRITE(IOUT,2095);]]
          ]
          WRITE(IOUT,212);
          ILINE=0;
          DO IB=1,MAXIB[ILINE=ILINE+1;
            IF(SLOTE <= 0.0)[ETOP=BINTOP(IB);]ELSE[ETOP=SLOTE*dble(IB);]
              IF(MOD(ILINE,5) ~= 0)[WRITE(IOUT,220)
              ETOP,(SCFLU(IB,IZ,IX,IQL,IP),SCFLU2(IB,IZ,IX,IQL,IP),IQL=1,3),
              SCFLEP(IB,IZ,IX,IP),SCFLEP2(IB,IZ,IX,IP);
            ]
            ELSE[WRITE(IOUT,221)
              ETOP,(SCFLU(IB,IZ,IX,IQL,IP),SCFLU2(IB,IZ,IX,IQL,IP),IQL=1,3),
              SCFLEP(IB,IZ,IX,IP),SCFLEP2(IB,IZ,IX,IP);
            ]
          ]"end loop over IB"
          WRITE(IOUT,230)
            (SCTFLU(IZ,IX,IQL,IP),SCTFLU2(IZ,IX,IQL,IP),IQL=1,3),
            SCTLEP(IZ,IX,IP),SCTLEP2(IZ,IX,IP),
            (SCEAVE(IZ,IX,IQL,IP),SCEAVE2(IZ,IX,IQL,IP),IQL=1,3),
            SCELEP(IZ,IX,IP),SCELEP2(IZ,IX,IP);
        ]"end of IPRTSP($IRL)=0 if"
      ]"end of loop over IX"
    ]"end of loop over IZ"
  ]"end of loop over IP"
]"end of IPRNTP = 0 | IPRNTP = 2 if"
ELSEIF(IPRNTP = 1)["ADD CONDENSED PHOTON SPECTRAL OUTPUT"]

IF(IPLT = 1)CALL PLOTEN;"   PLOT SPECTRA"

RETURN;

"FORMATS"
%F
%I0
90    FORMAT(/' Final brem photons split into ',I3,' photons'/)
1001  FORMAT(/' ',T18,'Total # charged particle steps',T55,
     11PE10.3,' +/-',0PF4.1,'%'/
     2' ',T2,'Total # charged particle steps/initial history',T55,
     31PE10.3,' +/-',0PF4.1,'%'/
     4' ',T6,'# PRESTA-II steps/# charged particle steps',T58,
     5F7.3,' +/-',0PF4.1,'%')
200   FORMAT(/T10,' Depth coordinates:',T30,F9.4,' TO',F9.4,' cm',
     1 '  REGION =',I3/)
201   FORMAT(T17,'Radial coordinates:',T37,F9.4,' TO',F9.4,' cm')
202   FORMAT(T25,'Broad parallel beam results')
203   FORMAT(T5,'In central radial region of',F10.3,' cm,beam radius=',
     1    F10.3,' cm')
208   FORMAT(/T18,' Total fluence/(MeV)/source particle')
209   FORMAT(/T18,' Primary fluence/(MeV)/source particle')
2095  FORMAT(/T18,' Secondary fluence/(MeV)/source particle')
210   FORMAT(/T18,' Total fluence/(MeV)/unit incident fluence')
211   FORMAT(/T18,' Primary fluence/(MeV)/unit incident fluence')
2115  FORMAT(/T18,' Secondary fluence/(MeV)/unit incident fluence')
212   FORMAT(/'    Bintop',T17,'electrons',T34,'photons',T50,
     1       'positrons',T67,'e(-) + e(+)'/
     2       '    ------',T17,'---------',T34,'-------',T50,
     3       '---------',T67,'-----------')
220   FORMAT(' ',F9.4,2X,4(1PE9.3,'+-',0PF4.1,'%',1X))
221   FORMAT(' ',F9.4,2('-'),3(1PE9.3,'+-',0PF4.1,'%',1('-')),
     1       1PE9.3,'+-',0PF4.1,'%')
230   FORMAT(' ',9('-'),T13,4(16('-'),1X)/
     1       '    Totals',T13,4(1PE9.3,'+-',0PF4.1,'%',1X)/
     2       '     Avg E',T13,4(1PE9.3,'+-',0PF4.1,'%',1X)//)
%M
%I4
" ******* IK: using wrapper subroutines for date and time.
" Was: 205   FORMAT(80A1/T62,$DATEN_FORMAT,1X,$TIMEN_FORMAT);
205   FORMAT(80A1/T56,$);
;
END; "END OF SUBROUTINE OSUMRY"

%Q1
%E    "start of PLOTSN"

"******************************************************************************
"
"                       PLOTSN
"
"       This routine will prepare a plot and/or file of data points of
"       fluence vs. depth corresponding to a number of chosen radial zones,
"       planar zones, and of fluence vs. bin energy for a number of chosen
"       geometrical regions
"
"*******************************************************************************
"
"  PLOT CONTROL DELIMETERS:   :start plot control:
"                             :stop plot control:
"
"*******************************************************************************
"                             PLOT CONTROL INPUTS
"                             *******************
"*******************************************************************************
"
"CARD PL1
"
"   PLOTTING
"          = Off         (0)   NO PLOTS OR PLOT FILES TO BE PREPARED
"          = On          (1)   PLOTTING TO BE PREPARED OR PRINTED
"
"
"
"CARD PL4       (ONLY IF   PLOTTING= On)
"
"   EXTERNAL PLOT TYPE
"          = Point       (1)   POINT PLOT ON EXTERNAL PLOTTER
"          = Histogram   (2)   HISTOGRAM ON EXTERNAL PLOTTER
"          = Both        (3)   BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
"
"CARD PL5       (ONLY IF   PLOTTING= On)
"
"  DRAW FLUENCE PLOTS
"          = none       (1,0)  PLOT TOTAL FLUENCE (As a minimum)
"          = all        (1,1)  PLOT TOTAL AND PRIAMRIES
"          = primaries  (0,1)  PLOT PRIMARIES ONLY
"          = total      (1,0)  PLOT TOTAL FLUENCE (The minimum)
"
"CARD PL6       (ONLY IF   PLOTTING= On)
"
"  PLOTS FOR ELECTRONS
"          = Off         (0)   DON'T GENERATE PLOTS FOR ELECTRONS
"          = On          (1)   GENERATE PLOTS FOR ELECTRONS
"
"  PLOTS FOR PHOTONS
"          = Off         (0)   DON'T GENERATE PLOTS FOR PHOTONS
"          = On          (1)   GENERATE PLOTS FOR PHOTONS
"
"  PLOTS FOR POSITRONS
"          = Off         (0)   DON'T GENERATE PLOTS FOR POSITRONS
"          = On          (1)   GENERATE PLOTS FOR POSITRONS
"
"  PLOTS FOR E- AND E+
"          = Off         (0)   DON'T GENERATE PLOTS FOR E- AND E+
"          = On          (1)   GENERATE PLOTS FOR E- AND E+
"
"CARD PL7       (ONLY IF   PLOTTING= On)
"
"  START SPECTRAL PLOT IN REGION
"                      (M)  LOWER (STARTING) NUMBERS DEFINING THE REGIONS FOR
"                           WHICH SPECTRA ARE TO BE PRINTED IN .SPECTRA FILE.
"
"  STOP SPECTRAL PLOT IN REGION
"                      (M)  HIGHER (FINAL) NUMBERS DEFINING THE REGIONS FOR
"                           WHICH SPECTRA ARE TO BE PRINTED IN .SPECTRA FILE.
"
"CARD PL8       (ONLY IF   PLOTTING= On)
"
"   PLOT RADIAL REGION IX  (M)  RADIAL PLANE NUMBERS TO PLOT
"                               (= 0 FOR NO PLOTS)
"
"
"CARD PL9       (ONLY IF   PLOTTING= On)
"
"   PLOT PLANAR REGION IZ  (M)  PLANAR SLAB NUMBERS TO PLOT
"                               (= 0 FOR NO PLOTS)
"
"
"       VERSION 01      ADAPTED FROM DOSERZ     6/84    E.F.
"       VERSION 02      ADAPTED FROM DOSRZ      8/84    E.F.
"       VERSION 03      CHANGED FORMATS MAR 29 1985 D.W.O.R.
"       VERSION 04      CHANGED FORMATS APR 25 1998 A. Merovitz
"
"*******************************************************************************

SUBROUTINE PLOTSN;

$IMPLICIT-NONE;

COMIN/GetInput,USER/;

$INTEGER I,IPLTUNX,IPLTUN,IPRIMS,J,IRL,ILOW,IHIGH,ILA120,
         IZ,IX,IPRIM1,IP,IQ,IB,IRLR,IQR,IPR;
$REAL FLUMX,TFLUMX,FLUMIN,HISTXMIN,BIN_CUT,FMAX;


"***************************************************************************"
"*                         User defined MACROS                             *"
"***************************************************************************"
REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
;
"***************************************************************************"
"*                   Variables passed to the subroutine                    *"
"***************************************************************************"
"***************************************************************************"
"*                   Variables used to declare inputs                      *"
"***************************************************************************"
INTEGER NPLOTR, NPLOTZ;


"***************************************************************************"
"*                Variables used to point to the inputs                    *"
"***************************************************************************"
INTEGER NUM_IOPLOT,
        NUM_IPLTPL,
        NUM_IPLPHB,
        NUM_DFLUP,
        NUM_PLOTE,
        NUM_PLOTPH,
        NUM_PLOTPO,
        NUM_PLOTBO,
        NUM_PLSPKRL,
        NUM_PLSPKRH,
        NUM_IPLTRAD,
        NUM_IPLTPLN;
"--------------------------------------------------------------------------"
;
$REAL XCOORD($EBIN), YCOORD($EBIN), UNCERT($EBIN);
INTEGER NPTS, PLTYPE, AXISTYPE, CURVENUM, inte, CHECK;
INTEGER IZR, IXR;
INTEGER UNITNUM, IPLTSPEC;
CHARACTER*80 GRAPHTITLE;
CHARACTER*60 SERIESTITLE, XTITLE, YTITLE,SUBTITLE;
CHARACTER*4 CH_IZ, CH_IX, CH_IQ, CH_IP, CH_IRL;
CHARACTER*1 a(3);
character backslash;
LOGICAL NEGVAL;

;COMIN/GEOM,BOUNDS,IODAT1,IODAT2,PRINTC,PLOTC,SCORE,USEFUL/;
"March 9, 2012 DR added BOUNDS to correct first energy in point plot"


"GET INPUT DATA"
"=============="
I=0;
IVAL = IVAL + 1;
NUM_IOPLOT = IVAL;
VALUES_SOUGHT(IVAL)='PLOTTING';
NVALUE(IVAL)=1;
TYPE(IVAL)=3;
ALLOWED_INPUTS(IVAL,0)='OFF';
ALLOWED_INPUTS(IVAL,1)='ON';
DELIMETER='PLOT CONTROL';
$GET_INPUT(NUM_IOPLOT);
IPLT=VALUE(NUM_IOPLOT,1);

OUTPUT;(' *** INPUT CARD PL1 ***');
IF (IPLT = 1) [OUTPUT;(' Plotting files will be created'/);]

IF(IPLT = 0)[ OUTPUT;(' Plotting files will not be created'/);
            IPLTPL=0; "this is just in-case - shouldn't be needed"
]
ELSE [
   OUTPUT;(' *** INPUT CARD PL2 no longer used ***');

   OUTPUT;(/' *** INPUT CARD PL3 ***');

   "IVAL = IVAL + 1;
   "NUM_IPLTPL = IVAL;
   "VALUES_SOUGHT(IVAL)='EXTERNAL PLOTTER OUTPUT';
   "NVALUE(IVAL)=1;
   "TYPE(IVAL)=3;
   "ALLOWED_INPUTS(IVAL,0)='OFF';
   "ALLOWED_INPUTS(IVAL,1)='ON';

   "$GET_INPUT(NUM_IPLTPL);
   "IPLTPL=VALUE(NUM_IPLTPL,1);

    IPLTPL = 1; "now always on if plotting on"

    OUTPUT;(' FILES WILL BE PREPARED FOR EXTERNAL PLOTTER');
    IPLTUNX=23; "xvgr plot file"
    IPLTUN=3; "OUTPUT TO UNIT 3 FOR PLOTTER"
    $SKIP-LINE;
    OUTPUT;(/' *** INPUT CARD PL4 ***');

    IVAL = IVAL + 1;
    NUM_IPLPHB = IVAL;
    VALUES_SOUGHT(IVAL)='EXTERNAL PLOT TYPE';
    NVALUE(IVAL)=1;
    TYPE(IVAL)=3;
    ALLOWED_INPUTS(IVAL,1)='POINT';
    ALLOWED_INPUTS(IVAL,2)='HISTOGRAM';
    ALLOWED_INPUTS(IVAL,3)='BOTH';

    $GET_INPUT(NUM_IPLPHB);
    IPLPHB=VALUE(NUM_IPLPHB,1);

    OUTPUT IPLPHB;(' Point plot(1)/Histogram(2)/Both(3) will be prepared:',I2);
   $SKIP-LINE;

   OUTPUT;(' *** INPUT CARD PL5 ***');
   IF (IPRIM ~=0) [ "non-zero=> there is more than total spec scored"
      IVAL = IVAL + 1;
      NUM_DFLUP = IVAL;
      VALUES_SOUGHT(IVAL)='DRAW FLUENCE PLOTS';
      NVALUE(IVAL)=1;
      TYPE(IVAL)=3;
      ALLOWED_INPUTS(IVAL,1)='NONE';
      ALLOWED_INPUTS(IVAL,2)='ALL';
      ALLOWED_INPUTS(IVAL,3)='PRIMARIES';
      ALLOWED_INPUTS(IVAL,4)='TOTAL';

      $GET_INPUT(NUM_DFLUP);

      IPRIMS=int(VALUE(NUM_DFLUP,1));
      IF (IPRIMS=1)|(IPRIMS=4) ["none or total"
         IPLTTP(1)=1; IPLTTP(2)=0;
         OUTPUT;('Will plot only total fluence plots');
      ]
      IF (IPRIMS=2) ["all = primaries and total"
         IPLTTP(1)=1; IPLTTP(2)=1;
         OUTPUT;('Will plot total and primary/secondary plots');
      ]
      IF (IPRIMS=3) [ "primaries"
         IPLTTP(1)=0; IPLTTP(2)=1;
         OUTPUT ;('Will plot only primary/secondary plots ');
      ]
   ]
   ELSE [ "IPRIM=0 case"
      IPLTTP(1)=1; IPLTTP(2)=0;
      OUTPUT ;('Will plot only total since that is all scored'/);
   ]


   IVAL = IVAL + 1;
   NUM_PLOTE = IVAL;
   VALUES_SOUGHT(IVAL)='PLOTS FOR ELECTRONS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=3;
   ALLOWED_INPUTS(IVAL,1)='OFF';
   ALLOWED_INPUTS(IVAL,2)='ON';

   IVAL = IVAL + 1;
   NUM_PLOTPH = IVAL;
   VALUES_SOUGHT(IVAL)='PLOTS FOR PHOTONS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=3;
   ALLOWED_INPUTS(IVAL,1)='OFF';
   ALLOWED_INPUTS(IVAL,2)='ON';

   IVAL = IVAL + 1;
   NUM_PLOTPO = IVAL;
   VALUES_SOUGHT(IVAL)='PLOTS FOR POSITRONS';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=3;
   ALLOWED_INPUTS(IVAL,1)='OFF';
   ALLOWED_INPUTS(IVAL,2)='ON';

   IVAL = IVAL + 1;
   NUM_PLOTBO = IVAL;
   VALUES_SOUGHT(IVAL)='PLOTS FOR E- AND E+';
   NVALUE(IVAL)=1;
   TYPE(IVAL)=3;
   ALLOWED_INPUTS(IVAL,1)='OFF';
   ALLOWED_INPUTS(IVAL,2)='ON';

   $GET_INPUTS(NUM_PLOTE,NUM_PLOTBO);

   OUTPUT;(/' *** INPUT CARD PL6 ***');
   IF (VALUE(NUM_PLOTE,1)=2) [
      IPLTIQ(1)=1;
      OUTPUT;('     PLOT FOR ELECTRONS');
   ]
   ELSE [IPLTIQ(1)=0;OUTPUT;('     NO PLOTS FOR ELECTRONS');]
   IF (VALUE(NUM_PLOTPH,1)=2) [
      IPLTIQ(2)=1;
      OUTPUT;('     PLOT FOR PHOTONS');
   ]
   ELSE [IPLTIQ(2)=0; OUTPUT;('     NO PLOTS FOR PHOTONS');]
   IF (VALUE(NUM_PLOTPO,1)=2) [
      IPLTIQ(3)=1;
      OUTPUT;('     PLOT FOR POSITRONS');
   ]
   ELSE [IPLTIQ(3)=0;OUTPUT;('     NO PLOTS FOR POSITRONS');]
   IF (VALUE(NUM_PLOTBO,1)=2) [
      IPLTIQ(4)=1;
      OUTPUT;('     PLOT FOR ELECTRONS AND POSITRONS');
   ]
   ELSE [IPLTIQ(4)=0;OUTPUT;('     NO PLOTS FOR ELECTRONS AND POSITRONS');]
   $SKIP-LINE;

   IVAL = IVAL + 1;
   NUM_PLSPKRL = IVAL;
   VALUES_SOUGHT(IVAL)='START SPECTRAL PLOT IN REGION';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=2;  "region 1 is exterior vac"
   VALUE_MAX(IVAL)=NREG;  "NREG includes exterior"
   DEFAULT(IVAL)=2;

   IVAL = IVAL + 1;
   NUM_PLSPKRH = IVAL;
   VALUES_SOUGHT(IVAL)='STOP SPECTRAL PLOT IN REGION';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=2;
   VALUE_MAX(IVAL)=NREG;
   DEFAULT(IVAL)=NREG;

   $GET_INPUTS(NUM_PLSPKRL,NUM_PLSPKRH);

   OUTPUT;(' *** INPUT CARD PL7 ***');
   DO IRL=2, NREG [IPLOT(IRL)=0;] "DEFAULT PRINT NOTHING"
   DO J=1, NVALUE(NUM_PLSPKRL) [
      ILOW=VALUE(NUM_PLSPKRL,J);
      IHIGH=VALUE(NUM_PLSPKRH,J);
      IF (ILOW=0) [
         OUTPUT ;('NO SPECTRAL PLOTS');
         EXIT;
      ]
      IF (ILOW>IHIGH) [IHIGH=ILOW;]
      IF (ILOW=IHIGH) [
         OUTPUT ILOW;(' Will plot spectrum in region #',I3);
         IPLOT(ILOW)= 1;
      ]
      ELSE [
         DO IRL= ILOW, IHIGH [IPLOT(IRL)= 1;]
         OUTPUT ILOW,IHIGH;('  Will plot spectra from zones #',I3,' to  #',I3);
      ]
   ]

   OUTPUT;(/' *** INPUT CARD PL8 ***');
   IVAL = IVAL + 1;
   NUM_IPLTRAD = IVAL;
   VALUES_SOUGHT(IVAL)='PLOT RADIAL REGION IX';
   TYPE(IVAL)=0; "integers"
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NR;
   DEFAULT(IVAL)=NR;

   $GET_INPUT(NUM_IPLTRAD);
   DO J=1,NR [IPLOTR(J) = 0;]
   NPLOTR=NVALUE(NUM_IPLTRAD); "number of values input"
   IF (int(VALUE(NUM_IPLTRAD,1)) > 0) [
      DO J=1, NPLOTR [
         IPLOTR(int(VALUE(NUM_IPLTRAD,J))) = 1;
         OUTPUT int(VALUE(NUM_IPLTRAD,J));
                      ('Will plot fluence vs depth in radial zone ', I3);
      ]
   ]
   ELSE [ OUTPUT;(' No plot of fluence vs depth for radial zones'); ]

   OUTPUT;(/' *** INPUT CARD PL9 ***');

   IVAL = IVAL + 1;
   NUM_IPLTPLN = IVAL;
   VALUES_SOUGHT(IVAL)='PLOT PLANAR REGION IZ';
   TYPE(IVAL)=0;
   VALUE_MIN(IVAL)=0;
   VALUE_MAX(IVAL)=NZ;
   DEFAULT(IVAL)=NZ;

   DO J = 1, NZ [IPLOTZ(J) = 0;]
   $GET_INPUT(NUM_IPLTPLN);
   NPLOTZ=NVALUE(NUM_IPLTPLN);
   IF (VALUE(NUM_IPLTPLN,1) > 0) [
      DO J=1, NPLOTZ [
         IPLOTZ(int(VALUE(NUM_IPLTPLN,J))) = 1;
         OUTPUT int(VALUE(NUM_IPLTPLN,J));
                      ('Will plot fluence vs radius in planar slab ', I3);
      ]
   ]
   ELSE [ OUTPUT;(' No fluence vs radius plots'); ]

]  "END IPLT = 1, i.e. creating xmgr files"

RETURN;

ENTRY PLOTEN;
"==========="
%I2    "WE NEST 10 LEVELS SO INDENT LESS"

backslash=char(92);
IPLTSPEC=17; "OUTPUT FOR XVGRPLOT(*.spectra FILE)"
IPLTUNX=23;  "OUTPUT FOR XVGRPLOT(*.plotdat FILE)"

write(iout,'(''\f'')'); "this is the same as call prnter(...,ipage=1)"
"CALL PRNTER(16,6,IOUT,1);"
ILA120=1;
"RESET ILA120, GO TO TOP OF PAGE AND SET FLAG SAYING AT PAGE TOP"


/FLUMX,TFLUMX/=0.0;
FLUMIN=100000;
DO IZ=1,NZ [ "determine the max and min fluence"
  DO IX=1,NR[
    IF(IPRIM = 0) [IPRIM1=1;] ELSE [IPRIM1=2;]
    DO IP=1,IPRIM1[
      DO IQ=1,3[
        IF(TFLUMX < SCTFLU(IZ,IX,IQ,IP))[TFLUMX=SCTFLU(IZ,IX,IQ,IP);]
        DO IB=1,MAXIB[
          IF(FLUMX < SCFLU(IB,IZ,IX,IQ,IP))[FLUMX=SCFLU(IB,IZ,IX,IQ,IP);]
          IF(SCFLU(IB,IZ,IX,IQ,IP) >  0.0)[
            IF(FLUMIN > SCFLU(IB,IZ,IX,IQ,IP))[FLUMIN=SCFLU(IB,IZ,IX,IQ,IP);]
          ]
        ]
      ]
    ]
  ]
]

"                 PRINT FLUENCE SPECTRA TO .spectra FILE   "
"                 =====================================    "
"Plot of fluence zone results to file [-.spectra]"
"this was already opened in

DO I=1,80[GRAPHTITLE(I:I)=TITLE(I);]

UNITNUM=IPLTSPEC;
CURVENUM=0;
DO IQ=1,4 [ "Q=4 is for electrons and positrons"
            "NB IQ in this routine, PLOTSN, is NOT the same as IQ(np) on"
            "the stack.  Here it goes from 1(e-) to 4 (e- + e+)"
 IF(IPLTIQ(IQ) = 1) [ "only plot if requested for this charge"
  IF(IPRIM = 0) [IPRIM1=1;"total fluence only"] ELSE [IPRIM1=2;]
  DO IP=1,IPRIM1 [
  IF(IPLTTP(IP) = 1) [ "total or secondary if requested"
    DO IRL=2,NREG [ "for each region"
      $GET-IX-IZ(IRL);
      IF(IPLOT(IRL) = 1) [ "output if requested for this region"
      IF(IPLTPL = 1)  [ "create file for external plotter"
        "write to specific output files"

        "plotting subroutine for xvgrplot"
        "Implemented by Aaron Merovitz, Jan 1998"
        "For complete summary of the following variables see"
        "xvgrplot.mortran"
        NPTS=MAXIB;                 "number of points per graph"
        XTITLE='energy/MeV';
        IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
           YTITLE='(fluence/MeV)/incident particle /cm'//backslash//'S-2'
             //backslash//'NMeV'//backslash//'S-1'//backslash//'N';
        ]
        ELSE[
           YTITLE='(fluence/MeV)/incident fluence /MeV'//backslash//'S-1'
            //backslash//'N';
        ]
        " --------------------------- >"
        call egs_get_fdate(SUBTITLE);
        SUBTITLE='fluence vs. energy on '//SUBTITLE(1:24);
        HISTXMIN=BIN_CUT;       "value of lower X-bin (histograms only)"
        AXISTYPE=0;             "0 for no logs"

        IF(IPLPHB = 1 | IPLPHB = 3)[ "prepare a point plot"
             DO IB=1,MAXIB[
               IF(IB = 1) [ "this special case was not here pre Mar 9,2012"
                  OUTPUT PCUT(2),ECUT(2);
                     (' PLOTSN: PCUT(2),ECUT(2)=',2F10.4,' MeV');
                  OUTPUT;(' Plot routines assume constant ECUT/PCUT');
                  "PCUT(2) and ECUT(2) are in comin BOUNDS"
                   IF(IQ = 2) ["this is a photon
                      XCOORD(IB) = (BINTOP(IB) + PCUT(2))/2.
                   ]
                   ELSE ["a charged particle"
                      XCOORD(IB) = (BINTOP(IB) + (ECUT(2)-PRM))/2.
                   ]
               ]"end of IB=1 block"
               ELSE [
                   XCOORD(IB) = (BINTOP(IB)+BINTOP(IB-1))/2;
               ]
               IF (IQ < 4) [
                 YCOORD(IB) = SCFLU(IB,IZ,IX,IQ,IP);
                 UNCERT(IB) = SCFLU(IB,IZ,IX,IQ,IP)*SCFLU2(IB,IZ,IX,IQ,IP)/100.;
               ]
               IF (IQ=4) [  "e- plus e+"
                 YCOORD(IB) = SCFLU(IB,IZ,IX,1,IP)+SCFLU(IB,IZ,IX,3,IP);
                 UNCERT(IB) = ((SCFLU(IB,IZ,IX,1,IP)*SCFLU2(IB,IZ,IX,1,IP))+
                              (SCFLU(IB,IZ,IX,3,IP)*
                                   SCFLU2(IB,IZ,IX,3,IP)))/100.;
               ]
             ]
             "Convert regional number(IRL) to a character string"
             IRLR=IRL; $CONVERT_INT(IRLR)_TO_CHAR(CH_IRL);
             "Convert charge number(IQ) to a character string"
             IQR=IQ-2; $CONVERT_INT(IQR)_TO_CHAR(CH_IQ);
             "Convert primary indicator(IP) to a character string"
             IPR=IP; $CONVERT_INT(IPR)_TO_CHAR(CH_IP);


             SERIESTITLE='IRL='//CH_IRL//'IQ='//CH_IQ//'IP='//CH_IP;
             PLTYPE=0;                 "histogram=1, XY-plot=0"
             HISTXMIN=BIN_CUT;       "value of lower X-bin (histograms only)"
             "plot XY-graph"
             CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                            NPTS, CURVENUM, SERIESTITLE,
                            XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                            UNITNUM, PLTYPE, HISTXMIN, AXISTYPE);
           CURVENUM=CURVENUM+1; "DEFINE A NEW PLOT"
        ]  "end of point plot"

        IF(IPLPHB = 2 | IPLPHB = 3)[  "prepare a histogram plot"
            OUTPUT BINTOP(1);(' PLOTSN: BINTOP(1) =',F10.4,' MeV');
            DO IB=1,MAXIB[
               XCOORD(IB) = BINTOP(IB);
               IF (IQ < 4) [
                 YCOORD(IB) = SCFLU(IB,IZ,IX,IQ,IP);
                 UNCERT(IB) = SCFLU(IB,IZ,IX,IQ,IP)*SCFLU2(IB,IZ,IX,IQ,IP)/100.;
               ]
               IF (IQ=4) [
                 YCOORD(IB) = SCFLU(IB,IZ,IX,1,IP)+SCFLU(IB,IZ,IX,3,IP);
                 UNCERT(IB) = ((SCFLU(IB,IZ,IX,1,IP)*SCFLU2(IB,IZ,IX,1,IP))+
                              (SCFLU(IB,IZ,IX,3,IP)*
                                      SCFLU2(IB,IZ,IX,3,IP)))/100.;
               ]
            ]

            "The following used ECUTIN and PCUTIN (before Mar 2012)"
            "The problem was that if the user left these 0.0 on input"
            "the low energy of the bin was assumed to be 0.0"
            "We now assume that the cutoffs in region 2 are the same"
            "everywhere"
            "Had to add comin BOUNDS to PLOTSN to get ECUT/PCUT"
            IF(IQ=2)[BIN_CUT=PCUT(2);] ELSE [BIN_CUT=ECUT(2)-PRM;]

             "Convert regional number(IRL) to a character string"
             IRLR=IRL; $CONVERT_INT(IRLR)_TO_CHAR(CH_IRL);
             "Convert primary indicator(IP) to a character string"
             IPR=IP; $CONVERT_INT(IPR)_TO_CHAR(CH_IP);
             "Convert charge number(IQ) to a character string"
             IQR=IQ-2; $CONVERT_INT(IQR)_TO_CHAR(CH_IQ);

             NPTS=MAXIB;                  "number of points per graph"
             SERIESTITLE='IRL='//CH_IRL//'IQ='//CH_IQ//'IP='//CH_IP;
             PLTYPE=1;                 "histogram=1, XY-plot=0"
             HISTXMIN=BIN_CUT;       "value of lower X-bin (histograms only)"
             "plot histogram"
             CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                            NPTS, CURVENUM, SERIESTITLE,
                            XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                            UNITNUM, PLTYPE, HISTXMIN, AXISTYPE);
             CURVENUM=CURVENUM+1; "DEFINE A NEW PLOT"
        ]    "END OF HISTOGRAM PLOT"
      ]  "END OF IPLTPL=1 i.e. external plotter"
      ] "END OF IPLOT(IRL)=1 LOOP"
    ] "END IRL LOOP"
    ] "end if block if plotting requested"
    ] "end do IP loop"
 ] "end if IQ loop"
] "end do IQ loop"

"               FLUENCE VS DEPTH PLOTS(.plotdat FILE) "
"               ===================================== "
"Line printer output removed, A Merovitz 98"
FMAX=0.0;
"DO IZ=1,NZ [FMAX=MAX(FMAX,SCTFLU(IZ,IX,IQ,IP));]"
DO IZ=1,NZ [ IF( SCTFLU(IZ,IX,IQ,IP)>FMAX ) FMAX=SCTFLU(IZ,IX,IQ,IP); ]
IF (FMAX ~=0.0) [
   WRITE(IOUT,*) 'LINEPRINTER OUTPUT NO LONGER AVAILABLE- see xmgr data files';
]
"Plot of fluence zone results to file [-.plotdat]"
"this file is now opened by subroutine egs_init"

UNITNUM=IPLTUNX;
CURVENUM=0;
DO IQ=1,3[
 IF(IPLTIQ(IQ) = 1) [ "only plot if requested for this charge"
  DO IP=1,IPRIM1 [  "total and then primary fluence if calculated"
  IF(IPLTTP(IP) = 1) [ "total or primaries if requested"
  DO IX=1,NR["loop over posssible radial zones for fluence vs depth plot"
    IF(IPLOTR(IX) = 1)[
      "NOW PREPARE PLOT"
      IF(IPLTPL = 1)[
        "WRITE INTO FILES FOR EXTERNAL PLOTTER"
        "plotting subroutine for xvgrplot"
        "Implemented by Aaron Merovitz, Jan 1998"

        "For complete summary of the following variables see"
        "xvgrplot.mortran"
        NPTS=NZ;                     "number of points per graph"
        " --------------------------- >"
        /* Check NPTS is not larger than array size */
        IF (NPTS > $PLTDIM)[
           OUTPUT NPTS,$PLTDIM;(
           '*** WARNING: SUBROUTINE PLOTSN ********'/,
           'Number of plotting points NPTS=',i5/,
           'larger than max. allowed $PLTDIM=',i5/,
           'Setting NPTS to $PLTDIM.'/,
           'You can reset $PLTDIM in your user-code!'/,
           '****************************************'/
           );
           NPTS=$PLTDIM;
        ]

        call egs_get_fdate(SUBTITLE);
        SUBTITLE='fluence vs. depth on '//SUBTITLE(1:24);
        XTITLE='depth/cm';
        IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
           YTITLE='fluence/incident particle /cm'//backslash//'S-2'
            //backslash//'N';
        ]
        ELSE[
           YTITLE='fluence/incident fluence';
        ]
        AXISTYPE=0;             "0 for no logs"
        IF(IPLPHB = 1 | IPLPHB = 3)[
        "POINT PLOT"
           DO IZ=1,NPTS [
             XCOORD(IZ) = (ZPLANE(IZ)+ZPLANE(IZ+1))/2.;
             YCOORD(IZ) = SCTFLU(IZ,IX,IQ,IP);
             UNCERT(IZ) = SCTFLU(IZ,IX,IQ,IP)*SCTFLU2(IZ,IX,IQ,IP)/100.;
           ]


           "Convert primary indicator(IP) to a character string"
           IPR=IP; $CONVERT_INT(IPR)_TO_CHAR(CH_IP);
           "Convert radial zone number(IX) to a character string"
           IXR=IX; $CONVERT_INT(IXR)_TO_CHAR(CH_IX);
           "Convert charge (IQR) to character string"
           IQR=IQ-2; $CONVERT_INT(IQR)_TO_CHAR(CH_IQ);
           SERIESTITLE='radial zone='//CH_IX//' IQ='//CH_IQ//' IP='//CH_IP;
           PLTYPE=0;                 "histogram=1, XY-plot=0"
           HISTXMIN=ZPLANE(1);       "value of lower X-bin (histograms only)"
           "plot XY-graph"
           CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                          NPTS, CURVENUM, SERIESTITLE,
                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                          UNITNUM, PLTYPE, HISTXMIN, AXISTYPE);
           CURVENUM=CURVENUM+1; "DEFINE A NEW PLOT"
        ]  "END OF POINT PLOT"

        IF(IPLPHB = 2 | IPLPHB = 3)[
        "HISTOGRAM PLOT"
           DO IZ=1,NPTS [
             XCOORD(IZ) = ZPLANE(IZ+1);
             YCOORD(IZ) = SCTFLU(IZ,IX,IQ,IP);
             UNCERT(IZ) = SCTFLU(IZ,IX,IQ,IP)*SCTFLU2(IZ,IX,IQ,IP)/100.;
           ]
           "Convert primary indicator(IP) to a character string"
           IPR=IP; $CONVERT_INT(IPR)_TO_CHAR(CH_IP);
           "Convert radial zone number(IX) to a character string"
           IXR=IX; $CONVERT_INT(IXR)_TO_CHAR(CH_IX);
           "Convert charge (IQR) to character string"
           IQR=IQ-2; $CONVERT_INT(IQR)_TO_CHAR(CH_IQ);
           SERIESTITLE='radial zone='//CH_IX//' IQ='//CH_IQ//' IP='//CH_IP;
           PLTYPE=1;                 "histogram=1, XY-plot=0"
           HISTXMIN=ZPLANE(1);     "value of lower X-bin (histograms only)"
           "plot histogram"
           CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                          NPTS, CURVENUM, SERIESTITLE,
                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                          UNITNUM, PLTYPE, HISTXMIN, AXISTYPE);
           CURVENUM=CURVENUM+1; "DEFINE A NEW PLOT"
        ]  "END OF HISTOGRAM PLOT"
      ]  "END OF IPLTPL=1"
    ]  "end of if IPLOTR(IX""
  ] "end of IX loop for fluence vs depth in radial zones"

    "                  FLUENCE VS RADIUS PLOTS     "
    "                  =======================     "
       DO IZ=1,NZ ["loop over depth slabs for fluence vs radius plots"
          IF(IPLOTZ(IZ) = 1) [
             IF(IPLTPL = 1) [
                "plotting subroutine for xvgrplot"
                "Implemented by Aaron Merovitz, Jan 1998"

                "For complete summary of the following variables see"
                "xvgrplot.mortran"
                NPTS=NR;                  "number of points per graph"
                XTITLE='radius/cm';
                IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
                   YTITLE='fluence/incident particle /cm'//backslash//'S-2'
                    //backslash//'N';

                ]
                ELSE[
                   YTITLE='fluence/incident fluence';
                ]
                " --------------------------- >"
                call egs_get_fdate(SUBTITLE);
                SUBTITLE='fluence vs. radius on '//SUBTITLE(1:24);
                AXISTYPE=0;       "0 for no logs"

                IF(IPLPHB = 1 | IPLPHB = 3)[ "POINT PLOT"
                   DO IX=1,NR [
                      XCOORD(IX) = (RCYL(IX)+RCYL(IX-1))/2;
                      IF (IQ < 4) [
                        YCOORD(IX) = SCTFLU(IZ,IX,IQ,IP);
                        UNCERT(IX) = SCTFLU(IZ,IX,IQ,IP)*
                                      SCTFLU2(IZ,IX,IQ,IP)/100.;
                      ]
                      IF (IQ=4) [
                        YCOORD(IX) = SCTFLU(IZ,IX,1,IP)+SCTFLU(IZ,IX,3,IP);
                        UNCERT(IX) = ((SCTFLU(IZ,IX,1,IP)*SCTFLU2(IZ,IX,1,IP))+
                              (SCTFLU(IZ,IX,3,IP)*SCTFLU2(IZ,IX,3,IP)))/100.;
                      ]
                   ]
                   "Convert planar zone number(IZ) to a character string"
                   IZR=IZ; $CONVERT_INT(IZR)_TO_CHAR(CH_IZ);
                   "Convert primary indicator(IP) to a character string"
                   IPR=IP; $CONVERT_INT(IPR)_TO_CHAR(CH_IP);
                   "Convert charge (IQR) to character string"
                   IQR=IQ-2; $CONVERT_INT(IQR)_TO_CHAR(CH_IQ);
     SERIESTITLE='planar zone='//CH_IZ//' IQ='//CH_IQ//' IP='//CH_IP;
                   PLTYPE=0;           "histogram=1, XY-plot=0"
                   HISTXMIN=0.0;       "value of lower X-bin (histograms only)"
                   "plot XY-graph"
                   CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                                  NPTS, CURVENUM, SERIESTITLE,
                                  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                                  UNITNUM, PLTYPE, HISTXMIN, AXISTYPE);
                   CURVENUM=CURVENUM+1; "DEFINE A NEW PLOT"
                ]  "end of point plot"

                IF(IPLPHB = 2 | IPLPHB = 3)[ "HISTOGRAM PLOT"
                   DO IX=1,NR [
                      XCOORD(IX) = RCYL(IX);
                      IF (IQ < 4) [
                        YCOORD(IX) = SCTFLU(IZ,IX,IQ,IP);
                        UNCERT(IX) = SCTFLU(IZ,IX,IQ,IP)*
                                      SCTFLU2(IZ,IX,IQ,IP)/100.;
                      ]
                      IF (IQ=4) [
                        YCOORD(IX) = SCTFLU(IZ,IX,1,IP)+SCTFLU(IZ,IX,3,IP);
                        UNCERT(IX) = ((SCTFLU(IZ,IX,1,IP)*SCTFLU2(IZ,IX,1,IP))+
                              (SCTFLU(IZ,IX,3,IP)*SCTFLU2(IZ,IX,3,IP)))/100.;
                      ]
                   ]
                   "Convert planar zone number(IZ) to a character string"
                   IZR=IZ; $CONVERT_INT(IZR)_TO_CHAR(CH_IZ);
                   "Convert primary indicator(IP) to a character string"
                   IPR=IP; $CONVERT_INT(IPR)_TO_CHAR(CH_IP);
                   "Convert charge (IQR) to character string"
                   IQR=IQ-2; $CONVERT_INT(IQR)_TO_CHAR(CH_IQ);
              SERIESTITLE='planar zone='//CH_IZ//' IQ='//CH_IQ//' IP='//CH_IP;
                   PLTYPE=1;          "histogram=1, XY-plot=0"
                   HISTXMIN=0.0;      "value of lower X-bin (histograms only)"
                   "plot histogram"
                   CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
                                  NPTS, CURVENUM, SERIESTITLE,
                                  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
                                  UNITNUM, PLTYPE, HISTXMIN, AXISTYPE);
                   CURVENUM=CURVENUM+1; "DEFINE A NEW PLOT"
                ]  "END OF HISTOGRAM"
              ]  "END OF IPLTPL=1"
            ] "end of if IZ loop"
          ]  "end of do IZ loop"

       ]  "END OF IPLTTP(IP)=1"
    ]  "END OF IP LOOP"
 ]  "END OF IPLTIQ(IQ)=1"
]  "END OF IQ LOOP"

"CALL PRNTER(13,6,IOUT,0);  RESET CHAR/INCH ON  LA120"
RETURN;

" ******* IK: using wrapper subroutines for date and time.
" Was:
"99    FORMAT(' ',80A1//' Calculation using FLURZnrc(EGSnrc) '$VERSION' ',
"            T70,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
"100   FORMAT('1',80A1//' Calculation using FLURZnrc(EGSnrc) '$VERSION' ',
"            T70,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
100   FORMAT('1',80A1//' Calculation using FLURZnrc(EGSnrc) '$VERSION' ',
            T56,$);
%F
%I0
101   FORMAT('1'/)
102   FORMAT(' '//11X,'Fluence vs depth plot for radial zone #',I2,
     1 '   normalized to',1PE13.3/' FROM',F5.1)
103   FORMAT(' '//11X,'Fluence vs radius plot for planar region #',I2,
     1 '   normalized to',1PE13.3)
104   FORMAT(' '//11X,'Fluence spectrum for region #',I4,
     1'  radial zone=',I2, '  depth zone=',I3,
     2'  normalized to',1PE13.3)
130   FORMAT(' Maximum fluence = 0.000, no plotting will be done')
2001  FORMAT('P    ',I2,'     ****start of another plot*****   '/
     1'L           1'/T11,'-1',T23,'40',T36,'6',T46,'150',T60, '0'/
     2'energy / MeV'/
     3'L           2'/T11,'50',T23,'-1',T36,'6',T46,
     4 '100',T60, '1'/'fluence/MeV /incident fluence'/
     5 'L           3'/T10,' -1',T22,'720',T36,'6',T46,
     6 '100',T60, '0'/40A1,'IZ=',I2,'  IX=',I2)
2002  FORMAT('P    ',I2,'     ****start of another plot*****   '/
     1'L           1'/T11,'-1',T23,'40',T36,'6',T46,'150',T60, '0'/
     2'depth / cm '/
     3'L           2'/T11,'50',T23,'-1',T36,'6',T46,
     4 '100',T60, '1'/'total fluence / incident fluence'/
     5 'L           3'/T10,' -1',T22,'720',T36,'6',T46,
     6 '100',T60, '0'/40A1,'IZ=',I2,'  IX=',I2)
2003  FORMAT('P    ',I2,'     ****start of another plot*****   '/
     1'L           1'/T11,'-1',T23,'40',T36,'6',T46,'150',T60, '0'/
     2'radius / cm '/
     3'L           2'/T11,'50',T23,'-1',T36,'6',T46,
     4 '100',T60, '1'/'total fluence / incident fluence'/
     5 'L           3'/T10,' -1',T22,'720',T36,'6',T46,
     6 '100',T60, '0'/40A1,'IZ=',I2,'  IX=',I2)
2009  FORMAT('@    legend string',I2,' "fluence/MeV IZ,IX,IQ=',
     1  I2,I3,I3,'"')
%M
END;  "last line of SUBROUTINE PLOTSN"

%E    "start of subroutine hownear"
"========================================================================

         subroutine hownear(tperp,x,y,z,ir);

"========================================================================

"The following is the $CALL-HOWNEAR macro for PRESTA-II
REPLACE {$CALL-HOWNEAR(#);} WITH
{
    call hownear({P1},x(np),y(np),z(np),ir(np));
}

$IMPLICIT-NONE;

COMIN/GEOM/;

"Subroutine arguments
$REAL
    tperp, "nearest distance to any boundary (output)
    x,     "x-position of the particle (input)
    y,     "y-position of the particle (input)
    z      "z-position of the particle (input)
;
$INTEGER
    ir     "region number of the particle
;

"Local variables

$REAL
    r "cylindrical radius
;
$INTEGER
    ix, "current cylindrical radius number
    iz  "current planar slab number
;
r = sqrt(x**2 + y**2);
$GET-IX-IZ(ir);
tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r);
IF(ix ~= 1)
[
    tperp = min(tperp,r - rcyl(ix - 1));
]

return;
end;

subroutine combine_results(file_name);
implicit none;
character*(*) file_name;
;COMIN/SCORE,RANDOM,IODAT2,GEOM,SOURCE/;
$INTEGER egs_get_unit,lnblnk1;
$INTEGER iout,itmax,ix,iz,it,iql,ib,iorstrt;
REAL*8 TSCSTP,TSCSTP2,TSCFLU,TSCFLU2,TSCEAVE,TSCEAVE2,TSCEAVE_COV,TSCTFLU,
       TSCTFLU2,TSCFLEP,TSCFLEP2,TSCELEP,TSCELEP2,TSCELEP_COV,TSCTLEP,
       TSCTLEP2,TMPPIISTP;
$LONG_INT TMPNCASE,TMPNNREAD;
$REAL TMPTMCPU;
$LOGICAL first_time;
data first_time/.true./;
save first_time;

iout=1;
IF(IPRIM = 0)[ITMAX=1;]ELSE[ITMAX=$MAXIT;]

IF( first_time ) [

    DATCOUNT=0;

    first_time = .false.;

    OUTPUT ;(/1X,'Summing the following .egsdat files');
    OUTPUT ; (1X,'------------------------------------'/);
    WRITE(IOUT,'(/1X,''Summing .egsdat files'')');
    WRITE(IOUT,'(1X,''---------------------''/)');

    /TMCPUO,NCASEO,NNREAD,PIISTP/=0;
    /SCSTP,SCSTP2/=0;
    DO IX=1,NR[
           DO IZ=1,NZ[
              DO IT=1,ITMAX[
                 DO IQL=1,3[
                    DO IB=1,MAXIB[
                       /SCFLU(IB,IZ,IX,IQL,IT),SCFLU2(IB,IZ,IX,IQL,IT)/=0.;
                    ]
                    /SCEAVE(IZ,IX,IQL,IT),SCEAVE2(IZ,IX,IQL,IT)/=0.;
                    /SCEAVE_COV(IZ,IX,IQL,IT),SCTFLU(IZ,IX,IQL,IT)/=0.;
                    SCTFLU2(IZ,IX,IQL,IT)=0.;
                 ]
                 DO IB=1,MAXIB[
                    /SCFLEP(IB,IZ,IX,IT),SCFLEP2(IB,IZ,IX,IT)/=0.;
                 ]
                 /SCELEP(IZ,IX,IT),SCELEP2(IZ,IX,IT),SCELEP_COV(IZ,IX,IT)/=0.;
                 /SCTLEP(IZ,IX,IT),SCTLEP2(IZ,IX,IT)/=0.;
              ]
           ]
    ]
]

IORSTRT=egs_get_unit(4); "SET UNIT 4 FOR THE FILES TO BE READ"
WRITE(IOUT,'(A)') $cstring(file_name);
WRITE(6,'(A)') $cstring(file_name);
open(IORSTRT,file=file_name,status='old',err=:EOF_RS1:);

DATCOUNT=DATCOUNT+1;

READ(IORSTRT,*) TSCSTP,TSCSTP2;
SCSTP=SCSTP+TSCSTP;SCSTP2=SCSTP2+TSCSTP2;

DO IX=1,NR[
     DO IZ=1,NZ[
        DO IT=1,ITMAX[
           DO IQL=1,3[
               DO IB=1,MAXIB[
                  READ(IORSTRT,*)TSCFLU,TSCFLU2;
                  SCFLU(IB,IZ,IX,IQL,IT)=SCFLU(IB,IZ,IX,IQL,IT)+
                                            TSCFLU;
                  SCFLU2(IB,IZ,IX,IQL,IT)=SCFLU2(IB,IZ,IX,IQL,IT)+
                                            TSCFLU2;
               ]
               READ(IORSTRT,*)TSCEAVE,TSCEAVE2,TSCEAVE_COV,
                              TSCTFLU,TSCTFLU2;
               SCEAVE(IZ,IX,IQL,IT)=SCEAVE(IZ,IX,IQL,IT)+TSCEAVE;
               SCEAVE2(IZ,IX,IQL,IT)=SCEAVE2(IZ,IX,IQL,IT)+TSCEAVE2;
               SCEAVE_COV(IZ,IX,IQL,IT)=SCEAVE_COV(IZ,IX,IQL,IT)+
                                             TSCEAVE_COV;
               SCTFLU(IZ,IX,IQL,IT)=SCTFLU(IZ,IX,IQL,IT)+TSCTFLU;
               SCTFLU2(IZ,IX,IQL,IT)=SCTFLU2(IZ,IX,IQL,IT)+TSCTFLU2;
           ]
           DO IB=1,MAXIB[
               READ(IORSTRT,*)TSCFLEP,TSCFLEP2;
               SCFLEP(IB,IZ,IX,IT)=SCFLEP(IB,IZ,IX,IT)+TSCFLEP;
               SCFLEP2(IB,IZ,IX,IT)=SCFLEP2(IB,IZ,IX,IT)+TSCFLEP2;
           ]
           READ(IORSTRT,*)TSCELEP,TSCELEP2,TSCELEP_COV,TSCTLEP,TSCTLEP2;
            SCELEP(IZ,IX,IT)=SCELEP(IZ,IX,IT)+TSCELEP;
            SCELEP2(IZ,IX,IT)=SCELEP2(IZ,IX,IT)+TSCELEP2;
            SCELEP_COV(IZ,IX,IT)=SCELEP_COV(IZ,IX,IT)+
                                 TSCELEP_COV;
            SCTLEP(IZ,IX,IT)=SCTLEP(IZ,IX,IT)+TSCTLEP;
            SCTLEP2(IZ,IX,IT)=SCTLEP2(IZ,IX,IT)+TSCTLEP2;
        ]
     ]
]
$RETRIEVE RNG STATE FROM UNIT IORSTRT;
READ(IORSTRT,*) TMPNCASE,TMPTMCPU,TMPNNREAD,TMPPIISTP;
TMCPUO=TMCPUO+TMPTMCPU;
NCASEO=NCASEO+TMPNCASE;
PIISTP=PIISTP+TMPPIISTP;
NNREAD=NNREAD+TMPNNREAD;
write(6,*) '  ncase = ',TMPNCASE,' cpu = ',TMPTMCPU,' total cpu = ',
  TMCPUO;
write(iout,*) '  ncase = ',TMPNCASE,' cpu = ',TMPTMCPU,' total cpu = ',
  TMCPUO;
CLOSE(UNIT=IORSTRT);
return;
:EOF_RS1:;
WRITE(6,*) 'Error opening file', $cstring(file_name);
return; end;
"       end of flurznrc.mortran"
