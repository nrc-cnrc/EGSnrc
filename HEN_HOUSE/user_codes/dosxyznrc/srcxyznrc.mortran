%C80
"#############################################################################"
"                                                                             "
"  EGSnrc dosxzynrc application source routines                               "
"  Copyright (C) 2015 National Research Council Canada                        "
"                                                                             "
"  This file is part of EGSnrc.                                               "
"                                                                             "
"  EGSnrc is free software: you can redistribute it and/or modify it under    "
"  the terms of the GNU Affero General Public License as published by the     "
"  Free Software Foundation, either version 3 of the License, or (at your     "
"  option) any later version.                                                 "
"                                                                             "
"  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
"  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
"  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
"  more details.                                                              "
"                                                                             "
"  You should have received a copy of the GNU Affero General Public License   "
"  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
"                                                                             "
"#############################################################################"
"                                                                             "
"  Author:          Dave Rogers, 1986                                         "
"                                                                             "
"  Contributors:    Alex Bielajew                                             "
"                   Bruce Faddegon                                            "
"                   George Ding                                               "
"                   Charlie Ma                                                "
"                   Mark Holmes                                               "
"                   Blake Walters                                             "
"                   Iwan Kawrakow                                             "
"                   Frederic Tessier                                          "
"                   Marc-Andre Renaud                                         "
"                                                                             "
"#############################################################################"
"                                                                             "
"  The contributors named above are only those who could be identified from   "
"  this file's revision history.                                              "
"                                                                             "
"  This code was originally part of the BEAM code system for Monte Carlo      "
"  simulation of radiotherapy treatments units. It was developed at the       "
"  National Research Council of Canada as part of the OMEGA collaborative     "
"  research project with the University of Wisconsin. The system was          "
"  originally described in:                                                   "
"                                                                             "
"  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
"  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
"  Medical Physics 22, 503-524 (1995).                                        "
"                                                                             "
"  BEAM User Manual                                                           "
"  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
"  NRC Report PIRS-509A (rev D)                                               "
"                                                                             "
"  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
"  made significant contributions to the code system, in particular the GUIs  "
"  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
"  played important roles in the overall OMEGA project within which the BEAM  "
"  code system was developed.                                                 "
"                                                                             "
"  There have been major upgrades in the BEAM code starting in 2000 which     "
"  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
"  EGSnrc, the inclusion of history-by-history statistics and the development "
"  of the directional bremsstrahlung splitting variance reduction technique.  "
"                                                                             "
"#############################################################################"
"                                                                             "
"  EGSnrc dosxyznrc application routines to input various sources, including  "
"  phase space files and beam characterization.                               "
"                                                                             "
"#############################################################################"


%C80         "80 column mortran input"
!INDENT M 4; "Indent 4 spaces for each nesting level in mortran listing file"
!INDENT F 4; "Indent 4 spaces for each nesting level in fortran output file"
%Q1          "Automatically close quotes at end of the line"
;
"*******************************************************************************

"
"                         ***************************        ""toc:
"                         *                         *        ""toc:
"                         * srcxyznrc.mortran $Revision: 1.39 $  *  ""toc:
"                         *                         *        ""toc:
"                         ***************************        ""toc:
"
"    Routines to be used with dosxyz to input various sources including
"    phase space files, and beam characterization.
"
"    1) srcinput: Parameter input
"    2) srcinit : Calculate 'one time only constants'
"    3) srchst  : Calculate input phase space for each history
"    4) srcout  : Print summary of source-related input data
"
"    Maintained under sccs control at NRCC
"
"
%E    "srcxyznrc.mortran start of input description
"*******************************************************************************
"
"                Input source parameters read by srcxyznrc.mortran       ""toc:
"                ==============================================
"              ($Revision: 1.39 $ last edited $Date: 2014/10/08 15:10:11 $)
"              (see section 4 of DOSXYZnrc User's Manual for details)
"
"*******************************************************************************
"
"Record SC1-0  Parallel beam incident on the front with rectangular collimation
"                                        (front is the zbound(1) plane)
"
"       iqin,isource,xinl,xinu,yinl,yinu,thetax,thetay,thetaz
"
"               iqin       Charge of the incident beam (defaults to 0)
"               isource    = 0
"               xinl,xinu  Lower and upper x-bounds on source (in cm)
"               yinl,yinu  Lower and upper y-bounds on source (in cm)
"               thetax     Angle of the beam relative to the X-axis (degrees)
"               thetay     Angle of the beam relative to the Y-axis (degrees)
"               thetaz     Angle of the beam relative to the Z-axis (degrees)
"                          (incident angles default to 90,90,0)
"
"-------------------------------------------------------------------------------
"
"Record SC1-1  Parallel beam incident from any direction with rectangular
"            collimation
"
"       iqin,isource,xiso,yiso,ziso,theta,phi,xcol,ycol,phicol
"
"               iqin        Charge of the incident beam (defaults to 0)
"               isource     = 1
"               x|y|z|iso   x|y|z|-coordinates of the isocenter
"               theta       angle between the +z direction and a line joining
"                           the center of the beam to the isocenter
"               phi         angle  between the +x direction and the
"                           projection of the line joining the center of the
"                           beam to the isocenter on the xy plane
"               x|y|col     total x- and y- widths of the beam on the plane
"                           perpendicular to the beam direction, defined
"                           by the center of the beam and the isocenter
"               phicol      angle by which the collimator is rotated in the
"                           collimator plane perpendicular to the beam direction
"                           Phicol is determined for theta=0 or 180 and phi=0.
"                           The positive sense of rotation is counterclockwise
"                           as one sights down the beam direction.
"
"-------------------------------------------------------------------------------
"
"Record SC1-2  Full phase-space source file, particles incident on front face
"
"       iqin,isource,xiso,yiso,ziso,theta,phi,dsource,phicol,i_dbs,r_dbs,
"                                         ssd_dbs,z_dbs,e_split
"
"               iqin(iqphsp)= 0 only photons from ph-sp file will be used
"                           = 1 only positrons will be used
"                           =-1 only electrons will be used
"                           = 2 all the particles will be used
"                           internally renamed as iqphsp
"               isource     =  2
"               x|y|z|iso   x|y|z|-coordinates of the isocenter
"               theta       angle between the +z direction and a line joining
"                           the origin in the phase space plane to the
"                           isocenter.  theta=180 degrees for a beam down
"                           from the top.
"               phi         angle  between the +x direction and the
"                           projection of the line joining the origin in the
"                           phase space plane to the isocenter on the xy plane
"               dsource     For a BEAMnrc format phase space source: absolute
"                           distance from the isocenter to the
"                           source center, which is, by definition, the
"                           origin in the phase space plane.  For an IAEA
"                           format phase space source: the primary source to
"                           isocentre distance (SAD).
"               phicol      angle by which the collimator is rotated in the
"                           collimator plane perpendicular to beam direction.
"                           Phicol is determined for theta=0 or 180 and phi=0.
"                           The positive sense of rotation is counterclockwise
"                           as one sights down from the origin in the
"                           phase space plane.
"                           phicol = 180 to retain same x,y positions passing
"                           from BEAM to DOSXYZ  (because of coordinate
"                           transformation used).
"               i_dbs       set to 1 if you used directional bremsstrahlung
"                           splitting (DBS) in the BEAM simulation used to
"                           generate this phase space source AND you wish to
"                           reject fat photons not aimed into the splitting
"                           field.  These fat photons may compromise dose
"                           statistics.  Set to 0 otherwise.
"               r_dbs       DBS splitting radius used in BEAMnrc simulation(cm).
"                           Set to 0 to disable this option.  Only needed if
"                           i_dbs=1.
"             ssd_dbs       SSD at which r_dbs is defined in the BEAM sim. (cm).
"                           Only needed if i_dbs=1.
"               z_dbs       Z in the BEAMnrc run where the phase space source
"                           was scored (in cm).  Only needed if i_dbs=1.
"             e_split       No. of times to split charged particles as soon
"                           as they enter the DOSXYZnrc geometry.  Used in
"                           conjunction with photon splitting (n_split) to
"                           prevent higher-weight charged particles from
"                           compromising dose statistics.  Recommended setting
"                           is e_split=n_split for optimum efficiency.  Not
"                           used if n_split<=1.
"
"      For i_dbs=1, photons are projected from z_dbs to ssd_dbs and if they will
"      fall outside of r_dbs (based on their Z direction cosine) then they will
"      be rejected.  This prevents fat photons from compromising dose
"      statistics.
"
"     Note: as currently set, multiple passers and all particles going
"           backwards in the phase space file are NOT used.
;
"-------------------------------------------------------------------------------
"
"Record SC1-3  Point source incident from the front (along the +ve z-axis)
"            employing rectangular collimation
"
"       iqin,isource,xinl,xinu,yinl,yinu,ssd
"
"               iqin       Charge of the incident beam (defaults to 0)
"               isource    = 3
"               xinl,xinu  Lower and upper x-bounds on source
"               yinl,yinu  Lower and upper y-bounds on source
"               ssd        Source-surface distance (ssd >0)
"
"-------------------------------------------------------------------------------
"
"Record SC1-4  Beam characterization model, particles incident on front face
"
"       iqin,isource,xiso,yiso,ziso,thetax,thetay,thetaz,phicol
"
"               iqin        = 0 only photons from ph-sp file will be simulated
"                           = 1 only positrons will be simulated
"                           =-1 only electrons will be simulated
"                           = 2 all the particles will be simulated
"               isource     =  4
"               x|y|z|iso   x|y|z|-coordinates of the isocenter
"               theta       angle between the +z direction and a line joining
"                           the origin in the phase space plane to the isocenter
"               phi         angle  between the +x direction and the
"                           projection of the line joining the origin in the
"                           phase space plane to the isocenter on the xy plane
"               dsource     absolute distance from the isocenter to the
"                           source center, which is, by definition, the
"                           origin in the phase space plane
"               phicol      angle by which the collimator is rotated in the
"                           collimator plane perpendicular to the beam direction
"                           Phicol is determined for theta=0 or 180 and phi=0.
"                           The positive sense of rotation is counterclockwise
"                           as one sights down from the origin in the
"                           phase space plane.
;
"-------------------------------------------------------------------------------
"
"Record SC1-6  Uniform isotropically radiating parallelepiped within DOSXYZ
"              phantom
"
"     iqin,isource,xinl,xinu,yinl,yinu,zinl,zinu
"               iqin        charge of particles from source (defaults to 0)
"               isource     = 6
"               xinl        min x of active volume (cm)
"               xinu        max x of active volume (cm)
"               yinl        min y of active volume (cm)
"               yinu        max y of active volume (cm)
"               zinl        min z of active volume (cm)
"               zinu        max z of active volume (cm)
"
"NOTE: The active volume must be completely contained within the phantom.
;
"------------------------------------------------------------------------------"
"Record SC1-7  Parallel beam incident from multiple, user-selected angles.
"
"       iqin,isource,xiso,yiso,ziso,nang,xcol,ycol,phicol
"
"               iqin        Charge of the incident beam (defaults to 0)
"               isource     = 7
"               x|y|z|iso   x|y|z|-coordinates of the isocenter
"               nang        number of incident theta-phi pairs or, if -ve,
"                           absolute value is the number of groups of theta-
"                           phi pairs.  Within a group:
"                              1. only theta or phi, but not both, can vary
"                              2. varying theta's or phi's are evenly
"                                 distributed
"                              3. theta-phi pairs have equal probability
"               x|y|col     total x- and y- widths of the beam on the plane
"                           perpendicular to the beam direction, defined
"                           by the center of the beam and the isocenter
"               phicol      angle by which the collimator is rotated in the
"                           collimator plane perpendicular to the beam direction
"                           Phicol is determined for theta=0 or 180 and phi=0.
"                           The positive sense of rotation is counterclockwise
"                           as one sights down the beam direction.
"
"  Note that, similar to source 1, theta is defined as the angle between the +z
"  direction and a line joining the center of the beam to the isocenter, and
"  phi is defined as the angle between the +x direction and the projection of
"  the line joining the center of the beam to the isocenter on the xy plane.
;
"-------------------------------------------------------------------------------
"Record SC1-8  Full phase-space source, particles incident from multiple,
"              user-selected angles.
"
"    iqin,isource,xiso,yiso,ziso,nang,dsource,phicol,i_dbs,r_dbs,ssd_dbs,
"             z_dbs,e_split
"
"               iqin(iqphsp)= 0 only photons from ph-sp file will be used
"                           = 1 only positrons will be used
"                           =-1 only electrons will be used
"                           = 2 all the particles will be used
"                           internally renamed as iqphsp
"               isource     =  8
"               x|y|z|iso   x|y|z|-coordinates of the isocenter
"               nang        number of incident theta-phi pairs or, if -ve,
"                           absolute value is the number of groups of theta-
"                           phi pairs.  Within a group:
"                              1. only theta or phi, but not both, can vary
"                              2. varying theta's or phi's are evenly
"                                 distributed
"                              3. theta-phi pairs have equal probability
"               dsource     For an BEAMnrc format phase space source: the
"                           absolute distance from the isocenter to the
"                           source center, which is, by definition, the
"                           origin in the phase space plane.  For an IAEA
"                           format source: the primary source-to-isocentre
"                           distance (SAD).
"               phicol      angle by which the collimator is rotated in the
"                           collimator plane perpendicular to beam direction.
"                           Phicol is determined for theta=0 or 180 and phi=0.
"                           The positive sense of rotation is counterclockwise
"                           as one sights down from the origin in the
"                           phase space plane.
"                           phicol = 180 to retain same x,y positions passing
"                           from BEAM to DOSXYZ  (because of coordinate
"                           transformation used).
"               i_dbs       set to 1 if you used directional bremsstrahlung
"                           splitting (DBS) in the BEAM simulation used to
"                           generate this phase space source AND you wish to
"                           reject fat photons not aimed into the splitting
"                           field.  These fat photons may compromise dose
"                           statistics.  Set to 0 otherwise.
"               r_dbs       DBS splitting radius used in BEAMnrc simulation(cm).
"                           Set to 0 to disable this option.  Only needed if
"                           i_dbs=1.
"             ssd_dbs       SSD at which r_dbs is defined in the BEAM sim. (cm).
"                           Only needed if i_dbs=1.
"               z_dbs       Z in the BEAMnrc run where the phase space source
"                           was scored (in cm).  Only needed if i_dbs=1.
"             e_split       No. of times to split charged particles as soon
"                           as they enter the DOSXYZnrc geometry.  Used in
"                           conjunction with photon splitting (n_split) to
"                           prevent higher-weight charged particles from
"                           compromising dose statistics.  Recommended setting
"                           is e_split=n_split for optimum efficiency.  Not
"                           used if n_split<=1.
"
"      For i_dbs=1, photons are projected from z_dbs to ssd_dbs and if they will
"      fall outside of r_dbs (based on their Z direction cosine) then they will
"      be rejected.  This prevents fat photons from compromising dose
"      statistics.
"
"     Note: as currently set, multiple passers and all particles going
"           backwards in the phase space file are NOT used.
"     Also note that, similar to source 2, theta is the angle between the +z
"     direction and a line joining the origin of the phase space plane to the
"     isocenter, and phi is the angle between the +x direction and the
"     projection of the line joining the origin of the phase space plane to
"     the isocenter in the xy plane.
;
"-------------------------------------------------------------------------------
"
"Record SC1-9 BEAM treatment head simulation used as source, incident from
"             any angle
"
"  This source requires unix/Linux systems to have a working C/C++ compiler
"  and requires the BEAM code, BEAM_accelname, to have been compiled as a
"  shared library (libBEAM_accelname.so or BEAM_accelname.dll) that exists in
"  your EGS_HOME/bin/config directory.  See the DOSXYZnrc Manual for more
"  details.
"
"       iqin,isource,xiso,yiso,ziso,theta,phi,dsource,phicol,i_dbs,e_split
"
"               iqin(iqinc)= 0 only photons from BEAM simulation will be used
"                           = 1 only positrons will be used
"                           =-1 only electrons will be used
"                           = 2 all the particles will be used
"                           internally renamed as iqinc
"               isource     = 9
"               x|y|z|iso   x|y|z|-coordinates of the isocenter.
"               theta       angle between the +z direction and a vector
"                           joining the isocentre to the origin of the source
"                           plane (the plane where the particles are sampled
"                           from the BEAM simulation--which is the
"                           scoring plane in a standard BEAM simulation).
"                           theta=180 degrees for a beam down from the top.
"               phi         angle between the +x direction and the
"                           projection of the vector joining the isocenter to
"                           the origin of the source plane.
"               dsource     absolute distance from the isocenter to the
"                           origin of the source plane.
"               phicol      angle by which the source plane is rotated about
"                           the BEAM central axis.  Rotation is counter-
"                           clockwise for theta=0.  Set phicol=180 degrees
"                           to retain same x,y, positions passing
"                           from BEAM to DOSXYZ when theta=180 (beam coming
"                           down from top).
"               i_dbs       set to 1 if you are using directional bremsstrahlung
"                           splitting (DBS) in the BEAM simulation
"                           AND you wish to reject fat photons not aimed into
"                           the splitting field.  These fat photons may
"                           compromise dose statistics.  Set to 0 otherwise.
"             e_split       No. of times to split charged particles as soon
"                           as they enter the DOSXYZnrc geometry.  Used in
"                           conjunction with photon splitting (n_split) to
"                           prevent higher-weight charged particles from
"                           compromising dose statistics.  Recommended setting
"                           is e_split=n_split for optimum efficiency.  Not
"                           used if n_split<=1.
"-------------------------------------------------------------------------------
"
"Record SC1-10 BEAM treatment head simulation used as source, incident from
"              multiple, user-defined angles.
"
"  This source requires unix/Linux systems to have a working C/C++ compiler
"  and requires the BEAM code, BEAM_accelname, to have been compiled as a
"  shared library (libBEAM_accelname.so or BEAM_accelname.dll) that exists in
"  your EGS_HOME/bin/config directory.  See the DOSXYZnrc Manual for more
"  details.
"
"       iqin,isource,xiso,yiso,ziso,nang,dsource,phicol,i_dbs,e_split
"
"               iqin(iqinc)= 0 only photons from BEAM simulation will be used
"                           = 1 only positrons will be used
"                           =-1 only electrons will be used
"                           = 2 all the particles will be used
"                           internally renamed as iqinc
"               isource     = 10
"               x|y|z|iso   x|y|z|-coordinates of the isocenter.
"               nang        number of incident theta-phi pairs or, if -ve,
"                           absolute value is the number of groups of theta-
"                           phi pairs.  Within a group:
"                              1. only theta or phi, but not both, can vary
"                              2. varying theta's or phi's are evenly
"                                 distributed
"                              3. theta-phi pairs have equal probability
"               dsource     absolute distance from the isocenter to the
"                           origin of the source plane.
"               phicol      angle by which the source plane is rotated about
"                           the BEAM central axis.  Rotation is counter-
"                           clockwise for theta=0.  Set phicol=180 degrees
"                           to retain same x,y, positions passing
"                           from BEAM to DOSXYZ when theta=180 (beam coming
"                           down from top).
"               i_dbs       set to 1 if you are using directional bremsstrahlung
"                           splitting (DBS) in the BEAM simulation
"                           AND you wish to reject fat photons not aimed into
"                           the splitting field.  These fat photons may
"                           compromise dose statistics.  Set to 0 otherwise.
"             e_split       No. of times to split charged particles as soon
"                           as they enter the DOSXYZnrc geometry.  Used in
"                           conjunction with photon splitting (n_split) to
"                           prevent higher-weight charged particles from
"                           compromising dose statistics.  Recommended setting
"                           is e_split=n_split for optimum efficiency.  Not
"                           used if n_split<=1.
"
"      Note that this source requires Record SC1-10a, described below.
;
"-------------------------------------------------------------------------------
"Record SC1-20 Synchronized phase space source simulating continuous motion of
"              the source plane between user-defined control points.  Option
"              to run the source through a geometry (usually MLC) defined using
"              BEAM or a non-EGSnrc code compiled as a shared library
"	       - added by Tony Popescu and Julio Lobo
"
"  This source requires unix/Linux systems to have a working C/C++ compiler
"  and requires the BEAM code or non-EGSnrc code (e.g particleDmlc) to have
"  been compiled as a shared library (libparticleDmlc.so) that exists in
"  your EGS_HOME/bin/config directory.
"
"
"       iqin,isource,nset,i_dbs,r_dbs,ssd_dbs,z_dbs,e_split,i_muidx_out, calflag
"
"               iqin(iqinc) = 0 only photons from BEAM simulation will be used
"                           = 1 only positrons will be used
"                           =-1 only electrons will be used
"                           = 2 all the particles will be used
"                           internally renamed as iqinc
"               isource     = 20
"               nset        number of settings (control points) (>=2)
"               i_dbs       set to 1 if you are using directional bremsstrahlung
"                           splitting (DBS) in the BEAM simulation
"                           AND you wish to reject fat photons not aimed into
"                           the splitting field.  These fat photons may
"                           compromise dose statistics.  Set to 0 otherwise.
"               r_dbs       DBS splitting radius used in BEAMnrc simulation(cm).
"                           Set to 0 to disable this option.  Only needed if
"                           i_dbs=1.
"             ssd_dbs       SSD at which r_dbs is defined in the BEAM sim. (cm).
"                           Only needed if i_dbs=1.
"               z_dbs       Z in the BEAMnrc run where the phase space source
"                           was scored (in cm).  Only needed if i_dbs=1.
"             e_split       No. of times to split charged particles as soon
"                           as they enter the DOSXYZnrc geometry.  Used in
"                           conjunction with photon splitting (n_split) to
"                           prevent higher-weight charged particles from
"                           compromising dose statistics.  Recommended setting
"                           is e_split=n_split for optimum efficiency.  Not
"                           used if n_split<=1.
"            i_muidx_out    Set to 1 to include frMU_indx (the fractional
"                           monitor unit index) in phase space output if
"                           i_phsp_out=1 or 2.
"               calflag     set to 1 to skip the calibration run performed to
"                           refine the estimate of NRCYCL needed to avoid
"                           rewinding the phsp. Only do this if certain that
"                           your phsp has enough particles compared to the no.
"                           of histories you are running.
;
"-------------------------------------------------------------------------------
"
"Record SC1-21 Synchronized BEAM treatment head simulation used as source
"              with continuous motion of the source plane between user-defined
"              control points.  Option to run the source through a geometry
"              (usually MLC) defined using a non-EGSnrc code compiled as a
"              shared library.
"	       - added by Tony Popescu and Julio Lobo
"
"  This source requires unix/Linux systems to have a working C/C++ compiler
"  and requires the BEAM code being used as the source, BEAM_accelname, to have
"  been compiled as a shared library (libBEAM_accelname.so or
"  BEAM_accelname.dll) that exists in your $EGS_HOME/bin/config directory.  See
"  the DOSXYZnrc Manual for more details.
"
"       iqin,isource,nset,i_dbs,e_split,i_muidx_out
"
"               iqin(iqinc) = 0 only photons from BEAM simulation will be used
"                           = 1 only positrons will be used
"                           =-1 only electrons will be used
"                           = 2 all the particles will be used
"                           internally renamed as iqinc
"               isource     = 21
"               nset        number of settings (control points) (>=2)
"               i_dbs       set to 1 if you are using directional bremsstrahlung
"                           splitting (DBS) in the BEAM simulation
"                           AND you wish to reject fat photons not aimed into
"                           the splitting field.  These fat photons may
"                           compromise dose statistics.  Set to 0 otherwise.
"             e_split       No. of times to split charged particles as soon
"                           as they enter the DOSXYZnrc geometry.  Used in
"                           conjunction with photon splitting (n_split) to
"                           prevent higher-weight charged particles from
"                           compromising dose statistics.  Recommended setting
"                           is e_split=n_split for optimum efficiency.  Not
"                           used if n_split<=1.
"            i_muidx_out    Set to 1 to include frMU_indx (the fractional
"                           monitor unit index) in phase space output if
"                           i_phsp_out=1 or 2.
;
"------------------------------------------------------------------------------
"Record SC1-7a, SC1-8a and SC1-10a (required for sources 7, 8 and 10 only)
"        if nang>0:
"         (theta(i),phi(i),pang(i),i=1,nang)
"
"               theta(i)    incident theta i
"               phi(i)      incident phi i.
"               pang(i)     probability of a particle being incident at
"                           theta(i)-phi(i) (probabilities are automatically
"                           normalized to 1).
"
"        if nang<0:
"         (ivary(i),angfixed(i),angmin(i),angmax(i),ngang(i),pgang(i),i=1,-nang)
"
"               ivary(i)    =0 to vary phi in group i, 1 to vary theta in
"                           group i
"               angfixed(i) =fixed theta (ivary=0) or phi (ivary=1) for group i
"               angmin(i)   min. value of varying phi (ivary=0) or theta
"                           (ivary=1) in group i
"               angmax(i)   max. value of varying phi or theta in group i
"               ngang(i)    number of equally-spaced phi's or theta's
"                           including angmin(i) and angmax(i) (Note: this
"                           means ngang(i) must be at least 2).
"               pgang(i)    probability of a particle being incident in
"                           group i (probabilities are automatically normalized
"                           to 1).
;
"-------------------------------------------------------------------------------
"Record SC1-20a and SC1-21a (required for sources 20 and 21)
"
"  (|x|y|ziso(i),theta(i),phi(i),phicol(i),dsource(i),muIndex(i),i=1,nset)
"
"           |x|y|ziso(i)    x,y,z of isocentre for control point i
"               theta(i)    incident theta for control point i
"               phi(i)      incident phi for control point i
"               phicol(i)   incident phicol for control point i
"               dsource(i)  distance from isocentre to origin of BEAM
"                           scoring plane for control point i.  For source
"                           21 using an IAEA phase space file, this is
"                           the primary source to isocentre distance (SAD).
"               muIndex(i)  fractional monitor unit index for control point
"                           i.  Restrictions: muIndex(i) is on [0,1],
"                           muIndex(i-1)<=muIndex(i), muIndex(1)=0.0,
"                           muIndex(nset)=1.0
"
"   Note: theta, phi, phicol, and dsource have the same meaning as for
"   Source 2 (see above).
;
"-------------------------------------------------------------------------------
"
" Record SC2
"       enflag,mode,medsur,dsurround(1),dflag,dsurround(2),dsurround(3),
"                                                              dsurround(4)
"
"            enflag    = 0 for monoenergetic beams
"                      = 1 for beams with an energy spectrum
"                      = 2 for ph-sp beam input or full BEAM sim.
"                      = 3 for ph-sp beam input or full BEAM sim. + dose
"                          components calculations (use of LATCH filters)
"                      = 4 for ph-sp beam modelled with multiple-source
"                          (use of LATCH filters)
"            mode      = 0 default file format for ph-sp data (enflag=2)
"                          (7 variables/record)
"                      = 2 special file format for ph-sp data with ZLAST
"                          (8 variables/record)
"           medsur   :     medium number for the region outside the phantom
"                          (default = vacuum if medsur = 0) for enflag > 1
"           dsurround(1):  if dflag=0, the thickness of the region surrounding
"                          the phantom on all sides (default=50cm)
"                          OR
"                          if dflag=1, the thickness of the region surrounding
"                          the phantom in the x direction (default=0cm)
"             dflag    = 0 dsurround(1) applies to all sides of phantom
"                      = 1 dsurround(1) applies to x direction; must input
"                          dsurround(2) for y direction, dsurround(3) for +z
"                          direction (down), dsurround(4) for -z direction (up)
"          dsurround(2):   (only required if dflag=1) thickness of region
"                           surrounding phantom in y direction (default=0cm)
"          dsurround(3):   (only required if dflag=1) thickness of region
"                           surrounding phantom in +z direction (default=0cm)
"          dsurround(4):   (only required if dflag=1) thickness of region
"                           surrounding phantom in -z direction (default=0cm)
"
"      Note:  Currently, medsur, dflag and dsurround(1...4) are only input
"             if enflag > 1.
;
"------------------------------------------------------------------------------
" Record SC3a   (if enflag = 0)
"            ein
"            ein       kinetic energy of the incident particles in MeV
"
"------------------------------------------------------------------------------
" Record SC3b   (if enflag = 1, 2, 3, or 4, each with different inputs)
"             FILNAM  or
"             the_beam_code, the_input_file, the_pegs_file or
"             the_shared_code,the_phsp_file,the_input_file (isource 20) or
"   the_beam_code,the_input_file,the_pegs_file,the_vcu_code,the_vcu_input_file
"                                                           (isource = 21)
"            FILNAM  Name of file containing energy spectrum   (enflag =1)
"
"                    name of file containing phase-space data  (enflag = 2,3
"                                                        and isource=2,8)
"
"                    name of file containing source parameters (enflag = 4)
"
"             or for isource = 9,10
"
"          the_beam_code    The name of the BEAM code you are running as a
"                           source (ie BEAM_accelname).  This must have been
"                           compiled as a shared library (libBEAM_accelname.so
"                           or BEAM_accelname.dll) and exist in
"                           EGS_HOME/bin/config.
"          the_input_file   The input file used to run the BEAM simulation
"                           (no .egsinp extension).  This must exist in your
"                           EGS_HOME/BEAM_accelname directory.  It must be
"                           a working input file and must be set up to write
"                           a phase space file at a single scoring plane.
"                           This plane becomes where particles are sampled from
"                           for the DOSXYZ simulation (no phase space file
"                           is scored, however).
"          the_pegs_file    The pegs data set used by the BEAM simulation
"                           (no .pegs4dat extension).  This must be in
"                           HEN_HOUSE/pegs4/data or EGS_HOME/pegs4/data.
"
"            or for isource = 20
"
"          the_shared_code  BEAM or non-EGSnrc code used to simulate a geometry
"                           interposed between phase space source and
"                           the phantom.  Must have been compiled as a shared
"                           library and exist in $EGS_HOME/bin/config
"                           (isource = 20)
"          the_phsp_file    Name of file containing phase space data
"                           (isource = 20)
"          the_input_file   Input file for the BEAM or non-EGSnrc code used
"                           to simulate a geometry interposed between the
"                           phase space source and the phantom.  In the
"                           case where you are using a BEAM accelerator, this
"                           must exist in the $EGS_HOME/BEAM_accelname
"                           directory and must specify a scoring plane at
"                           the bottom of the accelerator. (isource = 20)
"
"           or for isource = 21
"
"          the_beam_code    Same as for isource=9, 10
"          the_input_file   Same as for isource=9, 10
"          the_pegs_file    Same as for isource=9, 10
"          the_vcu_code     (optional) Name of non-EGSnrc code used to simulate
"                           a geometry (usually MLC) interposed between the
"                           treatment head source and the phantom.  Must have
"                           been compiled as a shared library and exist in
"                           $EGS_HOME/bin/config.
"	 the_vcu_input_file (optional) The full path to the input file for
"                           the_vcu_code
"------------------------------------------------------------------------------
" Record SC3c   (if enflag = 3)
"       I_BIT_FILTER, NBIT1, NBIT2
"
"            I_BIT_FILTER = 0 INclusive/EXclusive for bits: if any of the 1st
"                             set of NBIT1 bits are set and none of the 2nd set
"                             of NBIT2 bits are set, the particle is used.
"                         = 1 EXclusive for bits: if any of the set of NBIT1
"                             bits are set, the particle is not used.
"                         = 2 INclusive for regions: use secondary particles
"                             that originated in any of the specified NBIT1
"                             regions.
"                         = 3 EXclusive for regions: do not use secondary
"                             particles that originated in any of the NBIT1
"                             specified regions.
"
"                             Note: For I_BIT_FILTER=0,1 the actual bits
"                             specified below by LATBIT(i) are checked.
"                             For I_BIT_FILTER=2,3 the regions of origin
"                             (stored in bits 24 to 28 and specified by
"                             IREGION_TO_BIT) are checked against LATBIT(i)
"                             values.
"
"                      NBIT1: the number of bits or regions of origin to
"                             include (I_BIT_FILTER=0,2) or exclude
"                             (I_BIT_FILTER=1,3).
"                      NBIT2: the number of bits to exclude.  Only has meaning
"                             for I_BIT_FILTER=0, otherwise, it is
"                             automatically set to 0.
"
"              Restrictions: for I_BIT_FILTER=0:    0<=NBIT1+NBIT2<=29
"                            for I_BIT_FILTER=1:    0<=NBIT1<=29
"                            for I_BIT_FILTER=2,3:  0<=NBIT1<=24
;
"
"       (LATBIT(i),i=1,NBIT1)
"            (LATBIT(i),i=1,NBIT1): bits/IREGION_TO_BITs to
"                                   include (I_BIT_FILTER=0,2) or
"                                   exclude (I_BIT_FILTER=1,3) from the source.
"
"       Next line required only if I_BIT_FILTER=0 and NBIT2>0.
"
"       (LATBIT(i),i=NBIT1+1,NBIT1+NBIT2)
"         (LATBIT(i),i=NBIT1+1,NBIT1+NBIT2): bits to exclude (I_BIT_FILTER=0).
"
"              Restrictions: bits should be >=0 and <=28
"                            IREGION_TO_BITs should be >=0 and <=23.
"
"       Note: The check on particle charge is done independently before
"             these bit filters are applied.
;
"  end of inputs read by srcxyznrc.mortran
"------------------------------------------------------------------------------
%E "srcxyznrc.mortran start of subroutine srcinput ($Revision: 1.39 $)"
"**************************************************************************"
"
subroutine srcinput(ieof);

implicit none;

"This subroutine is used for source parameter input
"
"Energy parameters:
"   enflag = 0, monoenergetic source sets ein to k.e. and this is used to
"               set etotin in main.
"   enflag = 1, energy spectrum, ein is set to maximum k.e. in spectrum
"               and this value is used by PRESTA
"   phase space inputs: ein is max k.e. of particles in phase space file
"               read from first line.
"
"**************************************************************************"
REPLACE {$NTEMP} WITH {12} "Dimension of temporary input buffer
$REAL temp,fnorm,binsok,gridsz,ak;
$INTEGER i,k,j,ib,ieof;
dimension temp($NTEMP);
CHARACTER*256 FILNAM;
CHARACTER*80 SPEC_TITLE;
CHARACTER*5  MODE;
$INTEGER lnblnk1,ilen;
$INTEGER latchm,nhistm; "temp. variables used for source 2,8"
$REAL einm,xinm,yinm,uinm,vinm,wtm,zlastm,Z_SOURCE;
                        "temp. variables used for source 2,8"
;COMIN/ENERGYSRC,GEOM,PHSPFILE,SCORE,SOURCE,SSMDIS,MEDIA,MISC,BOUNDS,RWPHSP,
       EGS-IO/;

enflag = 0; "Default flag: Source energy same for each source particle
i_muidx_out = 0; "default not to output frMU_indx if writing phsp data"
calflag = 0; "default to running the calibration run (isource = 20)"

OUTPUT; ( / / ' Source configuration'/);
OUTPUT; (
    '      (0) Parallel, rectangular beam incident from the front' /
    '          Requires 9 inputs:'                                 /
    '          charge (-1,0,1),'                                   /
    '          0 (mandatory, to identify source type),'            /
    '          lower x-coordinate of the beam (cm),'               /
    '          upper x-coordinate of the beam (cm),'               /
    '          lower y-coordinate of the beam (cm),'               /
    '          upper y-coordinate of the beam (cm),'               /
    '          angle of beam with respect to the positive x-axis (degrees),'/
    '          angle of beam with respect to the positive y-axis (degrees),'/
    '          angle of beam with respect to the negative z-axis (degrees) '/
    '            (angles default to 90,90,0--incident on front of phantom)'/);
OUTPUT; (
    '   or (1) Parallel, rectangular beam incident from any direction'/
    '          Requires 10 inputs:'                                   /
    '          charge (-1,0,1),'                                      /
    '          1 (mandatory, to identify source type),'               /
    '          x-coordinate of the isocenter (cm),'                   /
    '          y-coordinate of the isocenter (cm),'                   /
    '          z-coordinate of the isocenter (cm),'                   /
    '          angle between +z direction and the line joining the   '/
    '             center of the beam (collimator) to the isocenter'   /
    '             --called the polar angle(degrees),'                 /
    '          angle between +x direction and the projection of the'  /
    '             line joining the center of the beam (collimator)'   /
    '             to the isocenter on the xy plane--called the azimuthal'/
    '             angle (degrees),'/
    '          total x-width of the beam in the plane perpendicular'  /
    '             to the beam direction (cm),'                        /
    '          total y-width of the beam in the plane perpendicular'  /
    '             to the beam direction (cm),'                        /
    '          angle by which the collimator is rotated in the'       /
    '             collimator plane perpendicular to the beam'         /
    '             direction (degrees),                     '          /
    '             (+ve rotation is counterclockwise looking along'    /
    '              the beam direction'                                /);
OUTPUT; (
    '  or  (2) Full phase-space of each particle'                     /
    '          Requires 9 inputs plus data stored in units 43 and 44:'/
    '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
    '          2 (mandatory, to identify source type),'               /
    '          x-coordinate of the isocenter (cm),'                   /
    '          y-coordinate of the isocenter (cm),'                   /
    '          z-coordinate of the isocenter (cm),'                   /
    '          angle between +z direction and the line joining the   '/
    '             origin in the phase space plane to the isocenter'   /
    '             --called the polar angle(degrees),'                 /
    '          angle between +x direction and the projection of the'  /
    '             line joining the origin in the phase space plane'   /
    '             to the isocenter on the xy plane--called the azimuthal'/
    '             angle (degrees),'                                   /
    '          absolute distance from the isocenter to the origin'    /
    '             in the phase space plane                      '     /
    '          angle by which the source is rotated in the'           /
    '             phase space plane perpendicular to the beam'        /
    '             direction (degrees),                     '          /
    '             (+ve rotation is counterclockwise looking down'     /
    '              from the origin in the phase space plane),'          /
    '          i_dbs--set to 1 if DBS was used in BEAM simulation used' /
    '             to generate the phsp source and you want to reject fat' /
    '             photons, 0 otherwise,'/
    '          DBS splitting radius (cm),'/
    '          SSD at which splitting radius defined (cm),'/
    '          Z at which phsp source collected (cm),'/
    '          No. of times to split charged particles.'/);
OUTPUT; (
    '   or (3) Point, rectangular beam incident from the front' /
    '          Requires 7 inputs:'                                 /
    '          charge (-1,0,1),'                                   /
    '          3 (mandatory, to identify source type),'            /
    '          lower x-coordinate of the beam (cm),'               /
    '          upper x-coordinate of the beam (cm),'               /
    '          lower y-coordinate of the beam (cm),'               /
    '          upper y-coordinate of the beam (cm),'               /
    '          distance to the plane (cm),'/
    );
OUTPUT; (
    '  or  (6) Uniform isotropically radiating parallelepiped within'/
    '          the phantom'/
    '          Requires 8 inputs:'/
    '          charge (-1,0,1),'      /
    '          6 (mandatory, to identify source type),'               /
    '          lower x-coordinate of active volume (cm)'/
    '          upper x-coordinate of active volume (cm),'            /
    '          lower y-coordinate of active volume (cm) '/
    '          upper y-coordinate of active volume (cm),'            /
    '          lower z-coordinate of active volume (cm)  ' /
    '          upper z-coordinate of active volume (cm) '/);
OUTPUT; (
    '  or  (7) Parallel beam incident from multiple, user-selected angles'/
    '          Requires 9 inputs on this line:'/
    '          charge (-1,0,1),'      /
    '          7 (mandatory, to identify source type),'               /
    '          x-coordinate of the isocenter (cm),'                   /
    '          y-coordinate of the isocenter (cm),'                   /
    '          z-coordinate of the isocenter (cm),'                   /
    '          number of incident theta-phi pairs or -ve number of',  /
    '             groups of incident theta-phi pairs where, within a group', /
    '             only theta or phi can vary, the varying angles are' /
    '             evenly distributed and have equal probability,'     /
    '          total x-width of the beam in the plane perpendicular'  /
    '             to the beam direction (cm),'                        /
    '          total y-width of the beam in the plane perpendicular'  /
    '             to the beam direction (cm),'                        /
    '          angle by which the collimator is rotated in the'       /
    '             collimator plane perpendicular to the beam'         /
    '             direction (degrees),                     '          /
    '             (+ve rotation is counterclockwise looking along'    /
    '              the beam direction'                                /);
OUTPUT; (
    '  or  (8) Full phase-space incident from multiple angles'        /
    '          Requires 8 inputs on this line and data stored in units 43,44:'/
    '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
    '          2 (mandatory, to identify source type),'               /
    '          x-coordinate of the isocenter (cm),'                   /
    '          y-coordinate of the isocenter (cm),'                   /
    '          z-coordinate of the isocenter (cm),'                   /
    '          number of incident theta-phi pairs or -ve number of',  /
    '             groups of incident theta-phi pairs where, within a group', /
    '             only theta or phi can vary, the varying angles are' /
    '             evenly distributed and have equal probability,'     /
    '          absolute distance from the isocenter to the origin'    /
    '             in the phase space plane                      '     /
    '          angle by which the source is rotated in the'           /
    '             phase space plane perpendicular to the beam'        /
    '             direction (degrees),                     '          /
    '             (+ve rotation is counterclockwise looking down'     /
    '              from the origin in the phase space plane),'         /
    '          i_dbs--set to 1 if DBS was used in BEAM simulation used' /
    '             to generate the phsp source and you want to reject fat' /
    '             photons, 0 otherwise,'/
    '          DBS splitting radius (cm),'/
    '          SSD at which splitting radius defined (cm),'/
    '          Z at which phsp source collected (cm)',/
    '          No. of times to split charged particles.'/);
OUTPUT; (
    '  or  (9) BEAM simulation of treatment head'                     /
    '          Requires 11 inputs plus name of accelerator simulation,'/
    '          input file used in accelerator simulation, and pegs4'/
    '          data used in accelerator simulation:'/
    '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
    '          9 (mandatory, to identify source type),'               /
    '          x-coordinate of the isocenter (cm),'                   /
    '          y-coordinate of the isocenter (cm),'                   /
    '          z-coordinate of the isocenter (cm),'                   /
    '          angle between beam central axis and +z axis in DOSXYZ'/
    '             geometry--called the polar angle(degrees),'         /
    '          angle between +x direction in DOSXYZ geometry and'  /
    '             beam central axis projected on the DOSXYZ xy plane'   /
    '             --called the azimuthal angle (degrees),'            /
    '          absolute distance from the isocenter to centre of'    /
    '             scoring plane in BEAM simulation,'     /
    '          angle to rotate BEAM simulation about its central'     /
    '             axis (degrees) (+ve rotation is counterclockwise'/
    '             looking down the axis),'          /
    '          i_dbs--set to 1 if DBS is being used in BEAM simulation' /
    '             and you want to reject fat photons, 0 otherwise,'/
    '          No. of times to split charged particles.'/);
OUTPUT; (
    '  or  (10) BEAM simulation source incident from multiple angles' /
    '          Requires 10 inputs plus name of accelerator simulation,'/
    '          input file used in accelerator simulation, and pegs4'/
    '          data used in accelerator simulation:'/
    '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
    '          9 (mandatory, to identify source type),'               /
    '          x-coordinate of the isocenter (cm),'                   /
    '          y-coordinate of the isocenter (cm),'                   /
    '          z-coordinate of the isocenter (cm),'                   /
    '          number of incident theta-phi pairs or -ve number of',  /
    '             groups of incident theta-phi pairs where, within a group', /
    '             only theta or phi can vary, the varying angles are' /
    '             evenly distributed and have equal probability,'     /
    '          absolute distance from the isocenter to centre of'    /
    '             scoring plane in BEAM simulation,'     /
    '          angle to rotate BEAM simulation about its central'     /
    '             axis (degrees) (+ve rotation is counterclockwise'/
    '             looking down the axis),'          /
    '          i_dbs--set to 1 if DBS is being used in BEAM simulation' /
    '             and you want to reject fat photons, 0 otherwise,'/
    '          No. of times to split charged particles.'/);
OUTPUT; (
    '  or  (20) Phase Space Incident from multiple settings '/
    '		optionally through an MLC or through a BEAM accel.'/
    '          Requires 6 inputs plus name of the input file used'/
    '	      for BEAM/vcu SIM. and the BEAM/VCU code if used'/
    '          data used in simulation:'/
    '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
    '          20 (mandatory, to identify source type),'               /
    '          number of control points, ',  /
    '          i_dbs: set to 1 if DBS is being used in simulation' /
    '             and you want to reject fat photons, 0 otherwise,'/
    '          r_dbs: radius of DBS splitting field in original'/
    '             BEAM simulation,'/
    '          ssd_dbs: SSD of DBS splitting field, '/
    '          z_dbs: Z position where phase space was scored '/
    '             in original BEAM simulation, '/
    '          No. of times to split charged particles,'/
    '          i_muidx_out: Set to 1 to include fractional MU index'/
    '             in output phase space (i_phsp_out=1 or 2)'/
    '          calflag: Set to 1 to skip the calibration run performed'/
    '             to refine the estimate of NRCYCL.'/);
OUTPUT; (
    '  or  (21) BEAM simulation of treatment head will multiple settings' /
    '		optionally through a MLC'/
    '          Requires  name of accelerator simulation,'/
    '          input file used in accelerator simulation, and pegs4'/
    '          data used in accelerator simulation, name of input file'/
    '	      for vcu SIM. and the VCU code (particleDmlc) if using MLC'/
    '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
    '          21 (mandatory, to identify source type),'               /
    '          number of control points ',  /
    '          i_dbs: set to 1 if DBS is being used in BEAM simulation' /
    '             and you want to reject fat photons, 0 otherwise,'/
    '          No. of times to split charged particles.'/
    '          i_muidx_out: Set to 1 to include fractional MU index'/
    '             in output phase space (i_phsp_out=1 or 2)'/);

OUTPUT;(' All inputs on one line:',$);

INPUT iqin,isource,(temp(i),i=1,$NTEMP); (2i12,$NTEMPf15.0);

IF( (iqin < -1) | (iqin > 1 & isource ~= 2 & isource < 8) | (iqin > 2) )[
  iqin=0;
]

"------------------------------------------------------------------------"
IF(isource = 0) [ "Frontal parallel beam directed along z-axis"
"------------------------------------------------------------------------"
    xinl   = temp(1);     xinu   = temp(2);     yinl   = temp(3);
    yinu   = temp(4);     thetax = temp(5);     thetay = temp(6);
    thetaz = temp(7);
    OUTPUT iqin,xinl,xinu,yinl,yinu,thetax,thetay,thetaz;
    ( / ' Parallel beam incident from the front(+ve z-axis)'/
        ' Electric charge of the source:',t40,i12           /
        ' x-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
        ' y-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
        ' Angle relative to +x:',t40,f10.4                   /
        ' Angle relative to +y:',t40,f10.4                   /
        ' Angle relative to -z:',t40,f10.4                   //);
]
"------------------------------------------------------------------------"
ELSEIF(isource = 1) [ "Parallel beam directed in any direction"
"------------------------------------------------------------------------"
    xiso   = temp(1);     yiso   = temp(2);     ziso   = temp(3);
    theta(1)  = temp(4);     phi(1)  = temp(5);     xcol   = temp(6);
    ycol   = temp(7);     phicol = temp(8);
    OUTPUT iqin,xiso,yiso,ziso,theta(1),phi(1),xcol,ycol,phicol;
    ( / ' Parallel beam incident from an arbitrary direction'/
        ' Electric charge of the source:'       ,t40,i12     /
        ' x-coordinate of the isocenter:'       ,t40,f10.4   /
        ' y-coordinate of the isocenter:'       ,t40,f10.4   /
        ' z-coordinate of the isocenter:'       ,t40,f10.4   /
        ' Polar angle of collimator center:'    ,t40,f10.4   /
        ' Azimuthal angle of collimator center:',t40,f10.4   /
        ' Total x-collimator width:'            ,t40,f10.4   /
        ' Total y-collimator width:'            ,t40,f10.4   /
        ' Collimator rotation angle:'           ,t40,f10.4   //);
]
"------------------------------------------------------------------------"
ELSEIF(isource = 2)[ "Full phase space for each particle"
"------------------------------------------------------------------------"
    xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
    theta(1)   = temp(4);     phi(1)     = temp(5);     dsource = temp(6);
    phicol  = temp(7);     iqphsp=iqin;
    i_dbs=temp(8); r_dbs=temp(9); ssd_dbs=temp(10); z_dbs=temp(11);
    e_split=temp(12);
    OUTPUT xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,e_split;
    ( / ' Full phase space from an arbitrary direction'/
        ' x-coordinate of the isocenter:'    ,t55,f10.4/
        ' y-coordinate of the isocenter:'    ,t55,f10.4/
        ' z-coordinate of the isocenter:'    ,t55,f10.4/
        ' Polar angle of origin in source plane:',t55,f10.4/
        ' Azimuthal angle of origin in source plane:' ,t55,f10.4/
        ' Distance from isocenter to origin in source plane:',t55,f10.4/
        ' Source rotation angle:'            ,t55,f10.4/
        ' No. of times to split e+/e-:'    ,t55,i10/);
    IF(i_dbs=1)[
      OUTPUT r_dbs,ssd_dbs,z_dbs;
      (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
        ' in BEAM simulation to generate phase space source with:'/
        '    DBS splitting radius:',t55,f10.4/
        '    SSD where radius defined:',t55,f10.4/
        '    Z where source scored:',t55,f10.4/
' Photons whose trajectory takes them outside the DBS splitting'/
' radius at the SSD will be rejected.'/);
      IF(ssd_dbs<z_dbs)[
         OUTPUT;(//' ***WARNING:'/
                   ' SSD where DBS splitting radius is defined < the Z'/
                   ' value of scoring plane for this source.'/
                   ' Particle rejection will be turned off.'//);
         i_dbs=0;
      ]
    ]
    ELSE[
      i_dbs=0;
    ]
    IF(iqphsp=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
    ELSE[ OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/); ]
]
"------------------------------------------------------------------------"
ELSEIF(isource = 3)[ "Frontal point source beam
"------------------------------------------------------------------------"
    xinl   = temp(1);     xinu   = temp(2);     yinl   = temp(3);
    yinu   = temp(4);     ssd    = temp(5);
    OUTPUT iqin,xinl,xinu,yinl,yinu,ssd;
    ( / ' Point source incident from the front(+ve z-axis)'/
        ' Electric charge of the source:',t40,i12           /
        ' x-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
        ' y-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
        ' SSD                     :',t40,f10.4             /);
]
"------------------------------------------------------------------------"
ELSEIF(isource = 4)[ ;$BEAMMODEL-SOURCE4-INPUT; ]
"------------------------------------------------------------------------"
"------------------------------------------------------------------------"
ELSEIF(isource = 6)[ "isotropically radiating source
"------------------------------------------------------------------------"
    xinl = temp(1);     xinu   = temp(2);     yinl   = temp(3);
    yinu   = temp(4);   zinl   = temp(5);     zinu   = temp(6);
        OUTPUT iqin,xinl,xinu,yinl,yinu,zinl,zinu;
        ( / ' Uniform isotropically radiating parallelepiped:'/
        ' Electric charge of the source:',t40,i12           /
        ' x-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
        ' y-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
        ' z-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /);
    IF(xinl>xinu)[
       OUTPUT; (//' ***ERROR in source 6:'/
                  ' xinl > xinu '//);
       STOP;
    ]
    IF(yinl>yinu)[
        OUTPUT; (//' ***ERROR in source 6:'/
                  ' yinl > yinu '//);
       STOP;
    ]
    IF(zinl>zinu)[
        OUTPUT; (//' ***ERROR in source 6:'/
                  ' zinl > zinu '//);
       STOP;
    ]
]
"------------------------------------------------------------------------"
ELSEIF(isource = 7) [ "Parallel at multiple, user-selected angles"
"------------------------------------------------------------------------"
    xiso   = temp(1);     yiso   = temp(2);     ziso   = temp(3);
    nang  = temp(4);     xcol   = temp(5);
    ycol   = temp(6);     phicol = temp(7);
    IF(nang>0)[
      OUTPUT iqin,xiso,yiso,ziso,nang,xcol,ycol,phicol;
      ( / ' Parallel beam incident from multiple, user-selected angles'/
          ' Electric charge of the source:'       ,t40,i12     /
          ' x-coordinate of the isocenter:'       ,t40,f10.4   /
          ' y-coordinate of the isocenter:'       ,t40,f10.4   /
          ' z-coordinate of the isocenter:'       ,t40,f10.4   /
          ' Number of incident theta-phi:'        ,t40,i12     /
          ' Total x-collimator width:'            ,t40,f10.4   /
          ' Total y-collimator width:'            ,t40,f10.4   /
          ' Collimator rotation angle:'           ,t40,f10.4   /);
      IF(nang>$MXANG)[
          OUTPUT61 $MXANG;
          (//' ***ERROR in source 7***'/
             ' Number of incident theta-phi > max. allowed (',I4,')'/
             ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
             ' and try again.'//);
          STOP;
      ]
      temp(1)=0.; "use temp(1) to normalize probabilities"
      DO I=1,nang["get each theta-phi and prob."
          OUTPUT I;(' Incident theta-phi pair ',I4,':'/
                    '    theta (deg.), phi (deg.), probability:',$);
          INPUT theta(I),phi(I),pang(I); (3F15.0);
          OUTPUT theta(I),phi(I),pang(I); (3F10.4);
          temp(1)=temp(1)+pang(I);
      ]
      DO I=1,nang["normalize probabilities + create cumulative prob distn"
          pang(I)=pang(I)/temp(1);
          IF(I>1)[
            pang(I)=pang(I)+pang(I-1);
          ]
      ]
      numang=nang;
    ]
    ELSEIF(nang<0)[
      OUTPUT iqin,xiso,yiso,ziso,-nang,xcol,ycol,phicol;
      ( / ' Parallel beam incident from multiple, user-selected angles'/
          ' Electric charge of the source:'       ,t40,i12     /
          ' x-coordinate of the isocenter:'       ,t40,f10.4   /
          ' y-coordinate of the isocenter:'       ,t40,f10.4   /
          ' z-coordinate of the isocenter:'       ,t40,f10.4   /
          ' No. of theta-phi groups:'             ,t40,i12     /
          ' Total x-collimator width:'            ,t40,f10.4   /
          ' Total y-collimator width:'            ,t40,f10.4   /
          ' Collimator rotation angle:'           ,t40,f10.4   /);
      temp(1)=0.; "use temp(1) to normalize probabilities"
      OUTPUT;(' For each theta-phi group, input:'/
'   ivary (=0 to vary phi, 1 to vary theta), fixed theta/phi (deg.), '/
'   min. varying theta/phi (deg.), max. varying theta/phi (deg.), '/
'   no. of varying angles in group (including min. and max.), '/
'   probability for group (all on one line).');
      DO I=1,-nang["get angle groups and probabilities"
         OUTPUT I;(' Incident theta-phi group ',I4,/
                   ' :',$);
         INPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
              (I12,3F15.0,I12,F15.0);
         IF(ngang(I)<2)[
           OUTPUT;(//' ***WARNING***'/
                     ' ngang(i) must be >=2.  It will be reset to 2 '/
                     ' in this case. '//);
           ngang(I)=2;
         ]
         OUTPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               (I10,3F10.4,I10,F10.4);
         temp(1)=temp(1)+pgang(I);
      ]
      K=0; "index for individual angles"
      DO I=1,-nang["calculate individual theta-phi, normalize probs, and"
                   "create cumulative prob distn"
         pgang(I)=pgang(I)/temp(1);"renormalize group probs"
         DO J=1,ngang(I)[
           K=K+1;
           IF(K>$MXANG)[
             OUTPUT61 $MXANG;
             (//' ***ERROR in source 7***'/
                ' Number of incident theta-phi > max. allowed (',I4,')'/
                ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
                ' and try again.'//);
             STOP;
           ]
           IF(ivary(I)=1)["fixed phi"
             phi(K)=angfixed(I);
             theta(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
           ]
           ELSE["fixed theta"
             theta(K)=angfixed(I);
             phi(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
           ]
           pang(K)=pgang(I)/ngang(I);
           IF(K>1)[
              pang(K)=pang(K)+pang(K-1);
           ]
         ]
      ]
      numang=K;
    ]
    OUTPUT;(' ');
]
"------------------------------------------------------------------------"
ELSEIF(isource = 8)[ "Full phase space incident from multiple angles"
"------------------------------------------------------------------------"
    xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
    nang   = temp(4);     dsource = temp(5);
    phicol  = temp(6);     iqphsp=iqin;
    i_dbs=temp(7); r_dbs=temp(8); ssd_dbs=temp(9); z_dbs=temp(10);
    e_split=temp(11);
    IF(nang>0)[
      OUTPUT xiso,yiso,ziso,nang,dsource,phicol,e_split;
      ( / ' Full hase space from multiple, user-selected angles'/
        ' x-coordinate of the isocenter:'    ,t55,f10.4/
        ' y-coordinate of the isocenter:'    ,t55,f10.4/
        ' z-coordinate of the isocenter:'    ,t55,f10.4/
        ' Number of incident theta-phi:',t55,i10/
        ' Distance from isocenter to origin in source plane:',t55,f10.4/
        ' Source rotation angle:'            ,t55,f10.4/
        ' No. of times to split e+/e-:'    ,t55,i10/);
      IF(i_dbs=1)[
        OUTPUT r_dbs,ssd_dbs,z_dbs;
        (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
          ' in BEAM simulation to generate phase space source with:'/
          '    DBS splitting radius:',t55,f10.4/
          '    SSD where radius defined:',t55,f10.4/
          '    Z where source scored:',t55,f10.4/
          ' Photons whose trajectory takes them outside the DBS splitting'/
          ' radius at the SSD will be rejected.'/);
        IF(ssd_dbs<z_dbs)[
         OUTPUT;(//' ***WARNING:'/
                   ' SSD where DBS splitting radius is defined < the Z'/
                   ' value of scoring plane for this source.'/
                   ' Particle rejection will be turned off.'//);
         i_dbs=0;
        ]
      ]
      ELSE[
        i_dbs=0;
      ]
      IF(iqphsp=2)[OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/);]
      ELSE[OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/);]
      IF(nang>$MXANG)[
          OUTPUT61 $MXANG;
          (//' ***ERROR in source 7***'/
             ' Number of incident theta-phi > max. allowed (',I4,')'/
             ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
             ' and try again.'//);
          STOP;
      ]
      temp(1)=0.; "use temp(1) to normalize probabilities"
      DO I=1,nang["get each theta-phi and prob."
          OUTPUT I;(' Incident theta-phi pair ',I4,':'/
                    '    theta (deg.), phi (deg.), probability:',$);
          INPUT theta(I),phi(I),pang(I); (3F15.0);
          OUTPUT theta(I),phi(I),pang(I); (3F10.4);
          temp(1)=temp(1)+pang(I);
      ]
      DO I=1,nang["normalize probabilities + create cumulative prob distn"
          pang(I)=pang(I)/temp(1);
          IF(I>1)[
            pang(I)=pang(I)+pang(I-1);
          ]
      ]
      numang=nang;
    ]
    ELSEIF(nang<0)[
      OUTPUT xiso,yiso,ziso,-nang,dsource,phicol;
      ( / ' Full phase space from multiple, user-selected angles'/
        ' x-coordinate of the isocenter:'    ,t55,f10.4/
        ' y-coordinate of the isocenter:'    ,t55,f10.4/
        ' z-coordinate of the isocenter:'    ,t55,f10.4/
        ' Number of theta-phi groups:',t55,i10/
        ' Distance from isocenter to origin in source plane:',t55,f10.4/
        ' Source rotation angle:'            ,t55,f10.4/);
      IF(i_dbs=1)[
        OUTPUT r_dbs,ssd_dbs,z_dbs;
        (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
          ' in BEAM simulation to generate phase space source with:'/
          '    DBS splitting radius:',t55,f10.4/
          '    SSD where radius defined:',t55,f10.4/
          '    Z where source scored:',t55,f10.4/
          ' Photons whose trajectory takes them outside the DBS splitting'/
          ' radius at the SSD will be rejected.'/);
        IF(ssd_dbs<z_dbs)[
         OUTPUT;(//' ***WARNING:'/
                   ' SSD where DBS splitting radius is defined < the Z'/
                   ' value of scoring plane for this source.'/
                   ' Particle rejection will be turned off.'//);
         i_dbs=0;
        ]
      ]
      ELSE[
        i_dbs=0;
      ]
      IF(iqphsp=2)[OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/);]
      ELSE[ OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/); ]
      temp(1)=0.; "use temp(1) to normalize probabilities"
      OUTPUT;(' For each theta-phi group, input:'/
'   ivary (=0 to vary phi, 1 to vary theta), fixed theta/phi (deg.), '/
'   min. varying theta/phi (deg.), max. varying theta/phi (deg.), '/
'   no. of varying angles in group (including min. and max.), '/
'   probability for group (all on one line).');
      DO I=1,-nang["get angle groups and probabilities"
         OUTPUT I;(' Incident theta-phi group ',I4,/
                   ' :',$);
         INPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
              (I12,3F15.0,I12,F15.0);
         IF(ngang(I)<2)[
           OUTPUT;(//' ***WARNING***'/
                     ' ngang(i) must be >=2.  It will be reset to 2 '/
                     ' in this case. '//);
           ngang(I)=2;
         ]
         OUTPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               (I10,3F10.4,I10,F10.4);
         temp(1)=temp(1)+pgang(I);
      ]
      K=0; "index for individual angles"
      DO I=1,-nang["calculate individual theta-phi, normalize probs, and"
                   "create cumulative prob distn"
         pgang(I)=pgang(I)/temp(1);"renormalize group probs"
         DO J=1,ngang(I)[
           K=K+1;
           IF(K>$MXANG)[
             OUTPUT61 $MXANG;
             (//' ***ERROR in source 7***'/
                ' Number of incident theta-phi > max. allowed (',I4,')'/
                ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
                ' and try again.'//);
             STOP;
           ]
           IF(ivary(I)=1)["fixed phi"
             phi(K)=angfixed(I);
             theta(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
           ]
           ELSE["fixed theta"
             theta(K)=angfixed(I);
             phi(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
           ]
           pang(K)=pgang(I)/ngang(I);
           IF(K>1)[
              pang(K)=pang(K)+pang(K-1);
           ]
         ]
      ]
      numang=K;
    ]
    OUTPUT;(' ');
]
"------------------------------------------------------------------------"
ELSEIF(isource = 9)[ "BEAM simulation of treatment head"
"------------------------------------------------------------------------"
    xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
    theta(1)   = temp(4);     phi(1)     = temp(5);     dsource = temp(6);
    phicol  = temp(7);     iqinc=iqin;
    i_dbs=temp(8); e_split=temp(9);
    OUTPUT xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,e_split;
    ( / ' BEAM simulation of treatment head incident from any direction'/
        ' x-coordinate of the isocenter:'    ,t55,f10.4/
        ' y-coordinate of the isocenter:'    ,t55,f10.4/
        ' z-coordinate of the isocenter:'    ,t55,f10.4/
        ' Polar angle of beam central axis:',t55,f10.4/
        ' Azimuthal angle of beam central axis:' ,t55,f10.4/
        ' Distance from isocenter to centre of'/
        '            scoring plane in BEAM simulation:',t55,f10.4/
        ' Rotation angle about beam axis:',t55,f10.4/
        ' No. of times to split e+/e-:',t55,i10/);
    IF(i_dbs=1)[
      OUTPUT;
    ( ' Fat photons resulting from DBS will be rejected'/);
    ]
    ELSE[
      OUTPUT;
    ( ' Fat photons resulting from DBS will not be rejected'/);
      i_dbs=0;
    ]
    IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
    ELSE[ OUTPUT iqinc; (/' Charge of incident particles to use: ',i2/); ]
]
"------------------------------------------------------------------------"
ELSEIF(isource = 10)[ "BEAM simulation source from multiple angles"
"------------------------------------------------------------------------"
    xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
    nang   = temp(4);     dsource = temp(5);
    phicol  = temp(6);     iqinc=iqin;
    i_dbs=temp(7); e_split=temp(8);
    IF (nang>0)[
      OUTPUT xiso,yiso,ziso,nang,dsource,phicol,e_split;
      ( / ' BEAM simulation source incident from multiple angles'/
        ' x-coordinate of the isocenter:'    ,t55,f10.4/
        ' y-coordinate of the isocenter:'    ,t55,f10.4/
        ' z-coordinate of the isocenter:'    ,t55,f10.4/
        ' No. of incident theta-phi:',t55,i10/
        ' Distance from isocenter to centre of'/
        '            scoring plane in BEAM simulation:',t55,f10.4/
        ' Rotation angle about beam axis:',t55,f10.4/
        ' No. of time to split e+/e-:',t55,i10/);
    ]
    ELSEIF (nang<0) [
      OUTPUT xiso,yiso,ziso,-nang,dsource,phicol,e_split;
      ( / ' BEAM simulation source incident from multiple angles'/
        ' x-coordinate of the isocenter:'    ,t55,f10.4/
        ' y-coordinate of the isocenter:'    ,t55,f10.4/
        ' z-coordinate of the isocenter:'    ,t55,f10.4/
        ' No. of theta-phi groups:',t55,i10/
        ' Distance from isocenter to centre of'/
        '            scoring plane in BEAM simulation:',t55,f10.4/
        ' Rotation angle about beam axis:',t55,f10.4/
        ' No. of time to split e+/e-:',t55,i10/);
    ]
    IF(i_dbs=1)[
      OUTPUT;
    ( ' Fat photons resulting from DBS will be rejected'/);
    ]
    ELSE[
      OUTPUT;
    ( ' Fat photons resulting from DBS will not be rejected'/);
      i_dbs=0;
    ]
    IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
    ELSE[ OUTPUT iqinc; (/' Charge of incident particles to use: ',i2/); ]
    IF(nang>0)[
      IF(nang>$MXANG)[
          OUTPUT61 $MXANG;
          (//' ***ERROR in source 7***'/
             ' Number of incident theta-phi > max. allowed (',I4,')'/
             ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
             ' and try again.'//);
          STOP;
      ]
      temp(1)=0.; "use temp(1) to normalize probabilities"
      DO I=1,nang["get each theta-phi and prob."
          OUTPUT I;(' Incident theta-phi pair ',I4,':'/
                    '    theta (deg.), phi (deg.), probability:',$);
          INPUT theta(I),phi(I),pang(I); (3F15.0);
          OUTPUT theta(I),phi(I),pang(I); (3F10.4);
          temp(1)=temp(1)+pang(I);
      ]
      DO I=1,nang["normalize probabilities + create cumulative prob distn"
          pang(I)=pang(I)/temp(1);
          IF(I>1)[
            pang(I)=pang(I)+pang(I-1);
          ]
      ]
      numang=nang;
    ]
    ELSEIF(nang<0)[
      temp(1)=0.; "use temp(1) to normalize probabilities"
      OUTPUT;(' For each theta-phi group, input:'/
'   ivary (=0 to vary phi, 1 to vary theta), fixed theta/phi (deg.), '/
'   min. varying theta/phi (deg.), max. varying theta/phi (deg.), '/
'   no. of varying angles in group (including min. and max.), '/
'   probability for group (all on one line).');
      DO I=1,-nang["get angle groups and probabilities"
         OUTPUT I;(' Incident theta-phi group ',I4,/
                   ' :',$);
         INPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
              (I12,3F15.0,I12,F15.0);
         IF(ngang(I)<2)[
           OUTPUT;(//' ***WARNING***'/
                     ' ngang(i) must be >=2.  It will be reset to 2 '/
                     ' in this case. '//);
           ngang(I)=2;
         ]
         OUTPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               (I10,3F10.4,I10,F10.4);
         temp(1)=temp(1)+pgang(I);
      ]
      K=0; "index for individual angles"
      DO I=1,-nang["calculate individual theta-phi, normalize probs, and"
                   "create cumulative prob distn"
         pgang(I)=pgang(I)/temp(1);"renormalize group probs"
         DO J=1,ngang(I)[
           K=K+1;
           IF(K>$MXANG)[
             OUTPUT61 $MXANG;
             (//' ***ERROR in source 7***'/
                ' Number of incident theta-phi > max. allowed (',I4,')'/
                ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
                ' and try again.'//);
             STOP;
           ]
           IF(ivary(I)=1)["fixed phi"
             phi(K)=angfixed(I);
             theta(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
           ]
           ELSE["fixed theta"
             theta(K)=angfixed(I);
             phi(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
           ]
           pang(K)=pgang(I)/ngang(I);
           IF(K>1)[
              pang(K)=pang(K)+pang(K-1);
           ]
         ]
      ]
      numang=K;
    ]
    OUTPUT;(' ');
]
"------------------------------------------------------------------------"
ELSEIF(isource = 20)[ "Phase Space Incident from multiple settings and "
		      "through an MLC (optional)"
"------------------------------------------------------------------------"
    nset   = temp(1);	  iqinc=iqin;
    i_dbs=temp(2); r_dbs=temp(3); ssd_dbs=temp(4); z_dbs=temp(5);
    e_split=temp(6); i_muidx_out=temp(7); calflag=temp(8);
    "The following IF statement is used to preserve compatibility with old"
    "input files and keep the e_split value (JL)"
    IF(ssd_dbs=0 & z_dbs=0 & r_dbs>0)[
        r_dbs = 0;
        e_split = temp(3);
    ]
    IF(nset>1)[
    OUTPUT nset,e_split;
    ( / ' Phase Space source though dynamic library with multiple variable'/
        ' geometry settings'/
        ' Number of settings:',t55,i10/
        ' No. of time to split e+/e-:',t55,i10/);
    IF(i_dbs=1)[
        OUTPUT r_dbs,ssd_dbs,z_dbs;
        (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
          ' in BEAM simulation to generate phase space source with:'/
          '    DBS splitting radius:',t55,f10.4/
          '    SSD where radius defined:',t55,f10.4/
          '    Z where source scored:',t55,f10.4/
          ' Photons whose trajectory takes them outside the DBS splitting'/
          ' radius at the SSD will be rejected.'/);
        IF(ssd_dbs<z_dbs)[
         OUTPUT;(//' ***WARNING:'/
                   ' SSD where DBS splitting radius is defined < the Z'/
                   ' value of scoring plane for this source.'/
                   ' Particle rejection will be turned off.'//);
         i_dbs=0;
        ]
         IF(r_dbs=0)["r_dbs was set to 0 assuming it was incorrectly read"
         "from an old input file (JL)"
         OUTPUT;(//' ***WARNING:'/
                   ' DBS splitting radius is 0.'/
                   ' Make sure it is defined correctly in the input file.'/
                   ' Particle rejection will be turned off.'//);
         i_dbs=0;
        ]
      ]
      ELSE[
        i_dbs=0;
      ]

    IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
    ELSE[ OUTPUT iqinc; (/' Charge of incident particles to use: ',i2/); ]

    IF(nset>$MXANG)[
          OUTPUT61 $MXANG;
          (//' ***ERROR in source 20***'/
             ' Number of incident settings > max. allowed (',I4,')'/
             ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
             ' and try again.'//);
          STOP;
     ]

     IF(i_muidx_out<0 | i_muidx_out>1) i_muidx_out=0;
     IF(i_muidx_out=1)[
         OUTPUT;
       (' If writing phase space data on exit from phantom (i_phsp_out=1 or 2)'/
        ' frMU_indx (fractional monitor unit index) will be included.');
     ]

     IF(calflag < 0 | calflag > 1) calflag = 0; "Default to running calib run"
     IF(calflag = 1)[
         OUTPUT;
         (' Skipping calibration run. Make sure that your phase space file has'/
          ' enough particles to avoid rewinding, otherwise uncertainty values'/
          ' will be inaccurate.');
     ]

      DO I=1,nset["get each setting"
         OUTPUT I;(' Incident setting ',I4,':'/
         '    xiso (cm), yiso (cm), ziso (cm), theta (deg.)',
	 	', phi (deg.), phicol (deg.),SAD (cm), MU Index:',$);
          INPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
	       phicoltemp(I),dsourcetemp(I),muIndex(I);(8F15.0);
          OUTPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
	       phicoltemp(I),dsourcetemp(I), muIndex(I); (8F10.4);
      ]
      dsource=dsourcetemp(1);"set to first one arbitrarily since its done"
				     "later on the fly"
    ]"if nset is greater than 1
    ELSEIF(nset<2) [
	  OUTPUT61 nset;
	  (//' ***ERROR in source 20***'/
	  'nset (',I8,') must be >= 2'//);
	  STOP;
    ]
    OUTPUT;(' ');
]
"------------------------------------------------------------------------"
ELSEIF(isource = 21)[ "BEAM simulation with multiple settings and through"
	       "MLC (optional)"
"------------------------------------------------------------------------"
    nset=temp(1);
    i_dbs=temp(2);
    e_split=temp(3);
    i_muidx_out=temp(4);
    iqinc=iqin;
    IF(nset>1)[
        OUTPUT nset,e_split;
        ( / ' Full BEAM Sim. incident from multiple settings'/
            ' Number of settings:',t55,i10/
            ' No. of time to split e+/e-:',t55,i10/);
        IF(i_dbs=1)[
            OUTPUT;
            ( ' Fat photons resulting from DBS will be rejected'/);
    ]
    ELSE[
      OUTPUT;
      ( ' Fat photons resulting from DBS will not be rejected'/);
      i_dbs=0;
    ]
    IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
    ELSE[ OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/); ]

    IF(nset>$MXANG)[
          OUTPUT61 $MXANG;
          (//' ***ERROR in source 12***'/
             ' Number of incident settings > max. allowed (',I4,')'/
             ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
             ' and try again.'//);
          STOP;
     ]

     IF(i_muidx_out<0 | i_muidx_out>1) i_muidx_out=0;
     IF(i_muidx_out=1)[
         OUTPUT;
       (' If writing phase space data on exit from phantom (i_phsp_out=1 or 2)'/
        ' frMU_indx (fractional monitor unit index) will be included.');
     ]

      DO I=1,nset["get each setting"
         OUTPUT I;(' Incident setting ',I4,':'/
         '  xiso (cm), yiso (cm), ziso (cm), theta (deg.)',
         '  phi (deg.), phicol (deg.), SAD (cm), MU Index:',$);
         INPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
            phicoltemp(I),dsourcetemp(I), muIndex(I);(8F15.0);
         OUTPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
            phicoltemp(I),dsourcetemp(I),muIndex(I); (8F10.4);
      ]
      dsource=dsourcetemp(1);"set to first one arbitrarily since its done"
				     "later on the fly"
  ]
  ELSEIF(nset<2) [
	  OUTPUT61 nset;
	  (//' ***ERROR in source 21***'/
	  'nset (',I8,') must be >= 2'//);
	  STOP;
	  ]
	  OUTPUT;(' ');
]
"------------------------------------------------------------------------"
ELSE[ "Bad input, set error flag and return"
"------------------------------------------------------------------------"
    OUTPUT61 isource;(' ***ISOURCE =', I10,' not valid: stopping');
    stop;
]

"     READ NEXT RECORD"
"     ================"

OUTPUT;
(' Enflag(0=mono-E,1=spectr,2=phsp or full BEAM sim.,3=dose comp,4=beam model),'
/' Mode(0,2), medsur(0 = vacuum), dsurround(1), dflag(0=1 dsurround,'/
 ' 1=4 dsurrounds), dsurround(2), dsurround(3), dsurround(4)',/,' :',$);
INPUT enflag,ismode,medsur,dsurround(1),dflag,dsurround(2),dsurround(3),
      dsurround(4); (3I12,F15.0,I12,3F15.0);

"Set the defaults for the above parameters if needed"
IF(enflag>1)[ "some sort of phase space input or BEAM simultion source"
  IF(ismode ~= 2)ismode=0;"default is 0"
  "now set the proper dsurrounds"
  IF(dflag~=1)[
    dflag=0;"default"
    IF(dsurround(1)<=0.)[
     dsurround(1)=50.;"default= 50 cm thickness"
     OUTPUT dsurround(1);(/10x,' dsurround(1) defaults to',F8.3,' cm.'/);
    ]
    dsurround(2)=dsurround(1);
    dsurround(3)=dsurround(1);
    dsurround(4)=dsurround(1);
  ]
  ELSE[
    IF(dsurround(1)<0.)["default to 0 here"
     dsurround(1)=0.;
     OUTPUT dsurround(1);(/10x,' dsurround(1) defaults to',F8.3,' cm.'/);
    ]
    IF(dsurround(2)<0.)["default to 0 here"
     dsurround(2)=0.;
     OUTPUT dsurround(2);(/10x,' dsurround(2) defaults to',F8.3,' cm.'/);
    ]
    IF(dsurround(3)<0.)["default to 0 here"
     dsurround(3)=0.;
     OUTPUT dsurround(3);(/10x,' dsurround(3) defaults to',F8.3,' cm.'/);
    ]
    IF(dsurround(4)<0.)["default to 0 here"
     dsurround(4)=0.;
     OUTPUT dsurround(4);(/10x,' dsurround(4) defaults to',F8.3,' cm.'/);
    ]
  ]
]
IF(enflag > 1 & dflag = 1)[
   OUTPUT enflag,ismode,medsur,dsurround(1),dflag,dsurround(2),dsurround(3),
       dsurround(4) ;(3I12,F8.3,I12,3F8.3);
]
ELSE[
   OUTPUT enflag,ismode,medsur,dsurround(1),dflag;(3I12,F8.3,I12);
]
IF(enflag>1)[
  IF (medsur<=0) | ( medsur>nmed)[
    med($IR(imax,jmax,kmax)+1)=0;
    IF(dflag=0)[
      OUTPUT61 dsurround(1);
    (/' The material in the region outside the phantom is vacuum.'/
     ' The thickness of this region (in x, y & z direction) is:',F8.3,' cm'/);
    ]
    ELSE[
      OUTPUT61 dsurround(1),dsurround(2),dsurround(3),dsurround(4);
    (/' The material in the region outside the phantom is vacuum.'/
     ' The thickness of this region in the x direction is:',F8.3,' cm'/
     ' The thickness in the y direction is:',F8.3,' cm'/
     ' The thickness in the +z direction is:',F8.3,' cm'/
     ' The thickness in the -z direction is:',F8.3,' cm'/);
    ]
  ]
  ELSE[
    med($IR(imax,jmax,kmax)+1)=medsur;
    IF(dflag=0)[
       OUTPUT61(media(j,medsur),j=1,24),dsurround(1);
    (/' The material in the region outside the phantom is:',24a1/
     ' The thickness of this region (in x, y & z direction) is:',F8.3,' cm'/);
    ]
    ELSE[
       OUTPUT61(media(j,medsur),j=1,24),dsurround(1),dsurround(2),
               dsurround(3),dsurround(4);
    (/' The material in the region outside the phantom is:',24a1/
      ' The thickness of this region in the x direction is:',F8.3,' cm'/
     ' The thickness in the y direction is:',F8.3,' cm'/
     ' The thickness in the +z direction is:',F8.3,' cm'/
     ' The thickness in the -z direction is:',F8.3,' cm'/);
    ]
  ]
  dsurround(1)=dsurround(1)+0.0001;
  dsurround(2)=dsurround(2)+0.0001;
  dsurround(3)=dsurround(3)+0.0001;
  dsurround(4)=dsurround(4)+0.0001;
  "added a small margin to prevent roundoff error later"
]
"----------------------------------------------------------------"
IF(enflag = 0)[ "monoenergetic source"
"----------------------------------------------------------------"
  OUTPUT;(' Beam Energy (K.E. in MeV):',$);
  read(5,*) ein;
  OUTPUT ein;(F10.3);
]
"----------------------------------------------------------------"
ELSEIF(enflag = 1)["input an energy spectrum"
"----------------------------------------------------------------"
    OUTPUT;(' Energy spectrum:');
    OUTPUT;(' Input name of file with spectrum data (A256): ',$);
    READ(5,101,ERR=:ERR_SOURCE1:) FILNAM;
    101 FORMAT(A256);
    OUTPUT61 FILNAM;(/'   Read input energy spectrum from: ',/A);
    call replace_env(FILNAM);
    OPEN(UNIT=99,STATUS='OLD',file=FILNAM);
    READ(99,101) SPEC_TITLE;
    READ(99,'(I10,F15.0,I5)')NENSRC,ENMIN,IMODE;
    IF (NENSRC > $NENSRC)[
       OUTPUT61 NENSRC,$NENSRC;(//' Number of energy bins=',I4,
       ' is greater than max allowed =',I4/' Reduced to max allowed.'//);
       NENSRC = $NENSRC;
    ]
    READ(99,'(2F20.0)')(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
    CLOSE(UNIT=99);
    OUTPUT61 NENSRC; ('  Have read',I5,' input energy bins from file');
    IF(IMODE=0)[OUTPUT61;('      Counts/bin assumed');  ]
    ELSEIF(IMODE = 1)[
       OUTPUT61;('      Counts/MeV assumed');
       SRCPDF(1) = SRCPDF(1)*(ENSRCD(1)-ENMIN);
       DO IB=2,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
       ] "end mode = 1 block"
    ELSE [
       OUTPUT61 IMODE;(///'*****MODE not 0 or 1 in spectrum file? **'
         /80('*') //);
       ]
    EIN = ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
    OUTPUT61 ENMIN,EIN;('    Energy ranges from',F10.3,' MeV to',F12.3,' MeV');

    "check that minimum energy of first non-zero bin is above ECUT,PCUT"
    IF(SRCPDF(1)>0.0)[
        IF(iqin=-1&ENMIN<ECUT)[
          OUTPUT61;(//' *******WARNING:'/
                      ' min. energy of spectrum < ECUT'/
' May lead to artifically high dose in voxel(s) on which source is incident'//);
        ]
        ELSEIF(iqin=0&ENMIN<PCUT)[
          OUTPUT61;(//' *******WARNING:'/
                      ' min. energy of spectrum < PCUT'/
' May lead to artifically high dose in voxel(s) on which source is incident'//);
        ]
    ]
    ELSE["find out the min energy of the first non-zero bin"
        DO IB=2,NENSRC[
          IF(SRCPDF(IB)>0.)[
            IF(iqin=-1&ENSRCD(IB-1)<ECUT)[
               OUTPUT61;(//' *******WARNING:'/
                      ' min. energy of spectrum < ECUT'/
' May lead to artifically high dose in voxel(s) on which source is incident'//);
            ]
            ELSEIF(iqin=0&ENSRCD(IB-1)<PCUT)[
               OUTPUT61;(//' *******WARNING:'/
                      ' min. energy of spectrum < PCUT'/
' May lead to artifically high dose in voxel(s) on which source is incident'//);
            ]
            EXIT;
          ]
        ]
    ]

    "INITIALIZATION ROUTINE TO CALCULATE THE INVERSE OF THE CUMULATIVE "
    "PROBABILITY DISTRIBUTION THAT IS USED DURING EXECUTION TO SAMPLE  "
    "THE INCIDENT PARTICLE ENERGY"
    "CALCULATE THE CPDF FROM THE PDF AND NORMALIZE IT"
    SRCCDF(1)=SRCPDF(1);
    DO IB=2,NENSRC[ SRCCDF(IB)=SRCCDF(IB-1)+SRCPDF(IB); ]
    FNORM=1./SRCCDF(NENSRC);
    BINSOK=0.0;
    DELTAK=$INVDIM;
    GRIDSZ=1/DELTAK;
    DO IB=1,NENSRC[
       SRCCDF(IB)=FNORM*SRCCDF(IB);
       IF(IB = 1)[IF(SRCCDF(1) <= 3.*GRIDSZ )[BINSOK = 1.0;] ]
       ELSE [     IF((SRCCDF(IB)-SRCCDF(IB-1)) < 3.*GRIDSZ) [BINSOK=1.0;] ]
    ]"END OF LOOP ON IB"
    IF(BINSOK.NE.0.0)[OUTPUT61;(///' *******WARNING******'/
      T20,'SOME OF NORMALIZED BIN PROBABILITIES SO SMALL BINS MAY BE MISSED'/);
    ]
    "CALCULATE CDFINV - AN ARRAY WHICH ALLOWS THE RAPID SAMPLING FOR THE"
    "ENERGY BY PRECOMPUTING THE RESULTS FOR A FINE GRID"

    DO K=1,$INVDIM [
       AK= FLOAT(K)*GRIDSZ;
       DO I=1,NENSRC [ IF(AK <= SRCCDF(I))[ GO TO :FOUND-BIN:;] ]
       "WE SHOULD NEVER FALL THROUGH TO HERE"
       :FOUND-BIN:
       IF(I ~= 1)[CDFINV(K,1) = ENSRCD(I-1);]
       ELSE [CDFINV(K,1) = ENMIN;]
       CDFINV(K,2) = ENSRCD(I)-CDFINV(K,1);
    ]"END LOOP OVER K"

    "OUTPUT IF IWATCH IS ACTIVE"
    IF(IWATCH ~= 0)[
      OUTPUT SPEC_TITLE;(1x,80A1);
      OUTPUT;(/' ENSRCD,   SRCPDF,   SRCCDF:'//);
      OUTPUT (ENSRCD(IB),SRCPDF(IB),SRCCDF(IB),IB=1,NENSRC);(3E17.7);
      OUTPUT;(//);]
]"end of (enflag = 1)"

"----------------------------------------------------------------"
ELSEIF( (enflag = 2) | (enflag = 3) )["phase space input or full BEAM sim."
"----------------------------------------------------------------"
  IF(isource=2 | isource=8)[
    OLDSRC=0;"flag for old phase space files"
    OUTPUT;(' Input name of phase space file (A256)'/'  : ',$);
    READ(5,101,ERR=:ERR_SOURCE2:) FILNAM;
    OUTPUT61 FILNAM;(/' Particles will be read from file: ',/A);

    call replace_env(FILNAM);

    i_iaea_in=0; "assume not in IAEA format"
    ilen=lnblnk1(FILNAM);
    IF(FILNAM(ilen-8:ilen)='.IAEAphsp')[
         i_iaea_in=1;
         FILNAM=FILNAM(:ilen-9);
    ]

    IF(i_iaea_in=1)[
        i_unit_in=44;
        $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,FILNAM);
        $IAEA_READ_PHSP_HEADER(i_unit_in,nshist,nphist,ein,nincsrc,
                               Z_SOURCE,ismode,i_mu_phsp,izscore);
        OUTPUT nshist,nphist,ein,NINCSRC;
           (T10,' IAEA format Phase space source with:'/
            T5,'                    Total number of particles =',I13/
            T5,'                            Number of photons =',I13/
            T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
            T5,' # of particles incident from original source =',F13.3/);
        IF(izscore=0)[
         OUTPUT Z_SOURCE;
         (T5,'                        Z where source scored =',F13.3,' cm'/);
        ]
        $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(i_unit_in);
    ]
    ELSE[

    $OPEN_PHSP_FOR_READ(ismode,44,FILNAM,MODE,nshist,nphist,ein,temp(2),
                         NINCSRC);
    IF(NINCSRC<2.)["old file with min phot. energy"
               OUTPUT61;(//' ******WARNING*****'/
                  ' PHASE SPACE SOURCE WAS GENERATED USING AN OLDER'/
                  ' VERSION OF BEAM IN WHICH # OF PARTICLES INCIDENT FROM'/
                  ' ORIGINAL SOURCE WAS NOT STORED.  THIS NUMBER WILL'/
                  ' BE SET EQUAL TO THE NUMBER OF PARTICLES IN THE PHASE'/
                  ' SPACE SOURCE, AND DOSE WILL BE NORMALIZED'/
                  ' WITH RESPECT TO THE # OF HISTORIES RUN...NOT'/
                  ' THE # OF INCIDENT PARTICLES FROM THE ORIGINAL SOURCE'//);
               NINCSRC=nshist;
               OLDSRC=1;
    ]
    OUTPUT61 nshist,nphist,ein,temp(2),NINCSRC;
          (/' Total number of particles in file      :',I13/
          ' Total number of photons                :',I13/
          ' The rest are electrons/positrons.'/ ' '/
          ' Maximum kinetic energy of the particles:     ',F13.3,' MeV'/
          ' Minimum kinetic energy of the electrons:     ',F13.3,' MeV'/
          ' # of particles incident from original source:',F13.1);

    "now read 2nd record, if nhistm gets incremented, then we have a"
    "phsp file that stores nhist"
    nhistm=0;
    $READ_PHSP_RECORD(ismode,44,2:
           nhistm,zlastm,latchm,einm,wtm,xinm,yinm,uinm,vinm);
    IF(nhistm~=1)[
       dose_stat=1;
       OUTPUT;(//' ***WARNING***'/
       ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
       ' Dose and fluence will be analyzed assuming each particle read from'/
       ' the ph-sp file is an independent history.  May result in an'/
       ' underestimate of uncertainties.'//);
    ]
   ]"end of standard BEAMnrc-format phsp source"
  ]
  ELSEIF(isource =9 | isource=10 )["full BEAM sim."
    "read in name of simulation, input file, pegs4 file"
    OUTPUT;
   (' Input name of beam code (BEAM_accelname), input file (no ext.), '/
    ' pegs data (no ext.) (A256)'/'  : ',$);
    READ(5,'(A)',ERR=:ERR_SOURCE9:) FILNAM;
    OUTPUT $cstring(FILNAM);(A);
    "now parse FILNAM for the inputs"

    the_beam_code=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_beam_code,' ')=1) [
      IF(len(the_beam_code)>=2)[
        the_beam_code=the_beam_code(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_beam_code=the_beam_code(:lnblnk1(the_beam_code));

    the_input_file=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_input_file,' ')=1) [
      IF(len(the_input_file)>=2) [
        the_input_file=the_input_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_input_file=the_input_file(:lnblnk1(the_input_file));

    the_pegs_file=FILNAM(:lnblnk1(FILNAM));
    "strip leading blanks"
    IF(len($cstring(the_pegs_file))=0)the_pegs_file='pegsless';
    WHILE(INDEX(the_pegs_file,' ')=1) [
      IF(len(the_pegs_file)>=2) [
        the_pegs_file=the_pegs_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]

    IF(the_pegs_file=' ')the_pegs_file='pegsless';

    OUTPUT $cstring(the_beam_code),$cstring(the_input_file),
             $cstring(the_pegs_file);
    (/' BEAM simulation name: ',A/
      '           input file: ',A/
      '   pegs data for BEAM: ',A/);
  ]
  ELSEIF(isource = 20)["Phase Space Incident from multiple settings"
			      "and through an MLC or BEAM Accel."
    "read in name of MLC/BEAM code, input file"
    OUTPUT;
   (' Name of BEAM/MLC code (e.g. particelDmlc)--leave blank if no geometry, '/
    ' phase space file above shared library, '/
    ' input file for BEAM/MLC code (A256), '/'  : ',$);
    READ(5,'(A)',ERR=:ERR_SOURCE20:) FILNAM;
    OUTPUT $cstring(FILNAM);(A);
    "now parse FILNAM for the input"

    the_shared_lib=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_shared_lib,' ')=1) [
      IF(len(the_shared_lib)>=2)[
        the_shared_lib=the_shared_lib(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_shared_lib=the_shared_lib(:lnblnk1(the_shared_lib));

    the_phsp_file=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_phsp_file,' ')=1) [
      IF(len(the_phsp_file)>=2) [
        the_phsp_file=the_phsp_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_phsp_file=the_phsp_file(:lnblnk1(the_phsp_file));

    OUTPUT $cstring(the_phsp_file);
    (/'phase space file: ',A/);

    OUTPUT61 the_phsp_file;(/' Particles will be read from file: ',/A);

    call replace_env(the_phsp_file);

    i_iaea_in=0; "assume not in IAEA format"
    dosxyz2beam_izscore=0; "assume not scoring Z for each particle"
    ilen=lnblnk1(the_phsp_file);
    IF(the_phsp_file(ilen-8:ilen)='.IAEAphsp')[
         i_iaea_in=1;
         the_phsp_file=the_phsp_file(:ilen-9);
    ]

    IF(i_iaea_in=1)[
        i_unit_in=44;
        $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,the_phsp_file);
        $IAEA_READ_PHSP_HEADER(i_unit_in,nshist,nphist,ein,NINCSRC,
                               Z_SOURCE,ismode,i_mu_phsp,izscore);
        OUTPUT nshist,nphist,ein,NINCSRC;
           (T10,' IAEA format Phase space source with:'/
            T5,'                    Total number of particles =',I13/
            T5,'                            Number of photons =',I13/
            T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
            T5,' # of particles incident from original source =',F13.3/);
        IF(izscore=0)[
         OUTPUT Z_SOURCE;
         (T5,'                        Z where source scored =',F13.3,' cm'/);
        ]
        IF(i_mu_phsp=1)[
           OUTPUT;(T5,' Fractional MU index stored in phase space data.'/
                   T5,' This will be used to set the MU index in the DOSXYZ'/
                   T5,' simulation.'/);
        ]
        $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(i_unit_in);
        dosxyz2beam_izscore=izscore;"this will be passed to BEAM if using"
                                    "an intervening BEAM geometry"
    ]
    ELSE[
    $OPEN_PHSP_FOR_READ(ismode,44,the_phsp_file,MODE,nshist,nphist,ein,temp(2),
                         NINCSRC);
    IF(NINCSRC<2.)["old file with min phot. energy"
               OUTPUT61;(//' ******WARNING*****'/
                  ' PHASE SPACE SOURCE WAS GENERATED USING AN OLDER'/
                  ' VERSION OF BEAM IN WHICH # OF PARTICLES INCIDENT FROM'/
                  ' ORIGINAL SOURCE WAS NOT STORED.  THIS NUMBER WILL'/
                  ' BE SET EQUAL TO THE NUMBER OF PARTICLES IN THE PHASE'/
                  ' SPACE SOURCE, AND DOSE WILL BE NORMALIZED'/
                  ' WITH RESPECT TO THE # OF HISTORIES RUN...NOT'/
                  ' THE # OF INCIDENT PARTICLES FROM THE ORIGINAL SOURCE'//);
               NINCSRC=nshist;
               OLDSRC=1;
    ]
    OUTPUT61 nshist,nphist,ein,temp(2),NINCSRC;
          (/' Total number of particles in file      :',I13/
          ' Total number of photons                :',I13/
          ' The rest are electrons/positrons.'/ ' '/
          ' Maximum kinetic energy of the particles:     ',F13.3,' MeV'/
          ' Minimum kinetic energy of the electrons:     ',F13.3,' MeV'/
          ' # of particles incident from original source:',F13.1);

    "now read 2nd record, if nhistm gets incremented, then we have a"
    "phsp file that stores nhist"
    nhistm=0;
    $READ_PHSP_RECORD(ismode,44,2:
           nhistm,zlastm,latchm,einm,wtm,xinm,yinm,uinm,vinm);
    IF(nhistm~=1)[
       dose_stat=1;
       OUTPUT;(//' ***WARNING***'/
       ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
       ' Dose and fluence will be analyzed assuming each particle read from'/
       ' the ph-sp file is an independent history.  May result in an'/
       ' underestimate of uncertainties.'//);
    ] "end of standard BEAMnrc-format phsp source"
    ]
    the_input_file=FILNAM(:lnblnk1(FILNAM));
    "strip leading blanks"
    WHILE(INDEX(the_input_file,' ')=1) [
         IF(len(the_input_file)>=2) [
           the_input_file=the_input_file(2:);
         ]
         ELSE [
           EXIT;
         ]
    ]
    "strip trailing blanks"
    the_input_file=the_input_file(:lnblnk1(the_input_file));

    IF(the_shared_lib='0')[
        "no shared library
        SHLflag = 0;
    ]
    ELSEIF(the_shared_lib='particleDmlc') [
        "particles must go through MLC code compiled as a shared library
        MLCflag =1;
        SHLflag = 1;
        OUTPUT61; (/' Will use VCU simulation compiled as shared library:'/);
        OUTPUT61 the_input_file;(/' VCU input file: ',/A80);
    ]
    ELSE[
        "particles must go through BEAM shared library
        SHLflag =1;
        MLCflag=0;
        IF(is_pegsless) [ the_pegs_file='pegsless';]
        ELSE [ the_pegs_file= pegs_file; ]
        OUTPUT61 the_shared_lib;(/' BEAM library: ',/A80);
        OUTPUT61 the_input_file;(' BEAM input file: ',/A80);
        OUTPUT61 the_pegs_file;(' BEAM pegs data: ',/A80);
    ]
  ]
  ELSEIF(isource=21)["Full BEAM sim.incident from multiple settings"
			      "and through an MLC"
    "read in name of BEAM simulation, input file, pegs4 file"
    OUTPUT;
   (' Input name of beam code (BEAM_accelname), BEAM input file (no ext.), '/
    ' BEAM pegs data (no ext.), name of MLC code (e.g. particelDmlc), '/
    ' MLC code input file (A256)'/'  : ',$);
    READ(5,'(A)',ERR=:ERR_SOURCE21:) FILNAM;
    OUTPUT $cstring(FILNAM);(A);
    "now parse FILNAM for the inputs"

    the_beam_code=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_beam_code,' ')=1) [
      IF(len(the_beam_code)>=2)[
        the_beam_code=the_beam_code(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_beam_code=the_beam_code(:lnblnk1(the_beam_code));

    the_input_file=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_input_file,' ')=1) [
      IF(len(the_input_file)>=2) [
       the_input_file=the_input_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_input_file=the_input_file(:lnblnk1(the_input_file));


    the_pegs_file=FILNAM(:INDEX(FILNAM,',')-1);
    IF(len($cstring(the_pegs_file))=0)the_pegs_file='pegsless';
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_pegs_file,' ')=1) [
      IF(len($cstring(the_pegs_file))>=2) [
        the_pegs_file=the_pegs_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]

    IF(the_pegs_file=' ')the_pegs_file='pegsless';

    the_vcu_code=FILNAM(:INDEX(FILNAM,',')-1);
    FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
    "strip leading blanks"
    WHILE(INDEX(the_vcu_code,' ')=1) [
      IF(len(the_vcu_code)>=2)[
        the_vcu_code=the_vcu_code(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_vcu_code=the_vcu_code(:lnblnk1(the_vcu_code));

    IF(the_vcu_code='0')[
	"no MLC
	MLCflag = 0;
    ]
    ELSE[
	"particles must go through MLC code compiled as a shared library
	MLCflag = 1;
    ]

    the_vcu_input_file=FILNAM(:lnblnk1(FILNAM));
    "strip leading blanks"
    WHILE(INDEX(the_vcu_input_file,' ')=1) [
      IF(len(the_vcu_input_file)>=2) [
        the_vcu_input_file=the_vcu_input_file(2:);
      ]
      ELSE [
        EXIT;
      ]
    ]
    "strip trailing blanks"
    the_vcu_input_file=the_vcu_input_file(:lnblnk1(the_vcu_input_file));


    OUTPUT $cstring(the_beam_code),$cstring(the_input_file),
           $cstring(the_pegs_file),$cstring(the_vcu_code),
	   $cstring(the_vcu_input_file);
    (/' BEAM simulation name: ',A/
      '           input file: ',A/
      '   pegs data for BEAM: ',A/
      '  VCU simulation name: ',A/
      '       vcu input file: ',A/);
  ]
  IF( enflag = 3) ["Now do some bit checks on the phases space input"
       OUTPUT61;
(/' I_BIT_FILTER(0-incl/excl bits,1-excl bits,2-incl regions,3-excl regions),'/
 ' NBIT1(# bits/regions to incl [I_BIT_FILTER=0 or 2] '/
 '                      or excl [I_BIT_FILTER=1 or 3],'/
 ' NBIT2(# bits to excl [I_BIT_FILTER=0 only])--all on one line'/
 ' :',$);
       INPUT I_BIT_FILTER,NBIT1,NBIT2; (3i5);
       OUTPUT61 I_BIT_FILTER,NBIT1,NBIT2; (3i5);
       IF(I_BIT_FILTER<0 | I_BIT_FILTER > 3)["default to no checking"
         OUTPUT;(//' ***ERROR: I_BIT_FILTER out of range.'//);
         STOP;
       ]
       IF(I_BIT_FILTER~=0 & NBIT2 ~= 0)[
         OUTPUT61;(//' ***WARNING: NBIT2 is not 0 and you are using'/
                   ' I_BIT_FILTER=1, 2 or 3.  NBIT2 set to 0 here.'//);
         NBIT2=0;
       ]
       IF (NBIT1<0)[
         OUTPUT61;(//' ***ERROR: NBIT1 < 0'//);
         STOP;
       ]
       IF(NBIT2<0)[
         OUTPUT61;(//' ***ERROR: NBIT2 < 0'//);
         STOP;
       ]

       IF (I_BIT_FILTER < 2 & (NBIT1+NBIT2<0|NBIT1+NBIT2>29))[
         OUTPUT61;(//' ***ERROR: '/
                   ' Total # of bits must be >= 0 and <= 29'//);
         STOP;
       ]
       ELSEIF(NBIT1<0|NBIT1>24)[
         OUTPUT61;(//' ***ERROR: '/
                   ' Total # of regions must be >= 0 and <= 23'//);
         STOP;
       ]
       IF(NBIT1 ~= 0)[
         IF(I_BIT_FILTER=0|I_BIT_FILTER=2)[
            OUTPUT61;
            (/' BIT(I)/IREGION_TO_BIT(I) (I=1,NBIT1) to include:'/' ',$);
         ]
         IF(I_BIT_FILTER=1|I_BIT_FILTER=3)[
            OUTPUT61;
            (/' BIT(I)/IREGION_TO_BIT(I) (I=1,Nbit1) to exclude:'/' ',$);
         ]
         INPUT (LATBIT(i),i=1,NBIT1); (30i5);
         OUTPUT61 (LATBIT(i),i=1,NBIT1); (30i5);
         DO i=1,NBIT1[
           IF (I_BIT_FILTER < 2 & (LATBIT(i)<0|LATBIT(i)>28))[
              OUTPUT;(//' ***ERROR:'/
                        ' BIT(I) must be >= 0 and <= 28'//);
              STOP;
           ]
           ELSEIF(LATBIT(I)<0|LATBIT(I)>23)[
              OUTPUT;(//' ***ERROR:'/
                        ' IREGION_TO_BIT(I) must be >=0 and <= 23'//);
              STOP;
           ]
         ]
       ]
       IF(NBIT2 ~= 0)[
         OUTPUT61;
  (/' BIT(I)/IREGION_TO_BIT(I) (I=NBIT1+1,NBIT1+NBIT2) to exclude:'/' ',$);
         INPUT (LATBIT(NBIT1+i),i=1,NBIT2); (30i5);
         OUTPUT61 (LATBIT(NBIT1+i),i=1,NBIT2); (30i5);
         DO i=1,NBIT2[
           IF (LATBIT(NBIT1+i)<0 | LATBIT(NBIT1+i)>28)[
              OUTPUT;(//' ***ERROR:'/
                        ' BIT(I) must be  >= 0 and <= 28'//);
              STOP;
           ]
         ]
       ]
   ]" end of block for just enflag=3"
] "end of (enflag = 2 or 3) block"

"----------------------------------------------------------------"
ELSEIF(isource = 4)[ ;$BEAMMODEL-ENFLAG4-INPUT; ]
"----------------------------------------------------------------"
ELSE[OUTPUT;('In srcxyznrc:  error on input, ENFLAG inconsistent ');
   STOP;]
"----------------------------------------------------------------"

return;  "normal return

:ERR_SOURCE1: "Error on reading spectrum file name, stop and print message"
   ;OUTPUT61;(//' *** error on reading spectrum file name ***');
   STOP;

:ERR_SOURCE2: "Error on reading file name, stop and print message"
   ;OUTPUT61;(//' *** error on reading file name ***');
   STOP; "End of input file return"

:ERR_SOURCE3: "error on opening file, stop and print message"
   ;OUTPUT61;(//' *** Error on opening file ***'//
              ' *** Please check whether this is a MODE0 file or '/
              ' *** it is in the right directory, and try again!'//);
   STOP; "End of input file return"

:ERR_SOURCE9: "error on reading accelerator, input file, pegs data names"
   ;OUTPUT61;(//' *** error on reading accelerator, input file, pegs data***');
   STOP;

:ERR_SOURCE20: "error on reading VCU sim., input file names
   ;OUTPUT61;(//' *** error on reading VCU sim., input file names ***');
   STOP;

:ERR_SOURCE21:"error on reading accelerator, input file, pegs data names"
   ;OUTPUT61;(//' *** error on reading accelerator, input file, pegs data***'//
		  ' (MLC code, MLC input file if selected) '//);
   STOP;


end; "End of subroutine srcinput
%E "srcxyznrc.mortran start of subroutine srcinit ($Revision: 1.39 $)"
"**************************************************************************"
"
subroutine srcinit(weight);
"
"This subroutine calculates 'one time only constants' that do not change
"for a given source configuration
"
"**************************************************************************"
implicit none;
;COMIN/GEOM,PHSPFILE,SOURCE,EGS-IO,RWPHSP/;

$REAL weight,
      costheta,sintheta,
      coscol,sincol,
      cosphi,sinphi;
$INTEGER i;

OUTPUT61;(' ');

"------------------------------------------------------------------------"
IF(isource = 0)[   "Frontal parallel beam source"
"------------------------------------------------------------------------"
    "Calculate the x-direction input zones
    IF(xinl < xbound(1))[xinl = xbound(1);]
    IF(xinu <= xinl)[ xinu = xinl;] "Default a pencil beam
    "Check not too big
    IF( xinu > xbound(imax+1) ) [xinu=xbound(imax+1);]
    IF( xinl > xbound(imax+1) ) [xinl=xbound(imax+1);]
    "Now search for initial region x index range
    OUTPUT61; (/' Index ranges of beam field'/
              ' --------------------------'/);
    ixinl=0;
    LOOP[ixinl=ixinl+1;]UNTIL(xbound(ixinl) <= xinl & xbound(ixinl+1) >  xinl);
    ixinu=ixinl-1;
    LOOP[ixinu=ixinu+1;]UNTIL(xbound(ixinu) <= xinu & xbound(ixinu+1) >= xinu);
    OUTPUT61 xinl,xinu;(' ',2f10.3,$);
    OUTPUT61 ixinl,ixinu;('   i index ranges over i=',i3,' to',i4);

    "Calculate the y-direction input zones
    IF(yinl < ybound(1)) [yinl = ybound(1);]
    IF(yinu <= yinl)[ yinu = yinl; "Default a pencil beam"]
    "Check not too big
    IF( yinu > ybound(jmax+1)) [yinu=ybound(jmax+1);]
    IF( yinl > ybound(jmax+1)) [yinl=ybound(jmax+1);]
    "Now search for initial region y index range
    jyinl=0;
    LOOP[jyinl=jyinl+1;]UNTIL(ybound(jyinl) <= yinl & ybound(jyinl+1) >  yinl);
    jyinu=jyinl-1;
    LOOP[jyinu=jyinu+1;]UNTIL(ybound(jyinu) <= yinu & ybound(jyinu+1) >= yinu);
    OUTPUT61 yinl,yinu;(' ',2f10.3,$);
    OUTPUT61 jyinl,jyinu;('   j index ranges over j=',i3,' to',i4);

    "Calculate the incident direction cosines
    winc = cos(thetaz*3.141593/180.);
    uinc = cos(thetax*3.141593/180.);
    vinc = cos(thetay*3.141593/180.);

    IF(thetaz > 90. | thetaz < -90.)[
       OUTPUT;(//' ***ERROR in source 0'/
                 ' thetaz set so that source is not incident on front of'/
                 ' phantom.  Check incident angles and try again.'//);
       STOP;
    ]
    ELSEIF(thetax > 180. | thetax < 0.)[
       OUTPUT;(//' ***ERROR in source 0'/
                 ' thetax set so that source is not incident on front of'/
                 ' phantom.  Check incident angles and try again.'//);
       STOP;
    ]
    ELSEIF(thetay > 180. | thetay < 0.)[
       OUTPUT;(//' ***ERROR in source 0'/
                 ' thetay set so that source is not incident on front of'/
                 ' phantom.  Check incident angles and try again.'//);
       STOP;
    ]

    IF(uinc*uinc+vinc*vinc+winc*winc>1.001 |
       uinc*uinc+vinc*vinc+winc*winc<0.009)[
       OUTPUT;(//' ***ERROR in source 0'/
                 ' Sum of squares of incident direction cosines must be 1.'/
                 ' Check angles and try again.'//);
       STOP;
    ]
    ELSE["close enough"
       winc=SQRT(1-uinc*uinc-vinc*vinc);
       thetaz = acos(winc)*180./3.141593;
    ]
    OUTPUT61;(/' Angle of beam to'/
               '  axes(in deg, 90,90,0 is normal): ',$);
    OUTPUT61 thetax,thetay,thetaz;(' ',3f10.2,' deg');

    "The remaining one-time constants
    beamarea = (xinu - xinl)*(yinu - yinl);
    zinc   = zbound(1);
    weight = 1.0; "Incident weight
    return;
]"end of (isource = 0) block"

"------------------------------------------------------------------------"
IF(isource = 1 | isource=7) [ "Parallel beam directed in any direction"
                              "or from side at user-selected angles"
"------------------------------------------------------------------------"
  "Distance to the centre of the source plane
  "Pick a reasonable distance from the isocenter so that the
  "beam is guaranteed to come from the outside.
  "This is the maximum of the distance to and vertex of the irradiation
  "volume from the isocenter plus an allowance for the collimator size.
  dsource= max(
   (xiso-xbound(1     ))**2+(yiso-ybound(1     ))**2+(ziso-zbound(1     ))**2,
   (xiso-xbound(imax+1))**2+(yiso-ybound(1     ))**2+(ziso-zbound(1     ))**2,
   (xiso-xbound(1     ))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(1     ))**2,
   (xiso-xbound(1     ))**2+(yiso-ybound(1     ))**2+(ziso-zbound(kmax+1))**2,
   (xiso-xbound(imax+1))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(1     ))**2,
   (xiso-xbound(imax+1))**2+(yiso-ybound(1     ))**2+(ziso-zbound(kmax+1))**2,
   (xiso-xbound(1     ))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(kmax+1))**2,
   (xiso-xbound(imax+1))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(kmax+1))**2);
  dsource = -sqrt(dsource + xcol**2+ ycol**2); "- sign is our convention
  beamarea = xcol*ycol;
]

"------------------------------------------------------------------------"
ELSEIF(isource = 2 | isource=8)["Full phase-space source"
"------------------------------------------------------------------------"
   dsource = -dsource;
   esrc = 0; "initialize counter"
   OUTCNT = 0; "initialize no. of times phsp file restarts during this run"
]
"------------------------------------------------------------------------"
ELSEIF(isource = 3 )[   "Frontal point source"
"------------------------------------------------------------------------"
  "Calculate the x-direction input zones
  IF(xinl < xbound(1))[xinl = xbound(1);]
  IF(xinu <= xinl)[ xinu = xinl;] "Default a pencil beam
  "Check not too big
  IF( xinu > xbound(imax+1) ) [xinu=xbound(imax+1);]
  IF( xinl > xbound(imax+1) ) [xinl=xbound(imax+1);]
  "Now search for initial region x index range
  OUTPUT61; (/' Index ranges of beam field'/
              ' --------------------------'/);
  ixinl=0;
  LOOP[ixinl=ixinl+1;]UNTIL(xbound(ixinl) <= xinl & xbound(ixinl+1) >  xinl);
  ixinu=ixinl-1;
  LOOP[ixinu=ixinu+1;]UNTIL(xbound(ixinu) <= xinu & xbound(ixinu+1) >= xinu);
  OUTPUT61 xinl,xinu;(' ',2f10.3,$);
  OUTPUT61 ixinl,ixinu;('   i index ranges over i=',i3,' to',i4);
  "Calculate the y-direction input zones
  IF(yinl < ybound(1)) [yinl = ybound(1);]
  IF(yinu <= yinl)[ yinu = yinl; "Default a pencil beam"]
  "Check not too big
  IF( yinu > ybound(jmax+1)) [yinu=ybound(jmax+1);]
  IF( yinl > ybound(jmax+1)) [yinl=ybound(jmax+1);]
  "Now search for initial region y index range
  jyinl=0;
  LOOP[jyinl=jyinl+1;]UNTIL(ybound(jyinl) <= yinl & ybound(jyinl+1) >  yinl);
  jyinu=jyinl-1;
  LOOP[jyinu=jyinu+1;]UNTIL(ybound(jyinu) <= yinu & ybound(jyinu+1) >= yinu);
  OUTPUT61 yinl,yinu;(' ',2f10.3,$);
  OUTPUT61 jyinl,jyinu;('   j index ranges over j=',i3,' to',i4);

  "The remaining one-time constants
  beamarea = (xinu - xinl)*(yinu - yinl);
  zinc   = zbound(1);
  weight = 1.0; "Incident weight
  return;
]"end of (isource = 3 ) block"
"------------------------------------------------------------------------"
ELSEIF(isource = 6 )[   "Isotropically radiation source"
"------------------------------------------------------------------------"
"make sure source is within volume"
   IF(xinl<xbound(1))[
      IF(xinu < xbound(1))[
          OUTPUT;(//' ***ERROR in source 6:'/
                    ' xinl & xinu < xbound(1) of volume'//);
           STOP;
      ]
      ELSE[
          xinl= xbound(1);
          OUTPUT61 xinl;(//' ***WARNING in source 6:'/
                        ' xinl < xbound(1)'/
                        ' xinl reset to',F10.4,' cm'//);
      ]
   ]
   IF(xinu > xbound(imax+1))[
        IF(xinl > xbound(imax+1))[
             OUTPUT;(//' ***ERROR in source 6:'/
                        ' xinl & xinu > max xbound of volume'//);
             STOP;
        ]
        ELSE[
           xinu=xbound(imax+1);
             OUTPUT61 xinu;(//' ***WARNING in source 6:'/
                        ' xinu > max xbound of geometry'/
                        ' xinu reset to',F10.4,' cm'//);
        ]
   ]
   IF(yinl<ybound(1))[
      IF(yinu < ybound(1))[
          OUTPUT;(//' ***ERROR in source 6:'/
                    ' yinl & yinu < ybound(1) of volume'//);
           STOP;
      ]
      ELSE[
          yinl= ybound(1);
          OUTPUT61 yinl;(//' ***WARNING in source 6:'/
                        ' yinl < ybound(1)'/
                        ' yinl reset to',F10.4,' cm'//);
      ]
   ]
   IF(yinu > ybound(jmax+1))[
        IF(yinl > ybound(jmax+1))[
             OUTPUT;(//' ***ERROR in source 6:'/
                        ' yinl & yinu > max ybound of volume'//);
             STOP;
        ]
        ELSE[
           yinu=ybound(jmax+1);
             OUTPUT61 yinu;(//' ***WARNING in source 6:'/
                        ' yinu > max ybound of geometry'/
                        ' yinu reset to',F10.4,' cm'//);
        ]
   ]
   IF(zinl<zbound(1))[
      IF(zinu < zbound(1))[
          OUTPUT;(//' ***ERROR in source 6:'/
                    ' zinl & zinu < zbound(1) of volume'//);
           STOP;
      ]
      ELSE[
          zinl= zbound(1);
          OUTPUT61 zinl;(//' ***WARNING in source 6:'/
                        ' zinl < zbound(1)'/
                        ' zinl reset to',F10.4,' cm'//);
      ]
   ]
   IF(zinu > zbound(kmax+1))[
        IF(zinl > zbound(kmax+1))[
             OUTPUT;(//' ***ERROR in source 6:'/
                        ' zinl & zinu > max zbound of volume'//);
             STOP;
        ]
        ELSE[
           zinu=zbound(kmax+1);
             OUTPUT61 zinu;(//' ***WARNING in source 6:'/
                        ' zinu > max zbound of geometry'/
                        ' zinu reset to',F10.4,' cm'//);
        ]
   ]
"Now search for initial region x index range
  OUTPUT61; (/' Index ranges of source volume'/
              ' -----------------------------'/);
  ixinl=0;
  LOOP[ixinl=ixinl+1;]UNTIL(xbound(ixinl) <= xinl & xbound(ixinl+1) >  xinl);
  ixinu=ixinl-1;
  LOOP[ixinu=ixinu+1;]UNTIL(xbound(ixinu) <= xinu & xbound(ixinu+1) >= xinu);
  OUTPUT61 xinl,xinu;(' ',2f10.3,$);
  OUTPUT61 ixinl,ixinu;('   i index ranges over i=',i3,' to',i4);
  "Now search for initial region y index range
  jyinl=0;
  LOOP[jyinl=jyinl+1;]UNTIL(ybound(jyinl) <= yinl & ybound(jyinl+1) >  yinl);
  jyinu=jyinl-1;
  LOOP[jyinu=jyinu+1;]UNTIL(ybound(jyinu) <= yinu & ybound(jyinu+1) >= yinu);
  OUTPUT61 yinl,yinu;(' ',2f10.3,$);
  OUTPUT61 jyinl,jyinu;('   j index ranges over j=',i3,' to',i4);
  "Now search for initial region z index range
  kzinl=0;
  LOOP[kzinl=kzinl+1;]UNTIL(zbound(kzinl) <= zinl & zbound(kzinl+1) >  zinl);
  kzinu=kzinl-1;
  LOOP[kzinu=kzinu+1;]UNTIL(zbound(kzinu) <= zinu & zbound(kzinu+1) >= zinu);
  OUTPUT61 zinl,zinu;(' ',2f10.3,$);
  OUTPUT61 kzinl,kzinu;('   k index ranges over k=',i3,' to',i4);

  weight=1.0;
]
"------------------------------------------------------------------------"
ELSEIF(isource = 9 | isource=10)["Full BEAM treatment head simulation"
"------------------------------------------------------------------------"
   dsource = -dsource;
   OUTPUT 'About to call init_beamsource';(//a);
   call init_beamsource(i_parallel,i_log,$CONFIGURATION_NAME,
                         hen_house,egs_home,the_beam_code,
                         the_pegs_file,the_input_file);
]
"------------------------------------------------------------------------"
ELSEIF(isource = 20)["Phase Space Incident from multiple settings and "
		     "optionally through an MLC"
"------------------------------------------------------------------------"
   dsource = -dsource;
   IF(SHLflag = 1)[
     survival_ratio = 1; "initialize survivival ratio to 1 so that only"
     "dosxyz performs the calibration run. If it was set to 0 then VCU code"
     "would do this but it cannot read IAEA phsps"
     IF(MLCflag = 1)[
       OUTPUT 'About to initialise MLC code and run calibration...';(//a);
       call init_vcusource(survival_ratio,$CONFIGURATION_NAME,hen_house,
			egs_home,the_shared_lib,the_input_file);
     ]
     ELSE[
       OUTPUT 'About to initialise BEAM code..';(//a);
       call init_beamsource(i_parallel,i_log,$CONFIGURATION_NAME,
                         hen_house,egs_home,the_shared_lib,
                         the_pegs_file,the_input_file);
     ]

     IF(calflag = 0)[
       call calibration_run(survival_ratio);
       OUTPUT61 survival_ratio;
       ('Survival Ratio is: ', F12.10);
     ]
     ELSE[
       survival_ratio = 1;  "We skipped the calibration run"
       OUTPUT61;
       (/'Calibration run skipped!'/);
     ]
   ]
   ELSE[
	OUTPUT61;
	(/'No shared library'/);
	survival_ratio = 1;

   ]
   esrc = 0; "initialize counter"
   OUTCNT = 0; "initialize no. of times phsp file restarts during this run"
]
"------------------------------------------------------------------------"
ELSEIF(isource = 21)["Full BEAM sim. incident from multiple settings and "
		     "optionally through an MLC"
"------------------------------------------------------------------------"
   dsource = -dsource;
   OUTPUT 'About to call init_beamsource';(//a);
   call init_beamsource(i_parallel,i_log,$CONFIGURATION_NAME,
                         hen_house,egs_home,the_beam_code,
                         the_pegs_file,the_input_file);
   OUTPUT 'Done initialization';(//a);
   survival_ratio = 1; "set to 1 to let vcu code know
			"not to run calibration run or if not using MLC
			"to set survival_ratio to 1
   IF(MLCflag = 1)
   [
	OUTPUT 'About to initialise MLC code...';(//a);
	call init_vcusource(survival_ratio,$CONFIGURATION_NAME,hen_house,
			egs_home,the_vcu_code,the_vcu_input_file);
   ]
   ELSE[
	OUTPUT61;
	(/'No external library MLC'/);
   ]
]
"------------------------------------------------------------------------"
IF(isource >3 & isource <7)[   dsource=-dsource; ]
"------------------------------------------------------------------------"
IF(isource ~= 20 & isource ~= 21)["four 20 and 21 the matrices are calculated"
"on the fly -per particle"
"Collimator/source rotation sine's and cosine's needed locally
costheta = cos(theta(1)*3.141593/180.); sintheta = sin(theta(1)*3.141593/180.);
coscol   = cos(phicol*3.141593/180.); sincol   = sin(phicol*3.141593/180.);
cosphi   = cos(phi(1)*3.141593/180.); sinphi   = sin(phi(1)*3.141593/180.);

"Rotation matrix needed during sampling routine
r_11(1) =  costheta*cosphi*coscol + sinphi*sincol;
r_12(1) = -costheta*cosphi*sincol + sinphi*coscol;
r_13(1) = -sintheta*cosphi                       ;
r_21(1) =  costheta*sinphi*coscol - cosphi*sincol;
r_22(1) = -costheta*sinphi*sincol - cosphi*coscol;
r_23(1) = -sintheta*sinphi                       ;
r_31(1) = -sintheta*coscol                       ;
r_32(1) =  sintheta*sincol                       ;
r_33(1) = -costheta                              ;
]
IF(isource=7 | isource=8 | isource=10)[
        "calculate the rest of the rotation matrices"
  DO I=2,numang[
    costheta = cos(theta(I)*3.141593/180.);
    sintheta = sin(theta(I)*3.141593/180.);
    cosphi = cos(phi(I)*3.141593/180.);
    sinphi= sin(phi(I)*3.141593/180.);
    r_11(I) =  costheta*cosphi*coscol + sinphi*sincol;
    r_12(I) = -costheta*cosphi*sincol + sinphi*coscol;
    r_13(I) = -sintheta*cosphi                       ;
    r_21(I) =  costheta*sinphi*coscol - cosphi*sincol;
    r_22(I) = -costheta*sinphi*sincol - cosphi*coscol;
    r_23(I) = -sintheta*sinphi                       ;
    r_31(I) = -sintheta*coscol                       ;
    r_32(I) =  sintheta*sincol                       ;
    r_33(I) = -costheta                              ;
  ]
]


"Constant factors employed in the search for irin
"This is done for efficiency, not understandability
"These constant factors are derived from the mapping of i,j,k
"to ir keeping ine if the surfaces constant
klowx        = 2 - imax - ijmax;
/khix,klowy/ = 1 - ijmax;
/khiy,klowz/ = 1 - imax;
khiz         = 1 - imax - ijmax + ijmax*kmax;

weight = 1.0; "Incident weight

return;
end; "End of subroutine srcinit

%E "srcxyznrc.mortran start of subroutine beam_calibration_run (JL & TP)"
"**************************************************************************"
"
subroutine calibration_run(s_ratio);
"
"This subroutine describes the source configuration to the output files
"
"**************************************************************************"
implicit none;

$REAL xsrc,ysrc,zlast,
      usrc,vsrc,wsrc,
      zsrc,weight,rncal,
      dist_dbs, mu_phsp;
real*4 s_ratio, total_survived;
$LONG_INT nhistdum;
$INTEGER npassdum,latchinp,num_hist,num2run,num_dbsrj,num_blocked;
;COMIN/SOURCE,RWPHSP,RANDOM,EGS-IO/;

OUTPUT 'Performing BEAM calibration run...';(//a);

IF(nshist>1000000)[
   num2run=1000000;
] ELSE [ num2run = nshist;]

OUTPUT61 num2run;
('Running ',i8, ' particles to calibrate BEAM accelerator...'/);

num_hist=1;
num_dbsrj=0;
total_survived=0.0;
more_in_cont=0;
LOOP[
	IF(more_in_cont = 0)[
	    :retry_read_phsp_calib:;
	    num_hist=num_hist+1;
	    IF(i_iaea_in=1)[
           $IAEA_READ_PHSP_RECORD(i_unit_in,npassdum,nhistdum,latchinp,iqin,
                          einsrc,weight,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,zlast,
                          mu_phsp);
        ]  ELSE [
		    $READ_PHSP(ismode,44,num_hist:nhistdum,npassdum,iqin,wsrc,zlast,
                  latchinp,einsrc,weight,xsrc,ysrc,usrc,vsrc);
	    ]
        IF(i_dbs=1 & iqin=0)["reject fat photons"
            IF(i_iaea_in=1)[
                dist_dbs=(ssd_dbs-zsrc)/wsrc;
            ] ELSE [
                dist_dbs=(ssd_dbs-z_dbs)/wsrc;
            ]
            IF((xsrc+usrc*dist_dbs)**2+(ysrc+vsrc*dist_dbs)**2>r_dbs**2)[
              num_dbsrj=num_dbsrj+1;
              goto :retry_read_phsp_calib:;
            ]
        ]

        IF(i_iaea_in=1 & i_mu_phsp=1)[
            frMU_indx = mu_phsp;
            ]ELSE [
                $RANDOMSET rncal;
                frMU_indx = rncal;
            ]
	]
        IF(MLCflag=1)[
            call sample_vcusource(einsrc,xsrc,ysrc,zsrc,usrc,
                          vsrc,wsrc,weight,iqin,latchinp,nhistdum,
                          more_in_cont,frMU_indx);
        ] ELSE [
           call phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,
                           wsrc,weight,iqin,latchinp,nhistdum,iphatsrc,
                                       more_in_cont,frMU_indx);
       ]

	IF(weight>0)[ total_survived=total_survived+1.0;]
	ELSE [ num_blocked=num_blocked+1;]
]UNTIL(num_hist>=(num2run+1));

IF(i_iaea_in=1)["rewind phsp"
    $IAEA_SET_PHSP_RECORD(i_unit_in,1);
]

more_in_cont=0;
s_ratio=total_survived/(num2run);

OUTPUT61 num2run,total_survived,num_dbsrj,num_blocked;
       ('Number run: ', I12/
        'Number survived: ', F12.0/
        'Number dbs rejected: ', I12/
        'Number blocked', I12);

OUTPUT 'Calibration complete.';(//a);


return;
end; "End of subroutine beam_calibration_run

%E "srcxyznrc.mortran start of subroutine srcout ($Revision: 1.39 $)"
"**************************************************************************"
"
subroutine srcout;
"
"This subroutine describes the source configuration to the output files
"
"**************************************************************************"
implicit none;
;COMIN/SOURCE,SSMDIS,BMODEL,PHSPFILE/;

$INTEGER i,lnblnk1,IOUTLIST;

"This needs to be defined for beammodeling"
IOUTLIST = 6;

OUTPUT61;
( /' ',79('*')//t10,
'Summary of source parameters (srcxyznrc $Revision: 1.39 $)' /
   ' ',79('*')/);

IF(isource = 0)[
   OUTPUT61 iqin,xinl,xinu,yinl,yinu,thetax,thetay,thetaz;
   ( t20,' Parallel beam incident from the front(+ve z-axis)'/
       /
       t25,' Electric charge of the source:',t57,i12           /
       t25,' x-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
       t25,' y-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
       T25,' Angle relative to +x:',t57,f10.4,' degrees'        /
       T25,' Angle relative to +y:',t57,f10.4,' degrees'        /
       T25,' Angle relative to -z:',t57,f10.4,' degrees'        /);
]
ELSEIF(isource = 1)[
    OUTPUT61 iqin,xiso,yiso,ziso,theta(1),phi(1),xcol,ycol,phicol;
    ( t15,' Parallel beam incident from an arbitrary direction'   / /
        t20,' Electric charge of the source:'  ,t62,i12             /
        t20,' x-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' y-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' z-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' Polar angle of collimator center:',t62,f10.4,' degrees'/
        t20,' Azimuthal angle of collimator center:',t62,f10.4,' degrees'/
        t20,' Total x-width of collimator,'    ,t62,f10.4,' cm'     /
        t20,' Total y-width of collimator,'             ,t62,f10.4,' cm'/
        t20,' Collimator rotation angle,'      ,t62,f10.4,' degrees'/);
]
ELSEIF(isource = 2)[
   OUTPUT61 xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,nshist;
   ( t15,' Full phase space input for each incident particle'      //
       t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' Polar angle of source plane:'      ,t62,f10.4,' degrees'/
       t10,' Azimuthal angle of origin in source plane:'
                                   ,t62,f10.4,' degrees'/
       t10,' Distance from isocenter to origin in source',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Source plane rotation angle,'      ,t62,f10.4,' degrees'/
       t10,' Total number of particles in phase space file:',t62,i12/);
   IF(i_dbs=1)[
      OUTPUT61 r_dbs,ssd_dbs,z_dbs;
      ( ' Directional Bremsstrahlung Splitting (DBS) used'/
        ' in BEAM simulation to generate phase space source with:'/
        '    DBS splitting radius:',t55,f10.4/
        '    SSD where radius defined:',t55,f10.4/
        '    Z where source scored:',t55,f10.4/
' Photons whose trajectory takes them outside the DBS splitting'/
' radius at the SSD will be rejected.'/);
   ]
   IF(IPARALLEL>1)[
     IF(PARNUM>0)[
     OUTPUT61 IPARALLEL,INT((PARNUM-1)*nshist/IPARALLEL)+1,
              INT(PARNUM*nshist/IPARALLEL);
      ('    This is one of ',i4,' parallel simulations.'/
       '    It will use from particle ',i12,' to particle ',i12,' in '/
       '    the phase space source for the simulation.'/);
     ]
     ELSEIF(PARNUM=0)[
     OUTPUT61 IPARALLEL;
      ('    This is one of ',i4,' parallel simulations.'/
       '    It will use the entire specified phase space source'/
       '    for the simulation.'/);
     ]
   ]
   IF(iqphsp=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
   ELSEIF(iqphsp=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
   ELSEIF(iqphsp=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
   ELSEIF(iqphsp=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
   IF(e_split>1 & iqphsp~=0)[
      OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
   ]
]
ELSEIF(isource = 3)[
   OUTPUT61 iqin,xinl,xinu,yinl,yinu,ssd;
   ( t20,' Point source incident from the front(+ve z-axis)'/
       t25,' Electric charge of the source:',t57,i12           /
       t25,' x-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
       t25,' y-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
       t25,' SSD                           ',f10.4,' cm'       /);
]
ELSEIF(isource = 6)[
   OUTPUT61 iqin,xinl,xinu,yinl,yinu,zinl,zinu;
 ( t20,' Uniform isotropically radiating parallelepiped'/
   t20,' within DOSXYZ volume'/
       t25,' Electric charge of the source:',t57,i12 /
       t25,' x-boundaries:',t43,f10.4,' cm-',f10.4,' cm' /
       t25,' y-boundaries:',t43,f10.4,' cm-',f10.4,' cm' /
       t25,' z-boundaries:',t43,f10.4,' cm-',f10.4,' cm'/);
]
ELSEIF(isource = 7)[
  IF(nang>0)[
    OUTPUT61 iqin,xiso,yiso,ziso,nang,xcol,ycol,phicol;
    ( t15,' Parallel beam incident from multiple, user-selected angles'   / /
        t20,' Electric charge of the source:'  ,t62,i12             /
        t20,' x-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' y-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' z-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' number of incident theta-phi:'   ,t62,i12/
        t20,' Total x-width of collimator,'    ,t62,f10.4,' cm'     /
        t20,' Total y-width of collimator,'             ,t62,f10.4,' cm'/
        t20,' Collimator rotation angle,'      ,t62,f10.4,' degrees');
    OUTPUT61;
       (t20,'  theta-phi     theta         phi        normalized'/
        t20,'    pair        (deg.)       (deg.)      probability');
    DO I=1,nang[
      IF(I=1)[
         OUTPUT61 I,theta(I),phi(I),pang(I); (t20,i7,f16.4,f13.4,f15.4);
      ]
      ELSE[
         OUTPUT61 I,theta(I),phi(I),pang(I)-pang(I-1);
                  (t20,i7,f16.4,f13.4,f15.4);
      ]
    ]
  ]
  ELSEIF(nang<0)[
    OUTPUT61 iqin,xiso,yiso,ziso,-nang,xcol,ycol,phicol;
    ( t15,' Parallel beam incident from side at user-selected angles'   / /
        t20,' Electric charge of the source:'  ,t62,i12             /
        t20,' x-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' y-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' z-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
        t20,' no. of theta-phi groups:'        ,t62,i12/
        t20,' Total x-width of collimator,'    ,t62,f10.4,' cm'     /
        t20,' Total y-width of collimator,'             ,t62,f10.4,' cm'/
        t20,' Collimator rotation angle,'      ,t62,f10.4,' degrees');
    OUTPUT61;
('  theta-phi     theta (deg.)       phi (deg.)     no. theta-   normalized'/
 '    group      min.     max.      min.    max.    phi pairs    probability');
    DO I=1,-nang[
      IF(ivary(I)=1)[
        OUTPUT61 I,angmin(I),angmax(I),angfixed(I),angfixed(I),ngang(I),
                 pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
      ]
      ELSE[
        OUTPUT61 I,angfixed(I),angfixed(I),angmin(I),angmax(I),ngang(I),
                 pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
      ]
    ]
  ]
  OUTPUT61;(' ');
]
ELSEIF(isource = 8)[
  IF(nang>0)[
    OUTPUT61 xiso,yiso,ziso,nang,dsource,phicol,nshist;
   ( t15,' Full phase space input incident from multiple angles'      //
       t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' number of incident theta-phi:'      ,t62,i10/
       t10,' Distance from isocenter to origin in source',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Source plane rotation angle,'      ,t62,f10.4,' degrees'/
       t10,' Total number of particles in phase space file:',t62,i12/);
    OUTPUT61;
       (t10,'  theta-phi     theta         phi        normalized'/
        t10,'    pair        (deg.)       (deg.)      probability');
    DO I=1,nang[
      IF(I=1)[
         OUTPUT61 I,theta(I),phi(I),pang(I); (t10,i7,f16.4,f13.4,f15.4);
      ]
      ELSE[
         OUTPUT61 I,theta(I),phi(I),pang(I)-pang(I-1);
                  (t10,i7,f16.4,f13.4,f15.4);
      ]
    ]
  ]
  ELSEIF(nang<0)[
    OUTPUT61 xiso,yiso,ziso,-nang,dsource,phicol,nshist;
   ( t15,' Full phase space input incident from multiple angles'      //
       t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' number theta-phi groups:'      ,t62,i10/
       t10,' Distance from isocenter to origin in source',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Source plane rotation angle,'      ,t62,f10.4,' degrees'/
       t10,' Total number of particles in phase space file:',t62,i12/);
    OUTPUT61;
('  theta-phi     theta (deg.)       phi (deg.)     no. theta-   normalized'/
 '    group      min.     max.      min.    max.    phi pairs    probability');
    DO I=1,-nang[
      IF(ivary(I)=1)[
        OUTPUT61 I,angmin(I),angmax(I),angfixed(I),angfixed(I),ngang(I),
                 pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
      ]
      ELSE[
        OUTPUT61 I,angfixed(I),angfixed(I),angmin(I),angmax(I),ngang(I),
                 pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
      ]
    ]
  ]
  OUTPUT61;(' ');
  IF(i_dbs=1)[
      OUTPUT61 r_dbs,ssd_dbs,z_dbs;
      ( ' Directional Bremsstrahlung Splitting (DBS) used'/
        ' in BEAM simulation to generate phase space source with:'/
        '    DBS splitting radius:',t55,f10.4/
        '    SSD where radius defined:',t55,f10.4/
        '    Z where source scored:',t55,f10.4/
' Photons whose trajectory takes them outside the DBS splitting'/
' radius at the SSD will be rejected.'/);
  ]
  IF(IPARALLEL>1)[
     IF(PARNUM>0)[
     OUTPUT61 IPARALLEL,INT((PARNUM-1)*nshist/IPARALLEL)+1,
              INT(PARNUM*nshist/IPARALLEL);
      ('    This is one of ',i4,' parallel simulations.'/
       '    It will use from particle ',i12,' to particle ',i12,' in '/
       '    the phase space source for the simulation.'/);
     ]
     ELSEIF(PARNUM=0)[
     OUTPUT61 IPARALLEL;
      ('    This is one of ',i4,' parallel simulations.'/
       '    It will use the entire specified phase space source'/
       '    for the simulation.'/);
     ]
  ]
  IF(iqphsp=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
  ELSEIF(iqphsp=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
  ELSEIF(iqphsp=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
  ELSEIF(iqphsp=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
  IF(e_split>1 & iqphsp~=0)[
      OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
  ]
]
ELSEIF(isource=9)[
   OUTPUT61 xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,
     $cstring(the_beam_code),$cstring(the_input_file),
     $cstring(the_pegs_file);
   ( t15,' BEAM treatment head simulation used as source:'      //
       t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' Polar angle of beam axis:'      ,t62,f10.4,' degrees'/
       t10,' Azimuthal angle of beam axis:'
                                   ,t62,f10.4,' degrees'/
       t10,' Distance from isocenter to centre of scoring',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Rotation angle about beam axis,'      ,t62,f10.4,' degrees'/
       t10,' BEAM simulation: ',a/
       t10,'      input file: ',a/
       t10,'  pegs data file: ',a/);
   IF(i_dbs=1)[
      OUTPUT61;(t10,' Fat photons from DBS will be rejected.'/);
   ]
   ELSE[
      OUTPUT61;(t10,' Fat photons from DBS will not be rejected.'/);
   ]
   IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
   ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
   ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
   ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
   IF(e_split>1 & iqphsp~=0)[
      OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
   ]
]
ELSEIF(isource=10)[
   IF(nang>0)[
     OUTPUT61 xiso,yiso,ziso,nang,dsource,phicol,
     $cstring(the_beam_code),$cstring(the_input_file),
     $cstring(the_pegs_file);
   ( t15,' BEAM simulation source from multiple angles:'      //
       t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' number of incident theta-phi:'      ,t62,i10/
       t10,' Distance from isocenter to centre of scoring',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Rotation angle about beam axis,'      ,t62,f10.4,' degrees'/
       t10,' BEAM simulation: ',a/
       t10,'      input file: ',a/
       t10,'  pegs data file: ',a/);
     OUTPUT61;
       (t10,'  theta-phi     theta         phi        normalized'/
        t10,'    pair        (deg.)       (deg.)      probability');
     DO I=1,nang[
      IF(I=1)[
         OUTPUT61 I,theta(I),phi(I),pang(I); (t10,i7,f16.4,f13.4,f15.4);
      ]
      ELSE[
         OUTPUT61 I,theta(I),phi(I),pang(I)-pang(I-1);
                  (t10,i7,f16.4,f13.4,f15.4);
      ]
     ]
   ]
   ELSEIF(nang<0)[
     OUTPUT61 xiso,yiso,ziso,-nang,dsource,phicol,
     $cstring(the_beam_code),$cstring(the_input_file),
     $cstring(the_pegs_file);
   ( t15,' BEAM simulation source from multiple angles:'      //
       t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
       t10,' number of theta-phi groups:'      ,t62,i10/
       t10,' Distance from isocenter to centre of scoring',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Rotation angle about beam axis,'      ,t62,f10.4,' degrees'/
       t10,' BEAM simulation: ',a/
       t10,'      input file: ',a/
       t10,'  pegs data file: ',a/);
     OUTPUT61;
('  theta-phi     theta (deg.)       phi (deg.)     no. theta-   normalized'/
 '    group      min.     max.      min.    max.    phi pairs    probability');
     DO I=1,-nang[
      IF(ivary(I)=1)[
        OUTPUT61 I,angmin(I),angmax(I),angfixed(I),angfixed(I),ngang(I),
                 pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
      ]
      ELSE[
        OUTPUT61 I,angfixed(I),angfixed(I),angmin(I),angmax(I),ngang(I),
                 pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
      ]
     ]
   ]
   IF(i_dbs=1)[
      OUTPUT61;(t10,' Fat photons from DBS will be rejected.'/);
   ]
   ELSE[
      OUTPUT61;(t10,' Fat photons from DBS will not be rejected.'/);
   ]
   IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
   ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
   ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
   ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
   IF(e_split>1 & iqphsp~=0)[
      OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
   ]
]
ELSEIF(isource=20)  [
  IF(nset>1) [
    OUTPUT61 nset,dsource,nshist,$cstring(the_shared_lib),
       $cstring(the_input_file);
   ( t15,'Phase Space Incident from multiple settings through a BEAM/MLC '//
       t10,' number of incident settings:'      ,t62,i10/
       t10,' first distance from isocenter to origin in source',
                          ' plane:',t62,f10.4,' cm'/
       t10,' Total number of particles in phase space file:',t62,i12/
       t10,' Shared library simulation: ',a/
       t10,' Shared library input file: ',a/);
    OUTPUT61;
(t10,'   setting      xiso      yiso           ziso        theta',
				'       phi          phicol         ',
				'SAD         MU Index'/
 t10,'   num           (cm)          (cm)           (cm)         (deg.)',
 			'     (deg.)             (deg.)          (cm)');
    DO I=1,nset[
       OUTPUT61 I,xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
		 phicoltemp(I),dsourcetemp(I),muIndex(I);
	 (t10,i7,f15.4,f11.4,f15.4,f12.4,f13.4,f11.4,f11.4,f10.4);
	 ]

   ]

  OUTPUT61;(' ');
     IF(i_dbs=1)[
      OUTPUT61 r_dbs,ssd_dbs,z_dbs;
      ( ' Directional Bremsstrahlung Splitting (DBS) used'/
        ' in BEAM simulation to generate phase space source with:'/
        '    DBS splitting radius:',t55,f10.4/
        '    SSD where radius defined:',t55,f10.4/
        '    Z where source scored:',t55,f10.4/
' Photons whose trajectory takes them outside the DBS splitting'/
' radius at the SSD will be rejected.'/);
   ]
   IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
   ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
   ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
   ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
   IF(e_split>1 & iqphsp~=0)[
      OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
   ]
]
ELSEIF(isource=21)  [
  IF(nset>1) [
    OUTPUT61 nset,dsource,
       $cstring(the_beam_code),$cstring(the_input_file),
       $cstring(the_pegs_file),$cstring(the_vcu_code),
       $cstring(the_vcu_input_file);
     ( t15,'BEAM treatment simulation used as source '    //
       t10,' number of incident settings:'      ,t62,i10/
       t10,' first distance from isocenter to origin in source',
                          ' plane:',t62,f10.4,' cm'/
       t10,' BEAM simulation: ',a/
       t10,' input file: ',a/
       t10,' pegs data file: ',a/
       t10,' VCU simulation: ',a/
       t10,' VCU input file: ',a/);
    OUTPUT61;
(t10,'   setting      xiso      yiso           ziso        theta',
				'       phi          phicol         ',
				'SAD         MU Index'/
 t10,'   num           (cm)          (cm)           (cm)         (deg.)',
 			'     (deg.)             (deg.)          (cm)');
    DO I=1,nset[
       OUTPUT61 I,xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
		 phicoltemp(I),dsourcetemp(I),muIndex(I);
	 (t10,i7,f15.4,f11.4,f15.4,f12.4,f13.4,f11.4,f11.4,f10.4);
	 ]

   ]

  OUTPUT61;(' ');
   IF(i_dbs=1)[
      OUTPUT61;(t10,' Fat photons from DBS will be rejected.'/);
   ]
   ELSE[
      OUTPUT61;(t10,' Fat photons from DBS will not be rejected.'/);
   ]
   IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
   ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
   ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
   ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
   IF(e_split>1 & iqphsp~=0)[
      OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
   ]
]
IF(isource = 4)[ ;$BEAMMODEL-SOURCE4-OUTPUT; ]

return;
end; "End of subroutine srcout"
%E "srcxyznrc.mortran start of subroutine srchst ($Revision: 1.39 $)"
"*******************************************************************************
"
subroutine srchst(xin,yin,zin,uin,vin,win,irin,weight,latchi);
"
"This subroutine does the sampling of the source distribution
"   Energy is passed in COMIN/SOURCE
"      For isource =0,1,3 & enflag =1(spectrum) it passes back
"                    esrc_sp which is the particles k.e.
"      For phase space sources, it returns einsrc which is particles
"                    total energy
"      No energy is sample for enflag=0, monoenergetic source
"                    since etotin is initialized and fixed in main
"
"**************************************************************************"
;
implicit none;
;COMIN/ENERGYSRC,SOURCE,GEOM,RANDOM,SSMDIS,BMODEL,PHSPFILE,RWPHSP,EGS-IO,
       SCORE/;

$REAL xsrc,ysrc,zsrc, "X,Y,Z position of incident particle (isource=2,8,9)"
      xsrcp,ysrcp,zsrcp, "transformed X,Y,Z position of incident particle"
      usrc,vsrc,wsrc, "U,V,W of incident particle (isource=2,8,9)"
      xindel,yindel,zindel, "X,Y,Z widths of incident beam"
      xin,yin,zin, "X,Y,Z position of incident particle"
      uin,vin,win, "U,V,W of incident particle"
      enin,        "energy of incident particle"
      zsrcdum,     "dummy value of zsrc read in from BEAM sim (isource=9)"
      SAD_s20,     "for source 20 if iaea phsp is read SAD is needed"
      r1,rnno1,rnno2, "random no.s"
      fw,
      rxyz, "radial position of incident particle"
      costheta,sintheta,
      weight, "incident particle weight"
      zlast,
      dist,
      dist_dbs, "distance along particle trajectory for dbs rejection"
      coscol,sincol,
      cosphi,sinphi,
      mu_phsp; "stores fractional MU index from IAEA phsp source"

$REAL RBEAM,DIST_RAY;

$INTEGER ix,jy,kz,i,j,k,
         irin, "region of incident particle"
         latchi, "input latch value"
         ibit;
$LONG_INT n_hist_dum;

save wsrc; "in case of phsp particle recycling"

zsrc = dsource;

"----------------------------------------------------------------"
IF(isource = 0)[ "Frontal parallel beam source"
"----------------------------------------------------------------"
    "Choose a point randomly in a rectangle
    xindel = xinu-xinl;
    IF(xindel = 0.0)[xin=xinl;]
    ELSE[ $RANDOMSET r1; xin = xinl + r1*xindel; ]
    yindel = yinu-yinl;
    IF(YINDEL = 0.0)[yin=yinl;]
    ELSE[ $RANDOMSET r1; yin = yinl + r1*yindel; ]
    zin = zinc;
    uin=uinc;vin=vinc;win=winc;

    "Determine region index of source particle
    IF(xindel = 0.0)[ix=ixinl;]
    ELSE[
       ix=ixinl-1;
       LOOP[ix=ix+1;]UNTIL( xbound(ix) <= xin & xbound(ix+1) > xin );
    ]
    IF(yindel = 0.0)[jy=jyinl;]
    ELSE[
        jy=jyinl-1;
        LOOP[jy=jy+1;]UNTIL( ybound(jy) <= yin & ybound(jy+1) > yin);
    ]
    irin = 1 + ix +(jy-1)*imax; "Input region

    IF(enflag = 1)[" select k.e. of input"
       $RANDOMSET RNNO1;
       $RANDOMSET RNNO2;
       K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
       esrc_sp = CDFINV(K,1) + RNNO2*CDFINV(K,2);
    ]
    return;
]  "end of isource = 0  Frontal parallel beam source"

"----------------------------------------------------------------"
IF(isource = 3)[ "Frontal point source"
"----------------------------------------------------------------"
    xindel = xinu-xinl;
    yindel = yinu-yinl;
    IF(xindel = 0.0 | yindel = 0.0 )[
          XIN = xinl; YIN = yinl; RXYZ=SQRT(SSD*SSD+XIN*XIN+YIN*YIN);
    ]
    ELSE[
       LOOP["this method is not so efficient for small SSDs"
          $RANDOMSET r1;
          xin=r1*xindel+xinl;
          $RANDOMSET r1;
          yin=r1*yindel+yinl;
          $RANDOMSET r1;
          RXYZ=SQRT(SSD*SSD+xin*xin+yin*yin);
          win=SSD/RXYZ;
          FW=win**3.;
          IF(r1<FW)GOTO :FOUND_A_POINT:;
       ]
       ;:FOUND_A_POINT:;
    ]
    zin = zinc;
    uin=XIN/RXYZ;
    vin=YIN/RXYZ;
    "win has been calaulated"
    "Determine region index of source particle
    IF(xindel = 0.0)[ix=ixinl;]
    ELSE[
       ix=ixinl-1;
       LOOP[ix=ix+1;]UNTIL( xbound(ix) <= xin & xbound(ix+1) > xin );
    ]
    IF(yindel = 0.0)[jy=jyinl;]
    ELSE[
        jy=jyinl-1;
        LOOP[jy=jy+1;]UNTIL( ybound(jy) <= yin & ybound(jy+1) > yin);
    ]
    irin = 1 + ix +(jy-1)*imax; "Input region
    IF(enflag = 1)[
       $RANDOMSET RNNO1;
       $RANDOMSET RNNO2;
       K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
       esrc_sp = CDFINV(K,1) + RNNO2*CDFINV(K,2);
    ]
    return;
]"end of (isource = 3) block -frontal point source"

"----------------------------------------------------------------"
IF(isource = 6)[ "uniform isotropically radiating volume"
"----------------------------------------------------------------"
    "Choose a point randomly in the active volume
    xindel = xinu-xinl;
    yindel = yinu-yinl;
    zindel = zinu-zinl;
    IF(xindel = 0.0)[xin=xinl;]
    ELSE[ $RANDOMSET r1; xin = xinl + r1*xindel; ]
    IF(yindel = 0.0)[yin=yinl;]
    ELSE[ $RANDOMSET r1; yin = yinl + r1*yindel; ]
    IF(zindel = 0.0)[zin=zinl;]
    ELSE[ $RANDOMSET r1; zin = zinl + r1*zindel; ]

    "find the initial angle"
    $RANDOMSET costheta; costheta=2.*costheta-1;
    sintheta=SQRT(1.0-costheta**2);
    $RANDOMSET phi(1); phi(1)=6.283185*phi(1);
    uin=sintheta*COS(phi(1));vin=sintheta*SIN(phi(1));win=costheta;

    "Determine region index of source particle
    IF(xindel = 0.0)[ix=ixinl;]
    ELSE[
       ix=ixinl-1;
       LOOP[ix=ix+1;]UNTIL( xbound(ix) <= xin & xbound(ix+1) > xin );
    ]
    IF(yindel = 0.0)[jy=jyinl;]
    ELSE[
        jy=jyinl-1;
        LOOP[jy=jy+1;]UNTIL( ybound(jy) <= yin & ybound(jy+1) > yin);
    ]
    IF(zindel = 0.0)[kz=kzinl;]
    ELSE[
        kz=kzinl-1;
        LOOP[kz=kz+1;]UNTIL( zbound(kz) <= zin & zbound(kz+1) > zin);
    ]
    irin = $IR(ix,jy,kz); "Input region

    IF(enflag = 1)[" select k.e. of input"
       $RANDOMSET RNNO1;
       $RANDOMSET RNNO2;
       K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
       esrc_sp = CDFINV(K,1) + RNNO2*CDFINV(K,2);
    ]
    return;
]  "end of isource = 6  isotropically radiating volume"

"----------------------------------------------------------------"
;:GET-ANOTHER-PARTICLE:;
"----------------------------------------------------------------"

"isource = 1, 2, 4, 5, 8 can produce phase space that misses the target"
"Loop until a hit is obtained
"----------------------------------------------------------------"
IF(isource = 1 | isource=7) [
                "Parallel beam incident from an arbitrary direction"
                "or parallel beam incident from side at user-selected angles"
"----------------------------------------------------------------"
    "Set the incident direction cosines"
    wsrc = 1.0; "Before rotation
    usrc = 0.;
    vsrc = 0.;
    "Choose a point randomly within the collimator
    $RANDOMSET xsrc; $RANDOMSET ysrc;
    xsrc = (xsrc-0.5)*xcol;
    ysrc = (ysrc-0.5)*ycol;
    IF(enflag = 1)[
       $RANDOMSET RNNO1;
       $RANDOMSET RNNO2;
       K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
       enin = CDFINV(K,1) + RNNO2*CDFINV(K,2);
       esrc_sp = enin;
    ]
]
"----------------------------------------------------------------"
ELSEIF(isource = 2 | isource=8)[ "Full phase space for each particle"
"----------------------------------------------------------------"
    "Recall nshist=#particles in ph sp file - given in header"
    "nnphsp is # of particle to read from file as start here"
    "          is initialized to 1 in main"
  IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)[ "recycle this particle"
    NofREPEAT=NofREPEAT+1;
    CYCLNUM=CYCLNUM+1;
    xsrc=xsrcold;
    ysrc=ysrcold;
    IF(i_iaea_in=1) zsrc=zsrcold;
    usrc=usrcold;
    vsrc=vsrcold;
    wsrc=wsrcold;
    einsrc=einsrcold;
    iqin=iqinold;
    weight=weightold;
    latchi=latchold;
  ]
  ELSE[ "choose a new particle"
    LOOP[
       :READ-PH-SP-DATA:;
       IF(n_parallel>0 & nnphsp>nnphsp_max)[
           "rewind phsp source chunk and output a warning"
           nnphsp=nnphsp_min;
           OUTCNT=OUTCNT+1;
           OUTPUT ;
     (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
       '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
       /1x,79('*')// );
           IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
                $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
           ]

       ]
       ELSEIF(IPARALLEL>1 & PARNUM>0 & nnphsp > INT(PARNUM*nshist/IPARALLEL))[
           NofREPEAT = NofREPEAT + 1;
           OUTCNT=OUTCNT+1;
           OUTPUT61;
    (/' *** Warning *** Used all particles from partition of source file'/
      '                 Restarting from first particle in this partition'/);
           nnphsp = INT((PARNUM-1)*nshist/IPARALLEL)+1;
           IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/IPARALLEL;
                $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
           ]
       ]
       ELSEIF( nnphsp > nshist)["Not enough particles to read from file"
           "Start reading from top of source file and write warning"
           NofREPEAT = NofREPEAT + 1;
           OUTCNT=OUTCNT+1;
           OUTPUT61;
           (/' *** Warning *** Used all particles from source file'/
            '                 Restarting from first particle in file'/);
           nnphsp = 1;
           IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC;
               $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
           ]
       ]

       nnphsp = nnphsp+1;"we use nnphsp+1 because 1st record is for MODE"
       IF(i_iaea_in=1)[
           $IAEA_READ_PHSP_RECORD(i_unit_in,npassi,nhist,latchi,iqin,einsrc,
                                 weight,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,zlast,
                                 mu_phsp);
       ]
       ELSE[
       $READ_PHSP(ismode,44,nnphsp:nhist,npassi,iqin,wsrc,zlast,
                  latchi,einsrc,weight,xsrc,ysrc,usrc,vsrc);
       ]

       nnread = nnread +1; "total actually read, initialized to 0 in main"

       IF(wsrc < 0.0) [nsrjct=nsrjct+1; goto :READ-PH-SP-DATA:;]
       "particle is going backward"

       IF( npassi=1 ) [nsrjct=nsrjct+1; goto :READ-PH-SP-DATA:;]
       "particle is a multiple passer"

       ELSEIF( iqin=1 & iqphsp ~= 1 & iqphsp ~=2) [
            nsrjct=nsrjct+1;
            goto :READ-PH-SP-DATA:;
       ]
       ELSEIF( iqin=0 & iqphsp ~= 0 & iqphsp ~=2) [
            nsrjct=nsrjct+1;
            goto :READ-PH-SP-DATA:;
       ]
       ELSEIF( iqin=-1 & iqphsp ~=-1 & iqphsp ~=2)[
            nsrjct=nsrjct+1;
            goto :READ-PH-SP-DATA:;
       ]
       ELSEIF(i_dbs=1 & iqin=0)["only reject photons"
          dist_dbs=(ssd_dbs-z_dbs)/wsrc;
          IF((xsrc+usrc*dist_dbs)**2+(ysrc+vsrc*dist_dbs)**2>r_dbs**2)[
              ndbsrjct=ndbsrjct+1;
              goto :READ-PH-SP-DATA:;
          ]
       ]

       IF(enflag = 3)["=> phase space input with bit filters"
          IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
                               "and none of the second NBIT2 bits are set"
             DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
                IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
                IF(IBIT=NBIT1)[
                    nsrjct=nsrjct+1;
                    goto :READ-PH-SP-DATA:;
                ]"discard the particle"
             ]
             DO IBIT=1,NBIT2["if any are set, discard the particle"
                IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
                    nsrjct=nsrjct+1;
                    goto :READ-PH-SP-DATA:;
                ]"discard the particle"
             ]
             goto :FOUND-THE-PARTICLE:;
          ]
          ELSEIF(I_BIT_FILTER=1)[
             DO IBIT= 1, NBIT1["discard if any of these bits are set"
                IF($BTEST(latchi,LATBIT(IBIT)))[
                    nsrjct=nsrjct+1;
                    goto :READ-PH-SP-DATA:;
                ]
             ]
             goto :FOUND-THE-PARTICLE:;
          ]
          ELSEIF(I_BIT_FILTER=2)[
             DO IBIT= 1, NBIT1["keep if any of these regions of origin set"
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[goto :FOUND-THE-PARTICLE:;]
             ]
             nsrjct=nsrjct+1;
             goto :READ-PH-SP-DATA:;
          ]
          ELSEIF(I_BIT_FILTER=3)[
             DO IBIT= 1, NBIT1["discard if any of these regions of origin set"
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                   nsrjct=nsrjct+1;
                   goto :READ-PH-SP-DATA:;
                ]
             ]
             goto :FOUND-THE-PARTICLE:;
          ]
       ]"end of (enflag = 3) block"

       :FOUND-THE-PARTICLE:;
       IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
          nsoutside=nsoutside+1;
       ]
    ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
    "end of LOOP"
    IF(NRCYCL>0)[
       CYCLNUM=1;
       NofREPEAT=0;
       xsrcold=xsrc;
       ysrcold=ysrc;
       IF(i_iaea_in=1) zsrcold=zsrc;
       usrcold=usrc;
       vsrcold=vsrc;
       wsrcold=wsrc;
       einsrcold=einsrc;
       iqinold=iqin;
       weightold=weight;
       latchold=latchi;
    ]
  ] "end of choosing a new particle"
]"end of isource = 2 or 8 full phase space"

"----------------------------------------------------------------"
ELSEIF( isource = 9 | isource =10 ) [ "full BEAM simulation"
"----------------------------------------------------------------"
    LOOP [;
        :retry_sample_beamsource:;
        call sample_beamsource(einsrc,xsrc,ysrc,zsrcdum,usrc,vsrc,wsrc,weight,
                               iqin,latchi,nhist,iphatsrc);
        nnread = nnread +1; "keep track of how many particles read from sim."
        IF( iqinc < 2 & iqin ~= iqinc ) [
           nsrjct=nsrjct+1;
           goto :retry_sample_beamsource:;
        ]
        ELSEIF( iqinc = 3 & iqin = 0 ) [
           nsrjct=nsrjct+1;
           goto :retry_sample_beamsource:;
        ]
        ELSEIF(i_dbs=1 & iqin=0 & iphatsrc>1) [
           nsrjct=ndbsrjct+1;
           goto :retry_sample_beamsource:;
        ]

        IF(enflag = 3)["=> full BEAM sim. with bit filters"
          IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
                               "and none of the second NBIT2 bits are set"
             DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
                IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
                IF(IBIT=NBIT1)[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_beamsource:;
                ]"discard the particle"
             ]
             DO IBIT=1,NBIT2["if any are set, discard the particle"
                IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_beamsource:;
                ]"discard the particle"
             ]
             goto :found_particle_beamsource:;
          ]
          ELSEIF(I_BIT_FILTER=1)[
             DO IBIT= 1, NBIT1["discard if any of these bits are set"
                IF($BTEST(latchi,LATBIT(IBIT)))[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_beamsource:;
                ]
             ]
             goto :found_particle_beamsource:;
          ]
          ELSEIF(I_BIT_FILTER=2)[
             DO IBIT= 1, NBIT1["keep if any of these regions of origin set"
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                      goto :found_particle_beamsource:;
                ]
             ]
             nsrjct=nsrjct+1;
             goto :retry_sample_beamsource:;
          ]
          ELSEIF(I_BIT_FILTER=3)[
             DO IBIT= 1, NBIT1["discard if any of these regions of origin set"
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                   nsrjct=nsrjct+1;
                   goto :retry_sample_beamsource:;
                ]
             ]
             goto :found_particle_beamsource:;
          ]
       ]"end of (enflag = 3) block"

       :found_particle_beamsource:;
       IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
          nsoutside=nsoutside+1;
       ]
    ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
]
"----------------------------------------------------------------"
ELSEIF( isource = 20 ) [ "Phase Space Incident from multiple settings"
			 "and through an MLC"
"----------------------------------------------------------------"
 IF(more_in_cont = 0)["if there are no more particles in the container"
   IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)[ "recycle this particle"
    NofREPEAT=NofREPEAT+1;
    CYCLNUM=CYCLNUM+1;
    einsrc=einsrcold;
    xsrc=xsrcold;
    ysrc=ysrcold;
    usrc=usrcold;
    vsrc=vsrcold;
    wsrc=wsrcold;
    weight=weightold;
    latchi=latchold;
    iqin=iqinold;
    IF(i_iaea_in=1)["added z coordinate for iaea phsps (JL and TP)"
       zsrc = zsrcold;
       IF(i_mu_phsp=1) mu_phsp = mu_phspold;
    ]
   ]
   ELSE["choose a new particle"
     LOOP[
       :retry_sample_vcusource:;

      "IF(more_in_cont = 0)[""if there are more particles in the container"
       "we don't read from the phase space so we skip this"
	  IF(n_parallel>0 & nnphsp>nnphsp_max)[
           "rewind phsp source chunk and output a warning"
           nnphsp=nnphsp_min;
           OUTCNT=OUTCNT+1;
           OUTPUT ;
           (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
           '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
           /1x,79('*')// );
	       IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
                $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
           ]
      ]
      ELSEIF(IPARALLEL>1 & PARNUM>0 & nnphsp > INT(PARNUM*nshist/IPARALLEL))[
           NofREPEAT = NofREPEAT + 1;
           OUTCNT=OUTCNT+1;
           OUTPUT61;
        (/' *** Warning *** Used all particles from partition of source file'/
          '                 Restarting from first particle in this partition'/);
           nnphsp = INT((PARNUM-1)*nshist/IPARALLEL)+1;
	       IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/IPARALLEL;
                $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
           ]
      ]
      ELSEIF( nnphsp > nshist)["Not enough particles to read from file"
           "Start reading from top of source file and write warning"
           NofREPEAT = NofREPEAT + 1;
           OUTCNT=OUTCNT+1;
           OUTPUT61;
           (/' *** Warning *** Used all particles from source file'/
            '                 Restarting from first particle in file'/);
           nnphsp = 1;
	       IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC;
               $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
           ]
      ]

	  nnphsp = nnphsp+1;"we use nnphsp+1 because 1st record is for MODE"
	  IF(i_iaea_in=1)[
           $IAEA_READ_PHSP_RECORD(i_unit_in,npassi,nhist,latchi,iqin,einsrc,
                              weight,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,zlast,
                              mu_phsp);
      ]  ELSE [
		$READ_PHSP(ismode,44,nnphsp:nhist,npassi,iqin,wsrc,zlast,
				latchi,einsrc,weight,xsrc,ysrc,usrc,vsrc);
	  ]


	  nnread = nnread +1; "keep track of how many particles read from phsp."
      " ] "

      IF( iqinc < 2 & iqin ~= iqinc ) [
           nsrjct=nsrjct+1;
	       goto :retry_sample_vcusource:;
      ]
      ELSEIF( iqinc = 3 & iqin = 0 ) [
           nsrjct=nsrjct+1;
           goto :retry_sample_vcusource:;
      ]
        "ELSEIF(i_dbs=1 & iqin=0 & iphatsrc=1) [ "
        "   nsrjct=ndbsrjct+1; "
        "   goto :retry_sample_vcusource:; "
        "] "
      ELSEIF(i_dbs=1 & iqin=0)["only reject photons"
          IF(i_iaea_in=1)[
                dist_dbs=(ssd_dbs-zsrc)/wsrc;
          ] ELSE [
                dist_dbs=(ssd_dbs-z_dbs)/wsrc;
          ]
          IF((xsrc+usrc*dist_dbs)**2+(ysrc+vsrc*dist_dbs)**2>r_dbs**2)[
              ndbsrjct=ndbsrjct+1;
              goto :retry_sample_vcusource:;
          ]
      ]
      IF(enflag = 3)["=> full VCU sim. with bit filters"
          IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
                               "and none of the second NBIT2 bits are set"
             DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
                IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
                IF(IBIT=NBIT1)[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_vcusource:;
                ]"discard the particle"
             ]
             DO IBIT=1,NBIT2["if any are set, discard the particle"
                IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_vcusource:;
                ]"discard the particle"
             ]
             goto :found_particle_vcusource:;
          ]
          ELSEIF(I_BIT_FILTER=1)[
             DO IBIT= 1, NBIT1["discard if any of these bits are set
                IF($BTEST(latchi,LATBIT(IBIT)))[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_vcusource:;
                ]
             ]
             goto :found_particle_vcusource:;
          ]
          ELSEIF(I_BIT_FILTER=2)[
             DO IBIT= 1, NBIT1["keep if any of these regions of origin set
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                      goto :found_particle_vcusource:;
                ]
             ]
             nsrjct=nsrjct+1;
             goto :retry_sample_vcusource:;
          ]
          ELSEIF(I_BIT_FILTER=3)[
             DO IBIT= 1, NBIT1["discard if any of these regions of origin set
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                   nsrjct=nsrjct+1;
                   goto :retry_sample_vcusource:;
                ]
             ]
             goto :found_particle_vcusource:;
          ]
      ]"end of (enflag = 3) block

      :found_particle_vcusource:;

      IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
          nsoutside=nsoutside+1;
	  ]

     ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
	 "end of LOOP"

	 IF(NRCYCL>0)[
	    CYCLNUM=1;
	    NofREPEAT=0;

	    einsrcold=einsrc;
	    xsrcold=xsrc;
	    ysrcold=ysrc;
	    usrcold=usrc;
	    vsrcold=vsrc;
	    wsrcold=wsrc;
	    weightold=weight;
	    latchold=latchi;
	    iqinold=iqin;
	    IF(i_iaea_in=1)["added z coordinate for iaea phsps (JL and TP)"
	        zsrcold = zsrc;
                IF(i_mu_phsp=1) mu_phspold = mu_phsp;
	    ]
	 ]
   ]"end of choose new particle"
   "*****************************************************************"
	   "HERE IS WHERE WE PICK A RANDOM frMU_indx         "
   "***************************************************************"
   IF(i_iaea_in=1 & i_mu_phsp=1)
   [
        frMU_indx = mu_phsp; "use frMU from phsp source"
   ]
   ELSE [
                $RANDOMSET RNNO1;
                frMU_indx = RNNO1;
   ]
]" end of if more_in_cont

 "Recycled particles must still go through shared libraries
 IF(SHLflag=1 & MLCflag=1)
 ["if there is an MLC, pass particles through it"
  "vcu does not use Z so just input dummy variable for this"
       IF(more_in_cont=0) ["the particle was just read and so has the correct"
       "z value. Store it so this value is always used"
            zsrcold = zsrc;
       ] ELSE [ "we will read the next value from the container next "
       "but need to make sure the old zsrc is used since it is not set in "
       "particleDmlc and so will be -dsource from the beginning of srchst"
            zsrc = zsrcold;
       ]
	        call sample_vcusource(einsrc,xsrc,ysrc,zsrc,usrc,
			  vsrc,wsrc,weight,iqin,latchi,n_hist_dum,
			  more_in_cont,frMU_indx);
 ] ELSEIF(SHLflag=1 & MLCflag=0) [" if there is a BEAM shared library"
         "******************************************************************"
	    "changed to allow motion in BEAM as well"
	    "necessary changes are also made in beam and in CMs"
	    "******************************************************************"
	    IF(i_iaea_in=1)[
	      call phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,
                           wsrc,weight,iqin,latchi,nhist,iphatsrc,
			               more_in_cont,frMU_indx);"
	    ] ELSE [" don't change the Z coordinate"
	      call phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrcdum,usrc,vsrc,
                           wsrc,weight,iqin,latchi,nhist,iphatsrc,
			               more_in_cont,frMU_indx);
	    ]
 ]
]
"----------------------------------------------------------------"
ELSEIF( isource = 21) [ "BEAM Sim. source Incident from multiple settings"
			 "and through an MLC"
"----------------------------------------------------------------"
LOOP [;
        :retry_sample_beam_vcu_source:;
	IF(more_in_cont = 0)["if there are more particles in the vcu container"
                        "we don't need to get another particle so we skip this"
	   "******************************************************************"
	   "HERE IS WHERE WE NEED TO PICK A RANDOM frMU_indx         "
	   "****************************************************************"
	   "note: since there is no recycling, every particle will get it's
	   "own setting so this can stay here whether we have an MLC or not
	   "******************************************************************"
	   "changed to allow motion in BEAM as well"
	   "necessary changes are also made in beam and in CMs"
	   "******************************************************************"
	   call motionsample_beamsource(einsrc,xsrc,ysrc,zsrcdum,usrc,vsrc,wsrc,
                              weight,iqin,latchi,nhist,iphatsrc,frMU_indx);

	   IF(frMU_indx<0.0)[
					  "BEAM did not set frMU_index (i.e."
					       "there was no CMs with motion)"
			$RANDOMSET RNNO1;
			frMU_indx = RNNO1;
	   ]

	   nnread = nnread +1;"keep track of how many particles read from sim."

	]

	IF(MLCflag=1)["if there is an MLC, pass particles through it
		call sample_vcusource(einsrc,xsrc,ysrc,zsrcdum,usrc,
			vsrc,wsrc,weight,iqin,latchi,n_hist_dum,
			more_in_cont,frMU_indx);

			"IF(weight=0.0)[""MLC blocked particle"
				"goto :retry_sample_beam_vcu_source:;"
				"more_in_cont=0;"
			"]"
	]


        IF( iqinc < 2 & iqin ~= iqinc ) [
           nsrjct=nsrjct+1;
           goto :retry_sample_beam_vcu_source:;
        ]
        ELSEIF( iqinc = 3 & iqin = 0 ) [
           nsrjct=nsrjct+1;
           goto :retry_sample_beam_vcu_source:;
        ]
        ELSEIF(i_dbs=1 & iqin=0 & iphatsrc>1) [
           nsrjct=ndbsrjct+1;
           goto :retry_sample_beam_vcu_source:;
        ]

        IF(enflag = 3)["=> full BEAM sim. with bit filters"
          IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
                               "and none of the second NBIT2 bits are set"
             DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
                IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
                IF(IBIT=NBIT1)[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_beam_vcu_source:;
                ]"discard the particle"
             ]
             DO IBIT=1,NBIT2["if any are set, discard the particle"
                IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_beam_vcu_source:;
                ]"discard the particle"
             ]
             goto :found_particle_beam_vcu_source:;
          ]
	  ELSEIF(I_BIT_FILTER=1)[
             DO IBIT= 1, NBIT1["discard if any of these bits are set"
                IF($BTEST(latchi,LATBIT(IBIT)))[
                    nsrjct=nsrjct+1;
                    goto :retry_sample_beam_vcu_source:;
                ]
             ]
             goto :found_particle_beam_vcu_source:;
          ]
          ELSEIF(I_BIT_FILTER=2)[
             DO IBIT= 1, NBIT1["keep if any of these regions of origin set"
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                      goto :found_particle_beam_vcu_source:;
                ]
             ]
             nsrjct=nsrjct+1;
             goto :retry_sample_beam_vcu_source:;
          ]
          ELSEIF(I_BIT_FILTER=3)[
             DO IBIT= 1, NBIT1["discard if any of these regions of origin set"
                IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
                   nsrjct=nsrjct+1;
                   goto :retry_sample_beam_vcu_source:;
                ]
             ]
             goto :found_particle_beam_vcu_source:;
          ]
       ]"end of (enflag = 3) block"

       :found_particle_beam_vcu_source:;
       IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
          nsoutside=nsoutside+1;
       ]
    ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
]


IF((isource = 20 | isource = 21) & weight = 0) ["library blocked particle
        more_in_cont=0;
        nsblocked = nsblocked + 1;
		goto :GET-ANOTHER-PARTICLE:;
]

"----------------------------------------------------------------"
ELSEIF(isource = 4)[;$BEAMMODEL_SOURCE4_SAMPLING;"in beammodel_macros.mortran"]
"----------------------------------------------------------------"

IF(NofREPEAT > 0 & ISMOOTH = 1)[
    CALL SHIFT_XYUV(NofREPEAT,xsrc,ysrc,usrc,vsrc);
]

"Rotate/translate the source particle into position
IF(isource<7 | isource=9)[
  IF(i_iaea_in=1) zsrc = zsrc + dsource;
  "this is zsrc - SAD, but dsource has been set -ve in srcinit"

  uin   = r_11(1)*usrc + r_12(1)*vsrc + r_13(1)*wsrc;
  vin   = r_21(1)*usrc + r_22(1)*vsrc + r_23(1)*wsrc;
  win   = r_31(1)*usrc + r_32(1)*vsrc + r_33(1)*wsrc;
  xsrcp = r_11(1)*xsrc + r_12(1)*ysrc + r_13(1)*zsrc + xiso;
  ysrcp = r_21(1)*xsrc + r_22(1)*ysrc + r_23(1)*zsrc + yiso;
  zsrcp = r_31(1)*xsrc + r_32(1)*ysrc + r_33(1)*zsrc + ziso;
]
"---------------------------------------------------------------------"
ELSEIF(isource=20 | isource=21)[
" get the correct setting based on the mu index
"---------------------------------------------------------------------"
   DO I=1, nset[
    "*********************************************************************"
    " get setting from randomly generated frMU_indx
    "*********************************************************************"
      IF(frMU_indx<muIndex(I))[
       K=I;
       EXIT;
      ]
   ]

   IF(i_iaea_in=1)[
        "for iaea phase space z is read from the particle"
        " dsourcetemp is now supposed to be SAD"
        SAD_s20 = (dsourcetemp(K-1)+(dsourcetemp(K)-dsourcetemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1)));
        zsrc = zsrc - SAD_s20;
   ]  ELSE [
		zsrc = -1.0*(dsourcetemp(K-1)+(dsourcetemp(K)-dsourcetemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1)));
   ]

   "calculate rotation matrix"
   " get theta, phi, phicol x|y|ziso"
   theta(1)=thetatemp(K-1)+(thetatemp(K)-thetatemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
   phi(1)=phitemp(K-1)+(phitemp(K)-phitemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
   phicol=phicoltemp(K-1)+(phicoltemp(K)-phicoltemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
   xiso=xtemp(K-1)+(xtemp(K)-xtemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
   yiso=ytemp(K-1)+(ytemp(K)-ytemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
   ziso=ztemp(K-1)+(ztemp(K)-ztemp(K-1))*
		(frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));

"Collimator/source rotation sine's and cosine's needed locally
costheta = cos(theta(1)*3.141593/180.); sintheta = sin(theta(1)*3.141593/180.);
coscol   = cos(phicol*3.141593/180.); sincol = sin(phicol*3.141593/180.);
cosphi   = cos(phi(1)*3.141593/180.); sinphi   = sin(phi(1)*3.141593/180.);

   "Rotation matrix needed during sampling routine
   r_11(1) =  costheta*cosphi*coscol + sinphi*sincol;
   r_12(1) = -costheta*cosphi*sincol + sinphi*coscol;
   r_13(1) = -sintheta*cosphi                       ;
   r_21(1) =  costheta*sinphi*coscol - cosphi*sincol;
   r_22(1) = -costheta*sinphi*sincol - cosphi*coscol;
   r_23(1) = -sintheta*sinphi                       ;
   r_31(1) = -sintheta*coscol                       ;
   r_32(1) =  sintheta*sincol                       ;
   r_33(1) = -costheta                              ;


   uin   = r_11(1)*usrc + r_12(1)*vsrc + r_13(1)*wsrc;
   vin   = r_21(1)*usrc + r_22(1)*vsrc + r_23(1)*wsrc;
   win   = r_31(1)*usrc + r_32(1)*vsrc + r_33(1)*wsrc;
   xsrcp = r_11(1)*xsrc + r_12(1)*ysrc + r_13(1)*zsrc + xiso;
   ysrcp = r_21(1)*xsrc + r_22(1)*ysrc + r_23(1)*zsrc + yiso;
   zsrcp = r_31(1)*xsrc + r_32(1)*ysrc + r_33(1)*zsrc + ziso;

]
ELSE[ "choose an incident angle from the distribution"
  $RANDOMSET RNNO1;
  k_field=numang;"use global variable k_field so we can untransform"
                 "if scoring phsp in BEAM coordinate system"
  DO I=1,numang-1[
   IF(RNNO1<pang(I))[
      k_field=I;
      EXIT;
   ]
  ]
  uin   = r_11(k_field)*usrc + r_12(k_field)*vsrc + r_13(k_field)*wsrc;
  vin   = r_21(k_field)*usrc + r_22(k_field)*vsrc + r_23(k_field)*wsrc;
  win   = r_31(k_field)*usrc + r_32(k_field)*vsrc + r_33(k_field)*wsrc;
  xsrcp = r_11(k_field)*xsrc + r_12(k_field)*ysrc + r_13(k_field)*zsrc + xiso;
  ysrcp = r_21(k_field)*xsrc + r_22(k_field)*ysrc + r_23(k_field)*zsrc + yiso;
  zsrcp = r_31(k_field)*xsrc + r_32(k_field)*ysrc + r_33(k_field)*zsrc + ziso;
]

                        "Select the input region"
                        "done already for isource =0 &3"
"------------------------------------------------------------------------"
IF(isource = 1 | isource=7)[
"------------------------------------------------------------------------"
  "Find the distance to the outside of the geometry,
  "transport from the source plane to the surface.
  "If the coordinates place the particle on the surface of the
  "geometry then the solution is unique.
  IF(uin > 0.0) [
  "Going towards lower x-plane
  dist = (xbound_min - xsrcp)/uin; "Distance to boundary
  yin  = ysrcp + dist*vin; "Transport transverse coordinates...
  zin  = zsrcp + dist*win; "...from source to target surface
      IF ( (yin >= ybound_min) & (yin <= ybound_max) &
          (zin >= zbound_min) & (zin <= zbound_max)) [
         "Hits the lower x-plane, search for the entrance region number
         DO j=1,jmax [
           IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
              DO k=1,kmax [
                 IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
                    xin  = xbound_min;
                    irin = imax*j + klowx + ijmax*k;
                    return; "No other solution possible
                 ]
              ]"end of do"
           ]
        ]
        stop ' * Stopped in srchst on lower x-plane. Can not find irin! *';
      ]
    ]
    ELSEIF(uin < 0.0) [ "Going towards upper x-plane
      dist = (xbound_max - xsrcp)/uin; "Distance to boundary
      yin  = ysrcp + dist*vin; "Transport transverse coordinates...
      zin  = zsrcp + dist*win; "...from source to target surface
      IF ( (yin >= ybound_min) & (yin <= ybound_max) &
          (zin >= zbound_min) & (zin <= zbound_max)) [
        "Hits the upper x-plane, search for the entrance region number
         DO j=1,jmax [
              IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
                 DO k=1,kmax [
                    IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
                       xin  = xbound_max;
                       irin = imax*j + khix + ijmax*k;
                       return; "No other solution possible
                    ]
                 ]
              ]
         ]
         stop ' * Stopped in srchst on upper x-plane. Can not find irin! *';
      ]
  ]
  IF(vin > 0.0) [
     "Going towards lower y-plane
     dist = (ybound_min - ysrcp)/vin; "Distance to boundary
     xin  = xsrcp + dist*uin; "Transport transverse coordinates...
     zin  = zsrcp + dist*win; "...from source to target surface
     IF ( (xin >= xbound_min) & (xin <= xbound_max) &
          (zin >= zbound_min) & (zin <= zbound_max)) [
        "Hits the lower y-plane, search for the entrance region number
        DO i=1,imax [
           IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               DO k=1,kmax [
                  IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
                     yin  = ybound_min;
                     irin = i + klowy + ijmax*k;
                     return; "No other solution possible
                  ]
               ]
           ]
        ]
        stop ' * Stopped in srchst on lower y-plane. Can not find irin! *';
     ]
  ]
  ELSEIF(vin < 0.0) [ "Going towards upper y-plane
     dist = (ybound_max - ysrcp)/vin; "Distance to boundary
     xin  = xsrcp + dist*uin; "Transport transverse coordinates...
     zin  = zsrcp + dist*win; "...from source to target surface
     IF ( (xin >= xbound_min) & (xin <= xbound_max) &
          (zin >= zbound_min) & (zin <= zbound_max)) [
        "Hits the upper y-plane, search for the entrance region number
        DO i=1,imax [
           IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               DO k=1,kmax [
                  IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
                     yin  = ybound_max;
                     irin = i + khiy + ijmax*k;
                     return; "No other solution possible
                  ]
               ]
           ]
        ]
        stop ' * Stopped in srchst on upper y-plane. Can not find irin! *';
     ]
  ]
  IF(win > 0.0) [ "Going towards lower z-plane
     dist = (zbound_min - zsrcp)/win; "Distance to boundary
     xin  = xsrcp + dist*uin; "Transport transverse coordinates...
     yin  = ysrcp + dist*vin; "...from source to target surface
     IF ( (xin >= xbound_min) & (xin <= xbound_max) &
          (yin >= ybound_min) & (yin <= ybound_max)) [
        "Hits the lower z-plane, search for the entrance region number
        DO i=1,imax [
           IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               DO j=1,jmax [
                  IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
                     zin  = zbound_min;
                     irin = i + klowz + imax*j;
                     return; "No other solution possible
                  ]
               ]
           ]
        ]
        stop ' * Stopped in srchst on lower z-plane. Can not find irin! *';
     ]
  ]
  ELSEIF(win < 0.0) [ "Going towards upper z-plane
     dist = (zbound_max-zsrcp)/win; "Distance to boundary
     xin  = xsrcp + dist*uin; "Transport transverse coordinates...
     yin  = ysrcp + dist*vin; "...from source to target surface
     IF ( (xin >= xbound_min) & (xin <= xbound_max) &
          (yin >= ybound_min) & (yin <= ybound_max)) [
        "Hits the upper z-plane, search for the entrance region number
        DO i=1,imax [
           IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
              DO j=1,jmax [
                 IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
                    zin  = zbound_max;
                    irin = i + khiz + imax*j;
                    return; "No other solution possible
                 ]
              ]
           ]
        ]
        stop ' * Stopped in srchst on upper z-plane. Can not find irin! *';
     ]
  ]

  nmissm = nmissm+1; "If gets here => it misses, count it and start again"
  goto :GET-ANOTHER-PARTICLE:;
]"end of isource=1 case"

"------------------------------------------------------------------------"
ELSE["isource = 2,4,8,9,10,20,21"
"------------------------------------------------------------------------"
    xin  = xsrcp;
    yin  = ysrcp;
    zin  = zsrcp;
    IF(IWATCH=-9999)[
       WRITE(*,*)' xin,yin,zin ',xin,yin,zin;
       "put to avoid roundoff error on zin when optimized"
       "this should never actually be printed"
    ]
    "IF(((isource=20)|(isource=21 ))& weight=0)["
	"the particle was blocked by the MLC leaves"
	"    nsblocked = nsblocked + 1;"
    "]"
    IF ( (xin >= xbound_min) & (xin <= xbound_max) &
         (yin >= ybound_min) & (yin <= ybound_max) &
         (zin >= zbound_min) & (zin <= zbound_max)) [
       "the particle is inside the phantom"
       DO i=1,imax [
          IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
             DO j=1,jmax [
               IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
                  DO k=1,kmax [
                     IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
                      irin = $IR(i,j,k);
                      return; "No other solution possible
                     ]
                  ]"end of do"
               ]
            ]"end of do"
          ]
       ]
       stop ' * Stopped in srchst. Cannot find irin! *';
    ]
    ELSEIF( (xin> xbound_max+dsurround(1)) | (xin < xbound_min-dsurround(1))|
            (yin> ybound_max+dsurround(2)) | (yin < ybound_min-dsurround(2))|
            (zin> zbound_max+dsurround(3)) | (zin < zbound_min-dsurround(4)))[
        "the particle is outside the given surrounding air region"
	"IF((isource=20) & weight=0)[""it was blocked by leaves
	"	return;"
	"] ELSE ["
		nsmiss = nsmiss+1;"it misses, count it and start again"
		goto :GET-ANOTHER-PARTICLE:;
	"]"
    ]
    ELSE["the particle is outside the phantom but in the "
             "given region surrounding the phantom"
       irin = imax*jmax*kmax+2; return;
    ]

]"end of isource = 2,4,8,9,10,20,21 case"
;
end; "End of subroutine srchst"
%E "srcxyznrc.mortran start of subroutine SHIFT_XYUV ($Revision: 1.39 $)"
"**************************************************************************"
"
SUBROUTINE SHIFT_XYUV(NofREPEAT,xsrc,ysrc,usrc,vsrc);
implicit none;

$REAL xsrc,ysrc,usrc,vsrc,
      X,Y,U,V;
$INTEGER NofREPEAT;
"
" Version 1.0 ---- 94/02/11 "
" Version 1.1 ---- 94/10/18 removed NofREPEAT > 3 part."
"**************************************************************************"
X = xsrc;    Y = ysrc;    U = usrc;    V = vsrc;

IF(NofREPEAT = 1)[ xsrc = -X;    ysrc =  Y;    usrc = -U;    vsrc =  V; ]
ELSEIF(NofREPEAT = 2)[ xsrc =  X; ysrc = -Y; usrc =  U; vsrc = -V; ]
ELSEIF(NofREPEAT = 3)[ xsrc = -X; ysrc = -Y; usrc = -U; vsrc = -V; ]
ELSEIF(NofREPEAT > 3)[ NofREPEAT = 0; ]
RETURN;

"The following are not valid for particles from the collimators "
"ELSEIF(NofREPEAT = 4)[ xsrc = Y; ysrc = X; usrc = V; vsrc = U; ]
"ELSEIF(NofREPEAT = 5)[ xsrc = -Y; ysrc = X; usrc = -V; vsrc = U; ]
"ELSEIF(NofREPEAT = 6)[ xsrc = Y; ysrc = -X; usrc = V; vsrc = -U; ]
"ELSEIF(NofREPEAT = 7)[ xsrc = -Y; ysrc = -X; usrc = -V; vsrc = -U; ]
"ELSEIF(NofREPEAT > 3)[ NofREPEAT = 0; ]
"RETURN;
END;

$HAVE_LOAD_DSO(#);

#ifndef HAVE_LOAD_DSO;

subroutine init_beamsource(i_parallel,i_log,conf_name,
                         hen_house,egs_home,the_beam_code,
                         the_pegs_file,the_input_file);
$INTEGER i_parallel,i_log;
character*(*) conf_name;
character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_input_file;
write(6,*) 'You need a working C compiler to use source 9!';
$CALL_EXIT(1);
end;

subroutine sample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
                               iqin,latchi,nhist,iphatsrc);

return; end;

subroutine motionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
                               iqin,latchi,nhist,iphatsrc,frMU_indx);
return; end;

subroutine phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,
                               weight,iqin,latchi,nhist,iphatsrc,
			       more_in_cont,frMU_indx);

subroutine finish_beamsource;
return; end;

subroutine call init_vcusource(conf_name,hen_house,egs_home,
			the_vcu_code,the_input_file);

character*(*) conf_name;
character*(*) hen_house,egs_home,the_vcu_code,the_input_file;
write(6,*) 'You need a working C compiler to use source 9!';
$CALL_EXIT(1);
end;

subroutine sample_vcusource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
                      iqin,latchi,n_hist_dum,more_in_cont,iphatsrc,frMU_indx);
return; end;

subroutine finish_vcusource;
return; end;

#endif;
" end of srcxyznrc.mortran ($Revision: 1.39 $)"
